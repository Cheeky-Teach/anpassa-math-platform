PROJECT EXPORT GENERATED AT 2026-01-31T09:28:31.882Z

--- FILE STRUCTURE ---
api\answer.ts
api\batch.ts
api\curriculum.ts
api\debug.ts
api\question.ts
backup_UI.html
bundle_project.ts
dev-server.ts
index.html
package-lock.json
package.json
postcss.config.js
src\App.jsx
src\components\modals\AboutModal.jsx
src\components\modals\ContentModal.jsx
src\components\modals\LevelUpModal.jsx
src\components\modals\LgrModal.jsx
src\components\modals\StatsModal.jsx
src\components\modals\StreakModal.jsx
src\components\practice\CluePanel.jsx
src\components\practice\HistoryList.jsx
src\components\practice\MobileDrawer.jsx
src\components\ui\Button.jsx
src\components\ui\MathText.jsx
src\components\views\Dashboard.jsx
src\components\views\DoNowConfig.jsx
src\components\views\DoNowGrid.jsx
src\components\views\PracticeView.jsx
src\components\visuals\GeometryComponents.jsx
src\components\visuals\GeometryVisual.jsx
src\components\visuals\GraphCanvas.jsx
src\components\visuals\InputComponents.jsx
src\components\visuals\SimpleTextLevel.jsx
src\components\visuals\VolumeVisualization.jsx
src\constants\content_map.js
src\constants\curriculum.js
src\constants\localization.js
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ExponentsGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\FractionArithGen.ts
src\core\generators\FractionBasicsGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\PercentGen.ts
src\core\generators\ProbabilityGen.ts
src\core\generators\PythagorasGen.ts
src\core\generators\ScaleGen.ts
src\core\generators\SimilarityGen.ts
src\core\generators\StatisticsGen.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGen.ts
src\core\interfaces\Generator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\MathUtils.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
src\index.css
src\main.jsx
tailwind.config.js
tsconfig.json
vercel.json
vite.config.js

==================================================


// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: "Method not allowed. Use POST." });
    }

    try {
        const { answer, token, streak = 0 } = req.body;

        if (!token) {
            return res.status(400).json({ error: "Missing token" });
        }

        // 1. Decode the correct answer from the Base64 token
        const correctAnswer = Buffer.from(token, 'base64').toString('utf-8');

        // 2. Normalize inputs for comparison
        // We remove spaces and convert to lowercase to be forgiving
        // e.g. "x + 5" should match "x+5"
        const normalize = (str: any) => String(str).toLowerCase().replace(/\s+/g, '').replace(',', '.');
        
        const userClean = normalize(answer);
        const correctClean = normalize(correctAnswer);

        const isCorrect = userClean === correctClean;

        let newStreak = streak;
        let levelUp = false;

        // 3. Update Streak Logic
        if (isCorrect) {
            newStreak++;
            // Propose level up every 8 correct answers
            if (newStreak > 0 && newStreak % 8 === 0) {
                levelUp = true;
            }
        } else {
            newStreak = 0;
        }

        return res.status(200).json({
            correct: isCorrect,
            correctAnswer, // Send back correct answer so UI can display it if wrong
            newStreak,
            levelUp
        });

    } catch (error) {
        console.error("Answer Validation Error:", error);
        return res.status(500).json({ error: "Validation failed." });
    }
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// UPDATED IMPORTS: Pointing to ../src/core/generators/
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGen } from '../src/core/generators/TenPowersGen';
import { ExponentsGen } from '../src/core/generators/ExponentsGen';
import { PercentGen } from '../src/core/generators/PercentGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { EquationGenerator } from '../src/core/generators/EquationGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGen } from '../src/core/generators/SimilarityGen';
import { PythagorasGen } from '../src/core/generators/PythagorasGen';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen';
import { StatisticsGen } from '../src/core/generators/StatisticsGen';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen';
import { FractionArithGen } from '../src/core/generators/FractionArithGen';

interface VercelRequest extends IncomingMessage {
    body: any;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
};

const generators: any = {
    arithmetic: new BasicArithmeticGen(),
    negative: new NegativeNumbersGen(),
    ten_powers: new TenPowersGen(),
    exponents: new ExponentsGen(),
    percent: new PercentGen(),
    fraction_basics: new FractionBasicsGen(),
    fraction_arith: new FractionArithGen(),
    simplify: new ExpressionSimplificationGen(),
    equation: new EquationGenerator(),
    graph: new LinearGraphGenerator(),
    geometry: new GeometryGenerator(),
    scale: new ScaleGenerator(),
    volume: new VolumeGenerator(),
    similarity: new SimilarityGen(),
    pythagoras: new PythagorasGen(),
    probability: new ProbabilityGen(),
    statistics: new StatisticsGen()
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    const { requests } = req.body;

    if (!Array.isArray(requests)) {
        return res.status(400).json({ error: 'Invalid request format' });
    }

    try {
        const results = requests.map((req: any) => {
            if (!generators[req.category]) return null;
            return generators[req.category].generate(Number(req.level), req.lang);
        });
        res.status(200).json({ results });
    } catch (error) {
        console.error("Batch error:", error);
        res.status(500).json({ error: 'Batch generation failed' });
    }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang."
    ],

    // Mapping modules to "Centralt Inneh√•ll" (Core Content)
    mapping: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        // Added: ten_powers, percent, exponents
        modules: ["arithmetic", "negative", "ten_powers", "percent", "exponents"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.",
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform vid √∂verslagsr√§kning, huvudr√§kning samt vid ber√§kningar med skriftliga metoder.",
          "Tal i potensform. Grundpotensform.", // TenPowersGen, ExponentsGen
          "Procent f√∂r att uttrycka f√∂r√§ndring och f√∂r√§ndringsfaktor samt ber√§kningar med procent i vardagliga situationer." // PercentGen
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["equation", "simplify"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.",
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Metoder f√∂r ekvationsl√∂sning."
        ]
      },
      geometri: {
        category: "Geometri",
        // Added: similarity, pythagoras
        modules: ["geometry", "scale", "volume", "similarity", "pythagoras"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt. Skala och dess anv√§ndning i vardagliga situationer.", // ScaleGen
          "Likformighet och symmetri inom plangeometrin.", // SimilarityGen
          "Geometriska satser och formler och behovet av argumentation f√∂r deras giltighet. Pythagoras sats.", // PythagorasGen
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta." // GeometryGen, VolumeGen
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"],
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      // NEW SECTION: Sannolikhet och statistik
      statistik: {
        category: "Sannolikhet och statistik",
        modules: ["probability", "statistics"],
        content: [
          "Likformig sannolikhet och metoder f√∂r att ber√§kna sannolikhet i vardagliga situationer.", // ProbabilityGen
          "Tabeller och diagram f√∂r att beskriva resultat fr√•n unders√∂kningar.", // StatisticsGen (Frequency Table)
          "L√§gesm√•tt: medelv√§rde, median och typv√§rde.", // StatisticsGen
          "Spridningsm√•tt: variationsbredd." // StatisticsGen
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"], // Specifically word problems in equations
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  return res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\debug.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import fs from 'fs';
import path from 'path';

export default function handler(req: VercelRequest, res: VercelResponse) {
    try {
        // Look for the generators folder relative to this executing function
        const generatorsPath = path.join(process.cwd(), 'src/core/generators');
        
        let files: string[] = [];
        if (fs.existsSync(generatorsPath)) {
            files = fs.readdirSync(generatorsPath);
        } else {
            files = ["Generators folder not found at: " + generatorsPath];
        }

        res.status(200).json({
            status: "Debug Online",
            cwd: process.cwd(),
            foundFiles: files
        });
    } catch (error) {
        res.status(500).json({ error: String(error) });
    }
}

// FILE END: api\debug.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// UPDATED IMPORTS: Pointing to ../src/core/generators/
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGen } from '../src/core/generators/TenPowersGen';
import { ExponentsGen } from '../src/core/generators/ExponentsGen';
import { PercentGen } from '../src/core/generators/PercentGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { EquationGenerator } from '../src/core/generators/EquationGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGen } from '../src/core/generators/SimilarityGen';
import { PythagorasGen } from '../src/core/generators/PythagorasGen';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen';
import { StatisticsGen } from '../src/core/generators/StatisticsGen';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen';
import { FractionArithGen } from '../src/core/generators/FractionArithGen';

interface VercelRequest extends IncomingMessage {
    body: any;
    query: Partial<{ [key: string]: string | string[] }>;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
    send: (data: any) => VercelResponse;
};

const generators: any = {
    arithmetic: new BasicArithmeticGen(),
    negative: new NegativeNumbersGen(),
    ten_powers: new TenPowersGen(),
    exponents: new ExponentsGen(),
    percent: new PercentGen(),
    fraction_basics: new FractionBasicsGen(),
    fraction_arith: new FractionArithGen(),
    simplify: new ExpressionSimplificationGen(),
    equation: new EquationGenerator(),
    graph: new LinearGraphGenerator(),
    geometry: new GeometryGenerator(),
    scale: new ScaleGenerator(),
    volume: new VolumeGenerator(),
    similarity: new SimilarityGen(),
    pythagoras: new PythagorasGen(),
    probability: new ProbabilityGen(),
    statistics: new StatisticsGen()
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    const { category, level, lang } = req.body;
    
    if (!generators[category]) {
        return res.status(400).json({ error: `Generator not found: ${category}` });
    }

    try {
        const question = generators[category].generate(Number(level), lang);
        res.status(200).json(question);
    } catch (error) {
        console.error(`Generation error:`, error);
        res.status(500).json({ error: 'Generation failed' });
    }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: dev-server.ts
// =======================================================

import express, { Request, Response } from 'express';
import cors from 'cors';
import { register } from 'tsconfig-paths';
import path from 'path';

// 1. Register Path Aliases (@core/*) from tsconfig
// This ensures the backend logic can find files in src/core
import tsConfig from './tsconfig.json' assert { type: "json" };

const baseUrl = path.resolve(process.cwd(), tsConfig.compilerOptions.baseUrl || '.');
const cleanup = register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths,
});

// 2. Import API Handlers
// We import these AFTER registering paths so they resolve correctly
import questionHandler from './api/question';
import answerHandler from './api/answer';
import curriculumHandler from './api/curriculum';

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// 3. Vercel -> Express Adapter
// Vercel functions are (req, res) => void, which matches Express,
// but we wrap them to ensure errors are caught.
const adapter = (handler: any) => async (req: Request, res: Response) => {
    try {
        await handler(req, res);
    } catch (err) {
        console.error("API Error:", err);
        res.status(500).json({ error: 'Internal Server Error', details: String(err) });
    }
};

// 4. Define Routes
// These must match the filenames in your /api folder
app.get('/api/question', adapter(questionHandler));
app.post('/api/answer', adapter(answerHandler));
app.get('/api/curriculum', adapter(curriculumHandler));

// 5. Start Server
app.listen(PORT, () => {
    console.log(`\nüöÄ Backend Simulation running at http://localhost:${PORT}`);
    console.log(`   - /api/question`);
    console.log(`   - /api/answer`);
    console.log(`   - /api/curriculum`);
    console.log(`\nüé® Frontend running at http://localhost:5173 (Proxy active)\n`);
});

// FILE END: dev-server.ts

// =======================================================
// FILE START: index.html
// =======================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <title>Anpassa | Math Platform</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// FILE END: index.html

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"vite\"",
    "dev:frontend": "vite",
    "dev:server": "tsx watch dev-server.ts",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "katex": "^0.16.9",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vercel/node": "^5.5.28",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.7.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.6"
  }
}


// FILE END: package.json

// =======================================================
// FILE START: postcss.config.js
// =======================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// FILE END: postcss.config.js

// =======================================================
// FILE START: src\App.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import Dashboard from './components/views/Dashboard';
import PracticeView from './components/views/PracticeView';
import DoNowConfig from './components/views/DoNowConfig';
import DoNowGrid from './components/views/DoNowGrid';
import AboutModal from './components/modals/AboutModal';
import LgrModal from './components/modals/LgrModal';
import StatsModal from './components/modals/StatsModal';
import StreakModal from './components/modals/StreakModal'; 
import ContentModal from './components/modals/ContentModal'; // NEW IMPORT
import MobileDrawer from './components/practice/MobileDrawer';
import { UI_TEXT, CATEGORIES, LEVEL_DESCRIPTIONS } from './constants/localization';

function App() {
    const [view, setView] = useState('dashboard'); // 'dashboard', 'practice', 'donow_config', 'donow_grid'
    const [lang, setLang] = useState('sv');
    const [topic, setTopic] = useState('');
    const [level, setLevel] = useState(0);

    const [question, setQuestion] = useState(null);
    const [input, setInput] = useState('');
    const [feedback, setFeedback] = useState(null);
    const [loading, setLoading] = useState(false);

    // Session Stats
    const [streak, setStreak] = useState(0);
    const [totalCorrect, setTotalCorrect] = useState(0);
    const [sessionStats, setSessionStats] = useState({
        attempted: 0,
        correctNoHelp: 0,
        correctHelp: 0,
        incorrect: 0,
        skipped: 0,
        maxStreak: 0
    });
    
    const [granularStats, setGranularStats] = useState({});
    const [history, setHistory] = useState([]);
    const [revealedClues, setRevealedClues] = useState([]);
    const [levelUpAvailable, setLevelUpAvailable] = useState(false);
    
    // Modals State
    const [aboutOpen, setAboutOpen] = useState(false);
    const [statsOpen, setStatsOpen] = useState(false);
    const [timeUpOpen, setTimeUpOpen] = useState(false);
    const [lgrOpen, setLgrOpen] = useState(false);
    const [contentOpen, setContentOpen] = useState(false); // NEW STATE FOR CONTENT MODAL
    const [showStreakModal, setShowStreakModal] = useState(false);
    const [showTotalModal, setShowTotalModal] = useState(false);
    const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);

    // Do Now State
    const [doNowQuestions, setDoNowQuestions] = useState([]);
    const [doNowConfig, setDoNowConfig] = useState([]); // Stores the selected topics for regeneration

    const [usedHelp, setUsedHelp] = useState(false);
    const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);

    // Timer State
    const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

    const ui = UI_TEXT[lang];

    // Timer Logic
    useEffect(() => {
        let interval = null;
        if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
            interval = setInterval(() => {
                setTimerSettings(prev => {
                    if (prev.remaining <= 1) {
                        clearInterval(interval);
                        setTimeUpOpen(true);
                        return { ...prev, remaining: 0, isActive: false };
                    }
                    return { ...prev, remaining: prev.remaining - 1 };
                });
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [timerSettings.isActive, view, timerSettings.remaining]);

    const toggleTimer = (minutes) => {
        const seconds = minutes * 60;
        setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
    };

    const resetTimer = () => {
        setTimerSettings({ duration: 0, remaining: 0, isActive: false });
    };

    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    };

    useEffect(() => {
        if (streak > sessionStats.maxStreak) {
            setSessionStats(prev => ({ ...prev, maxStreak: streak }));
        }
    }, [streak]);

    const fetchQuestion = async (t = topic, l = level, lg = lang, force = false) => {
        if (!force && (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen)) return;
        if (!t || !l) return;
        setLoading(true);
        setFeedback(null);
        setInput('');
        setRevealedClues([]);
        setUsedHelp(false);
        setIsSolutionRevealed(false);
        setLevelUpAvailable(false);
        try {
            const timestamp = new Date().getTime();
            const res = await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}${force ? `&force=true&t=${timestamp}` : ''}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            setQuestion(data);
        } catch (e) {
            console.error(e);
            setQuestion(null);
        } finally {
            setLoading(false);
        }
    };

    const startPractice = () => {
        if (topic && level) {
            setStreak(0);
            setView('practice');
            if (timerSettings.duration > 0) {
                setTimerSettings(prev => ({ ...prev, isActive: true }));
            }
            fetchQuestion(topic, level, lang);
        }
    };

    const quitPractice = () => {
        setStreak(0);
        setView('dashboard');
        setQuestion(null);
    };

    // --- DO NOW LOGIC ---

    const handleDoNowGenerate = async (selected) => {
        if (selected.length === 0) return;
        
        // Save config for regeneration
        setDoNowConfig(selected);
        
        setLoading(true);
        const fullConfig = [];
        const targetCount = Math.max(selected.length, 6);
        for (let i = 0; i < targetCount; i++) {
            fullConfig.push(selected[i % selected.length]);
        }

        try {
            const res = await fetch('/api/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ config: fullConfig, lang })
            });
            const data = await res.json();
            if (data.questions) {
                setDoNowQuestions(data.questions);
                setView('donow_grid');
            }
        } catch (e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    };

    const handleRefreshAll = async () => {
        if (doNowConfig.length > 0) {
            await handleDoNowGenerate(doNowConfig);
        }
    };

    const handleRefreshOne = async (index, topic, level) => {
        try {
            const timestamp = new Date().getTime();
            const res = await fetch(`/api/question?topic=${topic}&level=${level}&lang=${lang}&force=true&t=${timestamp}`);
            const newQuestion = await res.json();
            
            if (newQuestion.error) throw new Error(newQuestion.error);

            setDoNowQuestions(prev => {
                const copy = [...prev];
                copy[index] = newQuestion;
                return copy;
            });
        } catch (e) {
            console.error("Single refresh failed", e);
        }
    };

    // -------------------

    const handleSelection = (t, l) => { setTopic(t); setLevel(l); };

    const handleHint = () => {
        if (question?.clues) {
            setUsedHelp(true);
            const currentLen = revealedClues.length;
            if (currentLen < question.clues.length) {
                setRevealedClues([...revealedClues, question.clues[currentLen]]);
            }
        }
    };

    const handleSolution = () => {
        if (question?.clues) {
            setUsedHelp(true);
            setRevealedClues(question.clues);
            setIsSolutionRevealed(true);
            setStreak(0);
        }
    };

    const updateStats = (type) => {
        setSessionStats(prev => ({
            ...prev,
            attempted: prev.attempted + 1,
            [type]: prev[type] + 1
        }));
    };

    const updateGranularStats = (topicId, levelId, resultType) => {
        setGranularStats(prev => {
            const topicData = prev[topicId] || {};
            const levelData = topicData[levelId] || { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 };
            return {
                ...prev,
                [topicId]: {
                    ...topicData,
                    [levelId]: {
                        ...levelData,
                        [resultType]: (levelData[resultType] || 0) + 1
                    }
                }
            };
        });
    };

    const handleSkip = () => {
        const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
        const historyText = question.renderData.latex || descText;
        setHistory(prev => [{ topic, level, correct: false, skipped: true, text: historyText, clueUsed: revealedClues.length > 0 || isSolutionRevealed, time: Date.now() }, ...prev]);
        setStreak(0);
        updateStats('skipped');
        updateGranularStats(topic, level, 'skipped');
        fetchQuestion(topic, level, lang);
    };

    const handleChangeLevel = (delta) => { 
        const newLevel = level + delta; 
        const max = Object.keys(LEVEL_DESCRIPTIONS[topic] || {}).length; 
        if (newLevel >= 1 && newLevel <= max) { 
            // setStreak(0); // REMOVED: Preserve streak when manually changing or leveling up
            setLevel(newLevel); 
            fetchQuestion(topic, newLevel, lang, true); 
        } 
    };

    const handleSubmit = async (e, directInput) => {
        e.preventDefault();
        if (showStreakModal || showTotalModal || timeUpOpen) return;
        if (feedback === 'correct') return;
        let finalInput = directInput !== undefined ? directInput : input;
        if (!question || !finalInput) return;

        const isStatsLocked = isSolutionRevealed;
        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        try {
            const res = await fetch('/api/answer', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ 
                    answer: finalInput, 
                    token: question.token, 
                    streak: streak, 
                    level: level, 
                    topic: topic, 
                    usedHelp: helpUsed, 
                    solutionUsed: isSolutionRevealed, 
                    attempts: question.attempts 
                }) 
            });
            const result = await res.json();
            const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
            const historyText = question.renderData.latex || descText;

            if (result.correct) {
                if (!isStatsLocked) {
                    setHistory(prev => [{ topic, level, correct: true, text: historyText, clueUsed: helpUsed, time: Date.now() }, ...prev]);
                    setStreak(result.newStreak);
                    if (!helpUsed) {
                        updateStats('correctNoHelp');
                        updateGranularStats(topic, level, 'correctNoHelp');
                    } else {
                        updateStats('correctHelp');
                        updateGranularStats(topic, level, 'correctHelp');
                    }

                    const newTotal = totalCorrect + 1;
                    setTotalCorrect(newTotal);
                    if ([10, 20, 30, 40, 50].includes(newTotal)) setShowTotalModal(true);
                    if ([15, 20, 30, 40, 50].includes(result.newStreak)) setShowStreakModal(true);
                    else {
                        if (result.levelUp) setLevelUpAvailable(true);
                        setTimeout(() => {
                            if (!showTotalModal && !showStreakModal) {
                                if (!result.levelUp) fetchQuestion(topic, level, lang);
                            }
                        }, 1500);
                    }
                }
                setFeedback('correct');
            } else {
                question.attempts = (question.attempts || 0) + 1;
                if (question.attempts >= 2) {
                    handleSolution();
                    if (!isStatsLocked) {
                        updateStats('incorrect');
                        updateGranularStats(topic, level, 'incorrect');
                        setHistory(prev => [{
                            topic, level, correct: false, text: historyText, clueUsed: true, correctAnswer: result.correctAnswer || "See Solution", time: Date.now()
                        }, ...prev]);
                    }
                } else {
                    handleHint();
                }
                setFeedback('incorrect');
                setStreak(0);
            }
        } catch (e) { console.error(e); }
    };

    const toggleLang = () => setLang(prev => prev === 'sv' ? 'en' : 'sv');

    // RENDER LOGIC
    if (view === 'donow_config') {
        return <div className="min-h-screen bg-gray-50 font-sans"><DoNowConfig ui={ui} lang={lang} onBack={() => setView('dashboard')} onGenerate={handleDoNowGenerate} /></div>;
    }
    if (view === 'donow_grid') {
        return (
            <DoNowGrid 
                questions={doNowQuestions} 
                ui={ui} 
                onBack={() => setView('donow_config')} 
                lang={lang} 
                onRefreshAll={handleRefreshAll}
                onRefreshOne={handleRefreshOne}
            />
        );
    }

    return (
        <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
            <AboutModal visible={aboutOpen} onClose={() => setAboutOpen(false)} ui={ui} />
            <LgrModal visible={lgrOpen} onClose={() => setLgrOpen(false)} ui={ui} />
            <ContentModal visible={contentOpen} onClose={() => setContentOpen(false)} /> {/* NEW MODAL COMPONENT */}
            <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} ui={ui} />
            <StatsModal visible={statsOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setStatsOpen(false)} title={ui.stats_title} />
            <StatsModal visible={timeUpOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setTimeUpOpen(false)} title={ui.stats_times_up} />

            <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                    <div className="flex items-center gap-4">
                        <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                        {view === 'dashboard' && timerSettings.remaining > 0 && (
                            <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                <span>‚è∏ {ui.timer_paused}</span>
                                <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                            </div>
                        )}
                    </div>
                    <div className="flex items-center gap-3">
                        <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>
                        <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>
                        <button onClick={toggleLang} className="px-3 py-1 rounded-md text-xs font-bold border border-slate-200 bg-white text-slate-600 hover:bg-slate-50 transition-all shadow-sm flex items-center gap-1.5" title={lang === 'sv' ? "Byt spr√•k" : "Switch Language"}>
                            <span className="text-sm">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span><span>{lang === 'sv' ? 'SE' : 'ENG'}</span>
                        </button>
                        <button onClick={() => setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                        </button>
                        <button onClick={() => setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                    </div>
                </div>
            </header>

            <div className="flex-1 flex flex-col">
                {view === 'dashboard' ? (
                    <Dashboard
                        lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice} timerSettings={timerSettings} toggleTimer={toggleTimer} resetTimer={resetTimer} ui={ui} 
                        onLgrOpen={() => setLgrOpen(true)} 
                        onContentOpen={() => setContentOpen(true)} // PASSING THE HANDLER
                        onDoNowOpen={() => setView('donow_config')} 
                        toggleLang={toggleLang}
                    />
                ) : (
                    <PracticeView
                        lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{ history, topic, level }} actions={{ retry: (force) => fetchQuestion(topic, level, lang, force), goBack: quitPractice }} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect} timerSettings={timerSettings} formatTime={formatTime} setMobileHistoryOpen={setMobileHistoryOpen}
                    />
                )}
            </div>
        </div>
    );
}

export default App;

// FILE END: src\App.jsx

// =======================================================
// FILE START: src\components\modals\AboutModal.jsx
// =======================================================

import React from 'react';

const AboutModal = ({ visible, onClose, ui }) => {
    if (!visible) return null;
    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1">‚úï</button>

                <div className="mb-4 flex justify-center">
                    <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100">
                        <img
                            src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                            alt="Creator"
                            className="w-full h-full object-cover"
                        />
                    </div>
                </div>

                <div className="text-center mb-6">
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                    <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                    <hr className="my-4 border-gray-200" />
                    <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" /></svg>
                        {ui.contactLink}
                    </a>
                </div>
            </div>
        </div>
    );
};

export default AboutModal;

// FILE END: src\components\modals\AboutModal.jsx

// =======================================================
// FILE START: src\components\modals\ContentModal.jsx
// =======================================================

import React from 'react';
import { CONTENT_MAP } from '../../constants/content_map';

const ContentModal = ({ visible, onClose }) => {
    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-4xl max-h-[85vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden animate-bounce-in border border-slate-200">
                
                {/* Header */}
                <div className="bg-slate-50 border-b border-slate-200 p-6 flex justify-between items-center shrink-0">
                    <div>
                        <h2 className="text-2xl font-black text-slate-800 tracking-tight">Inneh√•llsf√∂rteckning</h2>
                        <p className="text-slate-500 text-sm mt-1">√ñversikt √∂ver alla omr√•den och niv√•er</p>
                    </div>
                    <button 
                        onClick={onClose} 
                        className="w-10 h-10 flex items-center justify-center rounded-full bg-white border border-slate-200 text-slate-400 hover:text-slate-700 hover:border-slate-300 transition-all text-xl font-bold"
                    >
                        ‚úï
                    </button>
                </div>

                {/* Scrollable Content */}
                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
                    <div className="space-y-12">
                        {Object.entries(CONTENT_MAP).map(([catKey, category]) => (
                            <div key={catKey}>
                                <h3 className="text-xl font-bold text-slate-900 uppercase tracking-widest border-b-2 border-slate-100 pb-2 mb-6">
                                    {category.title}
                                </h3>
                                
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    {category.topics.map(topic => (
                                        <div key={topic.id} className="bg-slate-50 rounded-xl p-5 border border-slate-100 hover:border-indigo-100 transition-colors">
                                            <h4 className="font-bold text-indigo-700 mb-4 flex items-center gap-2">
                                                <span className="w-2 h-2 rounded-full bg-indigo-500"></span>
                                                {topic.title}
                                            </h4>
                                            
                                            <div className="space-y-3">
                                                {topic.levels.map(lvl => (
                                                    <div key={lvl.lvl} className="flex items-start gap-3 text-sm">
                                                        <div className="font-mono font-bold text-slate-400 bg-white px-2 py-0.5 rounded border border-slate-200 text-xs mt-0.5">
                                                            {lvl.lvl}
                                                        </div>
                                                        <div>
                                                            <div className="font-semibold text-slate-700">{lvl.desc}</div>
                                                            <div className="text-slate-500 text-xs italic mt-0.5">Ex: {lvl.ex}</div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Footer */}
                <div className="bg-slate-50 border-t border-slate-200 p-4 flex justify-end shrink-0">
                    <button 
                        onClick={onClose} 
                        className="px-6 py-2 bg-slate-800 hover:bg-slate-900 text-white rounded-lg font-bold text-sm transition-colors"
                    >
                        St√§ng
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ContentModal;

// FILE END: src\components\modals\ContentModal.jsx

// =======================================================
// FILE START: src\components\modals\LevelUpModal.jsx
// =======================================================

import React from 'react';

const LevelUpModal = ({ visible, ui, onNext, onStay, lang }) => {
    if (!visible) return null;

    // Robust Fallback Logic: Ensure text exists even if UI keys are missing
    // We use the 'lang' prop to determine the default language
    const currentLang = lang || 'sv'; 
    
    const defaultTitle = currentLang === 'sv' ? "Niv√• upp?" : "Level Up?";
    const defaultDesc = currentLang === 'sv' 
        ? "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?" 
        : "You seem to know this! Do you want to skip to the next level?";
    const defaultYes = currentLang === 'sv' ? "Ja, k√∂r!" : "Yes, let's go!";
    const defaultNo = currentLang === 'sv' ? "Nej, stanna h√§r" : "No, stay here";

    const title = ui?.levelUpTitle || defaultTitle;
    const desc = ui?.levelUpDesc || defaultDesc;
    const btnYes = ui?.levelUpYes || defaultYes;
    const btnNo = ui?.levelUpNo || defaultNo;

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <div className="text-center mb-6">
                    <div className="text-5xl mb-4">üöÄ</div>
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{title}</h3>
                    <p className="text-gray-600">{desc}</p>
                </div>
                <div className="flex flex-col gap-3">
                    <button 
                        onClick={onNext} 
                        className="w-full py-4 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                    >
                        {btnYes}
                    </button>
                    <button 
                        onClick={onStay} 
                        className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95"
                    >
                        {btnNo}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default LevelUpModal;

// FILE END: src\components\modals\LevelUpModal.jsx

// =======================================================
// FILE START: src\components\modals\LgrModal.jsx
// =======================================================

import React, { useState, useEffect } from 'react';

const LgrModal = ({ visible, onClose, ui }) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (visible && !data) {
            setLoading(true);
            fetch('/api/curriculum')
                .then(res => res.json())
                .then(d => { setData(d); setLoading(false); })
                .catch(err => { console.error(err); setLoading(false); });
        }
    }, [visible, data]);

    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden">
                <div className="flex justify-between items-start mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                    <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600">‚úï</button>
                </div>

                <div className="overflow-y-auto custom-scrollbar flex-1 pr-2">
                    {loading ? (
                        <div className="py-10 text-center text-slate-400">Laddar l√§roplan...</div>
                    ) : data ? (
                        <div className="space-y-8">
                            <p className="text-slate-600 italic">{data.description}</p>
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700">
                                    {data.syfte.map((s, i) => <li key={i}>{s}</li>)}
                                </ul>
                            </div>
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Centralt Inneh√•ll (√•k 7-9)</h4>
                                <div className="grid gap-6">
                                    {Object.entries(data.mapping).map(([key, section]) => (
                                        <div key={key} className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                            <h5 className="font-bold text-slate-900 mb-2 text-sm">{section.category}</h5>
                                            <ul className="list-disc pl-5 space-y-1 text-xs text-slate-600">
                                                {section.content.map((c, i) => <li key={i}>{c}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                    )}
                </div>

                <div className="mt-6 pt-4 border-t border-slate-100 text-center">
                    <a href="https://www.skolverket.se" target="_blank" className="text-xs text-sky-600 hover:underline">K√§lla: Skolverket (Lgr22)</a>
                </div>
            </div>
        </div>
    );
};

export default LgrModal;

// FILE END: src\components\modals\LgrModal.jsx

// =======================================================
// FILE START: src\components\modals\StatsModal.jsx
// =======================================================

import React from 'react';
import { CATEGORIES } from '../../constants/localization';

const LevelBreakdown = ({ granularStats, ui, lang }) => {
    const topics = Object.keys(granularStats);
    if (topics.length === 0) return null;

    return (
        <div className="mt-6 border-t border-gray-100 pt-4 w-full">
            <h4 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-4">
                {ui.level_breakdown}
            </h4>
            <div className="space-y-4">
                {topics.map(topicKey => {
                    const topicLevels = granularStats[topicKey];
                    const levels = Object.keys(topicLevels).sort((a, b) => Number(a) - Number(b));

                    let topicLabel = topicKey;
                    for (const catKey in CATEGORIES) {
                        const found = CATEGORIES[catKey].topics.find(t => t.id === topicKey);
                        if (found) {
                            topicLabel = found.label[lang];
                            break;
                        }
                    }

                    return (
                        <div key={topicKey} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                            <h5 className="font-bold text-gray-700 text-sm mb-2 capitalize">{topicLabel}</h5>
                            <div className="space-y-2">
                                {levels.map(lvl => {
                                    const stats = topicLevels[lvl];
                                    const total = stats.skipped + stats.incorrect + stats.correctHelp + stats.correctNoHelp;
                                    if (total === 0) return null;

                                    const pSkip = (stats.skipped / total) * 100;
                                    const pWrong = (stats.incorrect / total) * 100;
                                    const pHelp = (stats.correctHelp / total) * 100;
                                    const pCorrect = (stats.correctNoHelp / total) * 100;
                                    const unassistedPct = Math.round(pCorrect);

                                    return (
                                        <div key={lvl} className="flex flex-col gap-1 mb-3 last:mb-0">
                                            <div className="flex justify-between items-center text-xs font-medium text-gray-500 mb-1">
                                                <span>{lang === 'sv' ? 'Niv√•' : 'Level'} {lvl}</span>
                                            </div>
                                            <div className="flex w-full h-3 rounded-full overflow-hidden bg-gray-200">
                                                {pSkip > 0 && <div style={{ width: `${pSkip}%` }} className="bg-gray-400" />}
                                                {pWrong > 0 && <div style={{ width: `${pWrong}%` }} className="bg-red-500" />}
                                                {pHelp > 0 && <div style={{ width: `${pHelp}%` }} className="bg-yellow-400" />}
                                                {pCorrect > 0 && <div style={{ width: `${pCorrect}%` }} className="bg-green-500" />}
                                            </div>
                                            <div className="flex flex-wrap gap-x-3 text-[10px] text-gray-500 mt-1">
                                                <span className="text-gray-500 font-semibold">{ui.stat_skip}: {stats.skipped}</span>
                                                <span className="text-red-600 font-semibold">{ui.stat_wrong}: {stats.incorrect}</span>
                                                <span className="text-yellow-600 font-semibold">{ui.stat_help}: {stats.correctHelp}</span>
                                                <span className="text-green-600 font-semibold">{ui.stat_correct}: {stats.correctNoHelp}</span>
                                            </div>
                                            <div className="text-[10px] text-gray-400 italic">
                                                {ui.stat_total}: {total} ({unassistedPct}% unassisted)
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const StatsModal = ({ visible, stats, granularStats, ui, onClose, title, lang }) => {
    if (!visible) return null;
    const attemptCount = stats.attempted || 0;
    const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

    return (
        <div className="fixed inset-0 z-[100] flex sm:items-center justify-center sm:p-4 bg-white sm:bg-black/50 sm:backdrop-blur-sm fade-in">
            <div className="bg-white w-full h-full sm:h-auto sm:max-h-[90vh] sm:rounded-2xl sm:shadow-2xl sm:max-w-md p-6 relative flex flex-col sm:border-4 sm:border-blue-500 overflow-y-auto custom-scrollbar">
                <div className="flex justify-between items-center mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-gray-900">{title || ui.stats_title}</h3>
                    <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 sm:hidden">‚úï</button>
                </div>

                <div className="shrink-0 grid grid-cols-2 gap-4 text-left text-sm mb-6">
                    <div className="text-gray-500">{ui.stats_longest_streak}</div>
                    <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                    <div className="text-gray-500">{ui.stats_attempted}</div>
                    <div className="font-bold text-right">{stats.attempted}</div>
                    <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                    <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_correct_help}</div>
                    <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_incorrect}</div>
                    <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                    <div className="text-gray-500">{ui.stats_skipped}</div>
                    <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                </div>

                <LevelBreakdown granularStats={granularStats} ui={ui} lang={lang} />

                <button onClick={onClose} className="mt-8 w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg shrink-0 hidden sm:block">
                    {ui.stats_close}
                </button>
            </div>
        </div>
    );
};

export default StatsModal;

// FILE END: src\components\modals\StatsModal.jsx

// =======================================================
// FILE START: src\components\modals\StreakModal.jsx
// =======================================================

import React from 'react';

const StreakModal = ({ visible, streak, ui, onClose }) => {
    if (!visible) return null;

    let icon = "ü•â";
    if (streak >= 50) icon = "üëë";
    else if (streak >= 40) icon = "üèÜ";
    else if (streak >= 30) icon = "ü•á";
    else if (streak >= 20) icon = "ü•à";
    else if (streak >= 15) icon = "ü•â";

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                <button 
                    onClick={onClose} 
                    className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                >
                    {ui.btn_close_streak}
                </button>
            </div>
        </div>
    );
};

export default StreakModal;

// FILE END: src\components\modals\StreakModal.jsx

// =======================================================
// FILE START: src\components\practice\CluePanel.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const CluePanel = ({ revealedClues, question, ui, isSolutionRevealed }) => {
    if (!revealedClues || revealedClues.length === 0) return null;

    // We need the total count to identify which clue is the "final" one
    const totalCluesCount = question.clues ? question.clues.length : 0;

    return (
        <div className="bg-orange-50 border border-orange-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
            <div className="flex items-center gap-2 mb-4 text-orange-800 font-bold border-b border-orange-200 pb-2">
                <span>üí° {ui.hintsTitle} ({revealedClues.length}/{totalCluesCount})</span>
            </div>
            <div className="space-y-6">
                {revealedClues.map((clue, i) => {
                    // Identify if this is the absolute last clue in the sequence
                    const isTheFinalClue = i === totalCluesCount - 1;
                    
                    // RESTORED LOGIC: 
                    // Hide the latex box for the final clue unless the solution is unlocked.
                    // This forces the student to perform the final step themselves.
                    const showLatex = !isTheFinalClue || isSolutionRevealed;

                    return (
                        <div key={i} className="group animate-slide-down">
                            {/* 1. Text Description (Always shown) */}
                            <div className="text-sm text-orange-900 mb-2 font-medium leading-relaxed">
                                <MathText text={clue.text} />
                            </div>
                            
                            {/* 2. Math Box (Conditional) */}
                            {clue.latex && showLatex && (
                                <div className="bg-white p-3 rounded-lg border border-orange-200 text-center shadow-sm overflow-x-auto mt-2">
                                    <MathText text={`$${clue.latex}$`} large={true} />
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default CluePanel;

// FILE END: src\components\practice\CluePanel.jsx

// =======================================================
// FILE START: src\components\practice\HistoryList.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const HistoryList = ({ history, ui }) => {
    return (
        <div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                <h2 className="font-bold text-gray-700">{ui.history}</h2>
                <span className="text-xs text-gray-400">{history.length}</span>
            </div>
            <div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px] custom-scrollbar">
                {history.length === 0 ? (
                    <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>
                ) : (
                    history.map((entry, i) => (
                        <div 
                            key={i} 
                            className={`p-3 rounded-lg border-l-4 text-sm ${
                                entry.correct 
                                    ? 'border-emerald-500 bg-emerald-50' 
                                    : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')
                            }`}
                        >
                            <div className="flex justify-between items-start mb-1">
                                <span className="font-semibold capitalize text-gray-700">
                                    {entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span>
                                </span>
                                <span className="text-xs text-gray-400">
                                    {new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                            </div>
                            
                            <div className="text-gray-600 mb-1 line-clamp-2">
                                <MathText text={entry.text} />
                            </div>

                            {!entry.correct && !entry.skipped && entry.correctAnswer && (
                                <div className="text-xs text-red-600 mt-1 font-medium">
                                    <MathText text={`Correct: ${entry.correctAnswer}`} />
                                </div>
                            )}

                            <div className="mt-2">
                                {entry.clueUsed && (
                                    <span className="inline-block px-1.5 py-0.5 bg-orange-100 text-orange-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">
                                        {ui.clueUsed}
                                    </span>
                                )} 
                                <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${
                                    entry.correct 
                                        ? 'bg-emerald-100 text-emerald-700' 
                                        : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')
                                }`}>
                                    {entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}
                                </span>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default HistoryList;

// FILE END: src\components\practice\HistoryList.jsx

// =======================================================
// FILE START: src\components\practice\MobileDrawer.jsx
// =======================================================

import React from 'react';
import HistoryList from './HistoryList';

const MobileDrawer = ({ open, onClose, history, ui }) => {
    return (
        <>
            {open && <div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}
            <div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}>
                <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                    <h2 className="font-bold text-gray-700">{ui.history}</h2>
                    <button onClick={onClose} className="text-gray-400">‚úï</button>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                    <HistoryList history={history} ui={ui} />
                </div>
            </div>
        </>
    );
};

export default MobileDrawer;

// FILE END: src\components\practice\MobileDrawer.jsx

// =======================================================
// FILE START: src\components\ui\Button.jsx
// =======================================================

import React from 'react';

export const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  className = '', 
  disabled = false,
  fullWidth = false 
}) => {
  const baseStyles = "px-4 py-2 rounded-lg font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-math-blue text-white hover:bg-blue-600 focus:ring-math-blue shadow-sm",
    secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500",
    success: "bg-math-green text-white hover:bg-green-600 focus:ring-math-green shadow-sm",
    danger: "bg-math-red text-white hover:bg-red-600 focus:ring-math-red shadow-sm",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
    >
      {children}
    </button>
  );
};

// FILE END: src\components\ui\Button.jsx

// =======================================================
// FILE START: src\components\ui\MathText.jsx
// =======================================================

import React from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css'; // Ensure CSS is imported

const MathText = ({ text, className = "", large = false }) => {
    if (!text) return null;

    // 1. Patch common LaTeX color syntax differences if necessary
    const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');

    // 2. Split by $ delimiters
    const parts = patchedText.split(/(\$[^\$]+\$)/g);

    return (
        <span className={className}>
            {parts.map((part, index) => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const tex = part.slice(1, -1);
                    try {
                        const html = katex.renderToString(tex, { 
                            throwOnError: false, 
                            displayMode: large 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index} className="text-red-500">{part}</span>;
                    }
                } else if (part.includes('\\')) {
                    // Catch-all for stray LaTeX without $ delimiters (legacy support)
                    try {
                        const html = katex.renderToString(part, { 
                            throwOnError: false, 
                            displayMode: false 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index}>{part}</span>;
                    }
                }
                return <span key={index}>{part}</span>;
            })}
        </span>
    );
};

export default MathText;

// FILE END: src\components\ui\MathText.jsx

// =======================================================
// FILE START: src\components\views\Dashboard.jsx
// =======================================================

import React from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const COLOR_VARIANTS = {
    pink: {
        bgLight: 'bg-pink-50', bgDark: 'bg-pink-500', border: 'border-pink-100', text: 'text-pink-700', ring: 'ring-pink-500', borderSolid: 'border-pink-500', selectFocus: 'focus:ring-pink-500'
    },
    indigo: {
        bgLight: 'bg-indigo-50', bgDark: 'bg-indigo-500', border: 'border-indigo-100', text: 'text-indigo-700', ring: 'ring-indigo-500', borderSolid: 'border-indigo-500', selectFocus: 'focus:ring-indigo-500'
    },
    emerald: {
        bgLight: 'bg-emerald-50', bgDark: 'bg-emerald-500', border: 'border-emerald-100', text: 'text-emerald-700', ring: 'ring-emerald-500', borderSolid: 'border-emerald-500', selectFocus: 'focus:ring-emerald-500'
    },
    purple: {
        bgLight: 'bg-purple-50', bgDark: 'bg-purple-500', border: 'border-purple-100', text: 'text-purple-700', ring: 'ring-purple-500', borderSolid: 'border-purple-500', selectFocus: 'focus:ring-purple-500'
    },
    yellow: {
        bgLight: 'bg-yellow-50', bgDark: 'bg-yellow-500', border: 'border-yellow-100', text: 'text-yellow-700', ring: 'ring-yellow-500', borderSolid: 'border-yellow-500', selectFocus: 'focus:ring-yellow-500'
    }
};

const Dashboard = ({ 
    lang, 
    selectedTopic, 
    selectedLevel, 
    onSelect, 
    onStart, 
    timerSettings, 
    toggleTimer, 
    resetTimer, 
    ui, 
    onLgrOpen, 
    onContentOpen, // New Prop
    onDoNowOpen, 
    toggleLang 
}) => {
    
    const getStyles = (category) => {
        const color = category.color || 'emerald';
        return COLOR_VARIANTS[color] || COLOR_VARIANTS.emerald;
    };

    return (
        <div className="max-w-6xl mx-auto w-full p-4 fade-in flex flex-col min-h-[calc(100vh-80px)]">
            
            <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-emerald-50/50 rounded-3xl mx-4 relative overflow-hidden">
                <h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight relative z-10">Anpassa</h1>
                <p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide relative z-10">{ui.tagline}</p>

                <div className="mt-8 flex justify-center relative z-10">
                    <div className="bg-white/80 backdrop-blur-sm rounded-xl p-2 px-4 shadow-sm border border-gray-100 flex items-center gap-3">
                        <span className="font-bold text-gray-700 text-xs uppercase tracking-wider">{ui.timer_title}</span>
                        <div className="relative group">
                            <select
                                value={timerSettings.duration / 60}
                                onChange={(e) => toggleTimer(Number(e.target.value))}
                                className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-emerald-500 cursor-pointer"
                            >
                                <option value="0">{ui.timer_off}</option>
                                {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                            </select>
                            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                        </div>
                        {timerSettings.duration > 0 && (
                            <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                        )}
                    </div>
                </div>
            </div>

            <div className="text-center mb-10">
                <p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">
                {Object.entries(CATEGORIES).map(([catKey, category]) => {
                    const styles = getStyles(category);
                    
                    return (
                        <div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}>
                            <div className={`${styles.bgLight} p-4 border-b ${styles.border}`}>
                                <h3 className={`text-lg font-bold ${styles.text} uppercase tracking-wide flex items-center gap-2`}>
                                    <span className={`w-3 h-3 rounded-full ${styles.bgDark}`}></span>
                                    {category.label[lang]}
                                </h3>
                            </div>
                            
                            <div className="p-4 space-y-4 flex-1">
                                {category.topics.map(topic => {
                                    return (
                                        <div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                                            <div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div>
                                            <div className="relative">
                                                <select 
                                                    value={selectedTopic === topic.id ? selectedLevel : 0} 
                                                    onChange={(e) => onSelect(topic.id, Number(e.target.value))} 
                                                    className={`
                                                        w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none appearance-none cursor-pointer
                                                        ${selectedTopic === topic.id ? `ring-2 ${styles.ring} ${styles.borderSolid}` : styles.selectFocus}
                                                    `}
                                                >
                                                    <option value={0} disabled>{ui.selectLevel}</option>
                                                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                        if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                        return (
                                                            <option key={lvl} value={lvl}>
                                                                {lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang] || ""}
                                                            </option>
                                                        );
                                                    })}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" /></svg>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>

            <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20">
                <button 
                    onClick={onStart} 
                    className={`
                        px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 
                        ${selectedTopic 
                            ? 'bg-orange-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-orange-600 shadow-orange-200' 
                            : 'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}
                    `}
                >
                    {ui.startBtn} <span>üöÄ</span>
                </button>
            </div>

            <footer className="mt-auto py-6 border-t border-gray-200 flex flex-col md:flex-row justify-between items-center px-4 gap-4">
                <button onClick={onDoNowOpen} className="w-full md:w-auto bg-slate-800 hover:bg-slate-900 text-white font-bold py-2 px-6 rounded-full text-sm transition-colors shadow-sm order-2 md:order-1">
                    {ui.donow_btn}
                </button>

                <div className="flex items-center gap-3 order-1 md:order-2 w-full md:w-auto justify-center md:justify-end">
                    {/* NEW CONTENT BUTTON */}
                    <button onClick={onContentOpen} className="bg-emerald-100 hover:bg-emerald-200 text-emerald-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-emerald-200 shadow-sm">
                        Inneh√•ll
                    </button>
                    <button onClick={onLgrOpen} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-sky-200 shadow-sm">
                        {ui.lgr_btn}
                    </button>
                </div>
            </footer>
        </div>
    );
};

export default Dashboard;

// FILE END: src\components\views\Dashboard.jsx

// =======================================================
// FILE START: src\components\views\DoNowConfig.jsx
// =======================================================

import React, { useState } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const DoNowConfig = ({ ui, onBack, onGenerate, lang }) => {
    const [selected, setSelected] = useState([]);

    const handleToggle = (topicId, level) => {
        setSelected(prev => {
            const exists = prev.find(p => p.topic === topicId && p.level === level);
            if (exists) {
                return prev.filter(p => !(p.topic === topicId && p.level === level));
            } else {
                if (prev.length >= 3) return prev; // Max 3
                return [...prev, { topic: topicId, level }];
            }
        });
    };

    return (
        <div className="max-w-5xl mx-auto p-6 h-full flex flex-col">
            <div className="flex justify-between items-center mb-6">
                <button onClick={onBack} className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2">
                    <span>‚Üê</span> {ui.backBtn}
                </button>
                <h2 className="text-2xl font-bold text-slate-800">{ui.donow_title}</h2>
                <button
                    onClick={() => onGenerate(selected)}
                    disabled={selected.length === 0}
                    className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
                >
                    {ui.donow_gen} ({selected.length}/3)
                </button>
            </div>

            <p className="text-slate-500 mb-6 text-center">{ui.donow_desc}</p>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-6 overflow-y-auto custom-scrollbar pb-10">
                {Object.entries(CATEGORIES).map(([catKey, category]) => (
                    <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                        <h3 className="font-bold text-slate-700 mb-3 border-b pb-2">{category.label[lang]}</h3>
                        <div className="space-y-4">
                            {category.topics.map(topic => (
                                <div key={topic.id}>
                                    <div className="text-xs font-bold text-slate-400 uppercase mb-2">{topic.label[lang]}</div>
                                    <div className="flex flex-col gap-2">
                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                            if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                            const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);
                                            return (
                                                <button
                                                    key={lvl}
                                                    onClick={() => handleToggle(topic.id, lvl)}
                                                    className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${isSelected ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'}`}
                                                >
                                                    <span className="font-mono font-bold w-6 text-center bg-white/50 rounded">{lvl}</span>
                                                    <span className="truncate">{LEVEL_DESCRIPTIONS[topic.id][lvl][lang]}</span>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default DoNowConfig;

// FILE END: src\components\views\DoNowConfig.jsx

// =======================================================
// FILE START: src\components\views\DoNowGrid.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual } from '../visuals/GeometryComponents';

const DoNowCard = ({ q, index, showAnswer, onToggle, lang, onRefresh }) => {
    const desc = typeof q.renderData.description === 'object' ? q.renderData.description[lang] : q.renderData.description;
    const latex = q.renderData.latex;

    // --- Adaptive Layout Logic ---
    const isTextOnly = 
        (q.topic === 'equation' && (q.level === 5 || q.level === 6)) ||
        (q.topic === 'simplify' && q.level === 5);

    // --- Dynamic Text Scaling ---
    const getDescSize = (text) => {
        if (!text) return 'text-xl md:text-3xl';
        const len = text.length;
        if (isTextOnly) {
            if (len > 200) return 'text-base md:text-xl leading-relaxed';
            if (len > 100) return 'text-lg md:text-2xl leading-relaxed';
            if (len > 50) return 'text-xl md:text-3xl leading-relaxed';
            return 'text-2xl md:text-4xl leading-relaxed';
        } else {
            if (len > 80) return 'text-sm md:text-base leading-snug';
            if (len > 40) return 'text-base md:text-xl leading-normal';
            return 'text-lg md:text-2xl font-medium';
        }
    };

    const hasVisualData = (q.renderData.geometry || q.renderData.graph) && !isTextOnly;

    const renderVisual = () => {
        if (!hasVisualData) return null;

        if (q.renderData.graph) {
            return <GraphCanvas data={q.renderData.graph} width={300} height={200} />;
        }

        const geom = q.renderData.geometry;
        if (!geom) return null;

        const volumeTypes = ['cuboid', 'cylinder', 'cone', 'sphere', 'hemisphere', 'pyramid', 'triangular_prism', 'silo', 'ice_cream'];
        if (volumeTypes.includes(geom.type)) {
            return <VolumeVisualization data={geom} width={300} height={200} />;
        }

        return <GeometryVisual data={geom} />;
    };

    // Calculate rotation for refresh icon interaction
    const [isSpinning, setIsSpinning] = useState(false);
    
    // Auto-stop spinning if the question data actually changes (detected by token or description change)
    useEffect(() => {
        if (isSpinning) {
            const timer = setTimeout(() => setIsSpinning(false), 500); // Minimum spin time
            return () => clearTimeout(timer);
        }
    }, [q.token, q.renderData.description]); // Dependency ensures spin stops when new data arrives

    const handleRefreshClick = (e) => {
        e.stopPropagation();
        if (isSpinning) return; // Prevent double-clicks
        
        setIsSpinning(true);
        if (onRefresh) onRefresh();
        
        // Safety timeout in case props don't change (e.g. same question generated)
        setTimeout(() => setIsSpinning(false), 2000); 
    };

    return (
        <div 
            onClick={onToggle}
            className={`
                relative flex flex-col justify-between 
                bg-white rounded-2xl shadow-sm border-2 transition-all duration-300 cursor-pointer overflow-hidden group
                ${showAnswer ? 'border-indigo-500 ring-4 ring-indigo-500/20 scale-[1.02]' : 'border-slate-200 hover:border-indigo-300 hover:shadow-md'}
            `}
        >
            {/* Card Content */}
            <div className="p-5 flex flex-col flex-1 h-full">
                
                {/* Refresh Button (New) */}
                <button
                    onClick={handleRefreshClick}
                    disabled={isSpinning}
                    className={`
                        absolute top-3 right-3 w-8 h-8 rounded-full flex items-center justify-center transition-colors z-20 border 
                        ${isSpinning ? 'bg-indigo-50 border-indigo-200 cursor-wait' : 'bg-slate-50 hover:bg-indigo-100 text-slate-400 hover:text-indigo-600 border-slate-200'}
                    `}
                    title={lang === 'sv' ? "Ny fr√•ga" : "New question"}
                >
                    <span className={`text-sm ${isSpinning ? 'animate-spin' : ''}`}>üîÑ</span>
                </button>

                {/* Visual Container */}
                {hasVisualData && (
                    <div className="mb-4 bg-slate-50 rounded-xl border border-slate-100 overflow-hidden flex justify-center items-center py-4 min-h-[160px]">
                        {renderVisual()}
                    </div>
                )}

                {/* Text Content */}
                <div className="flex-1 flex flex-col justify-center items-center text-center">
                    <p className={`font-medium text-slate-700 mb-3 ${getDescSize(desc)}`}>
                        {desc}
                    </p>
                    
                    {latex && (
                        <div className="mt-2 text-2xl md:text-4xl font-black text-slate-800 tracking-wide">
                            <MathText text={latex} />
                        </div>
                    )}
                </div>
            </div>

            {/* Answer Overlay */}
            {showAnswer && (
                <div className="absolute inset-0 z-10 bg-white/95 backdrop-blur-sm flex flex-col items-center justify-center p-6 animate-in fade-in duration-200">
                    <div className="text-xs font-bold text-indigo-500 uppercase tracking-widest mb-2">
                        {lang === 'sv' ? 'FACIT' : 'ANSWER'}
                    </div>
                    <div className="text-3xl md:text-5xl font-black text-indigo-900 text-center break-words w-full">
                        {tryDecode(q.token)} <span className="text-xl text-slate-400 font-medium ml-1">{q.renderData.suffix}</span>
                    </div>
                </div>
            )}

            {/* Number Badge */}
            <div className={`absolute top-3 left-3 w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold transition-colors ${showAnswer ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-400 group-hover:bg-slate-200'}`}>
                {index + 1}
            </div>
        </div>
    );
};

const tryDecode = (str) => {
    try { return atob(str); } catch (e) { return "Error"; }
};

const DoNowGrid = ({ questions, ui, lang, onBack, onRefreshAll, onRefreshOne }) => {
    const [revealed, setRevealed] = useState({});
    const [showAll, setShowAll] = useState(false);
    const [isRegenerating, setIsRegenerating] = useState(false);

    const toggleOne = (idx) => {
        setRevealed(prev => ({ ...prev, [idx]: !prev[idx] }));
    };

    const toggleAll = () => {
        if (showAll) {
            setRevealed({});
            setShowAll(false);
        } else {
            const all = {};
            questions.forEach((_, i) => all[i] = true);
            setRevealed(all);
            setShowAll(true);
        }
    };

    const handleRegenerateAll = () => {
        setIsRegenerating(true);
        setRevealed({});
        setShowAll(false);
        
        if (onRefreshAll) {
            onRefreshAll().finally(() => setIsRegenerating(false));
        } else {
            setTimeout(() => setIsRegenerating(false), 500);
        }
    };

    return (
        <div className="h-screen flex flex-col bg-slate-50">
            {/* Header */}
            <header className="bg-white border-b border-slate-200 px-6 py-4 flex justify-between items-center shadow-sm z-20 sticky top-0">
                <div className="flex items-center gap-4">
                    <button onClick={onBack} className="flex items-center gap-2 text-slate-500 font-bold hover:text-indigo-600 transition-colors">
                        <span className="text-xl">‚Üê</span> 
                        <span>{ui.backBtn || "Back"}</span>
                    </button>
                    <h2 className="text-lg font-black text-slate-800 hidden md:block tracking-tight border-l border-slate-200 pl-4 ml-2">
                        {ui.donow_title}
                    </h2>
                </div>

                <div className="flex items-center gap-3">
                    {/* Regenerate All Button (New) */}
                    <button 
                        onClick={handleRegenerateAll}
                        disabled={isRegenerating}
                        className="px-4 py-2 rounded-full font-bold text-sm bg-slate-100 text-slate-600 hover:bg-slate-200 hover:text-indigo-600 transition-all flex items-center gap-2"
                        title={ui.donow_regenerate || "Regenerate all"}
                    >
                        <span className={isRegenerating ? 'animate-spin' : ''}>üîÑ</span>
                        <span className="hidden sm:inline">{ui.donow_regenerate || "New Set"}</span>
                    </button>

                    <button 
                        onClick={toggleAll} 
                        className={`
                            px-5 py-2 rounded-full font-bold text-sm transition-all shadow-sm flex items-center gap-2
                            ${showAll 
                                ? 'bg-slate-800 text-white hover:bg-black' 
                                : 'bg-indigo-600 text-white hover:bg-indigo-700 hover:shadow-md'}
                        `}
                    >
                        <span>{showAll ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è'}</span>
                        {showAll ? (ui.donow_hide_all || "Hide All") : (ui.donow_show_all || "Show All")}
                    </button>
                </div>
            </header>

            {/* Scrollable Grid Area */}
            <div className="flex-1 p-4 md:p-8 overflow-y-auto">
                {/* STRICT 3 COLUMN GRID */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-3 gap-6 max-w-8xl mx-auto pb-10">
                    {questions.map((q, i) => (
                        <DoNowCard
                            key={i}
                            index={i}
                            q={q}
                            showAnswer={!!revealed[i]}
                            onToggle={() => toggleOne(i)}
                            lang={lang}
                            onRefresh={() => onRefreshOne && onRefreshOne(i, q.topic, q.level)}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
};

export default DoNowGrid;

// FILE END: src\components\views\DoNowGrid.jsx

// =======================================================
// FILE START: src\components\views\PracticeView.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual, StaticGeometryVisual } from '../visuals/GeometryComponents';
import CluePanel from '../practice/CluePanel';
import HistoryList from '../practice/HistoryList';
import LevelUpModal from '../modals/LevelUpModal';
import StreakModal from '../modals/StreakModal'; 
import { LEVEL_DESCRIPTIONS } from '../../constants/localization'; 

// --- SECURITY HELPERS ---

const isValidInput = (val, type) => {
    if (val === '') return true;
    const numericRegex = /^-?[\d\s]*([.,:]\d*)?$/;
    
    // Add 'range' to allowed types for numeric validation
    if (type === 'numeric' || type === 'scale' || type === 'range') {
        return numericRegex.test(val);
    }
    
    const dangerousRegex = /[<>{}]/g;
    return !dangerousRegex.test(val);
};

const sanitize = (val) => {
    return val.replace(/[<>{}]/g, "");
};

const PracticeView = ({ 
    lang, 
    ui, 
    question, 
    loading, 
    feedback, 
    streak, 
    input, 
    setInput, 
    handleSubmit, 
    handleHint, 
    handleSolution, 
    handleSkip, 
    handleChangeLevel, 
    revealedClues, 
    uiState, 
    actions, 
    levelUpAvailable, 
    setLevelUpAvailable, 
    isSolutionRevealed, 
    showStreakModal, 
    setShowStreakModal, 
    showTotalModal, 
    setShowTotalModal, 
    totalCorrect, 
    timerSettings, 
    formatTime, 
    setMobileHistoryOpen 
}) => {
    // --- STATE FOR STRUCTURED INPUTS ---
    const [scaleInputLeft, setScaleInputLeft] = useState('');
    const [scaleInputRight, setScaleInputRight] = useState('');
    
    // New States for Exponents Unit
    const [powerBase, setPowerBase] = useState('');
    const [powerExp, setPowerExp] = useState('');
    const [sciMantissa, setSciMantissa] = useState('');
    const [sciExp, setSciExp] = useState('');
    const [rangeLower, setRangeLower] = useState('');
    const [rangeUpper, setRangeUpper] = useState('');

    const inputRef = useRef(null);

    // Auto-advance logic
    const retryRef = useRef(actions.retry);
    useEffect(() => { retryRef.current = actions.retry; }, [actions.retry]);
    useEffect(() => {
        if (feedback === 'correct' && isSolutionRevealed) {
            const timer = setTimeout(() => {
                retryRef.current(); 
            }, 1500);
            return () => clearTimeout(timer);
        }
    }, [feedback, isSolutionRevealed]);

    const descriptionText = typeof question?.renderData?.description === 'object' ? question.renderData.description[lang] : question?.renderData?.description;
    
    const handleChoiceClick = (choice) => { 
        if (feedback === 'correct') return; 
        setInput(choice); 
        handleSubmit({ preventDefault: () => { } }, choice); 
    };
    
    // --- SUBMIT HANDLER ---
    const handleFormSubmit = (e) => {
        e.preventDefault();
        
        // UX FIX: If correct, next question
        if (feedback === 'correct') {
            actions.retry(true);
            return;
        }

        let finalInput = input;
        const type = question.renderData.answerType;

        if (type === 'scale') {
            if (scaleInputLeft === '' || scaleInputRight === '') return;
            finalInput = `${scaleInputLeft}:${scaleInputRight}`;
        } 
        else if (type === 'structured_power') {
            if (powerBase === '' || powerExp === '') return;
            finalInput = `${powerBase}^${powerExp}`;
        }
        else if (type === 'structured_scientific') {
            if (sciMantissa === '' || sciExp === '') return;
            finalInput = `${sciMantissa}*10^${sciExp}`;
        }
        else if (type === 'structured_range') {
            if (rangeLower === '' || rangeUpper === '') return;
            finalInput = `${rangeLower}:${rangeUpper}`;
        }
        else {
            if (!isValidInput(input, type === 'numeric' ? 'numeric' : 'text')) return;
            if (type !== 'numeric') finalInput = sanitize(input);
        }

        if (!finalInput || finalInput.trim() === '') return;

        handleSubmit(e, finalInput);
    };

    const handleInputChange = (e, setter, type) => {
        const val = e.target.value;
        if (isValidInput(val, type)) {
            setter(val);
        }
    };

    // Reset specialized inputs on new question
    useEffect(() => {
        if (question && !loading) {
            setScaleInputLeft(''); setScaleInputRight('');
            setPowerBase(question.renderData.prefillBase || '');
            setPowerExp('');
            setSciMantissa('');
            setSciExp('');
            setRangeLower('');
            setRangeUpper('');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            const isMobile = window.innerWidth < 768;
            if (!isMobile && inputRef.current) {
                inputRef.current.focus();
            }
        }
    }, [question, loading]);

    const maxLevels = Object.keys(LEVEL_DESCRIPTIONS[uiState.topic] || {}).length;

    const renderVisual = () => {
        if (!question?.renderData) return null;

        if (question.renderData.graph) return <GraphCanvas data={question.renderData.graph} />;
        
        const geom = question.renderData.geometry;
        if (geom) {
            if (geom.type === 'frequency_table') return <GeometryVisual data={geom} />; 
            const volumeTypes = ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'];
            if (volumeTypes.includes(geom.type)) return <VolumeVisualization data={geom} />;
            return <GeometryVisual data={geom} />;
        }

        if (uiState.topic === 'geometry') return <StaticGeometryVisual description={descriptionText} />;

        if (question.renderData.latex) {
             return <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true} /></div>;
        }

        return <div className="flex flex-col items-center justify-center w-full min-h-[100px]"></div>;
    };

    const getSubmitLabel = () => {
        if (feedback === 'correct') return ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°");
        if (feedback === 'incorrect') return ui.tagWrong || "Incorrect";
        return ui.btnCheck || (lang === 'sv' ? "Svara" : "Submit");
    };

    const isDisabled = feedback === 'correct';

    return (
        <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
            
            <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => { setLevelUpAvailable(false); actions.retry(true); }} lang={lang} />
            <StreakModal visible={showStreakModal} onClose={() => setShowStreakModal(false)} streak={streak} ui={ui} />
            
            <div className="flex-1 w-full min-w-0">
                {/* HEADER */}
                <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                    <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>

                    <div className="flex items-center gap-3">
                        {timerSettings.duration > 0 && (
                            <div className={`font-mono text-sm font-bold px-3 py-1.5 rounded-lg border hidden sm:block ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                {formatTime(timerSettings.remaining)}
                            </div>
                        )}
                        <div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200">
                            <button onClick={() => handleChangeLevel(-1)} disabled={uiState.level <= 1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel || "<"}>&lt;</button>
                            <span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span>
                            <button onClick={() => handleChangeLevel(1)} disabled={uiState.level >= maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel || ">"}>&gt;</button>
                        </div>
                        <button onClick={() => setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500 hover:bg-gray-200 transition-colors">
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                    </div>
                </div>

                <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                    {loading ? (
                        <div className="p-20 text-center flex flex-col items-center gap-4">
                            <div className="w-10 h-10 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"></div>
                        </div>
                    ) : question ? (
                        <div className="p-4 sm:p-6">
                            <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                {renderVisual()}
                            </div>
                            
                            <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText} /></h2></div>
                            
                            {question.renderData.answerType === 'multiple_choice' ? (
                                <div className="max-w-md mx-auto grid grid-cols-2 gap-4">
                                    {(question.renderData.options || question.renderData.choices || []).map((choice, idx) => (
                                        <button key={idx} onClick={() => handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback === 'correct' && choice === input ? 'bg-green-500 border-green-500 text-white' : feedback === 'incorrect' && choice === input ? 'bg-red-500 border-red-500 text-white' : 'bg-white border-gray-200 text-gray-700 hover:border-indigo-500 hover:text-indigo-600'}`} disabled={feedback !== null}>{choice}</button>
                                    ))}
                                    {feedback === 'correct' && <div className="col-span-2 mt-4"><button onClick={() => actions.retry(true)} className="w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 bg-primary-500 shadow-green-200 hover:bg-primary-600">{ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°")}</button></div>}
                                </div>
                            ) : (
                                <form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                    
                                    {/* --- INPUT TYPE SWITCH --- */}
                                    
                                    {question.renderData.answerType === 'scale' && (
                                        <div className="flex items-center justify-center gap-2">
                                            <input type="text" value={scaleInputLeft} onChange={(e) => handleInputChange(e, setScaleInputLeft, 'numeric')} className="w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm focus:border-indigo-500" placeholder="X" disabled={isDisabled} />
                                            <span className="text-2xl font-bold text-gray-400">:</span>
                                            <input type="text" value={scaleInputRight} onChange={(e) => handleInputChange(e, setScaleInputRight, 'numeric')} className="w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm focus:border-indigo-500" placeholder="X" disabled={isDisabled} />
                                        </div>
                                    )}

                                    {question.renderData.answerType === 'structured_power' && (
                                        <div className="flex items-end justify-center gap-1">
                                            <input type="text" value={powerBase} onChange={(e) => handleInputChange(e, setPowerBase, 'text')} className="w-24 p-4 text-center text-2xl font-bold border-2 rounded-xl outline-none focus:border-indigo-500" placeholder="Base" disabled={isDisabled} />
                                            <div className="mb-8">
                                                <input type="text" value={powerExp} onChange={(e) => handleInputChange(e, setPowerExp, 'numeric')} className="w-16 p-2 text-center text-lg font-bold border-2 rounded-lg outline-none focus:border-indigo-500 bg-gray-50" placeholder="exp" disabled={isDisabled} />
                                            </div>
                                        </div>
                                    )}

                                    {question.renderData.answerType === 'structured_scientific' && (
                                        <div className="flex items-center justify-center gap-2 text-2xl font-bold text-gray-600">
                                            <input type="text" value={sciMantissa} onChange={(e) => handleInputChange(e, setSciMantissa, 'numeric')} className="w-28 p-3 text-center border-2 rounded-xl outline-none focus:border-indigo-500" placeholder="a" disabled={isDisabled} />
                                            <span>¬∑ 10</span>
                                            <div className="mb-8">
                                                <input type="text" value={sciExp} onChange={(e) => handleInputChange(e, setSciExp, 'numeric')} className="w-16 p-2 text-center text-lg border-2 rounded-lg outline-none focus:border-indigo-500 bg-gray-50" placeholder="n" disabled={isDisabled} />
                                            </div>
                                        </div>
                                    )}

                                    {question.renderData.answerType === 'structured_range' && (
                                        <div className="flex items-center justify-center gap-3 text-xl font-bold text-gray-500">
                                            <input type="text" value={rangeLower} onChange={(e) => handleInputChange(e, setRangeLower, 'numeric')} className="w-20 p-3 text-center border-2 rounded-xl" placeholder="min" disabled={isDisabled} />
                                            <span>&lt;</span>
                                            <span className="text-black"><MathText text={question.renderData.latex} /></span>
                                            <span>&lt;</span>
                                            <input type="text" value={rangeUpper} onChange={(e) => handleInputChange(e, setRangeUpper, 'numeric')} className="w-20 p-3 text-center border-2 rounded-xl" placeholder="max" disabled={isDisabled} />
                                        </div>
                                    )}

                                    {/* Default Text Input */}
                                    {!['scale', 'structured_power', 'structured_scientific', 'structured_range'].includes(question.renderData.answerType) && (
                                        <div className="relative">
                                            <input ref={inputRef} type="text" value={input} onChange={(e) => handleInputChange(e, setInput, question.renderData.answerType)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-green-500 bg-green-50 text-green-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-indigo-500 focus:ring-4 focus:ring-indigo-50'}`} placeholder={ui.placeholder || "..."} disabled={isDisabled} />
                                            {question.renderData.suffix && <span className="absolute right-6 top-1/2 -translate-y-1/2 text-slate-400 font-bold text-lg pointer-events-none">{question.renderData.suffix}</span>}
                                        </div>
                                    )}
                                    
                                    <button 
                                        type="submit" 
                                        className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback === 'correct' ? 'bg-green-500 shadow-green-200 hover:bg-green-600' : 'bg-indigo-600 hover:bg-indigo-700 shadow-indigo-200 hover:shadow-lg'}`}
                                    >
                                        {getSubmitLabel()}
                                    </button>
                                </form>
                            )}

                            <div className="mt-6 flex gap-3 justify-center flex-wrap">
                                <button type="button" onClick={handleHint} disabled={!question.clues || revealedClues.length >= question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-yellow-50 text-yellow-700 border border-yellow-200 hover:bg-yellow-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button>
                                <button type="button" onClick={handleSolution} disabled={!question.clues || isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button>
                                <button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button>
                            </div>
                        </div>
                    ) : (
                        <div className="p-12 text-center text-red-400">
                            <p>{ui.error || "Failed to load question."}</p>
                            <button onClick={() => actions.retry(true)} className="text-indigo-600 underline text-sm mt-2">Retry</button>
                        </div>
                    )}
                </main>

                <div className="lg:hidden mt-6 w-full">
                    {(revealedClues.length > 0 || isSolutionRevealed) && (
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                    )}
                </div>

            </div>
            
            <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui} /></div>
            </div>
        </div>
    );
};

export default PracticeView;

// FILE END: src\components\views\PracticeView.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryComponents.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

// =====================================================================
// 1. 2D GEOMETRY VISUAL (Shapes & Icons & Probability & Statistics)
// =====================================================================
export const GeometryVisual = ({ data }) => {
    if (!data) return null;

    // --- STATISTICS: FREQUENCY TABLE ---
    if (data.type === 'frequency_table') {
        const { headers, rows } = data; // headers: ["Value", "Freq"], rows: [[1, 5], [2, 3]...]
        
        return (
            <div className="flex justify-center my-4 w-full">
                <div className="border border-slate-300 rounded-lg overflow-hidden shadow-sm bg-white min-w-[200px]">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-slate-100 text-slate-700 font-bold uppercase text-xs">
                            <tr>
                                {headers.map((h, i) => (
                                    <th key={i} className="px-4 py-2 border-b border-slate-200 text-center">{h}</th>
                                ))}
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-100">
                            {rows.map((row, rI) => (
                                <tr key={rI} className="hover:bg-slate-50">
                                    {row.map((cell, cI) => (
                                        <td key={cI} className="px-4 py-2 text-center font-mono text-slate-600">{cell}</td>
                                    ))}
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    }

    // --- PROBABILITY: MARBLES ---
    if (data.type === 'probability_marbles') {
        const { red, blue, green } = data.items;
        const total = red + blue + green;
        
        const colors = [];
        for(let i=0; i<red; i++) colors.push('#ef4444');
        for(let i=0; i<blue; i++) colors.push('#3b82f6');
        for(let i=0; i<green; i++) colors.push('#22c55e');
        
        // Pseudo-shuffle for visual stability based on counts
        // Just interleave them simply for deterministic render
        const mixed = [];
        while(colors.length) {
            if (colors.length % 3 === 0) mixed.push(colors.pop()); 
            else mixed.unshift(colors.pop());
        }

        return (
            <div className="flex justify-center my-4">
                <svg width="200" height="200" viewBox="0 0 200 200" className="bg-slate-100 rounded-full border-4 border-slate-300 shadow-inner">
                    {mixed.map((c, i) => {
                        // Spiral packing approximation
                        const angle = i * 2.4; 
                        const dist = 15 + i * 4; 
                        const x = 100 + dist * Math.cos(angle);
                        const y = 100 + dist * Math.sin(angle);
                        return <circle key={i} cx={x} cy={y} r={12} fill={c} stroke="rgba(0,0,0,0.2)" strokeWidth="1" />;
                    })}
                </svg>
            </div>
        );
    }

    // --- PROBABILITY: SPINNER ---
    if (data.type === 'probability_spinner') {
        const { sections, target } = data; 
        const radius = 80;
        const cx = 100;
        const cy = 100;
        const step = (2 * Math.PI) / sections;
        const colors = ['#3b82f6', '#ef4444', '#22c55e', '#eab308', '#a855f7', '#ec4899']; 

        const slices = [];
        for (let i = 0; i < sections; i++) {
            const startAngle = i * step - Math.PI/2; 
            const endAngle = (i + 1) * step - Math.PI/2;
            const x1 = cx + radius * Math.cos(startAngle);
            const y1 = cy + radius * Math.sin(startAngle);
            const x2 = cx + radius * Math.cos(endAngle);
            const y2 = cy + radius * Math.sin(endAngle);
            const largeArc = step > Math.PI ? 1 : 0;
            const pathData = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
            slices.push(<path key={i} d={pathData} fill={colors[i % colors.length]} stroke="white" strokeWidth="2" />);
        }

        return (
            <div className="flex justify-center my-4">
                <svg width="200" height="200" viewBox="0 0 200 200">
                    {slices}
                    <polygon points="100,20 90,40 110,40" fill="#1e293b" />
                    <circle cx="100" cy="100" r="5" fill="#1e293b" />
                </svg>
            </div>
        );
    }

    // --- PERCENT GRID ---
    if (data.type === 'percent_grid') {
        const { total = 100, colored = 0 } = data;
        const size = 300;
        const cellSize = size / 10;
        const cells = [];
        for (let i = 0; i < 100; i++) {
            const x = (i % 10) * cellSize;
            const y = Math.floor(i / 10) * cellSize;
            const isColored = i < colored;
            cells.push(
                <rect key={i} x={x} y={y} width={cellSize - 2} height={cellSize - 2} fill={isColored ? "#3b82f6" : "#f1f5f9"} stroke={isColored ? "#2563eb" : "#e2e8f0"} rx="4" />
            );
        }
        return <div className="flex justify-center my-4"><svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>{cells}</svg></div>;
    }

    // --- SHAPES RENDERER (Original Logic) ---
    const mkTxt = (x, y, txt, anchor = "middle", baseline = "middle", color = "#374151") =>
        <text key={`${x}-${y}-${txt}`} x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill={color} fontSize="20">{txt}</text>;

    const RenderShape = ({ type, dims, labels, areaText, offsetX = 0, offsetY = 0, scale = 1 }) => {
        const cx = 150 + offsetX;
        const cy = 125 + offsetY;
        
        const maxDim = Math.max(dims.width || 0, dims.height || 0, (dims.radius || 0) * 2) || 10;
        const baseScale = (120 / maxDim) * scale;

        const sw = (dims.width || 0) * baseScale;
        const sh = (dims.height || 0) * baseScale;
        const sr = (dims.radius || 0) * baseScale;

        // Resolve aliases for Base and Height
        const l_b = labels?.b || labels?.base || labels?.width || labels?.w || (type === 'rectangle' ? dims.width : null);
        const l_h = labels?.h || labels?.height || (type === 'rectangle' ? dims.height : null);
        // Added: Resolve aliases for Hypotenuse/Diagonal
        const l_hyp = labels?.hyp || labels?.hypotenuse || labels?.c || labels?.diagonal;
        
        if (type === 'rectangle' || type === 'square' || type === 'parallelogram') {
            return (
                <g>
                    <rect x={cx - sw / 2} y={cy - sh / 2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {l_b && mkTxt(cx, cy + sh / 2 + 25, l_b)}
                    {l_h && mkTxt(cx + sw / 2 + 15, cy, l_h, "start")}
                    {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
                </g>
            );
        }

        if (type === 'triangle') {
            const L = cx - sw / 2;
            const R = cx + sw / 2;
            const T = cy - sh / 2;
            const B = cy + sh / 2;

            if (dims.subtype === 'right') {
                const p1 = { x: L, y: T }; const p2 = { x: L, y: B }; const p3 = { x: R, y: B };
                const path = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
                return (
                    <g>
                        <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                        {/* Use l_h and l_b aliases instead of raw labels.h/b to support 'height'/'base' keys */}
                        {l_h && mkTxt(L - 15, cy, l_h)}
                        {l_b && mkTxt(cx, B + 25, l_b)}
                        {/* New: Hypotenuse Label (offset slightly up and right from center) */}
                        {l_hyp && mkTxt(cx + 10, cy - 10, l_hyp, "start")}
                    </g>
                );
            } 
            else {
                const points = `${L},${B} ${R},${B} ${cx},${T}`;
                return (
                    <g>
                        <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                        <polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                        {/* Use l_b and l_h aliases here too */}
                        {l_b && mkTxt(cx, B + 25, l_b)}
                        {l_h && mkTxt(cx + 5, cy, l_h, "start")}
                    </g>
                );
            }
        }

        if (type === 'circle') {
            const isDiameter = dims.show === 'diameter';
            const labelTxt = labels?.val || (labels?.r ? `r=${labels.r}` : `d=${labels.diameter}`);
            return (
                <g>
                    <circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {isDiameter ? (
                        <>
                            <line x1={cx - sr} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" strokeDasharray="4" />
                            <text x={cx} y={cy - 15} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>
                        </>
                    ) : (
                        <>
                            <circle cx={cx} cy={cy} r={3} fill="#374151" />
                            <line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" />
                            <text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>
                        </>
                    )}
                </g>
            );
        }
        return null;
    };

    if (data.type === 'similarity_compare') {
        const shapeType = data.shapeType || 'triangle';
        const leftDims = { ...data.left, width: 40, height: 40, radius: 20, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
        const rightDims = { ...data.right, width: 60, height: 60, radius: 30, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };

        return (
            <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
                <RenderShape type={shapeType} dims={leftDims} labels={data.left.labels} offsetX={-25} scale={0.8} />
                <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
                <RenderShape type={shapeType} dims={rightDims} labels={data.right.labels} offsetX={225} scale={1.2} />
            </svg>
        );
    }

    if (data.type === 'scale_single' || data.type === 'scale_compare') { 
        const shapeEmojis = { 
            square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', cube: 'üßä', cylinder: 'üõ¢Ô∏è', 
            pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ', arrow: '‚û°', star: '‚≠ê', lightning: '‚ö°', 
            key: 'üîë', heart: '‚ù§Ô∏è', cloud: '‚òÅÔ∏è', moon: 'üåô', sun: '‚òÄÔ∏è', magnifying_glass: 'üîç', map: 'üó∫Ô∏è',
            car: 'üöó', ladybug: 'üêû', house: 'üè†'
        }; 
        const emoji = shapeEmojis[data.shape] || 'üì¶'; 
        const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl select-none" style={{ fontSize: size }}>{emoji}</div>; 
        
        if (data.type === 'scale_single') 
            return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="80px" /><span className="bg-white px-4 py-2 rounded shadow text-3xl font-bold font-mono border border-gray-200">{data.label}</span></div>; 
        
        return (
            <div className="flex items-center justify-center gap-4 sm:gap-8 my-6">
                <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="60px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.leftValue}</span></div>
                <div className="text-gray-300 text-3xl">‚Üí</div>
                <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="100px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.rightValue}</span></div>
            </div>
        ); 
    }

    if (data.type === 'transversal') {
        const labels = data.labels;
        return (
            <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
                <polygon points="150,30 50,220 250,220" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.3" />
                <line x1="100" y1="125" x2="200" y2="125" stroke="#059669" strokeWidth="3" />
                <text x="85" y="80" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_top}</text>
                <text x="40" y="150" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_tot}</text>
                <text x="150" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_top}</text>
                <text x="150" y="240" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_bot}</text>
                <path d="M 150 125 l -5 -5 m 5 5 l -5 5" stroke="#059669" strokeWidth="2" fill="none"/>
                <path d="M 150 220 l -5 -5 m 5 5 l -5 5" stroke="#10b981" strokeWidth="2" fill="none"/>
            </svg>
        );
    }

    if (data.type === 'compare_shapes_area') {
        return (
             <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
                <RenderShape type={data.shapeType} dims={data.left} areaText={data.left.area} offsetX={-25} scale={0.8} />
                <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
                <RenderShape type={data.shapeType} dims={data.right} areaText={data.right.area} offsetX={225} scale={1.2} />
            </svg>
        );
    }

    if (['rectangle', 'square', 'parallelogram', 'triangle', 'circle'].includes(data.type)) {
        return (
            <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
                <RenderShape type={data.type} dims={data} labels={data.labels} />
            </svg>
        );
    }
    
    if (data.type === 'composite') {
        return (
            <div className="flex justify-center my-4">
                <svg width="200" height="200" viewBox="0 0 200 200" className="border border-gray-100 rounded-lg bg-white shadow-sm">
                    {data.subtype === 'house' ? (
                        <>
                            <rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <text x="160" y="120" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                            <text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                            <text x="130" y="60" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h_roof}</text>
                        </>
                    ) : (
                        <>
                            <rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                            <text x="160" y="120" textAnchor="start" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                        </>
                    )}
                </svg>
            </div>
        );
    }

    return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>;
};
GeometryVisual.requiresCanvas = true;

// ... GraphCanvas and VolumeVisualization are unchanged, implicitly included ...
export const GraphCanvas = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const range = data.range || 10;
        ctx.clearRect(0, 0, width, height);
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const toX = (val) => (val + range) * (width / (range * 2));
        const toY = (val) => height - (val + range) * (height / (range * 2));
        
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        for (let i = -range; i <= range; i += data.gridStep || 1) {
            ctx.beginPath(); ctx.moveTo(toX(i), 0); ctx.lineTo(toX(i), height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, toY(i)); ctx.lineTo(width, toY(i)); ctx.stroke();
        }
        ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(width, toY(0)); ctx.stroke();
        ctx.fillStyle = '#6b7280';
        const step = data.labelStep || 2;
        for (let i = -range; i <= range; i += step) {
            if (i === 0) continue;
            const xPos = toX(i); const yOrigin = toY(0);
            ctx.beginPath(); ctx.moveTo(xPos, yOrigin - 3); ctx.lineTo(xPos, yOrigin + 3); ctx.stroke();
            ctx.fillText(i.toString(), xPos, yOrigin + 12);
            const yPos = toY(i); const xOrigin = toX(0);
            ctx.beginPath(); ctx.moveTo(xOrigin - 3, yPos); ctx.lineTo(xOrigin + 3, yPos); ctx.stroke();
            ctx.fillText(i.toString(), xOrigin - 12, yPos);
        }
        data.lines.forEach(line => {
            ctx.strokeStyle = line.color || '#dc2626'; ctx.lineWidth = 3;
            ctx.beginPath();
            const x1 = -range; const y1 = line.slope * x1 + line.intercept;
            const x2 = range; const y2 = line.slope * x2 + line.intercept;
            ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke();
        });
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};
GraphCanvas.requiresCanvas = true;

export const VolumeVisualization = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = '#374151'; 
        ctx.fillStyle = '#f3f4f6';
        ctx.lineWidth = 2; 
        ctx.lineJoin = 'round'; 
        ctx.font = "bold 14px Inter, sans-serif"; 
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";
        const drawLabel = (text, x, y, color='#dc2626') => { 
            if (!text) return;
            ctx.save(); 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
            const m = ctx.measureText(text);
            ctx.fillRect(x - m.width/2 - 2, y - 10, m.width + 4, 20);
            ctx.fillStyle = color; 
            ctx.fillText(text, x, y); 
            ctx.restore(); 
        };
        const drawDashed = (x1, y1, x2, y2) => { 
            ctx.save(); 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath(); 
            ctx.moveTo(x1, y1); 
            ctx.lineTo(x2, y2); 
            ctx.stroke(); 
            ctx.restore(); 
        };
        const TARGET_SIZE = 140; 
        let dims = [];
        if (data.labels) {
            dims = Object.values(data.labels).map(v => parseInt(String(v))).filter(v => !isNaN(v));
        }
        const maxVal = Math.max(...dims, 10);
        const scale = TARGET_SIZE / maxVal;
        if (data.type === 'cuboid') {
            const dw = (parseInt(data.labels.w) || 10) * scale;
            const dh = (parseInt(data.labels.h) || 10) * scale;
            const dd = (parseInt(data.labels.d) || 10) * scale * 0.5;
            const x0 = cx - dw/2 - dd/2;
            const y0 = cy + dh/2 + dd/2;
            ctx.strokeRect(x0, y0 - dh, dw, dh);
            ctx.beginPath(); ctx.moveTo(x0, y0 - dh); ctx.lineTo(x0 + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw, y0 - dh); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dd); ctx.lineTo(x0 + dw, y0); ctx.stroke();
            drawLabel(data.labels.w, x0 + dw/2, y0 + 15);
            drawLabel(data.labels.h, x0 - 20, y0 - dh/2);
            drawLabel(data.labels.d, x0 + dw + dd/2 + 5, y0 - dd/2);
        } 
        else if (data.type === 'triangular_prism') {
            const b = (parseInt(data.labels.b) || 10) * scale;
            const hTri = (parseInt(data.labels.h) || 10) * scale;
            const len = (parseInt(data.labels.l) || 20) * scale * 0.7;
            const startX = cx - b/2 - len/2;
            const startY = cy + hTri/2;
            ctx.beginPath();
            ctx.moveTo(startX, startY); ctx.lineTo(startX + b, startY); ctx.lineTo(startX + b/2, startY - hTri); ctx.closePath(); ctx.stroke();
            const offX = len; const offY = -len * 0.3;
            ctx.beginPath(); ctx.moveTo(startX + b/2, startY - hTri); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX + b, startY); ctx.lineTo(startX + b + offX, startY + offY); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            drawDashed(startX + b/2, startY, startX + b/2, startY - hTri);
            drawLabel(data.labels.h, startX + b/2 + 10, startY - hTri/2);
            drawLabel(data.labels.b, startX + b/2, startY + 15);
            drawLabel(data.labels.l, startX + b + offX/2 + 10, startY + offY/2);
        }
        else if (data.type === 'pyramid') {
            const w = (parseInt(data.labels.w || data.labels.s || 10) * scale);
            const d = (parseInt(data.labels.d || data.labels.s || 10) * scale * 0.6); 
            const hPyr = (parseInt(data.labels.h) || 10) * scale;
            const x0 = cx - w/2 - d/2;
            const y0 = cy + hPyr/3; 
            const FL = {x: x0, y: y0}; const FR = {x: x0+w, y: y0};
            const BR = {x: x0+w+d, y: y0-d}; const BL = {x: x0+d, y: y0-d};
            const Apex = {x: x0 + w/2 + d/2, y: y0 - d/2 - hPyr};
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(FR.x, FR.y); ctx.lineTo(BR.x, BR.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(BL.x, BL.y); ctx.lineTo(FL.x, FL.y); ctx.stroke(); ctx.restore();
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(FR.x, FR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BL.x, BL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke(); ctx.restore();
            const centerBase = {x: x0 + w/2 + d/2, y: y0 - d/2};
            drawDashed(centerBase.x, centerBase.y, Apex.x, Apex.y);
            drawLabel("h=" + data.labels.h, Apex.x + 20, centerBase.y - hPyr/2);
            drawLabel(data.labels.w || data.labels.s, x0 + w/2, y0 + 15);
        }
        else {
            let r = 50; 
            if(data.labels.r) r = parseInt(data.labels.r) * scale;
            if(data.labels.d) r = (parseInt(data.labels.d)/2) * scale;
            r = Math.max(30, Math.min(r, 70));
            const drawCircleData = (centerY, showLabel=true) => {
                 const val = data.labels.val || (data.labels.r ? `r=${data.labels.r}` : `d=${data.labels.d}`);
                 if (data.show === 'diameter') {
                     drawDashed(cx - r, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx, centerY - 10);
                 } else {
                     ctx.beginPath(); ctx.arc(cx, centerY, 2, 0, 2*Math.PI); ctx.fill();
                     drawDashed(cx, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx + r/2, centerY - 10);
                 }
            };
            if (data.type === 'sphere') {
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, cy, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(cy);
            }
            else if (data.type === 'hemisphere') {
                const yBase = cy + 10;
                ctx.beginPath(); ctx.arc(cx, yBase, r, Math.PI, 0); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, yBase, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(yBase);
            }
            else if (data.type === 'cylinder' || data.type === 'silo') {
                const hCyl = (parseInt(data.labels.h) || 10) * scale;
                const topY = cy - hCyl/2;
                const botY = cy + hCyl/2;
                if (data.type === 'cylinder' || data.type === 'silo') {
                     ctx.beginPath(); ctx.ellipse(cx, topY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, topY); ctx.lineTo(cx-r, botY); ctx.stroke();
                     ctx.beginPath(); ctx.moveTo(cx+r, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 15, cy);
                }
                if (data.type === 'silo') { ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); }
                drawCircleData(topY, true);
            }
            else if (data.type === 'cone' || data.type === 'ice_cream') {
                 const hCone = (parseInt(data.labels.h) || 10) * scale;
                 if (data.type === 'cone') {
                     const topY = cy - hCone/2; const botY = cy + hCone/2;
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, botY); ctx.lineTo(cx, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawDashed(cx, botY, cx, topY);
                     drawLabel("h=" + data.labels.h, cx + 5, cy);
                     drawCircleData(botY, true);
                 } else {
                     const seamY = cy - 20; const tipY = seamY + hCone;
                     ctx.beginPath(); ctx.moveTo(cx-r, seamY); ctx.lineTo(cx, tipY); ctx.lineTo(cx+r, seamY); ctx.stroke();
                     ctx.beginPath(); ctx.arc(cx, seamY, r, Math.PI, 0); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, seamY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 10, seamY + hCone/2);
                     drawCircleData(seamY, true);
                 }
            }
        }
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={320} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};
VolumeVisualization.requiresCanvas = true;

// =====================================================================
// 4. STATIC GEOMETRY VISUAL
// =====================================================================
export const StaticGeometryVisual = ({ description }) => { 
    if (!description) return null; 
    const d = description.toLowerCase(); 
    if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; 
    return null; 
};

// FILE END: src\components\visuals\GeometryComponents.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryVisual.jsx
// =======================================================

import React from 'react';

/**
 * Renders SVG geometry. Handles 'similarity' by rendering multiple shapes.
 * Updated to use named export to match PracticeView imports.
 */
export const GeometryVisual = ({ data }) => {
  if (!data) return null;

  // --- Helper: Render a Single Polygon ---
  const renderShape = (points, offsetX = 0, offsetY = 0, color = 'black', key) => {
    if (!points || points.length < 2) return null;
    
    // SVG Coordinate System: Y increases downwards.
    // Math Coordinate System: Y increases upwards.
    // We flip Y (-p.y) so math coordinates (0,10) render above (0,0).
    const pathData = points.map((p, i) => 
      `${i === 0 ? 'M' : 'L'} ${p.x + offsetX} ${-p.y + offsetY}`
    ).join(' ') + ' Z';

    return (
      <path 
        key={key}
        d={pathData} 
        fill={color} 
        fillOpacity="0.2" 
        stroke={color} 
        strokeWidth="2"
        vectorEffect="non-scaling-stroke" // Keeps stroke width constant on zoom
        strokeLinejoin="round"
      />
    );
  };

  // --- Helper: Render Labels ---
  const renderLabels = (labels, shapes) => {
    if (!labels) return null;
    
    return labels.map((lbl, i) => {
      let x = lbl.x;
      let y = -lbl.y; // Flip Y to match shape coordinate system
      
      // Determine offset based on shapeIndex
      // If shapeIndex is 1 (the second shape), we shift it right
      if (lbl.shapeIndex === 1 && shapes && shapes.length > 0) {
        // Find max width of shape 0 to calculate the gap offset
        const shape0Width = shapes[0].points.reduce((max, p) => Math.max(max, p.x), 0);
        const gap = 4; // Must match the gap used in ViewBox calculation
        x += (shape0Width + gap); 
      }

      return (
        <text 
          key={`lbl-${i}`} 
          x={x} 
          y={y} 
          className="text-[0.6px] fill-gray-800 font-medium font-sans select-none"
          textAnchor="middle" 
          dominantBaseline="middle"
        >
          {lbl.text}
        </text>
      );
    });
  };

  // --- ViewBox Calculation ---
  // We need to determine the bounding box of ALL shapes to zoom the SVG correctly.
  let allPoints = [];
  const gap = 4; // Space between similarity shapes

  if (data.type === 'similarity' && data.shapes) {
    // Shape 1 points (no offset)
    const s0Points = data.shapes[0].points;
    
    // Shape 2 points (offset by Shape 1 width + gap)
    const s0Width = s0Points.reduce((max, p) => Math.max(max, p.x), 0);
    const s1Points = data.shapes[1].points.map(p => ({
        x: p.x + s0Width + gap,
        y: p.y
    }));

    allPoints = [...s0Points, ...s1Points];
  } else if (data.points) {
    // Standard single shape
    allPoints = data.points;
  }

  // Safety check
  if (allPoints.length === 0) {
      return <div className="p-4 text-gray-400 italic text-sm text-center">Visual unavailable</div>;
  }

  const minX = Math.min(...allPoints.map(p => p.x));
  const maxX = Math.max(...allPoints.map(p => p.x));
  const minY = Math.min(...allPoints.map(p => -p.y)); // SVG Y
  const maxY = Math.max(...allPoints.map(p => -p.y));

  const padding = 2; // Breathing room around shapes
  const width = maxX - minX + (padding * 2);
  const height = maxY - minY + (padding * 2);
  
  // Construct ViewBox
  const viewBox = `${minX - padding} ${minY - padding} ${width} ${height}`;

  return (
    <div className="w-full flex justify-center items-center p-6 bg-white rounded-xl shadow-sm border border-gray-100 my-4">
      <svg 
        viewBox={viewBox} 
        className="w-full max-w-[500px] h-auto overflow-visible"
        preserveAspectRatio="xMidYMid meet"
      >
        {/* Debug Grid/Axes if requested */}
        {data.showAxes && (
           <g stroke="#e5e7eb" strokeWidth="0.1">
             <line x1="-100" y1="0" x2="100" y2="0" stroke="#9ca3af" />
             <line x1="0" y1="-100" x2="0" y2="100" stroke="#9ca3af" />
           </g>
        )}

        {/* --- Render Logic for Similarity --- */}
        {data.type === 'similarity' && data.shapes && (
          <>
            {/* Shape 1 */}
            {renderShape(data.shapes[0].points, 0, 0, data.shapes[0].color, 's1')}
            
            {/* Shape 2 (Offset) */}
            {(() => {
              const s1Offset = data.shapes[0].points.reduce((max, p) => Math.max(max, p.x), 0) + gap;
              return renderShape(data.shapes[1].points, s1Offset, 0, data.shapes[1].color, 's2');
            })()}
            
            {/* Labels */}
            {renderLabels(data.labels, data.shapes)}
          </>
        )}

        {/* --- Render Logic for Standard Single Shape --- */}
        {(!data.type || data.type !== 'similarity') && (
           <g>
             {renderShape(data.points, 0, 0, '#3B82F6', 'single')}
             {/* If standard shapes have labels, render them here. Currently assumes custom labels array is for similarity */}
           </g>
        )}
      </svg>
    </div>
  );
};

GeometryVisual.requiresCanvas = true;

// FILE END: src\components\visuals\GeometryVisual.jsx

// =======================================================
// FILE START: src\components\visuals\GraphCanvas.jsx
// =======================================================

import React, { useEffect, useRef } from 'react';

/**
 * GraphCanvas
 * Renders a coordinate system and linear functions (y = kx + m).
 * Supports drawing two lines for system of equations if needed.
 */
export const GraphCanvas = ({ visual }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !visual) return;

    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    // Config
    const scale = 20; // pixels per unit
    const centerX = w / 2;
    const centerY = h / 2;

    // Reset
    ctx.clearRect(0, 0, w, h);
    
    // Draw Grid
    ctx.strokeStyle = '#e5e7eb'; // light gray
    ctx.lineWidth = 1;
    
    // Vertical grid lines
    for (let x = 0; x <= w; x += scale) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
    }
    // Horizontal grid lines
    for (let y = 0; y <= h; y += scale) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    // Draw Axes
    ctx.strokeStyle = '#374151'; // dark gray
    ctx.lineWidth = 2;
    
    // X-Axis
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(w, centerY);
    ctx.stroke();

    // Y-Axis
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, h);
    ctx.stroke();

    // Helper: Plot a line given slope (k) and intercept (m)
    const drawLine = (k, m, color = '#2563eb') => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        // Calculate start and end points
        // x = -10 (far left in units), x = 10 (far right)
        // Canvas coords: cx = centerX + x*scale, cy = centerY - y*scale
        
        const x1 = -15;
        const y1 = k * x1 + m;
        
        const x2 = 15;
        const y2 = k * x2 + m;

        ctx.moveTo(centerX + x1 * scale, centerY - y1 * scale);
        ctx.lineTo(centerX + x2 * scale, centerY - y2 * scale);
        ctx.stroke();
    };

    // Draw Lines from visual data
    if (visual.lines) {
        visual.lines.forEach((line, index) => {
            // Alternate colors for systems
            const color = index === 0 ? '#3b82f6' : '#ef4444'; 
            drawLine(line.k, line.m, color);
        });
    }

  }, [visual]);

  return (
    <div className="flex justify-center my-4 overflow-hidden rounded-lg border border-gray-200">
      <canvas 
        ref={canvasRef} 
        width={300} 
        height={300} 
        className="bg-white"
      />
    </div>
  );
};

GraphCanvas.requiresCanvas = true;

// FILE END: src\components\visuals\GraphCanvas.jsx

// =======================================================
// FILE START: src\components\visuals\InputComponents.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

// =====================================================================
// FRACTION INPUT COMPONENT
// Handles standard fractions (n/d) and mixed numbers (w n/d)
// Features: 
// - Visual separator line
// - Slash ('/') navigation
// - Tab navigation
// =====================================================================

interface FractionInputProps {
    value: string; // Expected format: "n/d" or "w n/d" or just "n"
    onChange: (val: string) => void;
    allowMixed?: boolean;
    autoFocus?: boolean;
}

export const FractionInput: React.FC<FractionInputProps> = ({ value, onChange, allowMixed = false, autoFocus = false }) => {
    const wholeRef = useRef<HTMLInputElement>(null);
    const numRef = useRef<HTMLInputElement>(null);
    const denRef = useRef<HTMLInputElement>(null);

    // Parse the current string value into parts
    let w = "", n = "", d = "";
    
    if (value.includes(' ')) {
        const parts = value.split(' ');
        w = parts[0];
        if (parts[1].includes('/')) {
            [n, d] = parts[1].split('/');
        }
    } else if (value.includes('/')) {
        [n, d] = value.split('/');
    } else {
        n = value;
    }

    const update = (newW: string, newN: string, newD: string) => {
        let res = "";
        if (newW) res += `${newW} `;
        if (newN || newD) res += `${newN}/${newD}`;
        onChange(res.trim());
    };

    const handleKeyDown = (e: React.KeyboardEvent, field: 'w' | 'n' | 'd') => {
        if (e.key === '/' || e.key === 'Divide') {
            e.preventDefault();
            if (field === 'w') numRef.current?.focus();
            if (field === 'n') denRef.current?.focus();
        }
        if (e.key === 'Backspace') {
            if (field === 'd' && d === '') {
                e.preventDefault();
                numRef.current?.focus();
            }
            if (field === 'n' && n === '' && allowMixed) {
                e.preventDefault();
                wholeRef.current?.focus();
            }
        }
    };

    useEffect(() => {
        if (autoFocus) {
            if (allowMixed) wholeRef.current?.focus();
            else numRef.current?.focus();
        }
    }, [autoFocus, allowMixed]);

    return (
        <div className="inline-flex items-center gap-2 font-mono text-xl text-slate-800">
            {/* Mixed Number (Whole) Part */}
            {allowMixed && (
                <input
                    ref={wholeRef}
                    type="text"
                    inputMode="numeric"
                    className="w-12 h-12 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={w}
                    onChange={(e) => update(e.target.value, n, d)}
                    onKeyDown={(e) => handleKeyDown(e, 'w')}
                    placeholder="#"
                />
            )}

            {/* Fraction Part (Stack) */}
            <div className="flex flex-col items-center justify-center">
                <input
                    ref={numRef}
                    type="text"
                    inputMode="numeric"
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded-t focus:border-blue-500 focus:outline-none focus:z-10 bg-white"
                    value={n}
                    onChange={(e) => update(w, e.target.value, d)}
                    onKeyDown={(e) => handleKeyDown(e, 'n')}
                    placeholder="n"
                />
                
                <div className="w-full h-0.5 bg-slate-800 my-0.5"></div>
                
                <input
                    ref={denRef}
                    type="text"
                    inputMode="numeric"
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded-b focus:border-blue-500 focus:outline-none focus:z-10 bg-white"
                    value={d}
                    onChange={(e) => update(w, n, e.target.value)}
                    onKeyDown={(e) => handleKeyDown(e, 'd')}
                    placeholder="d"
                />
            </div>
        </div>
    );
};

// =====================================================================
// EXPONENT INPUT COMPONENT
// Handles powers (base^exponent)
// Features: 
// - Base number input
// - Superscript exponent input
// - Caret ('^') navigation
// =====================================================================

interface ExponentInputProps {
    value: string; // Expected format: "base^exponent" e.g. "10^2"
    onChange: (val: string) => void;
    autoFocus?: boolean;
}

export const ExponentInput: React.FC<ExponentInputProps> = ({ value, onChange, autoFocus = false }) => {
    const baseRef = useRef<HTMLInputElement>(null);
    const expRef = useRef<HTMLInputElement>(null);

    // Parse value: "base^exp"
    let base = "";
    let exp = "";

    if (value.includes('^')) {
        [base, exp] = value.split('^');
    } else {
        base = value;
    }

    const update = (newBase: string, newExp: string) => {
        // If exponent exists, join with caret, otherwise just base
        if (newExp) {
            onChange(`${newBase}^${newExp}`);
        } else {
            onChange(newBase);
        }
    };

    const handleBaseKeyDown = (e: React.KeyboardEvent) => {
        // Allow user to jump to exponent by typing '^'
        if (e.key === '^' || (e.shiftKey && e.key === '6')) {
            e.preventDefault();
            expRef.current?.focus();
        }
    };

    const handleExpKeyDown = (e: React.KeyboardEvent) => {
        // Backspace on empty exponent jumps back to base
        if (e.key === 'Backspace' && exp === '') {
            e.preventDefault();
            baseRef.current?.focus();
        }
    };

    useEffect(() => {
        if (autoFocus) {
            baseRef.current?.focus();
        }
    }, [autoFocus]);

    return (
        <div className="inline-flex items-start font-mono text-xl text-slate-800">
            {/* Base Number */}
            <input
                ref={baseRef}
                type="text"
                inputMode="text"
                className="w-16 h-12 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                value={base}
                onChange={(e) => update(e.target.value, exp)}
                onKeyDown={handleBaseKeyDown}
                placeholder="x"
            />

            {/* Exponent (Superscript) */}
            <input
                ref={expRef}
                type="text"
                inputMode="numeric"
                className="w-10 h-8 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-sm relative -top-3 ml-1 shadow-sm"
                value={exp}
                onChange={(e) => update(base, e.target.value)}
                onKeyDown={handleExpKeyDown}
                placeholder="y"
            />
        </div>
    );
};

// FILE END: src\components\visuals\InputComponents.jsx

// =======================================================
// FILE START: src\components\visuals\SimpleTextLevel.jsx
// =======================================================

import React from 'react';

const SimpleTextLevel = ({ data }) => {
  return (
    <div className="text-content">
      <p>{data.question}</p>
    </div>
  );
};

// We simply don't add the property, or explicitly set it to false
// SimpleTextLevel.requiresCanvas = false; 

export default SimpleTextLevel;

// FILE END: src\components\visuals\SimpleTextLevel.jsx

// =======================================================
// FILE START: src\components\visuals\VolumeVisualization.jsx
// =======================================================

import React, { useEffect, useRef } from 'react';

/**
 * VolumeVisualization
 * Renders 3D shapes (Cubes, Rectangular Prisms, Cylinders) on HTML5 Canvas.
 * * MIGRATION NOTE:
 * - Uses TARGET_SIZE = 160.
 * - Implements dynamic scaling: scale = TARGET_SIZE / Math.max(w, h, d).
 */
export const VolumeVisualization = ({ visual }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !visual) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    ctx.lineJoin = 'round';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#374151'; // gray-700
    ctx.fillStyle = '#E5E7EB';   // gray-200

    const centerX = width / 2;
    const centerY = height / 2;

    // SCALING LOGIC
    const TARGET_SIZE = 160;
    // Determine max dimension to scale appropriately
    const maxDim = Math.max(
      visual.width || 0,
      visual.height || 0,
      visual.depth || 0,
      (visual.radius || 0) * 2
    );
    
    // Avoid division by zero
    const scale = maxDim > 0 ? TARGET_SIZE / maxDim : 1;

    // Drawing functions
    const drawCubeOrPrism = () => {
        const w = (visual.width || 0) * scale;
        const h = (visual.height || 0) * scale;
        const d = (visual.depth || 0) * scale * 0.5; // Foreshortening depth
        
        const x = centerX - w / 2;
        const y = centerY - h / 2;

        // Front Face
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.stroke();
        ctx.fill();

        // Top Face
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + d, y - d);
        ctx.lineTo(x + w + d, y - d);
        ctx.lineTo(x + w, y);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#D1D5DB'; // slightly darker
        ctx.fill();

        // Side Face
        ctx.beginPath();
        ctx.moveTo(x + w, y);
        ctx.lineTo(x + w + d, y - d);
        ctx.lineTo(x + w + d, y + h - d);
        ctx.lineTo(x + w, y + h);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#9CA3AF'; // darkest
        ctx.fill();
        
        // Labels
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        if (visual.labels) {
            // Simple label placement approximation
            if (visual.labels.w) ctx.fillText(visual.labels.w, x + w/2, y + h + 15);
            if (visual.labels.h) ctx.fillText(visual.labels.h, x - 20, y + h/2);
            if (visual.labels.d) ctx.fillText(visual.labels.d, x + w + d/2, y - d/2);
        }
    };

    const drawCylinder = () => {
        const r = (visual.radius || 0) * scale;
        const h = (visual.height || 0) * scale;
        
        // Ellipse squash factor
        const squash = 0.3; 
        const ry = r * squash;

        const x = centerX;
        const yTop = centerY - h/2;
        const yBottom = centerY + h/2;

        // Top Ellipse
        ctx.beginPath();
        ctx.ellipse(x, yTop, r, ry, 0, 0, 2 * Math.PI);
        ctx.fillStyle = '#D1D5DB';
        ctx.fill();
        ctx.stroke();

        // Body
        ctx.beginPath();
        ctx.moveTo(x - r, yTop);
        ctx.lineTo(x - r, yBottom);
        // Bottom curve (half ellipse)
        ctx.ellipse(x, yBottom, r, ry, 0, 0, Math.PI, false);
        ctx.lineTo(x + r, yTop);
        ctx.fillStyle = '#E5E7EB';
        ctx.fill();
        
        // Re-stroke sides to cover fill overlap
        ctx.beginPath();
        ctx.moveTo(x - r, yTop);
        ctx.lineTo(x - r, yBottom);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + r, yTop);
        ctx.lineTo(x + r, yBottom);
        ctx.stroke();

        // Bottom full ellipse stroke (optional, but helps depth)
        ctx.beginPath();
        ctx.ellipse(x, yBottom, r, ry, 0, 0, Math.PI, false);
        ctx.stroke();
        
        // Labels
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        if (visual.labels) {
            if (visual.labels.r) ctx.fillText(visual.labels.r, x + r/2, yTop - 5);
            if (visual.labels.h) ctx.fillText(visual.labels.h, x + r + 10, centerY);
        }
    };

    // Render based on type
    if (visual.type === 'cube' || visual.type === 'cuboid') {
        drawCubeOrPrism();
    } else if (visual.type === 'cylinder') {
        drawCylinder();
    }

  }, [visual]);

  return (
    <div className="flex justify-center my-4">
      <canvas 
        ref={canvasRef} 
        width={300} 
        height={250} 
        className="bg-white rounded-lg"
      />
    </div>
  );
};

VolumeVisualization.requiresCanvas = true;

// FILE END: src\components\visuals\VolumeVisualization.jsx

// =======================================================
// FILE START: src\constants\content_map.js
// =======================================================

export const CONTENT_MAP = {
    arithmetic: {
        title: "Taluppfattning",
        topics: [
            {
                id: "arithmetic",
                title: "De Fyra R√§knes√§tten",
                levels: [
                    { lvl: 1, desc: "Addition (Uppst√§llning)", ex: "345 + 129" },
                    { lvl: 2, desc: "Subtraktion (Uppst√§llning)", ex: "502 - 148" },
                    { lvl: 3, desc: "Decimaltal (+/-)", ex: "4.5 + 2.15" },
                    { lvl: 4, desc: "Multiplikation (Enkel)", ex: "6 ¬∑ 12" },
                    { lvl: 5, desc: "Multiplikation (Medel)", ex: "23 ¬∑ 4" },
                    { lvl: 6, desc: "Multiplikation (Sv√•r)", ex: "45 ¬∑ 12" },
                    { lvl: 7, desc: "Kort Division", ex: "84 / 4" },
                    { lvl: 8, desc: "Blandade Heltal", ex: "Mix av alla r√§knes√§tt" },
                    { lvl: 9, desc: "Blandade Decimaltal", ex: "Mix med decimaler" }
                ]
            },
            {
                id: "negative",
                title: "Negativa Tal",
                levels: [
                    { lvl: 1, desc: "Enkel Addition/Subtraktion", ex: "-5 + 3, 2 - 8" },
                    { lvl: 2, desc: "Sv√•rare Addition/Subtraktion", ex: "-5 - (-3)" },
                    { lvl: 3, desc: "Multiplikation", ex: "-4 ¬∑ 3" },
                    { lvl: 4, desc: "Division", ex: "-20 / -5" },
                    { lvl: 5, desc: "Blandade Uppgifter", ex: "Mix av alla" }
                ]
            },
            {
                id: "ten_powers",
                title: "10, 100, 1000",
                levels: [
                    { lvl: 1, desc: "Mult/Div med 10, 100, 1000", ex: "4.5 ¬∑ 100" },
                    { lvl: 2, desc: "Begreppsf√∂rst√•else", ex: "Vilket tal √§r 100 g√•nger st√∂rre?" },
                    { lvl: 3, desc: "Blandade Faktorer", ex: "0.1, 0.01, 1000" }
                ]
            },
            {
                id: "percent",
                title: "Procent",
                levels: [
                    { lvl: 1, desc: "Grundl√§ggande & Omvandling", ex: "1/4 = 25% = 0.25" },
                    { lvl: 2, desc: "Huvudr√§kning (Benchmarks)", ex: "50%, 25%, 10% av tal" },
                    { lvl: 3, desc: "Byggstenar (Multiplar)", ex: "30% (3 ¬∑ 10%)" },
                    { lvl: 4, desc: "Decimalmetoden", ex: "15% av 40 (0.15 ¬∑ 40)" },
                    { lvl: 5, desc: "Det Hela", ex: "20% √§r 10. Vad √§r 100%?" },
                    { lvl: 6, desc: "Verklig F√∂r√§ndring", ex: "L√∂n, Rea, Skatt" }
                ]
            },
            {
                id: "exponents",
                title: "Potenser & R√∂tter",
                levels: [
                    { lvl: 1, desc: "Grunder & Nollregeln", ex: "3^3, x^0 = 1" },
                    { lvl: 2, desc: "Tiopotenser", ex: "10^5, 10^-2" },
                    { lvl: 3, desc: "Grundpotensform", ex: "4.5 ¬∑ 10^4" },
                    { lvl: 4, desc: "Kvadratr√∂tter & Uppskattning", ex: "sqrt(64), sqrt(50)" },
                    { lvl: 5, desc: "Potenslagar (Enkel)", ex: "x^2 ¬∑ x^3" },
                    { lvl: 6, desc: "Potenslagar (Avancerad)", ex: "(x^2)^3" }
                ]
            }
        ]
    },
    algebra: {
        title: "Algebra",
        topics: [
            {
                id: "simplify",
                title: "Uttryck",
                levels: [
                    { lvl: 1, desc: "F√∂renkla Uttryck", ex: "3x + 2x + 5" },
                    { lvl: 2, desc: "Parenteser (Addition)", ex: "4 + (x + 2)" },
                    { lvl: 3, desc: "Parenteser (Multiplikation)", ex: "3(x + 2)" },
                    { lvl: 4, desc: "Parenteser (Subtraktion)", ex: "5x - (2x + 3)" },
                    { lvl: 5, desc: "Probleml√∂sning", ex: "Skriv uttryck f√∂r omkrets" },
                    { lvl: 6, desc: "Blandade Niv√•er", ex: "Mix av f√∂renkling" }
                ]
            },
            {
                id: "equation",
                title: "Ekvationer",
                levels: [
                    { lvl: 1, desc: "Enkels steg", ex: "x + 5 = 12" },
                    { lvl: 2, desc: "Tv√• steg", ex: "2x + 3 = 11" },
                    { lvl: 3, desc: "Med Parenteser", ex: "2(x + 1) = 10" },
                    { lvl: 4, desc: "Variabel p√• b√•da sidor", ex: "3x + 2 = x + 10" },
                    { lvl: 5, desc: "Probleml√∂sning (Skriv)", ex: "Tolka text till ekvation" },
                    { lvl: 6, desc: "Probleml√∂sning (L√∂s)", ex: "L√∂s textproblem" },
                    { lvl: 7, desc: "Blandade Ekvationer", ex: "Mix av alla typer" }
                ]
            }
        ]
    },
    geometry: {
        title: "Geometri",
        topics: [
            {
                id: "geometry",
                title: "Area & Omkrets",
                levels: [
                    { lvl: 1, desc: "Omkrets (Rektangel)", ex: "O = 2b + 2h" },
                    { lvl: 2, desc: "Area (Rektangel)", ex: "A = b ¬∑ h" },
                    { lvl: 3, desc: "Area (Triangel)", ex: "A = (b ¬∑ h) / 2" },
                    { lvl: 4, desc: "Cirkelns Area & Omkrets", ex: "Anv√§nd pi (3.14)" },
                    { lvl: 5, desc: "Sammansatta Figurer", ex: "Hus, Portaler" }
                ]
            },
            {
                id: "scale",
                title: "Skala",
                levels: [
                    { lvl: 1, desc: "F√∂rst√• Skala", ex: "Vad betyder 1:100?" },
                    { lvl: 2, desc: "Ber√§kna L√§ngd (Enkel)", ex: "Bild -> Verklighet" },
                    { lvl: 3, desc: "Blandade Scenarier", ex: "Karta, Ritning, Mikroskop" },
                    { lvl: 4, desc: "Best√§m Skalan", ex: "Hitta skalan givet tv√• m√•tt" },
                    { lvl: 5, desc: "Probleml√∂sning", ex: "Textuppgifter utan bild" },
                    { lvl: 6, desc: "Areaskala", ex: "L√§ngdskala¬≤" },
                    { lvl: 7, desc: "Blandat", ex: "Mix av alla" }
                ]
            },
            {
                id: "volume",
                title: "Volym",
                levels: [
                    { lvl: 1, desc: "R√§tblock & Kub", ex: "V = b ¬∑ d ¬∑ h" },
                    { lvl: 2, desc: "Prisma", ex: "V = Bas ¬∑ h√∂jd" },
                    { lvl: 3, desc: "Cylinder", ex: "V = pi ¬∑ r¬≤ ¬∑ h" },
                    { lvl: 4, desc: "Pyramid & Kon", ex: "Spetsiga kroppar (/3)" },
                    { lvl: 5, desc: "Klot & Sammansatta", ex: "Silo, Glass, Klot" },
                    { lvl: 6, desc: "Blandade Volymer", ex: "Mix av kroppar" },
                    { lvl: 7, desc: "Enhetsomvandling", ex: "cm¬≥ <-> liter <-> m¬≥" }
                ]
            },
            {
                id: "similarity",
                title: "Likformighet",
                levels: [
                    { lvl: 1, desc: "√Ñr de likformiga?", ex: "J√§mf√∂r former" },
                    { lvl: 2, desc: "Ber√§kna sida (Enkel)", ex: "Anv√§nd skalfaktor" },
                    { lvl: 3, desc: "Topptriangelsatsen", ex: "Triangel inuti triangel" },
                    { lvl: 4, desc: "Pythagoras & Likformighet", ex: "Avancerad probleml√∂sning" }
                ]
            },
            {
                id: "pythagoras",
                title: "Pythagoras Sats",
                levels: [
                    { lvl: 1, desc: "Kvadrater & R√∂tter", ex: "3^2, sqrt(25)" },
                    { lvl: 2, desc: "Hitta Hypotenusan", ex: "3-4-5 triangel" },
                    { lvl: 3, desc: "Hitta Kateten", ex: "c^2 - b^2 = a^2" },
                    { lvl: 4, desc: "Probleml√∂sning", ex: "Stege mot v√§gg" },
                    { lvl: 5, desc: "Avst√•nd (Koordinater)", ex: "Mellan (1,1) och (4,5)" },
                    { lvl: 6, desc: "√Ñr den r√§tvinklig?", ex: "Testa a^2 + b^2 = c^2" }
                ]
            }
        ]
    },
    samband: {
        title: "Samband",
        topics: [
            {
                id: "linear_graph",
                title: "R√§ta Linjen",
                levels: [
                    { lvl: 1, desc: "Hitta m-v√§rdet", ex: "Var sk√§r linjen y-axeln?" },
                    { lvl: 2, desc: "Hitta k-v√§rdet (Positiv)", ex: "Lutning upp√•t" },
                    { lvl: 3, desc: "Hitta k-v√§rdet (Negativ)", ex: "Lutning ned√•t" },
                    { lvl: 4, desc: "Best√§m funktionen", ex: "y = kx + m" },
                    { lvl: 5, desc: "Blandat", ex: "Mix av grafer" }
                ]
            }
        ]
    },
    statistics: {
        title: "Sannolikhet & Statistik",
        topics: [
            {
                id: "probability",
                title: "Sannolikhet",
                levels: [
                    { lvl: 1, desc: "Visuell Sannolikhet", ex: "Kulor i p√•se, Snurrhjul" },
                    { lvl: 2, desc: "T√§rning & Slump", ex: "T√§rning, Kortlek" },
                    { lvl: 3, desc: "Sannolikhet som Procent", ex: "Andel i %" },
                    { lvl: 4, desc: "Komplementh√§ndelse", ex: "Sannolikhet f√∂r 'Inte'" },
                    { lvl: 5, desc: "Oberoende H√§ndelser", ex: "Tv√• mynt, T√§rning + Mynt" },
                    { lvl: 6, desc: "Kombinatorik", ex: "Antal kombinationer (Tr√§d)" }
                ]
            },
            {
                id: "statistics",
                title: "Statistik",
                levels: [
                    { lvl: 1, desc: "Typv√§rde & Variationsbredd", ex: "Mode, Range" },
                    { lvl: 2, desc: "Medelv√§rde", ex: "Summa / Antal" },
                    { lvl: 3, desc: "Median", ex: "Mittenv√§rdet (sorterat)" },
                    { lvl: 4, desc: "Bakl√§nges medelv√§rde", ex: "Hitta saknat tal" },
                    { lvl: 5, desc: "Frekvenstabell", ex: "Analysera tabell" },
                    { lvl: 6, desc: "Blandade begrepp", ex: "Medel vs Median" }
                ]
            }
        ]
    }
};

// FILE END: src\constants\content_map.js

// =======================================================
// FILE START: src\constants\curriculum.js
// =======================================================

export const CATEGORIES = {
    ARITHMETIC: {
        id: 'ARITHMETIC',
        label: { en: 'Number Theory', sv: 'Taluppfattning' },
        color: 'pink',
        generators: [
            { id: 'BasicArithmeticGen', api: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'FractionBasicsGen', api: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, // Added
            { id: 'FractionArithGen', api: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, // Added
            { id: 'NegativeNumbersGen', api: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'TenPowersGen', api: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'PercentGen', api: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    ALGEBRA: {
        id: 'ALGEBRA',
        label: { en: 'Algebra', sv: 'Algebra' },
        color: 'indigo',
        generators: [
            { id: 'ExpressionSimplificationGen', api: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'EquationGenerator', api: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'LinearGraphGenerator', api: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    },
    GEOMETRY: {
        id: 'GEOMETRY',
        label: { en: 'Geometry', sv: 'Geometri' },
        color: 'emerald',
        generators: [
            { id: 'GeometryGenerator', api: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'ScaleGenerator', api: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'VolumeGenerator', api: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'SimilarityGenerator', api: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'PythagorasGen', api: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } }
        ]
    },
    STATISTICS: {
        id: 'STATISTICS',
        label: { en: 'Statistics', sv: 'Sannolikhet & Statistik' },
        color: 'yellow',
        generators: [
            { id: 'ProbabilityGen', api: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
            { id: 'StatisticsGen', api: 'statistics', label: { sv: "Statistik", en: "Statistics" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    BasicArithmeticGen: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    FractionBasicsGen: { // New
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Del av antal", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    FractionArithGen: { // New
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+)", en: "Mixed Numbers (+)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    NegativeNumbersGen: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    TenPowersGen: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    PercentGen: {
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Ber√§kna det hela", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    EquationGenerator: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    ExpressionSimplificationGen: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    GeometryGenerator: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        5: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    ScaleGenerator: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    VolumeGenerator: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
    },
    SimilarityGenerator: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    PythagorasGen: { 
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    },
    LinearGraphGenerator: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    },
    ProbabilityGen: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse", en: "Complementary Events" },
        5: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        6: { sv: "Kombinatorik", en: "Combinatorics" }
    },
    StatisticsGen: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    }
    
};

export const getColorClasses = (color, type) => {
    const c = color || 'emerald';
    switch (type) {
        case 'bg-light': return `bg-${c}-50`;
        case 'bg-dark': return `bg-${c}-500`;
        case 'border': return `border-${c}-100`;
        case 'text': return `text-${c}-700`;
        case 'ring': return `ring-${c}-500`;
        case 'border-solid': return `border-${c}-500`;
        default: return '';
    }
};

// FILE END: src\constants\curriculum.js

// =======================================================
// FILE START: src\constants\localization.js
// =======================================================

export const CATEGORIES = {
    arithmetic: {
        id: 'arithmetic', 
        label: { sv: "Taluppfattning", en: "Number Theory" },
        color: "pink",
        levels: 9,
        topics: [
            { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, // NEW
            { id: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, // NEW
            { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'exponents', label: { sv: "Potenser & R√∂tter", en: "Exponents & Roots" } },
            { id: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    
    algebra: {
        id: 'algebra',
        label: { sv: "Algebra", en: "Algebra" },
        color: "indigo",
        levels: 6,
        topics: [
            { id: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'linear_graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    },
    geometry: {
        id: 'geometry',
        label: { sv: "Geometri", en: "Geometry" },
        color: "emerald",
        levels: 7,
        topics: [
            { id: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } }
        ]
    },

    statistics: { 
        id: 'statistics',
        label: { sv: "Sannolikhet & Statistik", en: "Prob & Stats" },
        color: "yellow", 
        levels: 6,
        topics: [
             { id: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
             { id: 'statistics', label: { sv: "Statistik", en: "Statistics" } }
        ]
    }
};

export const CATEGORIES_ARRAY = Object.values(CATEGORIES);

export const UI_TEXT = {
    sv: {
        hero_title: "Mattest√∂d",
        hero_subtitle: "Anpassade uppgifter f√∂r h√∂gstadiet.",
        tagline: "R√§tt st√∂d. Direkt.",
        startBtn: "Starta √ñvning",
        aboutBtn: "Om Skaparen",
        contactTitle: "Kontakta mig",
        aboutTitle: "Om Skaparen",
        aboutText: "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att hitta nya s√§tt att undervisa i klassrummet.",
        contactLink: "F√∂lj mig p√• LinkedIn",
        tagCorrect: "R√§tt", tagWrong: "Fel", tagSkipped: "Hoppade √∂ver",
        streak_modal_title: "Grymt jobbat! üî•", streak_modal_msg: "Du har en streak p√• {streak}!",
        total_modal_title: "Bra jobbat! ‚úÖ", total_modal_msg: "Du har klarat {total} uppgifter! Forts√§tt s√•!",
        btn_close_streak: "K√∂r vidare!", btn_close_total: "Forts√§tt",
        timer_title: "Timer", timer_off: "Av", timer_min: "min", timer_reset: "Nollst√§ll", timer_paused: "Pausad",
        stats_title: "Statistik", stats_times_up: "Tiden √§r ute!", stats_longest_streak: "L√§ngsta streak", stats_attempted: "F√∂rs√∂k", stats_correct_no_help: "R√§tt (utan hj√§lp)", stats_correct_help: "R√§tt (med hj√§lp)", stats_incorrect: "Fel", stats_skipped: "Hoppade √∂ver", stats_close: "St√§ng",
        menu_btn: "Meny", level_breakdown: "Niv√•detaljer",
        stat_skip: "Hopp", stat_wrong: "Fel", stat_help: "Hj√§lp", stat_correct: "R√§tt", stat_total: "Totalt",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Aktivitet", donow_desc: "V√§lj upp till 3 niv√•er f√∂r att generera ett startkort.",
        donow_generate: "Generera", backBtn: "Tillbaka",
        donow_show_all: "Visa Alla Svar", donow_hide_all: "D√∂lj Alla Svar",
        donow_regenerate: "Nytt Set", 
        levels: "Niv√•er",
        clickToSelect: "Klicka f√∂r att v√§lja niv√•",
        selectLevel: "V√§lj Niv√•",
        btnCheck: "Svara", btnHint: "Ledtr√•d", btnSolution: "L√∂sning", btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        error: "N√•got gick fel. F√∂rs√∂k igen.",
        levelUpTitle: "Niv√• upp?", levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", levelUpYes: "Ja, k√∂r!", levelUpNo: "Nej, stanna h√§r"
    },
    en: {
        hero_title: "Math Support",
        hero_subtitle: "Adaptive exercises for middle school.",
        tagline: "Right support. Instantly.",
        startBtn: "Start Practice",
        aboutBtn: "About Creator",
        contactTitle: "Contact Me",
        aboutTitle: "About the Creator",
        aboutText: "Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
        contactLink: "Follow me on LinkedIn",
        tagCorrect: "Correct", tagWrong: "Wrong", tagSkipped: "Skipped",
        streak_modal_title: "Awesome! üî•", streak_modal_msg: "You hit a streak of {streak}!",
        total_modal_title: "Great work! ‚úÖ", total_modal_msg: "You answered {total} questions correctly! Great job!",
        btn_close_streak: "Great job!", btn_close_total: "Continue",
        timer_title: "Practice Timer", timer_off: "Off", timer_min: "min", timer_reset: "Reset", timer_paused: "Paused",
        stats_title: "Statistics", stats_times_up: "Time's up!", stats_longest_streak: "Longest streak", stats_attempted: "Problems attempted", stats_correct_no_help: "Correct (no help)", stats_correct_help: "Correct (with help)", stats_incorrect: "Incorrect", stats_skipped: "Skipped", stats_close: "Close",
        menu_btn: "Menu", level_breakdown: "Level Breakdown",
        stat_skip: "Skip", stat_wrong: "Wrong", stat_help: "Help", stat_correct: "Correct", stat_total: "Total",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Activity", donow_desc: "Select up to 3 levels to generate a startup card.",
        donow_generate: "Generate", backBtn: "Back",
        donow_show_all: "Show All Answers", donow_hide_all: "Hide All Answers",
        donow_regenerate: "New Set", 
        levels: "Levels",
        clickToSelect: "Click to select level",
        selectLevel: "Select Level",
        btnCheck: "Submit", btnHint: "Hint", btnSolution: "Solution", btnSkip: "Skip",
        btnNext: "Next ‚û°",
        error: "Something went wrong. Please retry.",
        levelUpTitle: "Level Up?", levelUpDesc: "You seem to know this! Do you want to skip to the next level?", levelUpYes: "Yes, let's go!", levelUpNo: "No, stay here"
    }
};

export const LEVEL_DESCRIPTIONS = {
    // --- NEW FRACTION GENERATORS ---
    fraction_basics: {
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Ber√§kna delen", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    fraction_arith: {
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+)", en: "Mixed Numbers (+)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    // --- EXISTING GENERATORS ---
    exponents: { 
        1: { sv: "Grunder & x^0", en: "Foundations & x^0" },
        2: { sv: "Tiopotenser", en: "Powers of 10" },
        3: { sv: "Grundpotensform", en: "Scientific Notation" },
        4: { sv: "Kvadratr√∂tter", en: "Square Roots" },
        5: { sv: "Potenslagar (Enkel)", en: "Exponent Laws (Basic)" },
        6: { sv: "Potenslagar (Avancerad)", en: "Exponent Laws (Adv)" }
    },
    arithmetic: {
        1: { sv: "Addition (Uppst√§llning)", en: "Addition (Vertical)" },
        2: { sv: "Subtraktion (Uppst√§llning)", en: "Subtraction (Vertical)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (Enkel)", en: "Multiplication (Simple)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Kort Division", en: "Short Division" },
        8: { sv: "Blandade Heltal", en: "Mixed Integers" },
        9: { sv: "Blandade Decimaltal", en: "Mixed Decimals" }
    },
    negative: {
        1: { sv: "Enkel Addition/Subtraktion", en: "Simple Add/Sub" },
        2: { sv: "Sv√•rare Addition/Subtraktion", en: "Harder Add/Sub" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandade Uppgifter", en: "Mixed Problems" }
    },
    ten_powers: {
        1: { sv: "Mult/Div med 10, 100, 1000", en: "Mult/Div by 10, 100, 1000" },
        2: { sv: "Begreppsf√∂rst√•else", en: "Conceptual Understanding" },
        3: { sv: "Blandade Faktorer (0.1, 100...)", en: "Mixed Factors" }
    },
    percent: { 
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Hitta helheten (100%)", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    probability: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse (Inte)", en: "Complementary Events" },
        5: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        6: { sv: "Kombinatorik", en: "Combinatorics" }
    },
    statistics: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    simplify: {
        1: { sv: "F√∂renkla Uttryck (Enkel)", en: "Simplify Expressions (Easy)" },
        2: { sv: "Parenteser (Addition)", en: "Parentheses (Addition)" },
        3: { sv: "Parenteser (Multiplikation)", en: "Parentheses (Multiplication)" },
        4: { sv: "Parenteser (Subtraktion)", en: "Parentheses (Subtraction)" },
        5: { sv: "Probleml√∂sning", en: "Problem Solving" },
        6: { sv: "Blandade Niv√•er", en: "Mixed Levels" }
    },
    equation: {
        1: { sv: "Enkels steg (x+a=b)", en: "One Step" },
        2: { sv: "Tv√• steg (ax+b=c)", en: "Two Steps" },
        3: { sv: "Med Parenteser", en: "With Parentheses" },
        4: { sv: "Variabel p√• b√•da sidor", en: "Variables on both sides" },
        5: { sv: "Skriv Ekvation (Problem)", en: "Write Equation (Word Problems)" },
        6: { sv: "L√∂s Problem (Ekvation)", en: "Solve Word Problems" },
        7: { sv: "Blandade Ekvationer", en: "Mixed Equations" }
    },
    linear_graph: {
        1: { sv: "Hitta m-v√§rdet", en: "Find m-value" },
        2: { sv: "Hitta k-v√§rdet (Positiv)", en: "Find k-value (Positive)" },
        3: { sv: "Hitta k-v√§rdet (Negativ)", en: "Find k-value (Negative)" },
        4: { sv: "Best√§m funktionen (y=kx+m)", en: "Determine Function" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    geometry: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Cirkelns Area & Omkrets", en: "Circle Area & Perimeter" },
        5: { sv: "Sammansatta Figurer", en: "Composite Shapes" }
    },
    scale: {
        1: { sv: "F√∂rst√• Skala", en: "Understand Scale" },
        2: { sv: "Ber√§kna L√§ngd (Enkel)", en: "Calculate Length (Simple)" },
        3: { sv: "Blandade Scenarier", en: "Mixed Scenarios" }, 
        4: { sv: "Best√§m Skalan", en: "Determine Scale" },
        5: { sv: "Probleml√∂sning", en: "Word Problems" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    volume: {
        1: { sv: "R√§tblock & Kub", en: "Cuboid & Cube" },
        2: { sv: "Prisma", en: "Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot & Sammansatta", en: "Sphere & Composite" },
        6: { sv: "Blandade Volymer", en: "Mixed Volumes" },
        7: { sv: "Enhetsomvandling", en: "Unit Conversion" } 
    },
    similarity: {
        1: { sv: "√Ñr de likformiga?", en: "Are they similar?" },
        2: { sv: "Ber√§kna sida (Enkel)", en: "Calc Side (Simple)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras & Likformighet", en: "Pythagoras & Similarity" }
    },
    pythagoras: {
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    }
};

// FILE END: src\constants\localization.js

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class BasicArithmeticGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSimple(lang);
            case 2: return this.level2_SubSimple(lang);
            case 3: return this.level3_Decimals(lang);
            case 4: return this.level4_MultEasy(lang);
            case 5: return this.level5_MultMedium(lang);
            case 6: return this.level6_MultHard(lang);
            case 7: return this.level7_DivEasy(lang);
            case 8: return this.level8_MixedIntegers(lang);
            case 9: return this.level9_MixedDecimals(lang);
            default: return this.level1_AddSimple(lang);
        }
    }

    // Helper for vertical layout
    private makeVertical(top: number | string, bottom: number | string, op: string): string {
        return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
    }

    // Level 1: Addition (1-3 digits)
    private level1_AddSimple(lang: string): any {
        const a = MathUtils.randomInt(1, 999);
        const b = MathUtils.randomInt(1, 999);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        
        return this.createProblem(a, b, '+', lang, isVertical);
    }

    // Level 2: Subtraction
    private level2_SubSimple(lang: string): any {
        const a = MathUtils.randomInt(2, 999);
        const b = MathUtils.randomInt(1, a - 1);
        const isVertical = MathUtils.randomInt(0, 1) === 1;

        return this.createProblem(a, b, '-', lang, isVertical);
    }

    // Level 3: Decimals (+/-)
    private level3_Decimals(lang: string): any {
        const op = MathUtils.randomChoice(['+', '-']);
        
        // Legacy Logic: Ensure reasonable numbers
        const getDec = () => MathUtils.randomInt(1, 4900) / 100;
        let a = getDec();
        let b = getDec();

        if (op === '+') {
            while (Math.floor(a + b) > 50) { a = getDec(); b = getDec(); }
        } else {
            if (b > a) [a, b] = [b, a]; // Ensure positive result
            while (Math.floor(a - b) > 50) { a = getDec(); b = getDec(); if (b > a) [a, b] = [b, a]; }
        }
        
        // Always vertical for decimals to encourage alignment practice
        return this.createProblem(a, b, op, lang, true, [
            { text: lang === 'sv' ? "St√§ll upp talen ovanp√• varandra." : "Line up the numbers vertically." },
            { text: lang === 'sv' ? "Viktigt: Decimaltecknen m√•ste vara rakt under varandra." : "Important: The decimal points must line up vertically." }
        ]);
    }

    // Level 4: Mult Easy (Tables 2-9)
    private level4_MultEasy(lang: string): any {
        const a = MathUtils.randomInt(1, 10);
        const b = MathUtils.randomInt(1, 10);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        return this.createProblem(a, b, '*', lang, isVertical);
    }

    // Level 5: Mult Medium (2 digit x 1 digit)
    private level5_MultMedium(lang: string): any {
        const a = MathUtils.randomInt(2, 20);
        const b = MathUtils.randomInt(2, 20);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        return this.createProblem(a, b, '*', lang, isVertical);
    }

    // Level 6: Mult Hard (Decimals) - Restored Legacy Subtypes
    private level6_MultHard(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        let a = 0, b = 0;

        if (type === 1) { // 0.x * 0.y
            a = MathUtils.randomInt(1, 9) / 10;
            b = MathUtils.randomInt(1, 9) / 10;
        } else if (type === 2) { // Int * 0.x
            a = MathUtils.randomInt(2, 20);
            b = MathUtils.randomInt(1, 9) / 10;
        } else if (type === 3) { // 0.x * 0.yz
            a = MathUtils.randomInt(1, 9) / 10;
            b = MathUtils.randomInt(1, 99) / 100;
        } else { // Int * 0.yz
            a = MathUtils.randomInt(2, 20);
            b = MathUtils.randomInt(1, 99) / 100;
        }

        return this.createProblem(a, b, '*', lang, false, [
            { text: lang === 'sv' ? "Ignorera decimalen f√∂rst. R√§kna som heltal." : "Ignore the decimal first. Calculate as integers." },
            { text: lang === 'sv' ? "R√§kna sedan hur m√•nga decimaler talen har totalt och s√§tt in i svaret." : "Count total decimal places and apply to the answer." }
        ]);
    }

    // Level 7: Division Easy (Integer results)
    private level7_DivEasy(lang: string): any {
        const f1 = MathUtils.randomInt(1, 10);
        const f2 = MathUtils.randomInt(1, 10);
        const product = f1 * f2;
        const divisor = MathUtils.randomInt(0, 1) === 1 ? f1 : f2;
        const answer = product / divisor;
        
        const latex = `\\frac{${product}}{${divisor}}`;
        const desc = lang === 'sv' ? "Dividera." : "Divide.";

        return {
            renderData: { latex, description: desc, answerType: 'text' },
            token: Buffer.from(answer.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? `T√§nk multiplikation: Vad g√•nger ${divisor} blir ${product}?` : `Think multiplication: What times ${divisor} makes ${product}?`, latex: `${divisor} \\cdot ? = ${product}` }
            ]
        };
    }

    // Level 8: Mixed Integers
    private level8_MixedIntegers(lang: string): any {
        const mode = MathUtils.randomChoice([1, 2, 4, 7]);
        if (mode === 1) return this.level1_AddSimple(lang);
        if (mode === 2) return this.level2_SubSimple(lang);
        if (mode === 4) return this.level4_MultEasy(lang);
        return this.level7_DivEasy(lang);
    }

    // Level 9: Mixed Decimals
    private level9_MixedDecimals(lang: string): any {
        const type = MathUtils.randomInt(1, 7);
        // Map 1-7 range roughly to the decimal/harder types
        if (type <= 3) return this.level3_Decimals(lang); // Add/Sub
        if (type <= 6) return this.level6_MultHard(lang); // Mult
        return this.level7_DivEasy(lang); // Keep division integer based for now as per legacy
    }

    // Helper
    private createProblem(a: number, b: number, op: string, lang: string, vertical: boolean = false, extraClues: any[] = []) {
        let ans = 0;
        let latex = "";
        
        if (op === '+') ans = a + b;
        if (op === '-') ans = a - b;
        if (op === '*') ans = a * b;
        
        // JS Floating point fix
        ans = Math.round(ans * 1000) / 1000;

        if (vertical) {
            const opSymbol = op === '*' ? '\\times' : op;
            const top = Math.max(a, b); // Standard convention puts larger on top usually
            const bot = Math.min(a, b);
            // Exception: Subtraction must respect order a - b
            if (op === '-') {
                latex = this.makeVertical(a, b, opSymbol);
            } else {
                latex = this.makeVertical(top, bot, opSymbol);
            }
        } else {
            const opSymbol = op === '*' ? '\\cdot' : op;
            latex = `${a} ${opSymbol} ${b}`;
        }

        const description = vertical 
            ? (lang === 'sv' ? "St√§ll upp och ber√§kna." : "Set up and calculate.")
            : (lang === 'sv' ? "Ber√§kna." : "Calculate.");

        // Default clues if none provided
        const defaultClues = [];
        if (vertical) {
            defaultClues.push({ text: lang === 'sv' ? "B√∂rja r√§kna fr√•n h√∂ger (entalen)." : "Start calculating from the right (ones)." });
        }

        return {
            renderData: { latex, description, answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: extraClues.length > 0 ? extraClues : defaultClues
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ExponentsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExponentsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Foundations(lang);
            case 2: return this.level2_PowersOfTen(lang);
            case 3: return this.level3_ScientificNotation(lang);
            case 4: return this.level4_SquareRoots(lang);
            case 5: return this.level5_LawsBasic(lang);
            case 6: return this.level6_LawsAdvanced(lang);
            default: return this.level1_Foundations(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Level 1: Foundations & Zero Rule
    private level1_Foundations(lang: string): any {
        const type = MathUtils.randomInt(1, 3);
        
        if (type === 1) { // Zero Rule
            const base = MathUtils.randomInt(5, 1000);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `${base}^0`,
                    answerType: 'numeric'
                },
                token: this.toBase64("1"),
                clues: [{ text: lang === 'sv' ? "Alla tal (utom 0) upph√∂jt till 0 blir 1." : "Any number (except 0) to the power of 0 is 1." }]
            };
        } 
        else if (type === 2) { // Write as power
            const base = MathUtils.randomInt(2, 9);
            const exp = MathUtils.randomInt(3, 6);
            const expanded = Array(exp).fill(base).join(' \\cdot ');
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv som en potens:" : "Write as a power:",
                    latex: expanded,
                    answerType: 'structured_power' // UI: [ ] ^ [ ]
                },
                token: this.toBase64(`${base}^${exp}`),
                clues: [
                    { text: lang === 'sv' ? "Basen √§r talet som multipliceras." : "The base is the number being multiplied." },
                    { text: lang === 'sv' ? "Exponenten √§r antalet g√•nger det upprepas." : "The exponent is how many times it repeats." }
                ]
            };
        }
        else { // Calculate simple power
            const base = MathUtils.randomInt(2, 5);
            const exp = MathUtils.randomInt(2, 4);
            const ans = Math.pow(base, exp);
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna v√§rdet:" : "Calculate the value:",
                    latex: `${base}^${exp}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [{ latex: `${Array(exp).fill(base).join('\\cdot')} = ${ans}` }]
            };
        }
    }

    // Level 2: Powers of 10
    private level2_PowersOfTen(lang: string): any {
        const type = MathUtils.randomChoice(['pos', 'neg', 'calc']);
        
        if (type === 'pos') {
            const exp = MathUtils.randomInt(3, 6);
            const num = Math.pow(10, exp);
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv som en tiopotens:" : "Write as a power of 10:",
                    latex: `${num}`, // e.g. 10000
                    answerType: 'structured_power',
                    prefillBase: "10" // Optional hint for UI to prefill base
                },
                token: this.toBase64(`10^${exp}`),
                clues: [{ text: lang === 'sv' ? "R√§kna nollorna." : "Count the zeros." }]
            };
        }
        else if (type === 'neg') {
            const exp = MathUtils.randomInt(2, 4); // 0.01, 0.001
            let decimal = "0.";
            for(let i=0; i<exp-1; i++) decimal += "0";
            decimal += "1";
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv som en tiopotens:" : "Write as a power of 10:",
                    latex: decimal,
                    answerType: 'structured_power',
                    prefillBase: "10"
                },
                token: this.toBase64(`10^-${exp}`),
                clues: [{ text: lang === 'sv' ? "F√∂r decimaltal √§r exponenten negativ. R√§kna decimalerna." : "For decimals, the exponent is negative. Count the decimal places." }]
            };
        }
        else {
            const exp = MathUtils.randomInt(2, 5);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `10^${exp}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(Math.pow(10, exp).toString()),
                clues: [{ text: lang === 'sv' ? `En etta f√∂ljt av ${exp} nollor.` : `A one followed by ${exp} zeros.` }]
            };
        }
    }

    // Level 3: Scientific Notation
    private level3_ScientificNotation(lang: string): any {
        const isBig = MathUtils.randomInt(0, 1) === 1;
        
        if (isBig) {
            const mantissa = MathUtils.randomInt(1, 9) + (MathUtils.randomInt(1, 9) / 10); // e.g. 4.5
            const exp = MathUtils.randomInt(3, 6);
            const num = Math.round(mantissa * Math.pow(10, exp));
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv i grundpotensform (vetenskaplig form):" : "Write in scientific notation:",
                    latex: `${num}`, // e.g. 45000
                    answerType: 'structured_scientific' // UI: [ ] * 10 ^ [ ]
                },
                token: this.toBase64(`${mantissa}*10^${exp}`),
                clues: [
                    { text: lang === 'sv' ? "Flytta kommatecknet s√• att bara en siffra (1-9) √§r till v√§nster." : "Move decimal so only one digit (1-9) is to the left." },
                    { latex: `${mantissa} \\cdot 10^${exp}` }
                ]
            };
        } else {
            const mantissa = MathUtils.randomInt(1, 9);
            const exp = MathUtils.randomInt(3, 5); // -3 to -5
            let numStr = (mantissa * Math.pow(10, -exp)).toFixed(exp);
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv i grundpotensform:" : "Write in scientific notation:",
                    latex: numStr,
                    answerType: 'structured_scientific'
                },
                token: this.toBase64(`${mantissa}*10^-${exp}`),
                clues: [{ latex: `${mantissa} \\cdot 10^{-${exp}}` }]
            };
        }
    }

    // Level 4: Square Roots & Estimation
    private level4_SquareRoots(lang: string): any {
        const type = MathUtils.randomChoice(['calc', 'est']);

        if (type === 'calc') {
            const base = MathUtils.randomInt(1, 15);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `\\sqrt{${base*base}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(base.toString()),
                clues: [{ text: lang === 'sv' ? "Vilket tal g√•nger sig sj√§lvt?" : "Which number times itself?" }]
            };
        } else {
            // Estimation
            const low = MathUtils.randomInt(3, 9);
            const high = low + 1;
            const target = MathUtils.randomInt((low*low)+1, (high*high)-1);
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Mellan vilka tv√• heltal ligger:" : "Between which two integers does this lie:",
                    latex: `\\sqrt{${target}}`,
                    answerType: 'structured_range' // UI: [ ] < sqrt < [ ]
                },
                token: this.toBase64(`${low}:${high}`),
                clues: [
                    { latex: `\\sqrt{${low*low}} = ${low}` },
                    { latex: `\\sqrt{${high*high}} = ${high}` },
                    { text: lang === 'sv' ? `${target} ligger mellan ${low*low} och ${high*high}.` : `${target} is between ${low*low} and ${high*high}.` }
                ]
            };
        }
    }

    // Level 5: Laws Basic
    private level5_LawsBasic(lang: string): any {
        const mode = MathUtils.randomChoice(['mult', 'div']);
        const baseVar = 'x';
        const a = MathUtils.randomInt(2, 6);
        const b = MathUtils.randomInt(2, 6);
        
        if (mode === 'mult') {
            const ans = a + b;
            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla:" : "Simplify:",
                    latex: `x^${a} \\cdot x^${b}`,
                    answerType: 'structured_power',
                    prefillBase: 'x'
                },
                token: this.toBase64(`x^${ans}`),
                clues: [{ text: lang === 'sv' ? "Addera exponenterna vid multiplikation." : "Add exponents when multiplying.", latex: `${a} + ${b} = ${ans}` }]
            };
        } else {
            // Division (ensure a > b)
            const big = Math.max(a, b) + 2;
            const small = Math.min(a, b);
            const ans = big - small;
             return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla:" : "Simplify:",
                    latex: `\\frac{x^${big}}{x^${small}}`,
                    answerType: 'structured_power',
                    prefillBase: 'x'
                },
                token: this.toBase64(`x^${ans}`),
                clues: [{ text: lang === 'sv' ? "Subtrahera exponenterna vid division." : "Subtract exponents when dividing.", latex: `${big} - ${small} = ${ans}` }]
            };
        }
    }

    // Level 6: Advanced Laws
    private level6_LawsAdvanced(lang: string): any {
        const a = MathUtils.randomInt(2, 4);
        const b = MathUtils.randomInt(2, 4);
        const ans = a * b;
        
        return {
             renderData: {
                description: lang === 'sv' ? "F√∂renkla:" : "Simplify:",
                latex: `(x^${a})^${b}`,
                answerType: 'structured_power',
                prefillBase: 'x'
            },
            token: this.toBase64(`x^${ans}`),
            clues: [{ text: lang === 'sv' ? "Multiplicera exponenterna (potens av potens)." : "Multiply the exponents (power of power).", latex: `${a} \\cdot ${b} = ${ans}` }]
        };
    }
}

// FILE END: src\core\generators\ExponentsGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExpressionSimplificationGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_CombineTerms(lang);
            case 2: return this.level2_Parentheses(lang);
            case 3: return this.level3_DistributeAndSimplify(lang);
            case 4: return this.level4_SubtractParentheses(lang);
            case 5: return this.level5_WordProblems(lang);
            case 6: return this.level6_Mixed(lang);
            default: return this.level1_CombineTerms(lang);
        }
    }

    // --- LEVEL 1: Combine Like Terms ---
    private level1_CombineTerms(lang: string): any {
        // Subtypes:
        // 1. ax + bx (Simple)
        // 2. ax + b + cx (Interleaved constant)
        // 3. ax + b + cx + d (Full mix)
        // 4. a - bx + cx + d (Negative start var, or const first)

        const subType = MathUtils.randomInt(1, 4);
        const v = 'x'; // Keep it simple for lower levels
        let latex = "";
        let answer = "";
        let clues: any[] = [];
        let desc = lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.";

        if (subType === 1) {
            // ax + bx
            const c1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 9);
            latex = `${c1}${v} + ${c2}${v}`;
            answer = `${c1+c2}${v}`;
            clues.push({ 
                text: lang === 'sv' ? "Addera koefficienterna (siffrorna framf√∂r x)." : "Add the coefficients.",
                latex: `${c1} + ${c2} = ${c1+c2}`
            });
            clues.push({
                text: lang === 'sv' ? "Svaret beh√•ller variabeln." : "Keep the variable.",
                latex: `\\mathbf{${answer}}`
            });
        } 
        else if (subType === 2) {
            // ax + b + cx
            const c1 = MathUtils.randomInt(2, 9);
            const k1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 9);
            
            // Random order: ax + b + cx OR b + ax + cx
            if (Math.random() > 0.5) latex = `${c1}${v} + ${k1} + ${c2}${v}`;
            else latex = `${k1} + ${c1}${v} + ${c2}${v}`;

            answer = `${c1+c2}${v} + ${k1}`;
            
            clues.push({
                text: lang === 'sv' ? "Hitta termerna med x och l√§gg ihop dem." : "Find the x-terms and add them.",
                latex: `${c1}${v} + ${c2}${v} = ${c1+c2}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Konstanten (siffran utan x) √§r kvar." : "The constant remains.",
                latex: `+ ${k1}`
            });
            clues.push({
                text: lang === 'sv' ? "S√§tt ihop uttrycket." : "Combine them.",
                latex: `\\mathbf{${answer}}`
            });
        }
        else if (subType === 3) {
            // ax + b + cx + d
            const c1 = MathUtils.randomInt(2, 6);
            const k1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 6);
            const k2 = MathUtils.randomInt(2, 9);

            latex = `${c1}${v} + ${k1} + ${c2}${v} + ${k2}`;
            answer = `${c1+c2}${v} + ${k1+k2}`;

            clues.push({
                text: lang === 'sv' ? "Steg 1: Addera x-termerna." : "Step 1: Add the x-terms.",
                latex: `${c1}${v} + ${c2}${v} = ${c1+c2}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Steg 2: Addera siffrorna (konstanterna)." : "Step 2: Add the constants.",
                latex: `${k1} + ${k2} = ${k1+k2}`
            });
            clues.push({
                text: lang === 'sv' ? "Resultat:" : "Result:",
                latex: `\\mathbf{${answer}}`
            });
        }
        else {
            // a - bx + cx + d (Negative handling)
            // Ensure result x is positive for simplicity in L1
            const k1 = MathUtils.randomInt(5, 15);
            const c_neg = MathUtils.randomInt(2, 5); // -bx
            const c_pos = c_neg + MathUtils.randomInt(1, 5); // cx, ensuring sum > 0
            const k2 = MathUtils.randomInt(2, 9);

            latex = `${k1} - ${c_neg}${v} + ${c_pos}${v} + ${k2}`;
            // (c_pos - c_neg)x + (k1 + k2)
            answer = `${c_pos - c_neg}${v} + ${k1+k2}`;

            clues.push({
                text: lang === 'sv' ? "Steg 1: Hantera x-termerna. T√§nk p√• minustecknet." : "Step 1: Handle x-terms. Mind the minus sign.",
                latex: `-${c_neg}${v} + ${c_pos}${v} = ${c_pos - c_neg}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Steg 2: Addera siffrorna." : "Step 2: Add the numbers.",
                latex: `${k1} + ${k2} = ${k1+k2}`
            });
            clues.push({
                text: lang === 'sv' ? "S√§tt ihop delarna." : "Combine parts.",
                latex: `\\mathbf{${answer}}`
            });
        }

        return {
            renderData: { latex, description: desc, answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: clues
        };
    }

    // --- LEVEL 2: Parentheses (Distribution) ---
    private level2_Parentheses(lang: string): any {
        const v = 'x';
        const outer = MathUtils.randomInt(2, 5);
        const innerC = MathUtils.randomInt(2, 5);
        const innerK = MathUtils.randomInt(1, 5);
        
        const latex = `${outer}(${innerC}${v} + ${innerK})`;
        const resC = outer * innerC;
        const resK = outer * innerK;
        const answer = `${resC}${v} + ${resK}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Multiplicera talet utanf√∂r med B√ÖDA termerna inuti." : "Multiply the number outside with BOTH terms inside.", 
                    latex: `${outer} \\cdot ${innerC}${v} + ${outer} \\cdot ${innerK}` 
                },
                { 
                    text: lang === 'sv' ? "Ber√§kna produkterna." : "Calculate the products.", 
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 3: Distribute & Combine ---
    private level3_DistributeAndSimplify(lang: string): any {
        const outer = MathUtils.randomInt(2, 4);
        const inC = MathUtils.randomInt(2, 4);
        const inK = MathUtils.randomInt(1, 5);
        const extraX = MathUtils.randomInt(2, 6);
        
        const latex = `${outer}(${inC}x + ${inK}) + ${extraX}x`;
        
        const distX = outer * inC;
        const distK = outer * inK;
        const totalX = distX + extraX;
        
        const answer = `${totalX}x + ${distK}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "B√∂rja med att ta bort parentesen." : "Start by removing the parentheses.", 
                    latex: `${distX}x + ${distK} + ${extraX}x` 
                },
                { 
                    text: lang === 'sv' ? "L√§gg ihop x-termerna." : "Combine the x-terms.", 
                    latex: `${distX}x + ${extraX}x = ${totalX}x` 
                },
                {
                    text: lang === 'sv' ? "Resultat:" : "Result:",
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 4: Subtracting Parentheses ---
    private level4_SubtractParentheses(lang: string): any {
        const startX = MathUtils.randomInt(5, 10);
        const subX = MathUtils.randomInt(1, startX - 1);
        const subK = MathUtils.randomInt(1, 5);
        
        const latex = `${startX}x - (${subX}x + ${subK})`;
        const resX = startX - subX;
        const resK = -subK; 
        
        const answer = `${resX}x - ${Math.abs(resK)}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Minus framf√∂r en parentes √§ndrar tecken p√• allt inuti." : "A minus in front of parentheses changes the sign of everything inside.", 
                    latex: `${startX}x - ${subX}x - ${subK}` 
                },
                { 
                    text: lang === 'sv' ? "F√∂renkla x-termerna." : "Simplify the x-terms.",
                    latex: `${startX}x - ${subX}x = ${resX}x`
                },
                {
                    text: lang === 'sv' ? "Resultat:" : "Result:",
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 5: Word Problems ---
    private level5_WordProblems(lang: string): any {
        const A = MathUtils.randomInt(2, 6);  
        const B = MathUtils.randomInt(5, 30); 
        const C = MathUtils.randomInt(2, 6);  
        
        const scenarios = [
            {
                type: 'add',
                sv: `Du har ${A} p√•sar med godis (x) och k√∂per ${C} p√•sar till. Du har ocks√• ${B} l√∂sa godisar.`,
                en: `You have ${A} bags of candy (x) and buy ${C} more bags. You also have ${B} loose candies.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `Du k√∂per ${A} tr√∂jor och ${C} byxor som alla kostar x kr styck. Du har en rabattkupong p√• ${B} kr.`,
                en: `You buy ${A} shirts and ${C} pants that all cost x kr each. You have a discount coupon for ${B} kr.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `Du betalar x kr/m√•nad i ${A} m√•nader, sen ${C} m√•nader till. Startavgiften var ${B} kr.`,
                en: `You pay x kr/mo for ${A} months, then ${C} months. Start fee was ${B} kr.`,
                op: '+', expl: '+'
            },
            {
                type: 'add',
                sv: `En triangel har sidorna x, ${A}x och ${C}x. Plus en extra str√§cka p√• ${B} cm.`,
                en: `A triangle has sides x, ${A}x, and ${C}x. Plus an extra length of ${B} cm.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `Du sparar x kr i ${A} veckor och ${C} veckor. Sen k√∂per du n√•got f√∂r ${B} kr.`,
                en: `You save x kr for ${A} weeks and ${C} weeks. Then you spend ${B} kr.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `Ett lag k√∂per x biljetter till ${A} spelare och ${C} ledare. Bokningsavgiften √§r ${B} kr.`,
                en: `A team buys x tickets for ${A} players and ${C} coaches. Booking fee is ${B} kr.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `En lastbil lastar ${A} l√•dor och ${C} paket (vikt x). Man lastar av ${B} kg skr√§p.`,
                en: `A truck loads ${A} boxes and ${C} packages (weight x). Unloads ${B} kg trash.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `I ett spel f√•r du x po√§ng i runda 1. Runda 2 ger ${A} g√•nger mer, runda 3 ger ${C} g√•nger mer. Bonus ${B} po√§ng.`,
                en: `Game: x points round 1. Round 2 is ${A}x, Round 3 is ${C}x. Bonus ${B} points.`,
                op: '+', expl: '+'
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const totalX = A + C; // Simplified logic assuming 1x is implied or adjusted in prompt if A/C not 1
        // Note: Scenarios assume "A bags" means "Ax", "C bags" means "Cx". 
        // If A or C represents "times more", logic holds.
        
        const answer = `${totalX}x ${s.op} ${B}`;
        
        const desc = lang === 'sv' 
            ? `${s.sv} Skriv ett uttryck f√∂r totalen och f√∂renkla.` 
            : `${s.en} Write an expression for the total and simplify.`;

        return {
            renderData: { latex: "", description: desc, answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? `1. Hitta x-termerna: ${A}x + ${C}x.` : `1. Find x-terms: ${A}x + ${C}x.`,
                    latex: `${totalX}x`
                },
                { 
                    text: lang === 'sv' ? `2. L√§gg till konstanten (${B}).` : `2. Add the constant (${B}).`, 
                    latex: `${totalX}x ${s.op} ${B}` 
                }
            ]
        };
    }

    private level6_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        return this.generate(lvl, lang);
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\FractionArithGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionArithGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SameDenom(lang);
            case 2: return this.level2_DiffDenom(lang);
            case 3: return this.level3_AdvancedAdd(lang);
            case 4: return this.level4_Multiplication(lang);
            case 5: return this.level5_Division(lang);
            default: return this.level1_SameDenom(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return b === 0 ? a : this.gcd(b, a % b);
    }

    private lcm(a: number, b: number): number {
        return (a * b) / this.gcd(a, b);
    }

    private simplify(n: number, d: number): { n: number, d: number } {
        const div = this.gcd(n, d);
        return { n: n / div, d: d / div };
    }

    // Level 1: Same Denominators (+/-)
    private level1_SameDenom(lang: string): any {
        const op = MathUtils.randomChoice(['+', '-']);
        const den = MathUtils.randomInt(3, 12);
        
        let n1 = MathUtils.randomInt(1, den - 1);
        let n2 = MathUtils.randomInt(1, den - 1);
        
        if (op === '-' && n1 < n2) [n1, n2] = [n2, n1]; // Ensure positive result

        const resN = op === '+' ? n1 + n2 : n1 - n2;
        const resD = den;
        const simp = this.simplify(resN, resD);

        const desc = lang === 'sv' ? "Ber√§kna:" : "Calculate:";

        return {
            renderData: {
                description: desc,
                latex: `\\frac{${n1}}{${den}} ${op} \\frac{${n2}}{${den}}`,
                answerType: 'fraction',
                geometry: null
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [
                { 
                    text: lang === 'sv' ? "N√§mnarna (botten) √§r lika. Addera/subtrahera bara t√§ljarna." : "Denominators are the same. Just add/subtract the numerators.",
                    latex: `\\frac{${n1} ${op} ${n2}}{${den}} = \\frac{${resN}}{${resD}}`
                },
                {
                    text: lang === 'sv' ? "Svara i enklaste form." : "Answer in simplest form.",
                    latex: `\\frac{${simp.n}}{${simp.d}}`
                }
            ]
        };
    }

    // Level 2: Different Denominators (+/-)
    private level2_DiffDenom(lang: string): any {
        const op = MathUtils.randomChoice(['+', '-']);
        
        // Scenario A: One fits into other (2 and 4, 3 and 6)
        // Scenario B: Co-prime (2 and 3, 3 and 4)
        const scenario = MathUtils.randomChoice(['fit', 'coprime']);
        
        let d1=0, d2=0;
        if (scenario === 'fit') {
            d1 = MathUtils.randomInt(2, 5);
            d2 = d1 * MathUtils.randomInt(2, 3);
        } else {
            d1 = MathUtils.randomInt(2, 5);
            d2 = d1 + 1; // 2&3, 3&4, 4&5
        }
        
        let n1 = 1, n2 = 1;
        // Make numerators small to keep arithmetic simple
        n1 = MathUtils.randomInt(1, d1-1);
        n2 = MathUtils.randomInt(1, d2-1);

        const commonD = this.lcm(d1, d2);
        const adjN1 = n1 * (commonD / d1);
        const adjN2 = n2 * (commonD / d2);
        
        // Ensure valid subtraction
        if (op === '-' && adjN1 < adjN2) {
             // Swap fractions logic roughly
             const tempN = n1; const tempD = d1;
             n1 = n2; d1 = d2;
             n2 = tempN; d2 = tempD;
        }

        const finalN = op === '+' ? adjN1 + adjN2 : adjN1 - adjN2; // Note: Re-calc after swap might be needed if exact values matter, but logic holds.
        // Actually, let's just calc proper result:
        const term1 = n1 * d2; 
        const term2 = n2 * d1;
        const rawNum = op === '+' ? term1 + term2 : term1 - term2;
        const rawDen = d1 * d2;
        
        // Better logic with LCM
        const extN1 = n1 * (commonD/d1);
        const extN2 = n2 * (commonD/d2);
        const resN = op === '+' ? extN1 + extN2 : extN1 - extN2;
        // Check negative again
        if (resN < 0) return this.level2_DiffDenom(lang); // Retry

        const simp = this.simplify(resN, commonD);

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna (Minsta gemensamma n√§mnare):" : "Calculate (Lowest Common Denominator):",
                latex: `\\frac{${n1}}{${d1}} ${op} \\frac{${n2}}{${d2}}`,
                answerType: 'fraction',
                geometry: null
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [
                { 
                    text: lang === 'sv' ? `Hitta gemensam n√§mnare (MGN) f√∂r ${d1} och ${d2}.` : `Find common denominator (LCD) for ${d1} and ${d2}.`,
                    latex: `\\text{MGN} = ${commonD}`
                },
                { 
                    text: lang === 'sv' ? "F√∂rl√§ng br√•ken." : "Extend the fractions.",
                    latex: `\\frac{${extN1}}{${commonD}} ${op} \\frac{${extN2}}{${commonD}}`
                },
                {
                    latex: `\\frac{${resN}}{${commonD}} = \\frac{${simp.n}}{${simp.d}}`
                }
            ]
        };
    }

    // Level 3: Advanced Addition (Mixed Numbers / Improper)
    private level3_AdvancedAdd(lang: string): any {
        // 1 1/2 + 3/4
        const w1 = 1;
        const n1 = 1, d1 = 2;
        const n2 = 3, d2 = 4;
        
        // Convert mixed to improper: 3/2
        const impN1 = 3; 
        // LCD is 4. -> 6/4
        const extN1 = 6;
        const extN2 = 3; 
        // Sum = 9/4
        const resN = 9;
        const resD = 4;
        
        // Simplified Logic for variety
        // Let's just generate one static type of problem structure for stability in this first version, or simple randomization
        const problem = MathUtils.randomChoice([
            { l: '1 \\frac{1}{2} + \\frac{1}{2}', ans: '2/1' },
            { l: '1 \\frac{1}{4} + \\frac{3}{4}', ans: '2/1' },
            { l: '1 \\frac{1}{3} + \\frac{1}{3}', ans: '5/3' },
            { l: '\\frac{3}{5} + 1 \\frac{1}{5}', ans: '9/5' }
        ]);

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna. Svara i br√•kform (eller heltal)." : "Calculate. Answer as a fraction (or whole number).",
                latex: problem.l,
                answerType: 'fraction',
                geometry: null
            },
            token: this.toBase64(problem.ans),
            clues: [
                { text: lang === 'sv' ? "G√∂r om blandad form till br√•kform f√∂rst." : "Convert mixed numbers to improper fractions first." }
            ]
        };
    }

    // Level 4: Multiplication
    private level4_Multiplication(lang: string): any {
        const isInteger = MathUtils.randomInt(0, 1) === 1;
        
        if (isInteger) {
            const int = MathUtils.randomInt(2, 6);
            const n = 1;
            const d = MathUtils.randomInt(3, 8);
            const resN = int * n;
            const simp = this.simplify(resN, d);
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `${int} \\cdot \\frac{${n}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${simp.n}/${simp.d}`),
                clues: [
                    { 
                        text: lang === 'sv' ? "Helatlet multipliceras bara med t√§ljaren." : "The whole number multiplies only with the numerator.",
                        latex: `\\frac{${int} \\cdot ${n}}{${d}} = \\frac{${resN}}{${d}}`
                    }
                ]
            };
        } else {
            const n1 = MathUtils.randomInt(1, 4);
            const d1 = MathUtils.randomInt(2, 6);
            const n2 = MathUtils.randomInt(1, 4);
            const d2 = MathUtils.randomInt(2, 6);
            
            const resN = n1 * n2;
            const resD = d1 * d2;
            const simp = this.simplify(resN, resD);

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `\\frac{${n1}}{${d1}} \\cdot \\frac{${n2}}{${d2}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${simp.n}/${simp.d}`),
                clues: [
                    { 
                        text: lang === 'sv' ? "Multiplicera t√§ljare med t√§ljare, n√§mnare med n√§mnare." : "Top times top, bottom times bottom.",
                        latex: `\\frac{${n1} \\cdot ${n2}}{${d1} \\cdot ${d2}} = \\frac{${resN}}{${resD}}`
                    }
                ]
            };
        }
    }

    // Level 5: Division
    private level5_Division(lang: string): any {
        const n1 = 1;
        const d1 = MathUtils.randomChoice([2, 3, 4]);
        const n2 = 1;
        const d2 = MathUtils.randomChoice([2, 3, 4]);
        
        // n1/d1 divided by n2/d2 -> n1/d1 * d2/n2
        const resN = n1 * d2;
        const resD = d1 * n2;
        const simp = this.simplify(resN, resD);

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                latex: `\\frac{${n1}}{${d1}} \\div \\frac{${n2}}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [
                { 
                    text: lang === 'sv' ? "Invertera det andra br√•ket och byt till g√•nger." : "Invert the second fraction and switch to multiply.",
                    latex: `\\frac{${n1}}{${d1}} \\cdot \\frac{${d2}}{${n2}}`
                },
                {
                    latex: `\\frac{${resN}}{${resD}}`
                }
            ]
        };
    }
}

// FILE END: src\core\generators\FractionArithGen.ts

// =======================================================
// FILE START: src\core\generators\FractionBasicsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionBasicsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_PartsOfQuantity(lang);
            case 3: return this.level3_MixedImproper(lang);
            case 4: return this.level4_SimplifyExtend(lang);
            case 5: return this.level5_Decimals(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return b === 0 ? a : this.gcd(b, a % b);
    }

    // Level 1: Visual Fractions (Marbles & Shapes)
    private level1_Visuals(lang: string): any {
        // Reuse Probability Marbles Logic
        const red = MathUtils.randomInt(1, 5);
        const blue = MathUtils.randomInt(1, 5);
        const green = MathUtils.randomInt(1, 5);
        const total = red + blue + green;
        
        const targetColor = MathUtils.randomChoice(['red', 'blue', 'green']);
        const count = targetColor === 'red' ? red : (targetColor === 'blue' ? blue : green);
        
        const colorNameSv = targetColor === 'red' ? 'r√∂da' : (targetColor === 'blue' ? 'bl√•a' : 'gr√∂na');
        const colorNameEn = targetColor;

        const desc = lang === 'sv' 
            ? `Hur stor andel av kulorna √§r ${colorNameSv}? Svara i br√•kform.` 
            : `What fraction of the marbles are ${colorNameEn}? Answer as a fraction.`;

        return {
            renderData: {
                description: desc,
                answerType: 'fraction', // Triggers the new InputComponent
                geometry: {
                    type: 'probability_marbles',
                    items: { red, blue, green }
                }
            },
            token: this.toBase64(`${count}/${total}`),
            clues: [
                { 
                    text: lang === 'sv' ? "R√§kna f√∂rst hur m√•nga kulor det finns totalt (n√§mnaren)." : "First count how many marbles there are in total (the denominator).",
                    latex: `\\text{Total} = ${total}`
                },
                { 
                    text: lang === 'sv' ? `R√§kna sedan hur m√•nga som √§r ${colorNameSv} (t√§ljaren).` : `Then count how many are ${colorNameEn} (the numerator).`,
                    latex: `\\text{${colorNameEn}} = ${count}`
                }
            ]
        };
    }

    // Level 2: Parts of Quantity (1/n of X)
    private level2_PartsOfQuantity(lang: string): any {
        const denom = MathUtils.randomChoice([2, 3, 4, 5, 10, 100]);
        const multiplier = MathUtils.randomInt(2, 12);
        const total = denom * multiplier; // Ensures clean division
        
        const desc = lang === 'sv'
            ? `Ber√§kna $\\frac{1}{${denom}}$ av ${total} kr.`
            : `Calculate $\\frac{1}{${denom}}$ of ${total} kr.`;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: null
            },
            token: this.toBase64(multiplier.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `Att ta en ${denom}-del √§r samma sak som att dela med ${denom}.` : `Finding a ${denom}-th is the same as dividing by ${denom}.`,
                    latex: `\\frac{1}{${denom}} \\cdot ${total} = \\frac{${total}}{${denom}}`
                },
                { 
                    text: lang === 'sv' ? "Utf√∂r divisionen." : "Perform the division.",
                    latex: `${total} / ${denom} = ${multiplier}`
                }
            ]
        };
    }

    // Level 3: Mixed <-> Improper
    private level3_MixedImproper(lang: string): any {
        const isMixedToImproper = MathUtils.randomInt(0, 1) === 1;
        const whole = MathUtils.randomInt(1, 5);
        const den = MathUtils.randomChoice([3, 4, 5, 6, 8]);
        const num = MathUtils.randomInt(1, den - 1); // Proper fraction part
        
        const improperNum = whole * den + num;

        if (isMixedToImproper) {
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv ${whole} $\\frac{${num}}{${den}}$ i br√•kform (utan heltal).` 
                        : `Write ${whole} $\\frac{${num}}{${den}}$ as an improper fraction.`,
                    answerType: 'fraction',
                    geometry: null
                },
                token: this.toBase64(`${improperNum}/${den}`),
                clues: [
                    { 
                        text: lang === 'sv' ? "Multiplicera heltalet med n√§mnaren och addera t√§ljaren." : "Multiply the whole number by the denominator and add the numerator.",
                        latex: `${whole} \\cdot ${den} + ${num} = ${improperNum}`
                    },
                    {
                        latex: `\\frac{${improperNum}}{${den}}`
                    }
                ]
            };
        } else {
            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Skriv $\\frac{${improperNum}}{${den}}$ i blandad form (heltal och br√•k).`
                        : `Write $\\frac{${improperNum}}{${den}}$ as a mixed number.`,
                    answerType: 'mixed_fraction', // Triggers Mixed Input
                    geometry: null
                },
                token: this.toBase64(`${whole} ${num}/${den}`),
                clues: [
                    { 
                        text: lang === 'sv' ? `Hur m√•nga g√•nger f√•r ${den} plats i ${improperNum}?` : `How many times does ${den} fit into ${improperNum}?`,
                        latex: `${improperNum} / ${den} = ${whole} \\text{ rest } ${num}`
                    },
                    {
                        latex: `${whole} \\frac{${num}}{${den}}`
                    }
                ]
            };
        }
    }

    // Level 4: Expand & Simplify
    private level4_SimplifyExtend(lang: string): any {
        const isSimplify = MathUtils.randomInt(0, 1) === 1;

        if (isSimplify) {
            // Create a fraction that can be simplified
            const baseN = MathUtils.randomInt(1, 9);
            const baseD = MathUtils.randomInt(baseN + 1, 12);
            // Ensure base is irreducible? Not strictly necessary if we multiply by large factor, but good for uniqueness.
            // Let's just pick a factor and multiply.
            const factor = MathUtils.randomChoice([2, 3, 4, 5]);
            const n = baseN * factor;
            const d = baseD * factor;
            
            // Simplest form calculation for token
            const divisor = this.gcd(n, d);
            const simpleN = n / divisor;
            const simpleD = d / divisor;

            return {
                renderData: {
                    description: lang === 'sv' ? `F√∂rkorta $\\frac{${n}}{${d}}$ s√• l√•ngt det g√•r.` : `Simplify $\\frac{${n}}{${d}}$ to its lowest terms.`,
                    answerType: 'fraction',
                    geometry: null
                },
                token: this.toBase64(`${simpleN}/${simpleD}`),
                clues: [
                    { 
                        text: lang === 'sv' ? `Hitta ett tal som b√•de ${n} och ${d} kan delas med (st√∂rsta gemensamma delare).` : `Find a number that divides both ${n} and ${d} (GCD).`,
                        latex: `\\text{GCD} = ${divisor}`
                    },
                    {
                        latex: `\\frac{${n} / ${divisor}}{${d} / ${divisor}} = \\frac{${simpleN}}{${simpleD}}`
                    }
                ]
            };
        } else {
            // Extend
            const n = MathUtils.randomInt(1, 5);
            const d = MathUtils.randomChoice([2, 3, 4, 5]);
            const factor = MathUtils.randomInt(2, 5);
            const targetD = d * factor;
            const targetN = n * factor;

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `F√∂rl√§ng $\\frac{${n}}{${d}}$ s√• att n√§mnaren blir ${targetD}.` 
                        : `Extend $\\frac{${n}}{${d}}$ so the denominator becomes ${targetD}.`,
                    answerType: 'fraction',
                    geometry: null
                },
                token: this.toBase64(`${targetN}/${targetD}`),
                clues: [
                    { 
                        text: lang === 'sv' ? `Vad m√•ste du multiplicera ${d} med f√∂r att f√• ${targetD}?` : `What must you multiply ${d} by to get ${targetD}?`,
                        latex: `${d} \\cdot ? = ${targetD} \\rightarrow ${factor}`
                    },
                    { 
                        text: lang === 'sv' ? "Multiplicera b√•de t√§ljare och n√§mnare med det talet." : "Multiply both top and bottom by that number.",
                        latex: `\\frac{${n} \\cdot ${factor}}{${d} \\cdot ${factor}} = \\frac{${targetN}}{${targetD}}`
                    }
                ]
            };
        }
    }

    // Level 5: Benchmark Translations
    private level5_Decimals(lang: string): any {
        const type = MathUtils.randomInt(1, 2); // 1: Frac->Dec, 2: Dec->Frac
        
        // The Benchmarks
        const benchmarks = [
            { n: 1, d: 2, dec: 0.5 },
            { n: 1, d: 4, dec: 0.25 },
            { n: 3, d: 4, dec: 0.75 },
            { n: 1, d: 5, dec: 0.2 },
            { n: 2, d: 5, dec: 0.4 },
            { n: 3, d: 5, dec: 0.6 },
            { n: 4, d: 5, dec: 0.8 },
            { n: 1, d: 10, dec: 0.1 },
            { n: 3, d: 10, dec: 0.3 },
            { n: 1, d: 100, dec: 0.01 },
            { n: 5, d: 100, dec: 0.05 }
        ];

        // 10% chance for 1/8
        if (Math.random() < 0.1) benchmarks.push({ n: 1, d: 8, dec: 0.125 });

        const item = MathUtils.randomChoice(benchmarks);

        if (type === 1) {
            // Fraction -> Decimal
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv $\\frac{${item.n}}{${item.d}}$ som decimaltal.` 
                        : `Write $\\frac{${item.n}}{${item.d}}$ as a decimal.`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(item.dec.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Br√•kstrecket betyder division." : "The fraction bar means division.",
                        latex: `${item.n} \\div ${item.d} = ${item.dec}`
                    }
                ]
            };
        } else {
            // Decimal -> Fraction
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv ${item.dec} som ett br√•k (enklaste form).` 
                        : `Write ${item.dec} as a fraction (simplest form).`,
                    answerType: 'fraction',
                    geometry: null
                },
                token: this.toBase64(`${item.n}/${item.d}`),
                clues: [
                    { 
                        text: lang === 'sv' ? "T√§nk p√• positionssystemet (tiondelar, hundradelar)." : "Think about place value (tenths, hundredths).",
                        latex: `${item.dec} = \\frac{${item.n * (1/this.gcd(item.n, item.d)) * (item.d/this.gcd(item.n, item.d))}}{...}` // Simplified hint logic
                    },
                    {
                        text: lang === 'sv' ? "F√∂rkorta br√•ket om det g√•r." : "Simplify the fraction if possible.",
                        latex: `\\frac{${item.n}}{${item.d}}`
                    }
                ]
            };
        }
    }
}

// FILE END: src\core\generators\FractionBasicsGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class GeometryGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        let mode = level;
        if (level >= 6) mode = MathUtils.randomInt(3, 5);

        switch (mode) {
            case 1: return this.level1_PerimeterRect(lang);
            case 2: return this.level2_AreaRect(lang);
            case 3: return this.level3_AreaTriangle(lang);
            case 4: return this.level4_Circles(lang);
            case 5: return this.level5_Composite(lang);
            default: return this.level1_PerimeterRect(lang);
        }
    }

    private level1_PerimeterRect(lang: string): any {
        const w = MathUtils.randomInt(3, 12);
        const h = MathUtils.randomInt(2, 8);
        const ans = 2 * (w + h);
        return {
            renderData: { 
                geometry: { 
                    type: 'rectangle', 
                    width: w, 
                    height: h, 
                    labels: { b: w, h: h } // Explicit b/h
                }, 
                description: lang === 'sv' ? "Ber√§kna omkretsen." : "Calculate the perimeter.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Omkretsen √§r str√§ckan runt hela figuren." : "Perimeter is the distance around the shape.", latex: "" },
                { text: lang === 'sv' ? "Addera alla fyra sidor." : "Add all four sides.", latex: `${w} + ${w} + ${h} + ${h} = \\mathbf{${ans}}` }
            ]
        };
    }

    private level2_AreaRect(lang: string): any {
        const w = MathUtils.randomInt(3, 12);
        const h = MathUtils.randomInt(2, 8);
        const ans = w * h;
        return {
            renderData: { 
                geometry: { 
                    type: 'rectangle', 
                    width: w, 
                    height: h, 
                    labels: { b: w, h: h } // Explicit b/h
                }, 
                description: lang === 'sv' ? "Ber√§kna arean." : "Calculate the area.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Area = Basen ¬∑ H√∂jden" : "Area = Base ¬∑ Height", latex: `A = ${w} \\cdot ${h}` },
                { latex: `\\mathbf{${ans}}` }
            ]
        };
    }

    private level3_AreaTriangle(lang: string): any {
        const b = MathUtils.randomInt(4, 14);
        const h = MathUtils.randomInt(2, 8) * 2;
        const ans = (b * h) / 2;
        const subtype = MathUtils.randomChoice(['right', 'isosceles']); 
        return {
            renderData: { 
                geometry: { 
                    type: 'triangle', 
                    subtype, 
                    width: b, 
                    height: h, 
                    labels: { b: b, h: h } // Explicit b/h
                }, 
                description: lang === 'sv' ? "Ber√§kna arean." : "Calculate the area.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Area = (Basen ¬∑ H√∂jden) / 2" : "Area = (Base ¬∑ Height) / 2", latex: `A = \\frac{${b} \\cdot ${h}}{2}` },
                { latex: `A = \\frac{${b*h}}{2} = \\mathbf{${ans}}` }
            ]
        };
    }

    private level4_Circles(lang: string): any {
        const r = MathUtils.randomInt(3, 9);
        const d = r * 2;
        const isArea = MathUtils.randomInt(0, 1) === 1;
        const showD = MathUtils.randomInt(0, 1) === 1;
        
        let ans = 0, desc = "", steps = [];
        const labelVal = showD ? `d=${d}` : `r=${r}`;

        if (isArea) {
            ans = Math.round(3.14 * r * r * 10) / 10;
            desc = lang === 'sv' ? "Ber√§kna arean (avrunda till 1 decimal)." : "Calculate area (round to 1 decimal).";
            if (showD) steps.push({ text: lang === 'sv' ? "F√∂rst, hitta radien (h√§lften av diametern)." : "First, find radius (half of diameter).", latex: `r = ${d}/2 = ${r}` });
            steps.push({ latex: `A \\approx 3.14 \\cdot ${r}^2 \\approx \\mathbf{${ans}}` });
        } else {
            ans = Math.round(2 * 3.14 * r * 10) / 10;
            desc = lang === 'sv' ? "Ber√§kna omkretsen (avrunda till 1 decimal)." : "Calculate circumference (round to 1 decimal).";
            steps.push({ latex: showD ? `O \\approx 3.14 \\cdot ${d} \\approx \\mathbf{${ans}}` : `O \\approx 2 \\cdot 3.14 \\cdot ${r} \\approx \\mathbf{${ans}}` });
        }

        return {
            renderData: { 
                geometry: { 
                    type: 'circle', 
                    radius: r, 
                    diameter: d, 
                    labels: { val: labelVal, radius: r, diameter: d }, 
                    show: showD ? 'diameter' : 'radius' 
                }, 
                description: desc, answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: steps
        };
    }

    private level5_Composite(lang: string): any {
        const type = MathUtils.randomChoice(['house', 'portal']);
        let w = MathUtils.randomInt(4, 20);
        const h = MathUtils.randomInt(4, 20);
        if (type === 'portal' && w % 2 !== 0) w += 1;

        const isArea = MathUtils.randomInt(0, 1) === 1;
        let ans = 0, steps = [], geom: any = {}, desc = "";

        if (type === 'house') {
            const hRoof = MathUtils.randomInt(3, 10);
            if (isArea) {
                const aRect = w * h;
                const aTri = (w * hRoof) / 2;
                ans = aRect + aTri;
                desc = lang === 'sv' ? `Ber√§kna arean. (Rektangel ${w}x${h} + Tak h√∂jd ${hRoof})` : `Calculate area.`;
                steps = [{ latex: `${w}\\cdot${h} + \\frac{${w}\\cdot${hRoof}}{2} = \\mathbf{${ans}}` }];
            } else {
                const half = w / 2;
                const slope = Math.sqrt(half*half + hRoof*hRoof);
                ans = Math.round((w + 2*h + 2*slope) * 10) / 10;
                desc = lang === 'sv' ? `Ber√§kna omkretsen. (Bredd ${w}, V√§gg ${h}, Tak h√∂jd ${hRoof})` : `Calculate perimeter.`;
                steps = [{ latex: `${w} + 2\\cdot${h} + 2\\cdot${Math.round(slope*10)/10} \\approx \\mathbf{${ans}}` }];
            }
            geom = { type: 'composite', subtype: 'house', labels: { w, h, h_roof: hRoof } };
        } else {
            const r = w / 2;
            if (isArea) {
                const aRect = w * h;
                const aSemi = Math.round(3.14 * r * r / 2 * 10) / 10;
                ans = Math.round((aRect + aSemi)*10)/10;
                desc = lang === 'sv' ? `Ber√§kna arean av portalen (Bredd ${w}, H√∂jd ${h}).` : `Calculate portal area.`;
                steps = [{ latex: `${w}\\cdot${h} + \\frac{3.14\\cdot${r}^2}{2} \\approx \\mathbf{${ans}}` }];
            } else {
                const arc = 3.14 * r;
                ans = Math.round((w + 2*h + arc) * 10) / 10;
                desc = lang === 'sv' ? `Ber√§kna omkretsen (Bredd ${w}, H√∂jd ${h}).` : `Calculate perimeter.`;
                steps = [{ latex: `${w} + 2\\cdot${h} + 3.14\\cdot${r} \\approx \\mathbf{${ans}}` }];
            }
            geom = { type: 'composite', subtype: 'portal', labels: { w, h } };
        }

        return {
            renderData: { geometry: geom, description: desc, answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: steps
        };
    }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';
import { LinearEquationProblemGen } from './LinearEquationProblemGen.js';

export class LinearEquationGen {
    private problemGen: LinearEquationProblemGen;

    constructor() {
        this.problemGen = new LinearEquationProblemGen();
    }

    public generate(level: number, lang: string = 'sv'): any {
        // Delegate Word Problems to the Specialist
        if (level === 5 || level === 6) {
            return this.problemGen.generate(level, lang);
        }
        
        // Mixed Level Drill
        if (level === 7) {
            return this.level7_Mixed(lang);
        }

        switch (level) {
            case 1: return this.level1_OneStep(lang);
            case 2: return this.level2_TwoStep(lang);
            case 3: return this.level3_Parentheses(lang);
            case 4: return this.level4_BothSides(lang);
            default: return this.level1_OneStep(lang);
        }
    }

    // --- LEVEL 1: One-Step Equations ---
    private level1_OneStep(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        let latex = '', answer = '', clues = [];
        
        if (type === 1) { // x / k = res
            const k = MathUtils.randomInt(2, 9);
            const res = MathUtils.randomInt(2, 10);
            const val = res * k;
            latex = `\\frac{x}{${k}} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. Eftersom x √§r delat med ${k}, g√∂r vi det motsatta: vi multiplicerar med ${k}.` 
                    : `We want x alone. Since x is divided by ${k}, we do the opposite: multiply by ${k}.`, 
                latex: `x = ${res} \\cdot ${k} \\\\ x = ${val}` 
            }];
        } 
        else if (type === 2) { // k * x = res
            const k = MathUtils.randomInt(2, 9);
            const val = MathUtils.randomInt(2, 10);
            const res = k * val;
            latex = `${k}x = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. Eftersom x √§r multiplicerat med ${k}, g√∂r vi det motsatta: vi dividerar med ${k}.` 
                    : `We want x alone. Since x is multiplied by ${k}, we do the opposite: divide by ${k}.`, 
                latex: `x = \\frac{${res}}{${k}} \\\\ x = ${val}` 
            }];
        } 
        else if (type === 3) { // x + k = res
            const k = MathUtils.randomInt(1, 20);
            const val = MathUtils.randomInt(1, 20);
            const res = val + k;
            latex = `x + ${k} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. H√§r st√•r plus ${k}, s√• vi g√∂r det motsatta: vi subtraherar ${k}.` 
                    : `We want x alone. It says plus ${k}, so we do the opposite: subtract ${k}.`, 
                latex: `x = ${res} - ${k} \\\\ x = ${val}` 
            }];
        } 
        else { // x - k = res
            const k = MathUtils.randomInt(1, 20);
            const val = MathUtils.randomInt(1, 20);
            const res = val - k;
            latex = `x - ${k} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. H√§r st√•r minus ${k}, s√• vi g√∂r det motsatta: vi adderar ${k}.` 
                    : `We want x alone. It says minus ${k}, so we do the opposite: add ${k}.`, 
                latex: `x = ${res} + ${k} \\\\ x = ${val}` 
            }];
        }

        return {
            renderData: { 
                latex, 
                description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", 
                answerType: 'text' 
            },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 2: Two-Step Equations ---
    private level2_TwoStep(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const x = MathUtils.randomInt(2, 12);
        let latex = '', answer = x.toString(), clues = [];

        if (type === 1) { // ax + b = c
            const a = MathUtils.randomInt(2, 9);
            const b = MathUtils.randomInt(1, 15);
            const c = a * x + b;
            latex = `${a}x + ${b} = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `F√∂rst m√•ste vi f√• termen med x ensam. Vi tar bort ${b} genom att subtrahera det.` 
                        : `First isolate the x-term. Remove ${b} by subtracting it.`, 
                    latex: `${a}x = ${c} - ${b} \\\\ ${a}x = ${c-b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Nu sitter ${a} ihop med x (g√•nger). Vi dividerar med ${a} f√∂r att f√• svaret.` 
                        : `Now ${a} is multiplied by x. Divide by ${a} to get the answer.`, 
                    latex: `x = \\frac{${c-b}}{${a}} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 2) { // ax - b = c
            const a = MathUtils.randomInt(2, 9);
            const b = MathUtils.randomInt(1, 15);
            const c = a * x - b;
            latex = `${a}x - ${b} = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `F√∂rst m√•ste vi f√• termen med x ensam. Vi tar bort minus ${b} genom att addera ${b}.` 
                        : `First isolate the x-term. Remove minus ${b} by adding ${b}.`, 
                    latex: `${a}x = ${c} + ${b} \\\\ ${a}x = ${c+b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Nu dividerar vi med ${a} f√∂r att f√• fram x.` 
                        : `Now divide by ${a} to find x.`, 
                    latex: `x = \\frac{${c+b}}{${a}} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 3) { // x/a + b = c
            const a = MathUtils.randomInt(2, 8);
            const b = MathUtils.randomInt(1, 10);
            const realX = x * a; 
            const c = x + b; 
            latex = `\\frac{x}{${a}} + ${b} = ${c}`;
            answer = realX.toString();
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Vi b√∂rjar med att isolera x-termen. Subtrahera ${b} fr√•n b√•da sidor.` 
                        : `Start by isolating the x-term. Subtract ${b} from both sides.`, 
                    latex: `\\frac{x}{${a}} = ${c} - ${b} \\\\ \\frac{x}{${a}} = ${c-b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `F√∂r att bli av med divisionen multiplicerar vi med ${a}.` 
                        : `To remove the division, multiply by ${a}.`, 
                    latex: `x = ${c-b} \\cdot ${a} \\\\ x = ${realX}` 
                }
            ];
        }
        else { // x/a - b = c
            const a = MathUtils.randomInt(2, 8);
            const b = MathUtils.randomInt(1, 10);
            const realX = x * a;
            const c = x - b; 
            latex = `\\frac{x}{${a}} - ${b} = ${c}`;
            answer = realX.toString();
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Isolera x-termen genom att addera ${b} p√• b√•da sidor.` 
                        : `Isolate the x-term by adding ${b} to both sides.`, 
                    latex: `\\frac{x}{${a}} = ${c} + ${b} \\\\ \\frac{x}{${a}} = ${c+b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera med ${a} f√∂r att f√• x ensamt.` 
                        : `Multiply by ${a} to get x alone.`, 
                    latex: `x = ${c+b} \\cdot ${a} \\\\ x = ${realX}` 
                }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 3: Parentheses ---
    private level3_Parentheses(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const a = MathUtils.randomInt(2, 6);
        let latex = '', answer = '', clues = [];

        if (type === 1) { // a(x + b) = c
            const x = MathUtils.randomInt(1, 10);
            const b = MathUtils.randomInt(1, 9);
            const c = a * (x + b);
            answer = x.toString();
            latex = `${a}(x + ${b}) = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Vi b√∂rjar med att multiplicera in ${a} i parentesen (distribuera).` 
                        : `Start by multiplying ${a} into the parentheses (distribute).`, 
                    latex: `${a} \\cdot x + ${a} \\cdot ${b} = ${c} \\\\ ${a}x + ${a*b} = ${c}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Nu l√∂ser vi ekvationen som vanligt. Subtrahera konstanten och dela sedan." 
                        : "Now solve as usual. Subtract the constant then divide.", 
                    latex: `${a}x = ${c - a*b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 2) { // a(x - b) = c
            const x = MathUtils.randomInt(5, 15);
            const b = MathUtils.randomInt(1, x - 1);
            const c = a * (x - b);
            answer = x.toString();
            latex = `${a}(x - ${b}) = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera in ${a} i parentesen. Kom ih√•g minustecknet.` 
                        : `Multiply ${a} into the parentheses. Remember the minus sign.`, 
                    latex: `${a} \\cdot x - ${a} \\cdot ${b} = ${c} \\\\ ${a}x - ${a*b} = ${c}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${a*b} till b√•da sidor och dela sedan.` 
                        : `Add ${a*b} to both sides and then divide.`, 
                    latex: `${a}x = ${c + a*b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 3) { // a(bx - c) = d (Inner coefficient)
            const bVar = MathUtils.randomInt(2, 5);
            const x = MathUtils.randomInt(2, 8);
            const cVar = MathUtils.randomInt(1, bVar * x - 1);
            const d = a * (bVar * x - cVar);
            answer = x.toString();
            latex = `${a}(${bVar}x - ${cVar}) = ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera in ${a} med b√•da termerna i parentesen.` 
                        : `Multiply ${a} with both terms in the parentheses.`, 
                    latex: `${a} \\cdot ${bVar}x - ${a} \\cdot ${cVar} = ${d} \\\\ ${a*bVar}x - ${a*cVar} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Addera konstanten och dela med koefficienten." 
                        : "Add the constant and divide by the coefficient.", 
                    latex: `${a*bVar}x = ${d + a*cVar} \\\\ x = ${x}` 
                }
            ];
        }
        else { // a(bx + c) = d
            const bVar = MathUtils.randomInt(2, 5);
            const x = MathUtils.randomInt(1, 8);
            const cVar = MathUtils.randomInt(1, 9);
            const d = a * (bVar * x + cVar);
            answer = x.toString();
            latex = `${a}(${bVar}x + ${cVar}) = ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera in ${a} i parentesen.` 
                        : `Distribute ${a} into the parentheses.`, 
                    latex: `${a} \\cdot ${bVar}x + ${a} \\cdot ${cVar} = ${d} \\\\ ${a*bVar}x + ${a*cVar} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Subtrahera konstanten och dela med koefficienten." 
                        : "Subtract the constant and divide by the coefficient.", 
                    latex: `${a*bVar}x = ${d - a*cVar} \\\\ x = ${x}` 
                }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 4: Variables on Both Sides ---
    private level4_BothSides(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const x = MathUtils.randomInt(1, 10);
        let a = MathUtils.randomInt(3, 9);
        let c = MathUtils.randomInt(2, a - 1); 
        if (a === c) a++;

        let latex = '', answer = x.toString(), clues = [];

        if (type === 1) { // ax + b = cx + d
            const b = MathUtils.randomInt(1, 15);
            const d = a*x + b - c*x;
            if (d <= 0) return this.level4_BothSides(lang); 

            latex = `${a}x + ${b} = ${c}x + ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Vi vill samla alla x p√• ena sidan. Vi subtraherar ${c}x fr√•n b√•da sidor.` 
                        : `Gather all x on one side. Subtract ${c}x from both sides.`, 
                    latex: `${a}x - ${c}x + ${b} = ${d} \\\\ ${a-c}x + ${b} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Nu √§r det en vanlig ekvation. Flytta √∂ver konstanten och l√∂s ut x." 
                        : "Now solve as usual. Move the constant and solve for x.", 
                    latex: `${a-c}x = ${d} - ${b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 2) { // ax - b = cx + d
            const b = MathUtils.randomInt(1, 15);
            const d = a*x - b - c*x;
            if (d <= 0) return this.level4_BothSides(lang);

            latex = `${a}x - ${b} = ${c}x + ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Subtrahera ${c}x fr√•n b√•da sidor f√∂r att samla x.` 
                        : `Subtract ${c}x from both sides to gather x.`, 
                    latex: `${a}x - ${c}x - ${b} = ${d} \\\\ ${a-c}x - ${b} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${b} till b√•da sidor och l√∂s ut x.` 
                        : `Add ${b} to both sides and solve for x.`, 
                    latex: `${a-c}x = ${d} + ${b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 3) { // ax + b = cx - d
            const temp = a; a = c; c = temp; 
            const b = MathUtils.randomInt(1, 15);
            const d = c*x - a*x - b; 
            if (d <= 0) return this.level4_BothSides(lang); 

            latex = `${a}x + ${b} = ${c}x - ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Subtrahera ${a}x fr√•n b√•da sidor (f√∂r att h√•lla x positivt).` 
                        : `Subtract ${a}x from both sides (to keep x positive).`, 
                    latex: `${b} = ${c}x - ${a}x - ${d} \\\\ ${b} = ${c-a}x - ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${d} till b√•da sidor.` 
                        : `Add ${d} to both sides.`, 
                    latex: `${b} + ${d} = ${c-a}x \\\\ x = ${x}` 
                }
            ];
        }
        else { // ax - b = cx - d
            if (a < c) { const t = a; a = c; c = t; }
            const b = MathUtils.randomInt(5, 20);
            const d = b - (a*x - c*x);
            if (d <= 0) return this.level4_BothSides(lang);

            latex = `${a}x - ${b} = ${c}x - ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Subtrahera ${c}x fr√•n b√•da sidor.` 
                        : `Subtract ${c}x from both sides.`, 
                    latex: `${a}x - ${c}x - ${b} = -${d} \\\\ ${a-c}x - ${b} = -${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${b} till b√•da sidor.` 
                        : `Add ${b} to both sides.`, 
                    latex: `${a-c}x = -${d} + ${b} \\\\ x = ${x}` 
                }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    private level7_Mixed(lang: string): any {
        return this.generate(MathUtils.randomInt(1, 4), lang);
    }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearEquationProblemGen {
    public generate(level: number, lang: string = 'sv'): any {
        const isWriteMode = level === 5;
        const type = MathUtils.randomChoice(['A', 'B', 'C', 'D']);
        
        let data: any;

        switch (type) {
            case 'A': data = this.scenarioA_RatePlusFixed(lang); break; // ax + b = c
            case 'B': data = this.scenarioB_RateMinusFixed(lang); break; // ax - b = c
            case 'C': data = this.scenarioC_CompareSum(lang); break; // x + (x+a) = c
            case 'D': data = this.scenarioD_CompareDiff(lang); break; // x + (x-b) = c
            default: data = this.scenarioA_RatePlusFixed(lang);
        }

        const taskText = isWriteMode 
            ? (lang === 'sv' ? "Skriv en ekvation som beskriver problemet (du beh√∂ver inte l√∂sa den)." : "Write an equation that describes the problem (you don't need to solve it).")
            : (lang === 'sv' ? "L√∂s problemet. Vilket tal √§r x?" : "Solve the problem. What number is x?");

        const answer = isWriteMode ? data.equation : data.solution;
        const steps = isWriteMode ? data.stepsWrite : data.stepsSolve;

        return {
            renderData: {
                latex: "",
                description: `${data.text} ${taskText}`,
                answerType: isWriteMode ? 'text' : 'text'
            },
            token: Buffer.from(answer.toString()).toString('base64'),
            serverData: { answer: answer, solutionSteps: steps }
        };
    }

    // --- Type A: ax + b = c (Rate + Fixed Cost) ---
    private scenarioA_RatePlusFixed(lang: string) {
        // Expanded Scenarios
        const scenarios = [
            {   // Shopping
                item: lang === 'sv' ? "√§pplen" : "apples",
                unit: lang === 'sv' ? "st" : "each",
                fixed: lang === 'sv' ? "kasse" : "bag",
                textSv: (a:number, b:number, c:number) => `Du k√∂per x √§pplen f√∂r ${a} kr/st och en kasse f√∂r ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x apples for ${a} kr each and a bag for ${b} kr. In total you pay ${c} kr.`
            },
            {   // Taxi
                item: "km",
                unit: "km",
                fixed: lang === 'sv' ? "startavgift" : "start fee",
                textSv: (a:number, b:number, c:number) => `En taxi kostar ${a} kr/km plus ${b} kr i startavgift. Resan kostade totalt ${c} kr. Du √•kte x km.`,
                textEn: (a:number, b:number, c:number) => `A taxi costs ${a} kr/km plus a ${b} kr start fee. The trip cost ${c} kr in total. You traveled x km.`
            },
            {   // Rental
                item: "min",
                unit: "min",
                fixed: lang === 'sv' ? "uppl√•sningsavgift" : "unlock fee",
                textSv: (a:number, b:number, c:number) => `Att hyra en elscooter kostar ${b} kr i startavgift och ${a} kr per minut. Du betalade ${c} kr f√∂r x minuter.`,
                textEn: (a:number, b:number, c:number) => `Renting an e-scooter costs ${b} kr to unlock and ${a} kr per minute. You paid ${c} kr for x minutes.`
            },
            {   // Subscription
                item: lang === 'sv' ? "m√•nader" : "months",
                unit: lang === 'sv' ? "m√•n" : "mo",
                fixed: lang === 'sv' ? "startavgift" : "signup fee",
                textSv: (a:number, b:number, c:number) => `Ett gymkort kostar ${a} kr i m√•naden och ${b} kr i startavgift. Du har betalat totalt ${c} kr. Hur m√•nga m√•nader (x) har du tr√§nat?`,
                textEn: (a:number, b:number, c:number) => `A gym membership costs ${a} kr/month plus a ${b} kr signup fee. You have paid ${c} kr in total. For how many months (x)?`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(3, 15);
        const a = MathUtils.randomInt(5, 30);
        const b = MathUtils.randomChoice([10, 20, 49, 50, 99]);
        const c = a * x + b;

        const equation = `${a}x+${b}=${c}`;
        const text = lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c);

        const stepsWrite = [
            { text: lang === 'sv' ? `1. Den r√∂rliga kostnaden √§r priset per ${s.unit} g√•nger antalet (x).` : `1. The variable cost is the price per ${s.unit} times the quantity (x).`, latex: `${a} \\cdot x = ${a}x` },
            { text: lang === 'sv' ? `2. L√§gg till den fasta avgiften (${s.fixed}).` : `2. Add the fixed fee (${s.fixed}).`, latex: `+ ${b}` },
            { text: lang === 'sv' ? `3. Summan ska bli totalbeloppet ${c}.` : `3. The sum must equal the total ${c}.`, latex: `${a}x + ${b} = ${c}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? `Ta bort den fasta avgiften (${b}) fr√•n totalen.` : `Subtract the fixed fee (${b}) from the total.`, latex: `${a}x = ${c} - ${b} = ${c-b}` },
            { text: lang === 'sv' ? `Dela det som √§r kvar med priset per ${s.unit} (${a}).` : `Divide the remainder by the price per ${s.unit} (${a}).`, latex: `x = \\frac{${c-b}}{${a}} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type B: ax - b = c (Discount) ---
    private scenarioB_RateMinusFixed(lang: string) {
        const scenarios = [
            {
                textSv: (a:number, b:number, c:number) => `Du k√∂per x datorspel f√∂r ${a} kr/st. Du har en rabattkupong p√• ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x video games for ${a} kr each. You have a discount coupon for ${b} kr. You pay ${c} kr total.`
            },
            {
                textSv: (a:number, b:number, c:number) => `En grupp p√• x personer g√•r p√• bio. Biljetten kostar ${a} kr. Gruppen f√•r en grupprabatt p√• ${b} kr. De betalar totalt ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `A group of x people go to the cinema. Tickets are ${a} kr. The group gets a ${b} kr discount. They pay ${c} kr total.`
            },
            {
                textSv: (a:number, b:number, c:number) => `Du k√∂per x tr√∂jor som kostar ${a} kr styck. Eftersom du √§r medlem f√•r du ${b} kr rabatt p√• hela k√∂pet. Du betalar ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x shirts costing ${a} kr each. As a member, you get ${b} kr off the total purchase. You pay ${c} kr.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(2, 8);
        const a = MathUtils.randomInt(50, 150);
        const b = MathUtils.randomChoice([20, 50, 100]);
        const c = a * x - b;

        const equation = `${a}x-${b}=${c}`;
        const text = lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c);

        const stepsWrite = [
            { text: lang === 'sv' ? "1. B√∂rja med vad det hade kostat utan rabatt (pris g√•nger antal)." : "1. Start with the cost without discount (price times quantity).", latex: `${a}x` },
            { text: lang === 'sv' ? `2. Rabatten minskar priset, s√• vi subtraherar ${b}.` : `2. The discount reduces the price, so subtract ${b}.`, latex: `- ${b}` },
            { text: lang === 'sv' ? "3. S√§tt uttrycket lika med det du faktiskt betalade." : "3. Set the expression equal to what you actually paid.", latex: `${a}x - ${b} = ${c}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "L√§gg tillbaka rabatten p√• totalen f√∂r att se vad ordinarie pris var." : "Add the discount back to the total to find the original price.", latex: `${a}x = ${c} + ${b} = ${c+b}` },
            { text: lang === 'sv' ? `Dela med styckpriset (${a}) f√∂r att se hur m√•nga du k√∂pte.` : `Divide by the unit price (${a}) to see how many you bought.`, latex: `x = \\frac{${c+b}}{${a}} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type C: Compare Sum (x + (x+a) = c) ---
    private scenarioC_CompareSum(lang: string) {
        const scenarios = [
            {   // Money
                textSv: (a:number, c:number) => `Kim har x kr. Alex har ${a} kr mer √§n Kim. Tillsammans har de ${c} kr.`,
                textEn: (a:number, c:number) => `Kim has x kr. Alex has ${a} kr more than Kim. Together they have ${c} kr.`
            },
            {   // Age
                textSv: (a:number, c:number) => `Leo √§r x √•r. Hans syster √§r ${a} √•r √§ldre. Tillsammans √§r de ${c} √•r.`,
                textEn: (a:number, c:number) => `Leo is x years old. His sister is ${a} years older. Together they are ${c} years old.`
            },
            {   // Election/Votes
                textSv: (a:number, c:number) => `I ett val fick Parti A x r√∂ster. Parti B fick ${a} fler r√∂ster. Totalt fick de ${c} r√∂ster.`,
                textEn: (a:number, c:number) => `In an election, Party A got x votes. Party B got ${a} more votes. In total they got ${c} votes.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(5, 25);
        const a = MathUtils.randomInt(2, 10);
        const total = x + (x + a);
        
        const equation = `2x+${a}=${total}`;
        const text = lang === 'sv' ? s.textSv(a, total) : s.textEn(a, total);

        const stepsWrite = [
            { text: lang === 'sv' ? "Person/Sak 1:" : "Person/Item 1:", latex: "x" },
            { text: lang === 'sv' ? `Person/Sak 2 (som har ${a} mer):` : `Person/Item 2 (has ${a} more):`, latex: `x + ${a}` },
            { text: lang === 'sv' ? "Addera dem f√∂r att f√• summan:" : "Add them to get the sum:", latex: `x + (x + ${a}) = ${total} \\implies 2x + ${a} = ${total}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "Ta bort det extra (skillnaden) fr√•n totalen." : "Remove the extra difference from the total.", latex: `2x = ${total} - ${a} = ${total-a}` },
            { text: lang === 'sv' ? "Dela resten lika p√• tv√•." : "Divide the remainder equally by two.", latex: `x = \\frac{${total-a}}{2} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type D: Compare Diff (x + (x-b) = c) ---
    private scenarioD_CompareDiff(lang: string) {
        const scenarios = [
            {   // Class size
                textSv: (b:number, c:number) => `I klass 7A g√•r det x elever. I 7B g√•r det ${b} f√§rre elever. Totalt g√•r det ${c} elever i √•rskursen.`,
                textEn: (b:number, c:number) => `Class 7A has x students. 7B has ${b} fewer students. There are ${c} students in total.`
            },
            {   // Lengths
                textSv: (b:number, c:number) => `En planka delas i tv√• bitar. Den f√∂rsta √§r x cm. Den andra √§r ${b} cm kortare. Hela plankan var ${c} cm.`,
                textEn: (b:number, c:number) => `A plank is cut in two. The first piece is x cm. The second is ${b} cm shorter. The whole plank was ${c} cm.`
            },
            {   // Weight
                textSv: (b:number, c:number) => `Hundvalpen v√§ger x kg. Katten v√§ger ${b} kg mindre. Tillsammans v√§ger de ${c} kg.`,
                textEn: (b:number, c:number) => `The puppy weighs x kg. The cat weighs ${b} kg less. Together they weigh ${c} kg.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(10, 50);
        const b = MathUtils.randomInt(2, 9);
        const total = x + (x - b);

        const equation = `2x-${b}=${total}`;
        const text = lang === 'sv' ? s.textSv(b, total) : s.textEn(b, total);

        const stepsWrite = [
            { text: lang === 'sv' ? "Del 1:" : "Part 1:", latex: "x" },
            { text: lang === 'sv' ? `Del 2 (som √§r ${b} mindre):` : `Part 2 (which is ${b} less):`, latex: `x - ${b}` },
            { text: lang === 'sv' ? "Summan av delarna:" : "Sum of the parts:", latex: `x + (x - ${b}) = ${total} \\implies 2x - ${b} = ${total}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "L√§gg till skillnaden till totalen f√∂r att 'j√§mna ut' det." : "Add the difference to the total to 'even it out'.", latex: `2x = ${total} + ${b} = ${total+b}` },
            { text: lang === 'sv' ? "Dela resultatet p√• tv√•." : "Divide the result by two.", latex: `x = \\frac{${total+b}}{2} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearGraphGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_FindM(lang);
            case 2: return this.level2_FindK_Pos(lang);
            case 3: return this.level3_FindK_Neg(lang);
            case 4: return this.level4_FindFunction(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_FindM(lang);
        }
    }

    private level1_FindM(lang: string): any {
        const m = MathUtils.randomInt(-4, 4);
        return {
            renderData: { graph: { range: 10, lines: [{ slope: 1, intercept: m, color: '#2563eb' }] }, description: "Best√§m m-v√§rdet.", answerType: 'text' },
            token: Buffer.from(m.toString()).toString('base64'),
            serverData: { answer: m, solutionSteps: [
                { text: lang === 'sv' ? "m √§r v√§rdet d√§r linjen sk√§r y-axeln." : "m is where the line crosses the y-axis." },
                { latex: `(0, ${m})` }
            ]}
        };
    }

    private level2_FindK_Pos(lang: string): any {
        const k = MathUtils.randomInt(1, 3);
        return {
            renderData: { graph: { range: 10, lines: [{ slope: k, intercept: 0, color: '#16a34a' }] }, description: "Best√§m k-v√§rdet (lutningen).", answerType: 'text' },
            token: Buffer.from(k.toString()).toString('base64'),
            serverData: { answer: k, solutionSteps: [
                { text: lang === 'sv' ? "G√• 1 steg √•t h√∂ger. Hur m√•nga steg g√•r du upp?" : "Go 1 step right. How many steps up?", latex: `\\Delta x = 1, \\Delta y = ${k}` }
            ]}
        };
    }

    private level3_FindK_Neg(lang: string): any {
        const k = MathUtils.randomInt(-3, -1);
        return {
            renderData: { graph: { range: 10, lines: [{ slope: k, intercept: 5, color: '#dc2626' }] }, description: "Best√§m k-v√§rdet.", answerType: 'text' },
            token: Buffer.from(k.toString()).toString('base64'),
            serverData: { answer: k, solutionSteps: [
                { text: lang === 'sv' ? "Linjen lutar ned√•t, s√• k √§r negativt." : "Line slopes down, so k is negative.", latex: `k = ${k}` }
            ]}
        };
    }

    private level4_FindFunction(lang: string): any {
        const k = MathUtils.randomChoice([1, 2, -1, -2]);
        const m = MathUtils.randomInt(-3, 3);
        const sign = m >= 0 ? '+' : '';
        const eq = `y=${k}x${sign}${m}`;
        
        return {
            renderData: { graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#7c3aed' }] }, description: "Skriv formeln (y=kx+m).", answerType: 'text' },
            token: Buffer.from(eq).toString('base64'),
            serverData: { answer: eq, solutionSteps: [
                { text: lang === 'sv' ? "1. Hitta m (y-sk√§rning)." : "1. Find m (intercept).", latex: `m=${m}` },
                { text: lang === 'sv' ? "2. Hitta k (lutning)." : "2. Find k (slope).", latex: `k=${k}` }
            ]}
        };
    }

    private level5_Mixed(lang: string): any {
        return this.generate(MathUtils.randomInt(1, 4), lang);
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class NegativeNumbersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSubSimple(lang);
            case 2: return this.level2_AddSubHard(lang);
            case 3: return this.level3_Multiplication(lang);
            case 4: return this.level4_Division(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_AddSubSimple(lang);
        }
    }

    private p(n: number): string {
        return n < 0 ? `(${n})` : `${n}`;
    }

    // Level 1: Simple (-5 + 3, 2 - 8)
    private level1_AddSubSimple(lang: string): any {
        // Range logic from legacy: 10 range, min -10
        const start = MathUtils.randomInt(-10, 10);
        const change = MathUtils.randomInt(1, 10);
        const op = Math.random() > 0.5 ? '+' : '-';
        const ans = op === '+' ? start + change : start - change;

        return {
            renderData: { 
                latex: `${start} ${op} ${change}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "T√§nk p√• en termometer." : "Think of a thermometer." },
                { 
                    text: op === '+' 
                        ? (lang === 'sv' ? `Starta p√• ${start} och g√• ${change} steg UPP√ÖT.` : `Start at ${start} and go ${change} steps UP.`) 
                        : (lang === 'sv' ? `Starta p√• ${start} och g√• ${change} steg NED√ÖT.` : `Start at ${start} and go ${change} steps DOWN.`) 
                }
            ]
        };
    }

    // Level 2: Double signs (5 - (-3))
    private level2_AddSubHard(lang: string): any {
        const a = MathUtils.randomInt(-10, 10);
        const b = MathUtils.randomInt(-10, -1); // Negative second number ensures double sign
        const op = Math.random() > 0.5 ? '+' : '-';
        const ans = op === '+' ? a + b : a - b;

        let ruleText = "";
        let ruleLatex = "";

        // Pedagogical Logic
        if (op === '+') {
            // Adding a negative: 5 + (-3) -> 5 - 3
            ruleText = lang === 'sv' ? "Plus och minus bredvid varandra blir MINUS." : "Plus and minus next to each other become MINUS.";
            ruleLatex = `${a} - ${Math.abs(b)}`;
        } else {
            // Subtracting a negative: 5 - (-3) -> 5 + 3
            ruleText = lang === 'sv' ? "Tv√• minus bredvid varandra blir PLUS." : "Two minuses next to each other become PLUS.";
            ruleLatex = `${a} + ${Math.abs(b)}`;
        }

        return {
            renderData: { 
                latex: `${a} ${op} (${b})`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: ruleText, latex: ruleLatex },
                { text: lang === 'sv' ? "R√§kna nu ut det nya uttrycket." : "Now calculate the new expression." }
            ]
        };
    }

    // Level 3: Multiplication (-5 * -5)
    private level3_Multiplication(lang: string): any {
        // Ensure non-zero to emphasize sign rules
        let a = 0, b = 0;
        while(a===0) a = MathUtils.randomInt(-10, 10);
        while(b===0) b = MathUtils.randomInt(-10, 10);
        
        const ans = a * b;
        const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);

        return {
            renderData: { 
                latex: `${this.p(a)} \\cdot ${this.p(b)}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { 
                    text: sameSign 
                    ? (lang === 'sv' ? "Lika tecken ger PLUS (+)." : "Same signs give PLUS (+).") 
                    : (lang === 'sv' ? "Olika tecken ger MINUS (-)." : "Different signs give MINUS (-).") 
                },
                {
                    text: lang === 'sv' ? `Multiplicera siffrorna: ${Math.abs(a)} * ${Math.abs(b)}` : `Multiply the numbers: ${Math.abs(a)} * ${Math.abs(b)}`,
                    latex: `\\mathbf{${ans}}`
                }
            ]
        };
    }

    // Level 4: Division
    private level4_Division(lang: string): any {
        let b = 0;
        while(b === 0) b = MathUtils.randomInt(-10, 10);
        
        const maxRes = Math.floor(100 / Math.abs(b));
        let res = 0;
        while(res === 0) res = MathUtils.randomInt(-maxRes, maxRes);
        
        const a = res * b;
        const ans = res;
        
        const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);

        return {
            renderData: { 
                latex: `\\frac{${a}}{${b}}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { 
                    text: sameSign 
                    ? (lang === 'sv' ? "Lika tecken ger PLUS (+)." : "Same signs give PLUS (+).") 
                    : (lang === 'sv' ? "Olika tecken ger MINUS (-)." : "Different signs give MINUS (-).") 
                },
                {
                    text: lang === 'sv' ? `Dividera siffrorna: ${Math.abs(a)} / ${Math.abs(b)}` : `Divide the numbers: ${Math.abs(a)} / ${Math.abs(b)}`
                }
            ]
        };
    }

    private level5_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        return this.generate(lvl, lang);
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\PercentGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PercentGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ConceptsAndConversions(lang);
            case 2: return this.level2_Benchmarks(lang);
            case 3: return this.level3_MultiplesOfTen(lang);
            case 4: return this.level4_GeneralCalculation(lang);
            case 5: return this.level5_FindWhole(lang);
            case 6: return this.level6_RealWorldChange(lang);
            default: return this.level1_ConceptsAndConversions(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Level 1: Concepts & Conversions (Visuals + Fraction/Decimal/Percent drill)
    private level1_ConceptsAndConversions(lang: string): any {
        // Mode 0: Visual Grid (Legacy)
        // Mode 1: Fraction -> Percent
        // Mode 2: Decimal -> Percent
        // Mode 3: Percent -> Fraction
        // Mode 4: Fraction -> Decimal
        const mode = MathUtils.randomChoice([0, 1, 2, 3, 4]);

        // BENCHMARK DATA
        // n: numerator, d: denominator, p: percent, dec: decimal string
        const benchmarks = [
            { n: 1, d: 2, p: 50, dec: "0.5" },
            { n: 1, d: 4, p: 25, dec: "0.25" },
            { n: 2, d: 4, p: 50, dec: "0.5" }, // Simplified to 1/2 usually, but good for drilling
            { n: 3, d: 4, p: 75, dec: "0.75" },
            { n: 1, d: 5, p: 20, dec: "0.2" },
            { n: 2, d: 5, p: 40, dec: "0.4" },
            { n: 3, d: 5, p: 60, dec: "0.6" },
            { n: 4, d: 5, p: 80, dec: "0.8" },
            { n: 1, d: 10, p: 10, dec: "0.1" },
            { n: 2, d: 10, p: 20, dec: "0.2" },
            { n: 3, d: 10, p: 30, dec: "0.3" },
            { n: 4, d: 10, p: 40, dec: "0.4" },
            { n: 5, d: 10, p: 50, dec: "0.5" },
            { n: 6, d: 10, p: 60, dec: "0.6" },
            { n: 7, d: 10, p: 70, dec: "0.7" },
            { n: 8, d: 10, p: 80, dec: "0.8" },
            { n: 9, d: 10, p: 90, dec: "0.9" },
            { n: 1, d: 100, p: 1, dec: "0.01" },
            { n: 10, d: 100, p: 10, dec: "0.1" }, // 10/100
            { n: 50, d: 100, p: 50, dec: "0.5" }  // 50/100
        ];

        // Special handling for 1/3 (approximate)
        const third = { n: 1, d: 3, p: 33.3, dec: "0.33" }; 

        if (mode === 0) {
            // Visual Grid (Keep existing logic but streamlined)
            const colored = MathUtils.randomChoice([1, 5, 10, 20, 25, 50, 75, 99]);
            return {
                renderData: {
                    description: lang === 'sv' ? "Hur m√•nga procent av rutan √§r f√§rgad?" : "What percent of the grid is colored?",
                    answerType: 'numeric',
                    suffix: '%',
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(colored.toString()),
                clues: [{ text: lang === 'sv' ? "R√§kna rutorna (av 100)." : "Count the squares (out of 100)." }]
            };
        }

        const data = MathUtils.randomChoice(benchmarks); // Pick a benchmark
        // We exclude 1/3 from some exact conversions unless we handle the rounding explicitly
        // For simplicity in L1, let's stick to the exact ones for now or handle 1/3 separately if picked.

        if (mode === 1) { // Fraction -> Percent
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv br√•ket ${data.n}/${data.d} som procent.` 
                        : `Write the fraction ${data.n}/${data.d} as a percent.`,
                    answerType: 'numeric',
                    suffix: '%'
                },
                token: this.toBase64(data.p.toString()),
                clues: [
                    { text: lang === 'sv' ? "Procent betyder hundradelar." : "Percent means hundredths." },
                    { text: lang === 'sv' ? `F√∂rl√§ng br√•ket s√• n√§mnaren blir 100.` : `Extend the fraction so the denominator is 100.`, latex: `\\frac{${data.n} \\cdot k}{${data.d} \\cdot k} = \\frac{${data.p}}{100}` }
                ]
            };
        }

        if (mode === 2) { // Decimal -> Percent
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv decimaltalet ${data.dec} som procent.` 
                        : `Write the decimal ${data.dec} as a percent.`,
                    answerType: 'numeric',
                    suffix: '%'
                },
                token: this.toBase64(data.p.toString()),
                clues: [
                    { text: lang === 'sv' ? "Flytta kommatecknet tv√• steg √•t h√∂ger." : "Move the decimal point two steps to the right.", latex: `${data.dec} \\cdot 100 = ${data.p}` }
                ]
            };
        }

        if (mode === 3) { // Percent -> Fraction
            // Use multiple choice for fractions to avoid input parsing hell (e.g. "1/4" vs "2/8")
            const correct = `${data.n}/${data.d}`;
            const wrong1 = `${data.d}/${data.n}`;
            const wrong2 = `${data.n}/${data.d * 2}`;
            
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Vad √§r ${data.p}% i br√•kform?` 
                        : `What is ${data.p}% as a fraction?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, wrong1, wrong2])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? `${data.p}% betyder ${data.p} av 100.` : `${data.p}% means ${data.p} out of 100.`, latex: `\\frac{${data.p}}{100}` },
                    { text: lang === 'sv' ? "F√∂renkla br√•ket." : "Simplify the fraction." }
                ]
            };
        }

        if (mode === 4) { // Fraction -> Decimal
             return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv br√•ket ${data.n}/${data.d} som decimaltal.` 
                        : `Write the fraction ${data.n}/${data.d} as a decimal.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(data.dec),
                clues: [
                    { text: lang === 'sv' ? "Dela t√§ljaren med n√§mnaren." : "Divide numerator by denominator.", latex: `${data.n} / ${data.d} = ${data.dec}` }
                ]
            };
        }
    }

    // Level 2: Benchmarks (Mental Math)
    private level2_Benchmarks(lang: string): any {
        const pct = MathUtils.randomChoice([10, 25, 50, 100]);
        const base = MathUtils.randomInt(2, 40) * (pct === 25 ? 4 : 10); 
        
        const ans = (base * pct) / 100;
        
        let clueText = "";
        let clueLatex = "";

        if (pct === 50) {
            clueText = lang === 'sv' ? "50% √§r exakt h√§lften. F√∂r att hitta h√§lften, dela med 2." : "50% is exactly half. To find half, divide by 2.";
            clueLatex = `\\frac{${base}}{2}`;
        }
        else if (pct === 25) {
            clueText = lang === 'sv' ? "25% √§r en fj√§rdedel. F√∂r att hitta en fj√§rdedel, dela med 4." : "25% is a quarter. To find a quarter, divide by 4.";
            clueLatex = `\\frac{${base}}{4}`;
        }
        else if (pct === 10) {
            clueText = lang === 'sv' ? "10% √§r en tiondel. F√∂r att hitta en tiondel, flytta kommatecknet ett steg √•t v√§nster." : "10% is a tenth. To find a tenth, move the decimal one step left.";
            clueLatex = `${base} \\to ${base/10}`;
        }
        else {
            clueText = lang === 'sv' ? "100% √§r hela talet. Inget √§ndras." : "100% is the whole number. Nothing changes.";
            clueLatex = `${base}`;
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna ${pct}% av ${base}.` : `Calculate ${pct}% of ${base}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [{ text: clueText, latex: clueLatex }]
        };
    }

    // Level 3: Building Blocks (Multiples of 10)
    private level3_MultiplesOfTen(lang: string): any {
        const pct = MathUtils.randomChoice([20, 30, 40, 60, 70, 80, 90]);
        const base = MathUtils.randomInt(2, 20) * 10;
        
        const oneTenth = base / 10;
        const ans = (base * pct) / 100;

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna ${pct}% av ${base}.` : `Calculate ${pct}% of ${base}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "B√∂rja med att r√§kna ut vad 10% √§r (en tiondel)." : "Start by figuring out what 10% is (one tenth).", 
                    latex: `10\\% \\text{ av } ${base} = ${oneTenth}` 
                },
                { 
                    text: lang === 'sv' ? `Nu har du 10%. Du vill ha ${pct}%. Multiplicera din tiondel med ${pct/10}.` : `Now you have 10%. You want ${pct}%. Multiply your tenth by ${pct/10}.`, 
                    latex: `${oneTenth} \\cdot ${pct/10} = ${ans}` 
                }
            ]
        };
    }

    // Level 4: General Calculation (Decimal Method)
    private level4_GeneralCalculation(lang: string): any {
        const pct = MathUtils.randomInt(1, 19) * 5; 
        const base = MathUtils.randomInt(2, 20) * 4; 
        
        const ans = (base * pct) / 100;
        const fixedAns = Math.round(ans * 100) / 100;

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna ${pct}% av ${base}.` : `Calculate ${pct}% of ${base}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(fixedAns.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r att r√§kna med procent kan du g√∂ra om det till decimalform. Dela procenten med 100." : "To calculate with percent, convert it to decimal. Divide the percent by 100.", 
                    latex: `${pct}\\% = ${pct/100}` 
                },
                { 
                    text: lang === 'sv' ? "Multiplicera decimaltalet med det hela talet." : "Multiply the decimal by the whole number.", 
                    latex: `${pct/100} \\cdot ${base} = ${fixedAns}` 
                }
            ]
        };
    }

    // Level 5: Find the Whole
    private level5_FindWhole(lang: string): any {
        const pct = MathUtils.randomChoice([10, 20, 25, 50]);
        const part = MathUtils.randomInt(2, 20);
        const whole = (part * 100) / pct;

        return {
            renderData: {
                description: lang === 'sv' 
                    ? `${pct}% av ett tal √§r ${part}. Vilket √§r talet?` 
                    : `${pct}% of a number is ${part}. What is the number?`,
                answerType: 'numeric'
            },
            token: this.toBase64(whole.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `Vi vet att ${pct}% √§r v√§rt ${part}. F√∂rst, ta reda p√• vad 1% √§r v√§rt genom att dela.` : `We know that ${pct}% is worth ${part}. First, find out what 1% is worth by dividing.`,
                    latex: `1\\% = \\frac{${part}}{${pct}} = ${part/pct}` 
                },
                { 
                    text: lang === 'sv' ? "Det hela talet √§r alltid 100%. Multiplicera ditt v√§rde f√∂r 1% med 100." : "The whole number is always 100%. Multiply your value for 1% by 100.", 
                    latex: `${part/pct} \\cdot 100 = ${whole}` 
                }
            ]
        };
    }

    // Level 6: Real World Change (Whole Numbers)
    private level6_RealWorldChange(lang: string): any {
        const scenarios = [
            { id: 'salary', inc: true, sv: (b,p) => `Din l√∂n √§r ${b} kr. Den h√∂js med ${p}%. Vad blir din nya l√∂n?`, en: (b,p) => `Your salary is ${b} kr. It raises by ${p}%. What is your new salary?` },
            { id: 'sale', inc: false, sv: (b,p) => `En jacka kostar ${b} kr. Det √§r ${p}% rea. Vad kostar jackan nu?`, en: (b,p) => `A jacket costs ${b} kr. It is ${p}% off. What is the price now?` },
            { id: 'tax', inc: false, sv: (b,p) => `Du vinner ${b} kr. Skatten √§r ${p}%. Hur mycket f√•r du beh√•lla?`, en: (b,p) => `You win ${b} kr. Tax is ${p}%. How much do you keep?` },
            { id: 'pop', inc: true, sv: (b,p) => `En by har ${b} inv√•nare. Befolkningen √∂kar med ${p}%. Hur m√•nga bor d√§r nu?`, en: (b,p) => `A village has ${b} people. Population grows by ${p}%. How many live there now?` },
            { id: 'battery', inc: false, sv: (b,p) => `Ett batteri har ${b} mAh. Det tappar ${p}% kapacitet. Vad √§r kvar?`, en: (b,p) => `A battery has ${b} mAh. It loses ${p}% capacity. What is left?` },
            { id: 'speed', inc: true, sv: (b,p) => `En bil k√∂r ${b} km/h. Farten √∂kar med ${p}%. Vad √§r nya hastigheten?`, en: (b,p) => `A car goes ${b} km/h. Speed increases by ${p}%. What is the new speed?` },
            { id: 'rent', inc: true, sv: (b,p) => `Hyran √§r ${b} kr. Den h√∂js med ${p}%. Vad blir nya hyran?`, en: (b,p) => `Rent is ${b} kr. It goes up by ${p}%. What is the new rent?` },
            { id: 'ticket', inc: true, sv: (b,p) => `En biljett kostar ${b} kr. En avgift p√• ${p}% tillkommer. Totalt pris?`, en: (b,p) => `A ticket costs ${b} kr. A fee of ${p}% is added. Total price?` },
            { id: 'storage', inc: true, sv: (b,p) => `En h√•rddisk rymmer ${b} GB. Du uppgraderar med ${p}%. Ny storlek?`, en: (b,p) => `A drive holds ${b} GB. You upgrade by ${p}%. New size?` },
            { id: 'weight', inc: false, sv: (b,p) => `En s√§ck v√§ger ${b} kg. Den torkar och tappar ${p}% vikt. Ny vikt?`, en: (b,p) => `A sack weighs ${b} kg. It dries and loses ${p}% weight. New weight?` }
        ];

        const s = MathUtils.randomChoice(scenarios);
        
        let pct = MathUtils.randomInt(1, 50); 
        if (Math.random() > 0.8) pct = MathUtils.randomInt(50, 99); 

        const possibleBases = [];
        const minBase = s.id === 'salary' ? 20000 : (s.id === 'rent' ? 5000 : 50);
        const maxBase = s.id === 'salary' ? 40000 : (s.id === 'rent' ? 15000 : 500);
        const step = s.id === 'salary' || s.id === 'rent' ? 100 : 10;

        let base = 100;
        for(let i=0; i<20; i++) {
            let candidate = MathUtils.randomInt(minBase/step, maxBase/step) * step;
            if ((candidate * pct) % 100 === 0) {
                base = candidate;
                break;
            }
        }
        if ((base * pct) % 100 !== 0) base = MathUtils.randomInt(1, 10) * 100;

        const change = (base * pct) / 100;
        const final = s.inc ? base + change : base - change;

        return {
            renderData: {
                description: lang === 'sv' ? s.sv(base, pct) : s.en(base, pct),
                answerType: 'numeric'
            },
            token: this.toBase64(final.toString()),
            clues: [
                {
                    text: lang === 'sv' ? `F√∂rst m√•ste vi r√§kna ut hur mycket ${pct}% √§r i kronor/antal. Multiplicera:` : `First we calculate how much ${pct}% is in value. Multiply:`,
                    latex: `${pct}\\% \\cdot ${base} = ${change}`
                },
                {
                    text: lang === 'sv' 
                        ? (s.inc ? "Eftersom det √§r en √∂kning, plussar vi p√• √§ndringen." : "Eftersom det √§r en minskning, drar vi av √§ndringen.") 
                        : (s.inc ? "Since it's an increase, add the change." : "Since it's a decrease, subtract the change."),
                    latex: s.inc ? `${base} + ${change} = ${final}` : `${base} - ${change} = ${final}`
                }
            ]
        };
    }
}

// FILE END: src\core\generators\PercentGen.ts

// =======================================================
// FILE START: src\core\generators\ProbabilityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ProbabilityGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_StandardRandomness(lang);
            case 3: return this.level3_PercentConversion(lang);
            case 4: return this.level4_Complementary(lang);
            case 5: return this.level5_CompoundIndependent(lang);
            case 6: return this.level6_Combinatorics(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private simplifyFraction(n: number, d: number): string {
        const gcd = (a: number, b: number): number => b ? gcd(b, a % b) : a;
        const divisor = gcd(n, d);
        return `${n/divisor}/${d/divisor}`;
    }

    // Level 1: Visual Probability (Marbles & Spinners)
    private level1_Visuals(lang: string): any {
        const type = MathUtils.randomChoice(['marbles', 'spinner']);
        
        if (type === 'marbles') {
            const red = MathUtils.randomInt(1, 5);
            const blue = MathUtils.randomInt(1, 5);
            const green = MathUtils.randomInt(1, 5);
            const total = red + blue + green;
            
            const target = MathUtils.randomChoice(['red', 'blue', 'green']);
            const targetVal = target === 'red' ? red : (target === 'blue' ? blue : green);
            const targetName = lang === 'sv' ? (target === 'red' ? 'r√∂d' : (target === 'blue' ? 'bl√•' : 'gr√∂n')) : target;

            const desc = lang === 'sv' 
                ? `Vad √§r sannolikheten att dra en ${targetName} kula? (Svara i br√•kform)`
                : `What is the probability of picking a ${targetName} marble? (Answer as fraction)`;

            const ans = this.simplifyFraction(targetVal, total);

            return {
                renderData: {
                    description: desc,
                    answerType: 'text',
                    geometry: { 
                        type: 'probability_marbles', 
                        items: { red, blue, green } 
                    }
                },
                token: this.toBase64(ans),
                clues: [
                    { 
                        text: lang === 'sv' ? `Antal ${targetName}a kulor: ${targetVal}` : `Number of ${targetName} marbles: ${targetVal}`,
                        latex: `\\frac{\\text{Delen}}{\\text{Det hela}}`
                    },
                    { 
                        text: lang === 'sv' ? `Totalt antal kulor: ${total}` : `Total marbles: ${total}`,
                        latex: `${red} + ${blue} + ${green} = ${total}`
                    }
                ]
            };
        } else {
            // Spinner
            const sections = MathUtils.randomInt(3, 6);
            const desc = lang === 'sv' 
                ? `Vad √§r sannolikheten att pilen stannar p√• bl√•tt? (Svara i br√•kform)`
                : `What is the probability the arrow lands on blue? (Answer as fraction)`;
            
            return {
                renderData: {
                    description: desc,
                    answerType: 'text',
                    geometry: { type: 'probability_spinner', sections: sections, target: 1 }
                },
                token: this.toBase64(`1/${sections}`),
                clues: [
                    { text: lang === 'sv' ? "Hur m√•nga bl√•a f√§lt finns det?" : "How many blue sections are there?" },
                    { text: lang === 'sv' ? "Hur m√•nga f√§lt finns det totalt?" : "How many sections total?" }
                ]
            };
        }
    }

    // Level 2: Dice & Decks
    private level2_StandardRandomness(lang: string): any {
        const scenario = MathUtils.randomChoice(['die', 'card']);

        if (scenario === 'die') {
            const mode = MathUtils.randomChoice(['gt', 'lt', 'even', 'odd', 'exact']);
            let favorable = 0;
            let labelSv = "", labelEn = "";

            if (mode === 'gt') {
                const n = MathUtils.randomInt(1, 4);
                favorable = 6 - n;
                labelSv = `st√∂rre √§n ${n}`; labelEn = `greater than ${n}`;
            } else if (mode === 'lt') {
                const n = MathUtils.randomInt(3, 6);
                favorable = n - 1;
                labelSv = `mindre √§n ${n}`; labelEn = `less than ${n}`;
            } else if (mode === 'even') {
                favorable = 3; labelSv = "j√§mnt tal"; labelEn = "an even number";
            } else if (mode === 'odd') {
                favorable = 3; labelSv = "udda tal"; labelEn = "an odd number";
            } else {
                favorable = 1; 
                const n = MathUtils.randomInt(1, 6);
                labelSv = `en ${n}:a`; labelEn = `a ${n}`;
            }

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Du kastar en t√§rning. Vad √§r sannolikheten att f√• ${labelSv}? (Svara i br√•kform)`
                        : `You roll a die. What is the probability of getting ${labelEn}? (Answer as fraction)`,
                    answerType: 'text',
                    geometry: { type: 'scale_single', shape: 'cube', label: '1-6' } 
                },
                token: this.toBase64(this.simplifyFraction(favorable, 6)),
                clues: [{ text: "Gynsamma utfall / M√∂jliga utfall", latex: `\\frac{${favorable}}{6}` }]
            };
        } 
        else {
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? "Du drar ett kort ur en lek (52 kort). Vad √§r sannolikheten att det √§r Hj√§rter? (Svara i br√•kform)"
                        : "You pick a card from a deck (52 cards). What is the probability it is Hearts? (Answer as fraction)",
                    answerType: 'text'
                },
                token: this.toBase64("1/4"),
                clues: [
                    { text: lang === 'sv' ? "Det finns 4 f√§rger: Hj√§rter, Spader, Ruter, Kl√∂ver." : "There are 4 suits: Hearts, Spades, Diamonds, Clubs." },
                    { text: lang === 'sv' ? "Varje f√§rg √§r lika sannolik." : "Each suit is equally likely." }
                ]
            };
        }
    }

    // Level 3: Probability as Percent (Expanded Scenarios)
    private level3_PercentConversion(lang: string): any {
        // Scenarios where percentage makes sense
        const scenarios = [
            { 
                sv: (t, f) => `Du kastar pil ${t} g√•nger och tr√§ffar tavlan ${f} g√•nger. Vad √§r din tr√§ffs√§kerhet i procent?`,
                en: (t, f) => `You throw a dart ${t} times and hit the board ${f} times. What is your accuracy in percent?`, 
                context: 'darts' 
            },
            { 
                sv: (t, f) => `En klass har ${t} elever. ${f} elever har glas√∂gon. Hur stor andel har glas√∂gon?`,
                en: (t, f) => `A class has ${t} students. ${f} students wear glasses. What percent wear glasses?`, 
                context: 'class' 
            },
            { 
                sv: (t, f) => `Du drar en lott ur en l√•da med ${t} lotter. ${f} st √§r vinstlotter. Vad √§r vinstchansen?`,
                en: (t, f) => `You pick a ticket from a box of ${t}. ${f} are winning tickets. What is the chance to win?`, 
                context: 'lottery' 
            },
            // NEW SCENARIOS ---
            {
                sv: (t, f) => `Det har regnat ${f} av de senaste ${t} dagarna. Hur stor andel √§r det?`,
                en: (t, f) => `It rained on ${f} of the last ${t} days. What percentage is that?`,
                context: 'weather'
            },
            {
                sv: (t, f) => `I en l√•da med ${t} gl√∂dlampor √§r ${f} trasiga. Hur m√•nga procent √§r trasiga?`,
                en: (t, f) => `In a box of ${t} light bulbs, ${f} are broken. What percent are broken?`,
                context: 'quality'
            },
            {
                sv: (t, f) => `En fotbollsspelare skjuter ${t} skott och g√∂r m√•l ${f} g√•nger. Vad √§r m√•lchansen?`,
                en: (t, f) => `A soccer player takes ${t} shots and scores ${f} goals. What is the goal percentage?`,
                context: 'sports'
            },
            {
                sv: (t, f) => `Du passerar ${t} trafikljus. ${f} visade gr√∂nt. Hur stor andel var gr√∂na?`,
                en: (t, f) => `You pass ${t} traffic lights. ${f} were green. What percentage were green?`,
                context: 'traffic'
            },
            {
                sv: (t, f) => `I en unders√∂kning med ${t} personer svarade ${f} "Ja". Hur m√•nga procent sa Ja?`,
                en: (t, f) => `In a survey of ${t} people, ${f} said "Yes". What percent said Yes?`,
                context: 'survey'
            },
            {
                sv: (t, f) => `Du planterade ${t} fr√∂n. ${f} av dem v√§xte upp. Vad √§r grobarheten?`,
                en: (t, f) => `You planted ${t} seeds. ${f} of them sprouted. What is the germination rate?`,
                context: 'seeds'
            }
        ];

        // Ensure numbers result in clean percentages (10, 20, 25, 50 as bases)
        const total = MathUtils.randomChoice([10, 20, 25, 50]);
        const favorable = MathUtils.randomInt(1, total - 1);
        const percent = (favorable / total) * 100;
        
        const s = MathUtils.randomChoice(scenarios);
        const descText = lang === 'sv' ? s.sv(total, favorable) : s.en(total, favorable);
        const instruction = lang === 'sv' ? "(Svara i procent)" : "(Answer in percent)";

        return {
            renderData: {
                description: `${descText} ${instruction}`,
                answerType: 'numeric',
                suffix: '%'
            },
            token: this.toBase64(percent.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "B√∂rja med att st√§lla upp det som ett br√•k (delen genom det hela)." : "Start by writing it as a fraction (part over whole).", 
                    latex: `\\frac{${favorable}}{${total}}` 
                },
                { 
                    text: lang === 'sv' ? "F√∂r att f√• procent, multiplicera br√•ket med 100." : "To get percent, multiply the fraction by 100.", 
                    latex: `\\frac{${favorable}}{${total}} \\cdot 100 = ${percent}` 
                }
            ]
        };
    }

    // Level 4: Complementary Events (P(Not))
    private level4_Complementary(lang: string): any {
        const type = MathUtils.randomInt(1, 2);
        
        if (type === 1) { // Percent
            const rainChance = MathUtils.randomInt(1, 9) * 10;
            const desc = lang === 'sv'
                ? `Sannolikheten f√∂r regn √§r ${rainChance}%. Vad √§r sannolikheten att det INTE regnar?`
                : `The probability of rain is ${rainChance}%. What is the probability it does NOT rain?`;
                
            return {
                renderData: {
                    description: desc,
                    answerType: 'numeric',
                    suffix: '%'
                },
                token: this.toBase64((100 - rainChance).toString()),
                clues: [
                    { text: lang === 'sv' ? "Hela sannolikheten (regn + inte regn) m√•ste bli 100%." : "The total probability (rain + not rain) must be 100%." },
                    { text: lang === 'sv' ? "Ta bort regnchansen fr√•n 100%." : "Subtract rain chance from 100%.", latex: `100\\% - ${rainChance}\\%` }
                ]
            };
        } else { // Fraction
            const total = MathUtils.randomInt(5, 20);
            const red = MathUtils.randomInt(1, total - 2);
            
            const desc = lang === 'sv'
                ? `I en p√•se finns ${total} kulor. ${red} √§r r√∂da. Vad √§r sannolikheten att dra en kula som INTE √§r r√∂d? (Svara i br√•kform)`
                : `A bag has ${total} marbles. ${red} are red. What is the probability of picking a marble that is NOT red? (Answer as fraction)`;

            return {
                renderData: {
                    description: desc,
                    answerType: 'text'
                },
                token: this.toBase64(this.simplifyFraction(total - red, total)),
                clues: [
                    { text: lang === 'sv' ? "Om vi inte vill ha r√∂da, vilka kulor r√§knas d√•? Jo, alla andra." : "If we don't want red, which marbles count? All the others." },
                    { text: lang === 'sv' ? "Subtrahera de r√∂da fr√•n totalen." : "Subtract the red ones from the total.", latex: `${total} - ${red} = ${total - red}` },
                    { latex: `\\frac{${total - red}}{${total}}` }
                ]
            };
        }
    }

    // Level 5: Compound Independent Events (Multiplying)
    private level5_CompoundIndependent(lang: string): any {
        const s = MathUtils.randomChoice(['2coins', 'coin_die']);
        
        if (s === '2coins') {
            const desc = lang === 'sv' 
                ? "Du singlar slant med tv√• mynt. Vad √§r sannolikheten att B√ÖDA visar Krona? (Svara i br√•kform)"
                : "You flip two coins. What is the probability BOTH show Heads? (Answer as fraction)";
            
            return {
                renderData: { description: desc, answerType: 'text' },
                token: this.toBase64("1/4"),
                clues: [
                    { text: lang === 'sv' ? "H√§ndelserna sker oberoende av varandra. Sannolikheten f√∂r ETT mynt √§r 1/2." : "Events happen independently. Probability for ONE coin is 1/2." },
                    { text: lang === 'sv' ? "N√§r det st√•r 'och'/'b√•da', ska vi multiplicera sannolikheterna." : "When it says 'and'/'both', multiply the probabilities.", latex: "\\frac{1}{2} \\cdot \\frac{1}{2}" }
                ]
            };
        } else {
            const desc = lang === 'sv'
                ? "Du singlar slant och sl√•r en t√§rning. Vad √§r sannolikheten f√∂r Krona OCH en 6:a? (Svara i br√•kform)"
                : "You flip a coin and roll a die. What is the probability of Heads AND a 6? (Answer as fraction)";
            
            return {
                renderData: { description: desc, answerType: 'text' },
                token: this.toBase64("1/12"),
                clues: [
                    { latex: `P(\\text{Krona}) = \\frac{1}{2}, \\quad P(6) = \\frac{1}{6}` },
                    { latex: `\\frac{1}{2} \\cdot \\frac{1}{6}` }
                ]
            };
        }
    }

    // Level 6: Combinations (Simple Tree Diagrams logic)
    private level6_Combinatorics(lang: string): any {
        const A = MathUtils.randomInt(2, 5);
        const B = MathUtils.randomInt(2, 6);
        const total = A * B;

        const scenarios = [
            { 
                sv: `Du har ${A} tr√∂jor och ${B} byxor. Hur m√•nga olika outfits kan du v√§lja?`, 
                en: `You have ${A} shirts and ${B} pants. How many different outfits can you choose?`
            },
            {
                sv: `En meny har ${A} f√∂rr√§tter och ${B} varmr√§tter. Hur m√•nga olika m√•ltider finns det?`,
                en: `A menu has ${A} starters and ${B} main courses. How many different meals are there?`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        
        return {
            renderData: {
                description: lang === 'sv' ? s.sv : s.en,
                answerType: 'numeric'
            },
            token: this.toBase64(total.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r varje val du g√∂r i f√∂rsta gruppen, har du alla val i andra gruppen." : "For every choice in the first group, you have all choices in the second.",
                },
                { 
                    text: lang === 'sv' ? "Vi anv√§nder multiplikationsprincipen: Ta antal i grupp 1 g√•nger antal i grupp 2." : "Use multiplication principle: Count 1 times Count 2.",
                    latex: `${A} \\cdot ${B}` 
                }
            ]
        };
    }
}

// FILE END: src\core\generators\ProbabilityGen.ts

// =======================================================
// FILE START: src\core\generators\PythagorasGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PythagorasGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SquaresRoots(lang);
            case 2: return this.level2_Hypotenuse(lang);
            case 3: return this.level3_Leg(lang);
            case 4: return this.level4_Applications(lang);
            case 5: return this.level5_Coordinates(lang);
            case 6: return this.level6_Converse(lang);
            default: return this.level1_SquaresRoots(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Helper: Get a scaled triple
    private getTriple(): { a: number, b: number, c: number, k: number } {
        const primitives = [
            // Classics
            [3, 4, 5], 
            [5, 12, 13], 
            [8, 15, 17], 
            [7, 24, 25], 
            [20, 21, 29],
            [12, 35, 37],
            [9, 40, 41],
            [28, 45, 53],
            [11, 60, 61],
            [16, 63, 65],
            [33, 56, 65],
            [48, 55, 73],
            [13, 84, 85],
            [36, 77, 85],
            [39, 80, 89]
        ];
        const base = MathUtils.randomChoice(primitives);
        
        // Random multiplier to ensure variety
        const k = MathUtils.randomChoice([1, 1, 1, 2, 2, 3, 4, 5, 10]); 
        
        return { a: base[0]*k, b: base[1]*k, c: base[2]*k, k: k };
    }

    // Level 1: Squares & Roots (Mental Math)
    private level1_SquaresRoots(lang: string): any {
        const isRoot = MathUtils.randomInt(0, 1) === 1;
        const base = MathUtils.randomInt(1, 15);
        const square = base * base;

        if (isRoot) {
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna roten ur:" : "Calculate the square root:",
                    latex: `\\sqrt{${square}}`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(base.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Vilket tal g√•nger sig sj√§lvt blir det h√§r?" : "Which number times itself equals this?", 
                        latex: `? \\cdot ? = ${square}` 
                    }
                ]
            };
        } else {
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna kvadraten:" : "Calculate the square:",
                    latex: `${base}^2`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(square.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Multiplicera talet med sig sj√§lvt." : "Multiply the number by itself.", 
                        latex: `${base} \\cdot ${base}` 
                    }
                ]
            };
        }
    }

    // Level 2: Find Hypotenuse (Simple Algebra Logic)
    private level2_Hypotenuse(lang: string): any {
        const t = this.getTriple();
        // Randomize which leg is base vs height for visual variety
        const swap = MathUtils.randomInt(0, 1) === 1;
        const width = swap ? t.b : t.a;
        const height = swap ? t.a : t.b;

        const desc = lang === 'sv' 
            ? "Triangeln √§r r√§tvinklig. Ber√§kna den l√§ngsta sidan (hypotenusan x)." 
            : "The triangle is right-angled. Calculate the longest side (hypotenuse x).";

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: { 
                    type: 'triangle', subtype: 'right', 
                    width: width, height: height, 
                    // UPDATED: Explicitly map 'b' and 'h' so GeometryComponents renders them.
                    // Added 'hyp' for future compatibility, though current component may not render it.
                    labels: { b: width, h: height, hyp: 'x', c: 'x' } 
                }
            },
            token: this.toBase64(t.c.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Anv√§nd Pythagoras sats: a¬≤ + b¬≤ = c¬≤." : "Use Pythagoras theorem: a¬≤ + b¬≤ = c¬≤.", 
                    latex: `${width}^2 + ${height}^2 = x^2` 
                },
                { 
                    text: lang === 'sv' ? "R√§kna ut summan och ta sedan roten ur." : "Calculate the sum, then take the square root.",
                    latex: `x = \\sqrt{${t.c*t.c}}` 
                }
            ]
        };
    }

    // Level 3: Find Leg (Subtraction Logic)
    private level3_Leg(lang: string): any {
        const t = this.getTriple();
        
        // Decide if we are solving for the base (b) or the height (h)
        const solveForBase = MathUtils.randomInt(0, 1) === 1;

        let labels: any = {};
        let missingVar = 'x';
        
        if (solveForBase) {
            // We know Height (h) and Hypotenuse (c). We need Base (b).
            // NOTE: GeometryComponents uses 'h' and 'b' keys.
            labels = { h: t.a, b: 'x', hyp: t.c, c: t.c };
            missingVar = 'b';
        } else {
            // We know Base (b) and Hypotenuse (c). We need Height (h).
            labels = { b: t.b, h: 'x', hyp: t.c, c: t.c };
            missingVar = 'a';
        }

        // UPDATED: Added hypotenuse length to description because GeometryComponents 
        // does not currently render the label on the hypotenuse.
        const desc = lang === 'sv' 
            ? `Hypotenusan √§r ${t.c}. Ber√§kna den ok√§nda sidan (x).` 
            : `The hypotenuse is ${t.c}. Calculate the unknown side (x).`;

        const knownLeg = solveForBase ? t.a : t.b;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: { 
                    type: 'triangle', subtype: 'right', 
                    width: solveForBase ? t.b : t.b, // keep visual width proportional-ish
                    height: solveForBase ? t.a : t.a,
                    labels: labels 
                }
            },
            token: this.toBase64((solveForBase ? t.b : t.a).toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Du vet den l√§ngsta sidan. D√• ska du subtrahera (ta minus)." : "You know the longest side. So you must subtract.", 
                    latex: `c^2 - ${missingVar === 'a' ? 'b' : 'a'}^2 = ${missingVar}^2` 
                },
                { 
                    text: lang === 'sv' ? "Ta stora kvadraten minus lilla kvadraten." : "Take the big square minus the small square.",
                    latex: `${t.c}^2 - ${knownLeg}^2 = x^2` 
                }
            ]
        };
    }

    // Level 4: Applications (7 Scenarios)
    private level4_Applications(lang: string): any {
        const s = MathUtils.randomChoice([
            { id: 'ladder', type: 'find_c', txtSv: "En stege lutar mot en v√§gg. Stegen n√•r {a} m upp och st√•r {b} m fr√•n v√§ggen. Hur l√•ng √§r stegen?", txtEn: "A ladder leans against a wall. It reaches {a} m up and stands {b} m out. How long is the ladder?" },
            { id: 'map', type: 'find_c', txtSv: "Du g√•r {a} km norrut och sedan {b} km √∂sterut. Hur l√•ngt √§r du fr√•n starten (f√•gelv√§gen)?", txtEn: "You walk {a} km North and then {b} km East. How far are you from the start?" },
            { id: 'tv', type: 'find_c', txtSv: "En TV-sk√§rm √§r {a} cm bred och {b} cm h√∂g. Hur l√•ng √§r diagonalen?", txtEn: "A TV screen is {a} cm wide and {b} cm high. How long is the diagonal?" },
            { id: 'mast', type: 'find_c', txtSv: "En mast √§r {a} m h√∂g. En st√∂dvajer f√§sts i marken {b} m fr√•n masten. Hur l√•ng √§r vajern?", txtEn: "A mast is {a} m tall. A wire is attached to the ground {b} m away. How long is the wire?" },
            // Find Leg Scenarios
            { id: 'kite', type: 'find_a', txtSv: "Ett sn√∂re till en drake √§r {c} m l√•ngt. Draken sv√§var rakt ovanf√∂r en punkt {b} m bort. Hur h√∂gt √§r draken?", txtEn: "A kite string is {c} m long. The kite is above a spot {b} m away. How high is the kite?" },
            { id: 'ramp', type: 'find_a', txtSv: "En ramp √§r {c} m l√•ng. Den n√•r en h√∂jd p√• {b} m. Hur l√•ngt str√§cker den sig l√§ngs marken?", txtEn: "A ramp is {c} m long. It reaches a height of {b} m. How far does it stretch along the ground?" },
            { id: 'envelope', type: 'find_a', txtSv: "Diagonalen p√• ett kuvert √§r {c} cm. H√∂jden √§r {b} cm. Hur brett √§r kuvertet?", txtEn: "The diagonal of an envelope is {c} cm. The height is {b} cm. How wide is it?" }
        ]);

        const t = this.getTriple();
        const k = MathUtils.randomInt(1, 3);
        const primitive = MathUtils.randomChoice([[3,4,5], [5,12,13], [8,15,17]]);
        const a = primitive[0] * k; 
        const b = primitive[1] * k; 
        const c = primitive[2] * k;

        let desc = "";
        let ans = 0;
        let hintFormula = "";

        if (s.type === 'find_c') {
            desc = lang === 'sv' ? s.txtSv.replace('{a}', a).replace('{b}', b) : s.txtEn.replace('{a}', a).replace('{b}', b);
            ans = c;
            hintFormula = `\\sqrt{${a}^2 + ${b}^2}`;
        } else {
            desc = lang === 'sv' ? s.txtSv.replace('{c}', c).replace('{b}', b) : s.txtEn.replace('{c}', c).replace('{b}', b);
            ans = a;
            hintFormula = `\\sqrt{${c}^2 - ${b}^2}`;
        }

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: null 
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Rita en triangel och anv√§nd Pythagoras." : "Draw a triangle and use Pythagoras." },
                { latex: hintFormula }
            ]
        };
    }

    // Level 5: Coordinate Distance
    private level5_Coordinates(lang: string): any {
        const t = this.getTriple();
        const dx = t.a;
        const dy = t.b;
        const dist = t.c;

        const x1 = MathUtils.randomInt(0, 10);
        const y1 = MathUtils.randomInt(0, 10);
        const x2 = x1 + dx;
        const y2 = y1 + dy;

        const desc = lang === 'sv'
            ? `Ber√§kna avst√•ndet mellan punkterna (${x1}, ${y1}) och (${x2}, ${y2}).`
            : `Calculate the distance between points (${x1}, ${y1}) and (${x2}, ${y2}).`;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: null
            },
            token: this.toBase64(dist.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Skillnaden i x √§r basen. Skillnaden i y √§r h√∂jden." : "The difference in x is the base. The difference in y is the height.",
                    latex: `\\Delta x = ${dx}, \\quad \\Delta y = ${dy}`
                },
                { 
                    text: lang === 'sv' ? "Anv√§nd Pythagoras p√• skillnaderna." : "Use Pythagoras on the differences.",
                    latex: `\\sqrt{${dx}^2 + ${dy}^2}` 
                }
            ]
        };
    }

    // Level 6: Converse Theorem (Yes/No)
    private level6_Converse(lang: string): any {
        const isRight = MathUtils.randomInt(0, 1) === 1;
        let a=0, b=0, c=0;

        if (isRight) {
            const t = this.getTriple();
            a=t.a; b=t.b; c=t.c;
        } else {
            const base = MathUtils.randomChoice([[3,4,5], [5,12,13]]);
            const k = MathUtils.randomInt(1, 3);
            a = base[0]*k; 
            b = base[1]*k; 
            c = (base[2]*k) + 1; // Incorrect hypotenuse
        }

        const desc = lang === 'sv'
            ? `En triangel har sidorna ${a}, ${b} och ${c}. √Ñr den r√§tvinklig?`
            : `A triangle has sides ${a}, ${b}, and ${c}. Is it a right-angled triangle?`;

        const correct = lang === 'sv' ? (isRight ? "Ja" : "Nej") : (isRight ? "Yes" : "No");
        const wrong = lang === 'sv' ? (isRight ? "Nej" : "Ja") : (isRight ? "No" : "Yes");

        // UPDATED: Added explicit geometry: null to avoid crash if frontend tries to render undefined geometry.
        // Also ensuring shuffle logic is safe.
        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([correct, wrong]),
                geometry: null
            },
            token: this.toBase64(correct),
            clues: [
                { 
                    text: lang === 'sv' ? "Testa om ekvationen st√§mmer:" : "Test if the equation holds:", 
                    latex: `${a}^2 + ${b}^2 = ${c}^2 ?` 
                }
            ]
        };
    }
}

// FILE END: src\core\generators\PythagorasGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ScaleGen {
    // Standard shapes for legacy/lower levels
    private static readonly SHAPES = ['arrow', 'star', 'lightning', 'key', 'heart', 'cloud', 'moon', 'sun'];

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_CalcLengthSimple(lang);
            case 3: return this.level3_MixedScenarios(lang);
            case 4: return this.level4_DetermineScale(lang);
            case 5: return this.level5_NoPictures(lang);
            case 6: return this.level6_AreaScale(lang);
            case 7: return this.level7_Mixed(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    // Helper to safely format numbers (replaces MathUtils.formatNumber dependency)
    private formatNum(n: number): string {
        return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    }

    // Helper for Base64 (Node/Browser safe-ish)
    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Level 1: Basic Concepts (Understanding 1:X vs X:1)
    private level1_Concepts(lang: string): any {
        // Fallback for shuffle if MathUtils is missing it
        const shuffle = (arr: any[]) => arr.sort(() => Math.random() - 0.5);

        const isReduction = MathUtils.randomInt(0, 1) === 1;
        const ratio = MathUtils.randomChoice([2, 5, 10, 50, 100]);
        const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
        
        const desc = lang === 'sv' 
            ? `Vad betyder skalan ${scaleStr}?`
            : `What does the scale ${scaleStr} mean?`;
            
        let correct = "";
        let wrong = "";
        const same = lang === 'sv' ? "De √§r lika stora." : "They are the same size.";
        
        if (isReduction) {
            correct = lang === 'sv' ? `Verkligheten √§r ${ratio} ggr st√∂rre √§n bilden.` : `Reality is ${ratio}x larger than image.`;
            wrong = lang === 'sv' ? `Bilden √§r ${ratio} ggr st√∂rre √§n verkligheten.` : `Image is ${ratio}x larger than reality.`;
        } else {
            correct = lang === 'sv' ? `Bilden √§r ${ratio} ggr st√∂rre √§n verkligheten.` : `Image is ${ratio}x larger than reality.`;
            wrong = lang === 'sv' ? `Verkligheten √§r ${ratio} ggr st√∂rre √§n bilden.` : `Reality is ${ratio}x larger than image.`;
        }

        // Ensure options array is valid
        const options = shuffle([correct, wrong, same]);

        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                options: options,
                geometry: { 
                    type: 'scale_compare', 
                    leftLabel: lang === 'sv' ? 'Bild' : 'Image', 
                    rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                    leftValue: isReduction ? 1 : ratio,
                    rightValue: isReduction ? ratio : 1,
                    shape: 'arrow' // Safe shape
                }
            },
            token: this.toBase64(correct),
            clues: []
        };
    }

    // Level 2: Simple Calculation
    private level2_CalcLengthSimple(lang: string): any {
        const scale = MathUtils.randomChoice([2, 3, 4, 5, 10]);
        const imageSize = MathUtils.randomInt(2, 12);
        const realSize = imageSize * scale;

        const desc = lang === 'sv'
            ? `En bild √§r ritad i skala 1:${scale}. Bilden √§r ${imageSize} cm bred. Hur bred √§r den i verkligheten?`
            : `A picture is drawn in scale 1:${scale}. The picture is ${imageSize} cm wide. How wide is it in reality?`;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: { 
                    type: 'scale_compare', 
                    leftLabel: lang === 'sv' ? 'Bild' : 'Image', 
                    rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                    leftValue: 1,
                    rightValue: scale,
                    shape: MathUtils.randomChoice(ScaleGen.SHAPES)
                },
                suffix: 'cm'
            },
            token: this.toBase64(realSize.toString()),
            clues: [
                { text: lang === 'sv' ? "Multiplicera med skalan." : "Multiply by the scale.", latex: `${imageSize} \\\\cdot ${scale}` }
            ]
        };
    }

    // Level 3: Mixed Scenarios (Fixed formatting)
    private level3_MixedScenarios(lang: string): any {
        const scenarioType = MathUtils.randomChoice([0, 1, 2, 3]);

        let desc = "";
        let answer = 0;
        let suffix = "";
        let visualData: any = {};
        let clues: any[] = [];

        // Scenario 0: Map
        if (scenarioType === 0) {
            const scaleBase = MathUtils.randomChoice([10000, 20000, 50000]); 
            const mapCm = MathUtils.randomInt(2, 8); 
            const realCm = mapCm * scaleBase;
            const realKm = realCm / 100000; 
            
            const useMeters = realKm < 1;
            answer = useMeters ? realCm / 100 : realKm;
            suffix = useMeters ? 'm' : 'km';

            desc = lang === 'sv'
                ? `P√• en karta i skala 1:${this.formatNum(scaleBase)} √§r avst√•ndet mellan tv√• stugor ${mapCm} cm. Hur l√•ngt √§r det i verkligheten? Svara i ${suffix}.`
                : `On a map with scale 1:${this.formatNum(scaleBase)}, the distance between two cabins is ${mapCm} cm. How far is it in reality? Answer in ${suffix}.`;

            visualData = {
                type: 'scale_compare',
                leftLabel: lang === 'sv' ? 'Karta' : 'Map',
                rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                leftValue: 1,
                rightValue: scaleBase,
                shape: 'map' 
            };

            clues = [
                {
                    text: lang === 'sv' ? "R√§kna ut cm i verkligheten." : "Calc real cm.",
                    latex: `${mapCm} \\\\cdot ${this.formatNum(scaleBase)} = ${this.formatNum(realCm)} \\\\text{ cm}`
                },
                {
                    text: lang === 'sv' ? `Omvandla cm till ${suffix}.` : `Convert cm to ${suffix}.`,
                    latex: useMeters ? `${realCm} / 100 = ${answer}` : `${realCm} / 100000 = ${answer}`
                }
            ];
        }

        // Scenario 1: Blueprint
        else if (scenarioType === 1) {
            const scale = MathUtils.randomChoice([20, 40, 50, 100]);
            const realM = MathUtils.randomInt(30, 80) / 10; 
            const realCm = realM * 100;
            const drawingCm = realCm / scale;

            answer = drawingCm;
            suffix = 'cm';

            desc = lang === 'sv'
                ? `En v√§gg √§r ${realM} meter l√•ng i verkligheten. Hur l√•ng blir linjen p√• en ritning i skala 1:${scale}? Svara i cm.`
                : `A wall is ${realM} meters long in reality. How long is the line on a blueprint with scale 1:${scale}? Answer in cm.`;

            visualData = {
                type: 'scale_compare',
                leftLabel: lang === 'sv' ? 'Ritning' : 'Blueprint',
                rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                leftValue: 1,
                rightValue: scale,
                shape: 'house' 
            };

            clues = [
                {
                    text: lang === 'sv' ? "G√∂r om till cm." : "Convert to cm.",
                    latex: `${realM} \\\\text{ m} = ${realCm} \\\\text{ cm}`
                },
                {
                    text: lang === 'sv' ? "Dela med skalan." : "Divide by scale.",
                    latex: `${realCm} / ${scale} = ${answer}`
                }
            ];
        }

        // Scenario 2: Model
        else if (scenarioType === 2) {
            const scale = MathUtils.randomChoice([18, 24, 87]); 
            let realM = 4.5;
            if (scale === 18) realM = MathUtils.randomChoice([3.6, 4.5, 5.4]);
            if (scale === 24) realM = MathUtils.randomChoice([4.8, 7.2, 9.6]);
            if (scale === 87) realM = MathUtils.randomChoice([17.4, 26.1]);

            const realCm = Math.round(realM * 100);
            answer = realCm / scale; 
            suffix = 'cm';

            desc = lang === 'sv'
                ? `Ett t√•g √§r ${realM} meter l√•ngt. Hur l√•ng blir en modell i skala 1:${scale}? Svara i cm.`
                : `A train is ${realM} meters long. How long is the model in scale 1:${scale}? Answer in cm.`;

            visualData = {
                type: 'scale_compare',
                leftLabel: lang === 'sv' ? 'Modell' : 'Model',
                rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                leftValue: 1,
                rightValue: scale,
                shape: 'car'
            };

            clues = [
                {
                    text: lang === 'sv' ? "G√∂r om till cm." : "Convert to cm.",
                    latex: `${realM} \\\\text{ m} = ${realCm} \\\\text{ cm}`
                },
                {
                    text: lang === 'sv' ? "Dela med skalan." : "Divide by scale.",
                    latex: `${realCm} / ${scale} = ${answer}`
                }
            ];
        }

        // Scenario 3: Magnification
        else {
            const scale = MathUtils.randomChoice([10, 20, 50, 100]);
            const realMm = MathUtils.randomChoice([0.5, 1, 2, 4, 5]); 
            const imageMm = realMm * scale;
            answer = imageMm / 10; // cm
            suffix = 'cm';

            desc = lang === 'sv'
                ? `En insekt √§r ${realMm} mm l√•ng. Den fotograferas i skala ${scale}:1. Hur l√•ng blir insekten p√• bilden? Svara i cm.`
                : `An insect is ${realMm} mm long. It is photographed in scale ${scale}:1. How long is the insect in the picture? Answer in cm.`;

            visualData = {
                type: 'scale_compare',
                leftLabel: lang === 'sv' ? 'Bild' : 'Image',
                rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                leftValue: scale,
                rightValue: 1,
                shape: 'ladybug' 
            };

            clues = [
                {
                    text: lang === 'sv' ? "Skalan X:1 betyder f√∂rstoring." : "X:1 means magnification.",
                    latex: `${realMm} \\\\text{ mm} \\\\cdot ${scale} = ${imageMm} \\\\text{ mm}`
                },
                {
                    text: lang === 'sv' ? "Svara i cm." : "Answer in cm.",
                    latex: `${imageMm} / 10 = ${answer}`
                }
            ];
        }

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: visualData,
                suffix: suffix
            },
            token: this.toBase64(answer.toString()),
            clues: clues
        };
    }

    // Level 4: Determine Scale
    private level4_DetermineScale(lang: string): any {
        const scale = MathUtils.randomChoice([10, 20, 50, 100]);
        const drawCm = MathUtils.randomInt(2, 8);
        const realM = (drawCm * scale) / 100;

        const desc = lang === 'sv'
            ? `Ett rum √§r ${realM} m l√•ngt. P√• ritningen √§r det ${drawCm} cm. Vilken skala √§r ritningen? Svara som 1:X.`
            : `A room is ${realM} m long. On the drawing it is ${drawCm} cm. What is the scale? Answer as 1:X.`;

        return {
            renderData: {
                description: desc,
                answerType: 'text',
                placeholder: '1:...'
            },
            token: this.toBase64(`1:${scale}`),
            clues: [
                { text: lang === 'sv' ? "G√∂r om till samma enhet (cm)." : "Convert to same unit (cm).", latex: `${realM} \\\\text{ m} = ${realM*100} \\\\text{ cm}` },
                { text: lang === 'sv' ? "J√§mf√∂r bild och verklighet." : "Compare image and reality.", latex: `${drawCm} : ${realM*100}` },
                { text: lang === 'sv' ? "F√∂rkorta." : "Simplify.", latex: `1 : ${(realM*100)/drawCm}` }
            ]
        };
    }

    // Level 5: Word Problems
    private level5_NoPictures(lang: string): any {
        const data = this.level3_MixedScenarios(lang);
        data.renderData.geometry = null;
        return data;
    }

    // Level 6: Area Scale (Fixed Visuals)
    private level6_AreaScale(lang: string): any {
        const shape = MathUtils.randomChoice(['rectangle', 'triangle']);
        const L = MathUtils.randomInt(2, 5); 
        const A = L * L; 
        
        let width = 0, height = 0, baseArea = 0;
        let subtype: string | undefined = undefined;

        if (shape === 'rectangle') {
            width = MathUtils.randomInt(2, 6);
            height = MathUtils.randomInt(2, 6);
            baseArea = width * height;
        } else if (shape === 'triangle') {
            width = MathUtils.randomInt(2, 6); 
            height = MathUtils.randomInt(2, 6); 
            if ((width * height) % 2 !== 0) width += 1; 
            subtype = 'isosceles';
            baseArea = (width * height) / 2;
        }

        const bigArea = baseArea * A;
        const scaledWidth = width * L;
        const scaledHeight = height * L;

        const desc = lang === 'sv' 
            ? `L√§ngdskalan √§r 1:${L}. Lilla arean √§r ${baseArea} cm¬≤. Hur stor √§r den stora arean?`
            : `Length scale 1:${L}. Small area ${baseArea} cm¬≤. How big is the large area?`;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: { 
                    type: 'compare_shapes_area', 
                    shapeType: shape, 
                    // Left (Image)
                    left: { 
                        width: width, height: height, subtype: subtype,
                        label: lang === 'sv'?'Bild':'Image', area: baseArea,
                        labels: { b: width, h: height } 
                    }, 
                    // Right (Reality - Scaled)
                    right: { 
                        width: scaledWidth, height: scaledHeight, subtype: subtype,
                        label: lang === 'sv'?'Verklighet':'Reality', area: '?',
                        labels: { b: scaledWidth, h: scaledHeight } 
                    } 
                },
                suffix: 'cm¬≤'
            },
            token: this.toBase64(bigArea.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Area skalan = (L√§ngdskalan)¬≤" : "Area scale = (Length scale)¬≤", 
                    latex: `A_{skala} = ${L}^2 = ${A}` 
                },
                { 
                    text: lang === 'sv' ? `Arean blir ${A} g√•nger st√∂rre.` : `Area becomes ${A} times larger.`, 
                    latex: `${baseArea} \\\\cdot ${A} = ${bigArea}` 
                }
            ]
        };
    }

    // Level 7: Mixed Bag
    private level7_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(2, 6);
        return this.generate(subLevel, lang);
    }
}

// FILE END: src\core\generators\ScaleGen.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class SimilarityGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concept(lang);
            case 2: return this.level2_CalcSide(lang);
            case 3: return this.level3_TopTriangle(lang);
            case 4: return this.level4_Pythagoras(lang);
            default: return this.level1_Concept(lang);
        }
    }

    // Level 1: Concept (Similar or Not?)
    private level1_Concept(lang: string): any {
        const isSimilar = MathUtils.randomInt(0, 1) === 1;
        const type = MathUtils.randomChoice(['rect_sides', 'tri_sides', 'tri_angles']);
        
        let geom: any = { type: 'similarity_compare' };
        let desc = "";
        let steps = [];

        if (type === 'rect_sides') {
            geom.shapeType = 'rectangle';
            const w1 = MathUtils.randomInt(2, 5) * 10;
            const h1 = MathUtils.randomInt(2, 5) * 10;
            
            const k = isSimilar ? MathUtils.randomChoice([1.5, 2, 0.5]) : MathUtils.randomChoice([1.2, 1.8, 0.8]);
            const w2 = Math.round(w1 * k);
            const h2 = isSimilar ? Math.round(h1 * k) : Math.round(h1 * (k + 0.5)); 

            geom.left = { labels: { b: w1, h: h1 } };
            geom.right = { labels: { b: w2, h: h2 } };
            
            desc = lang === 'sv' ? "√Ñr rektanglarna likformiga?" : "Are the rectangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "F√∂r att de ska vara likformiga m√•ste f√∂rh√•llandet mellan sidorna vara samma. J√§mf√∂r baserna och h√∂jderna." : "For similarity, side ratios must be equal. Compare bases and heights.", 
                latex: `\\frac{${w2}}{${w1}} \\text{ vs } \\frac{${h2}}{${h1}}` 
            });
        } 
        else if (type === 'tri_angles') {
            geom.shapeType = 'triangle';
            const a1 = MathUtils.randomInt(40, 75);
            const a2 = MathUtils.randomInt(40, 75);
            
            const b1 = isSimilar ? a1 : a1 + MathUtils.randomChoice([-15, 15]);
            const b2 = isSimilar ? a2 : a2;

            // Pass angles for visual arcs
            geom.left = { angles: [a1, a2, null], labels: { a1: `${a1}¬∞`, a2: `${a2}¬∞` } };
            geom.right = { angles: [b1, b2, null], labels: { a1: `${b1}¬∞`, a2: `${b2}¬∞` } };

            desc = lang === 'sv' ? "√Ñr trianglarna likformiga?" : "Are the triangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "Likformiga trianglar m√•ste ha exakt samma vinklar. J√§mf√∂r vinklarna." : "Similar triangles must have exactly the same angles. Compare them.", 
                latex: "" 
            });
        }
        else { // tri_sides
            geom.shapeType = 'triangle';
            const s1 = MathUtils.randomInt(4, 9);
            const s2 = MathUtils.randomInt(4, 9);
            
            const k = isSimilar ? 2 : 1.5;
            const r1 = s1 * k;
            const r2 = isSimilar ? s2 * k : Math.floor(s2 * (k + 0.4));

            geom.left = { labels: { s1: s1, s2: s2 } };
            geom.right = { labels: { s1: r1, s2: r2 } };
            
            desc = lang === 'sv' ? "√Ñr trianglarna likformiga?" : "Are the triangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "Kolla om b√•da sidorna har v√§xt lika mycket (samma skalning)." : "Check if both sides scaled by the same factor.", 
                latex: `\\frac{${r1}}{${s1}} \\text{ vs } \\frac{${r2}}{${s2}}` 
            });
        }

        const correct = isSimilar ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");
        const wrong = isSimilar ? (lang === 'sv' ? "Nej" : "No") : (lang === 'sv' ? "Ja" : "Yes");

        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                choices: [correct, wrong],
                geometry: geom,
                latex: ""
            },
            token: Buffer.from(correct).toString('base64'),
            clues: steps
        };
    }

    // Level 2: Calc Side (Updated with more variety and division)
    private level2_CalcSide(lang: string): any {
        // Expanded scale factors: decimals and larger integers
        const k = MathUtils.randomChoice([1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]);
        
        const s1 = MathUtils.randomInt(3, 12);
        const s2 = MathUtils.randomInt(3, 12);
        
        const bigS1 = Math.round(s1 * k * 10) / 10;
        const bigS2 = Math.round(s2 * k * 10) / 10;
        
        // Randomly find small side (division) or big side (multiplication)
        const findBig = MathUtils.randomInt(0, 1) === 1;
        let ans = 0, clues = [];

        let lLabels: any = { s1, s2 };
        let rLabels: any = {};

        if (findBig) {
            // Finding a side on the larger triangle
            ans = bigS1;
            // Left (Small) has s1, s2. Right (Big) has x, bigS2.
            lLabels = { s1: s1, s2: s2 };
            rLabels = { s1: 'x', s2: bigS2 };
            
            clues.push({ 
                text: lang === 'sv' ? "1. Hitta skalan genom att j√§mf√∂ra de k√§nda sidorna." : "1. Find scale by comparing the known sides.", 
                latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` 
            });
            clues.push({ 
                text: lang === 'sv' ? "2. Den ok√§nda sidan √§r i den stora figuren. Multiplicera." : "2. The unknown side is in the large shape. Multiply.", 
                latex: `x = ${s1} \\cdot ${k} = \\mathbf{${ans}}` 
            });
        } else {
            // Finding a side on the smaller triangle
            ans = s1;
            // Left (Small) has x, s2. Right (Big) has bigS1, bigS2.
            lLabels = { s1: 'x', s2: s2 };
            rLabels = { s1: bigS1, s2: bigS2 };
            
            clues.push({ 
                text: lang === 'sv' ? "1. Hitta skalan genom att j√§mf√∂ra de k√§nda sidorna." : "1. Find scale by comparing the known sides.", 
                latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` 
            });
            clues.push({ 
                text: lang === 'sv' ? "2. Den ok√§nda sidan √§r i den lilla figuren. Dividera." : "2. The unknown side is in the small shape. Divide.", 
                latex: `x = \\frac{${bigS1}}{${k}} = \\mathbf{${ans}}` 
            });
        }
        
        return {
            renderData: { 
                geometry: { type: 'similarity_compare', shapeType: 'triangle', left: { labels: lLabels }, right: { labels: rLabels } }, 
                description: lang === 'sv' ? "Figurerna √§r likformiga. Ber√§kna x." : "Shapes are similar. Calculate x.", 
                answerType: 'text',
                latex: ""
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: clues
        };
    }

    // Level 3: Top Triangle
    private level3_TopTriangle(lang: string): any {
        const top = MathUtils.randomInt(4, 10);
        const add = MathUtils.randomInt(2, 6);
        const tot = top + add;
        
        const smallBase = MathUtils.randomInt(5, 12);
        const largeBase = (tot / top) * smallBase;
        
        // Ensure integer answer or simple decimal
        // Reroll if ugly
        if (!Number.isInteger(largeBase) && (largeBase * 10) % 5 !== 0) return this.level3_TopTriangle(lang);

        return {
            renderData: { 
                geometry: { type: 'transversal', labels: { left_top: top, left_tot: tot, base_top: smallBase, base_bot: 'x' } }, 
                description: lang === 'sv' ? "Ber√§kna basen x." : "Calculate base x.", 
                answerType: 'text',
                latex: ""
            },
            token: Buffer.from(largeBase.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Topptriangelsatsen: Liten/Stor = Liten/Stor" : "Top Triangle Theorem: Small side / Big side = Small base / Big base", latex: `\\frac{${top}}{${tot}} = \\frac{${smallBase}}{x}` },
                { text: lang === 'sv' ? "L√∂s ut x." : "Solve for x.", latex: `x = \\frac{${tot} \\cdot ${smallBase}}{${top}} = \\mathbf{${largeBase}}` }
            ]
        };
    }

    // Level 4: Pythagoras
    private level4_Pythagoras(lang: string): any {
        const [a, b, c] = MathUtils.randomChoice([[3,4,5], [5,12,13], [6,8,10], [8,15,17]]);
        const findHyp = MathUtils.randomInt(0, 1) === 1;
        const orient = MathUtils.randomChoice(['up', 'down', 'left', 'right']);
        
        let ans = 0;
        let labels: any = {};
        let clue = "";
        let desc = "";

        if (findHyp) {
            ans = c;
            labels = { base: a, height: b, hypotenuse: 'x' };
            clue = `x = \\sqrt{${a}^2 + ${b}^2} = \\mathbf{${c}}`;
            desc = lang === 'sv' ? "Ber√§kna hypotenusan (x)." : "Calculate hypotenuse (x).";
        } else {
            ans = a;
            labels = { base: 'x', height: b, hypotenuse: c };
            clue = `x = \\sqrt{${c}^2 - ${b}^2} = \\mathbf{${a}}`;
            desc = lang === 'sv' ? "Ber√§kna kateten (x)." : "Calculate leg (x).";
        }

        return {
            renderData: { 
                geometry: { type: 'triangle', subtype: 'right', width: a, height: b, labels, orientation: orient }, 
                description: desc,
                answerType: 'text',
                latex: ""
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Pythagoras sats:" : "Pythagoras theorem:", latex: "a^2 + b^2 = c^2" },
                { text: lang === 'sv' ? (findHyp ? "F√∂r hypotenusan, addera kvadraterna." : "F√∂r en katet, subtrahera.") : (findHyp ? "Add squares." : "Subtract squares."), latex: clue }
            ]
        };
    }
}

// FILE END: src\core\generators\SimilarityGen.ts

// =======================================================
// FILE START: src\core\generators\StatisticsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class StatisticsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ModeRange(lang);
            case 2: return this.level2_Mean(lang);
            case 3: return this.level3_Median(lang);
            case 4: return this.level4_ReverseMean(lang);
            case 5: return this.level5_FrequencyTable(lang);
            case 6: return this.level6_RealWorldMixed(lang);
            default: return this.level1_ModeRange(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Mode (Typv√§rde) & Range (Variationsbredd) ---
    private level1_ModeRange(lang: string): any {
        const scenarios = [
            { id: 'shoe', sv: "skostorlekar", en: "shoe sizes", vals: [36, 37, 38, 39, 40, 41, 42] },
            { id: 'goals', sv: "gjorda m√•l", en: "goals scored", vals: [0, 1, 2, 3, 4, 5] },
            { id: 'temp', sv: "temperaturer (¬∞C)", en: "temperatures (¬∞C)", vals: [-5, -2, 0, 1, 3, 5, 8] },
            { id: 'age', sv: "√•ldrar i en grupp", en: "ages in a group", vals: [10, 11, 12, 13, 14, 15] },
            { id: 'dice', sv: "t√§rningsslag", en: "dice rolls", vals: [1, 2, 3, 4, 5, 6] },
            { id: 'points', sv: "po√§ng p√• prov", en: "test points", vals: [5, 6, 7, 8, 9, 10] },
            { id: 'pets', sv: "husdjur per familj", en: "pets per family", vals: [0, 1, 2, 3] }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const len = MathUtils.randomInt(5, 9);
        const list: number[] = [];
        
        // Generate list with a clear Mode
        const modeVal = MathUtils.randomChoice(s.vals);
        for(let i=0; i<3; i++) list.push(modeVal); // Ensure mode exists
        for(let i=0; i<len-3; i++) list.push(MathUtils.randomChoice(s.vals));
        
        // Manual shuffle to avoid dependency
        const shuffled = list.sort(() => Math.random() - 0.5);
        const setStr = shuffled.join(', ');

        const type = MathUtils.randomInt(1, 2); // 1=Mode, 2=Range

        if (type === 1) { // Mode
            const desc = lang === 'sv' 
                ? `H√§r √§r en lista √∂ver ${s.sv}: ${setStr}. Vad √§r typv√§rdet?` 
                : `Here is a list of ${s.en}: ${setStr}. What is the mode?`;
            
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(modeVal.toString()),
                clues: [
                    { text: lang === 'sv' ? "Typv√§rdet √§r det tal som f√∂rekommer flest g√•nger." : "The mode is the number that appears most often." },
                    { text: lang === 'sv' ? `Talet ${modeVal} finns med flest g√•nger.` : `The number ${modeVal} appears most times.` }
                ]
            };
        } else { // Range
            const min = Math.min(...list);
            const max = Math.max(...list);
            const range = max - min;
            const desc = lang === 'sv'
                ? `H√§r √§r en lista √∂ver ${s.sv}: ${setStr}. Vad √§r variationsbredden?`
                : `Here is a list of ${s.en}: ${setStr}. What is the range?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(range.toString()),
                clues: [
                    { text: lang === 'sv' ? "Variationsbredd = St√∂rsta v√§rdet - Minsta v√§rdet." : "Range = Max value - Min value." },
                    { latex: `${max} - ${min} = ${range}` }
                ]
            };
        }
    }

    // --- LEVEL 2: Mean (Medelv√§rde) ---
    private level2_Mean(lang: string): any {
        const scenarios = [
            { sv: "sju kompisar", en: "seven friends", unit: "√•r", count: 7 },
            { sv: "fem dagar", en: "five days", unit: "¬∞C", count: 5 },
            { sv: "fyra p√•sar godis", en: "four bags of candy", unit: "g", count: 4 },
            { sv: "tre hopp", en: "three jumps", unit: "m", count: 3 },
            { sv: "sex matcher", en: "six matches", unit: "m√•l", count: 6 },
            { sv: "fem kvitton", en: "five receipts", unit: "kr", count: 5 },
            { sv: "fyra provresultat", en: "four test scores", unit: "po√§ng", count: 4 }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const mean = MathUtils.randomInt(5, 20);
        const targetSum = mean * s.count;
        
        let currentSum = 0;
        const list: number[] = [];
        for(let i=0; i<s.count-1; i++) {
            const val = MathUtils.randomInt(1, mean + 5);
            list.push(val);
            currentSum += val;
        }
        const lastVal = targetSum - currentSum;
        list.push(lastVal);
        
        // Safety check for negatives if context forbids
        if ((s.unit === '√•r' || s.unit === 'kr' || s.unit === 'g') && lastVal < 0) {
            return this.level2_Mean(lang); // Retry
        }

        const setStr = list.sort(() => Math.random() - 0.5).join(', ');
        
        const desc = lang === 'sv'
            ? `Ber√§kna medelv√§rdet f√∂r: ${setStr} (${s.unit}).`
            : `Calculate the mean for: ${setStr} (${s.unit}).`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(mean.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Addera alla talen f√∂rst (Summan)." : "Add all numbers first (The Sum).", 
                    latex: `${list.join('+')} = ${targetSum}` 
                },
                { 
                    text: lang === 'sv' ? `Dela summan med antalet tal (${s.count}).` : `Divide the sum by the count (${s.count}).`, 
                    latex: `${targetSum} / ${s.count} = ${mean}` 
                }
            ]
        };
    }

    // --- LEVEL 3: Median ---
    private level3_Median(lang: string): any {
        const scenarios = [
            { sv: "husnummer", en: "house numbers" },
            { sv: "l√§ngder (cm)", en: "heights (cm)" },
            { sv: "skostorlekar", en: "shoe sizes" },
            { sv: "t√§rningsslag", en: "dice rolls" },
            { sv: "√•ldrar", en: "ages" },
            { sv: "timmar s√∂mn", en: "hours of sleep" },
            { sv: "antal syskon", en: "number of siblings" }
        ];
        const s = MathUtils.randomChoice(scenarios);
        const isOdd = MathUtils.randomInt(0, 1) === 1;
        const len = isOdd ? MathUtils.randomChoice([5, 7, 9]) : MathUtils.randomChoice([4, 6, 8]);
        
        const list: number[] = [];
        for(let i=0; i<len; i++) list.push(MathUtils.randomInt(1, 20));
        
        const shuffled = [...list];
        const sorted = list.sort((a,b) => a-b);
        
        let median = 0;
        let explanation = "";

        if (isOdd) {
            const midIdx = Math.floor(len / 2);
            median = sorted[midIdx];
            explanation = lang === 'sv' 
                ? `Mittenv√§rdet i den sorterade listan √§r ${median}.` 
                : `The middle value in the sorted list is ${median}.`;
        } else {
            const mid1 = sorted[len/2 - 1];
            const mid2 = sorted[len/2];
            median = (mid1 + mid2) / 2;
            explanation = lang === 'sv'
                ? `Mitten best√•r av ${mid1} och ${mid2}. Medelv√§rdet av dem √§r ${median}.`
                : `The middle is ${mid1} and ${mid2}. The average of them is ${median}.`;
        }

        const desc = lang === 'sv'
            ? `Hitta medianen f√∂r dessa ${s.sv}: ${shuffled.sort(() => Math.random() - 0.5).join(', ')}`
            : `Find the median for these ${s.en}: ${shuffled.sort(() => Math.random() - 0.5).join(', ')}`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(median.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂rst m√•ste du sortera talen i storleksordning!" : "First you must sort the numbers in order!",
                    latex: sorted.join(', ')
                },
                { text: explanation }
            ]
        };
    }

    // --- LEVEL 4: Reverse Mean ---
    private level4_ReverseMean(lang: string): any {
        // Scaffolding: 3, 5, or 7 items
        const count = MathUtils.randomChoice([3, 5, 7]);
        
        const mean = MathUtils.randomInt(5, 15);
        const total = mean * count;
        
        // Generate n-1 known numbers
        const knownValues: number[] = [];
        let currentSum = 0;
        
        for (let i = 0; i < count - 1; i++) {
            // Generate numbers relatively close to the mean to stay realistic
            const val = MathUtils.randomInt(Math.max(1, mean - 6), mean + 6);
            knownValues.push(val);
            currentSum += val;
        }
        
        let missing = total - currentSum;

        // Ensure missing value is non-negative. If negative, adjust the last known value.
        if (missing < 0) {
            const adjustment = Math.abs(missing) + MathUtils.randomInt(1, 5);
            // Decrease last value to increase missing value
            knownValues[knownValues.length - 1] -= adjustment;
            // Prevent that value from going negative too?
            if (knownValues[knownValues.length - 1] < 0) {
                 knownValues[knownValues.length - 1] = 1; // Fallback
            }
            // Recalculate sum and missing
            currentSum = knownValues.reduce((a, b) => a + b, 0);
            missing = total - currentSum;
        }
        
        // Just in case it's still weird, simple retry logic is robust here, 
        // but the math above should handle 99% of cases.
        if (missing < 0) return this.level4_ReverseMean(lang);

        const knownStr = knownValues.join(', ');
        
        // Ordinal words for the question
        let ordinalSv = "tredje";
        let ordinalEn = "third";
        if (count === 5) { ordinalSv = "femte"; ordinalEn = "fifth"; }
        if (count === 7) { ordinalSv = "sjunde"; ordinalEn = "seventh"; }

        const desc = lang === 'sv'
            ? `Medelv√§rdet av ${count} tal √§r ${mean}. ${count-1} av talen √§r ${knownStr}. Vilket √§r det ${ordinalSv} talet?`
            : `The mean of ${count} numbers is ${mean}. ${count-1} of the numbers are ${knownStr}. What is the ${ordinalEn} number?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(missing.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `R√§kna ut vad summan av alla ${count} m√•ste vara.` : `Calculate what the sum of all ${count} must be.`,
                    latex: `\\text{Sum} = ${mean} \\cdot ${count} = ${total}`
                },
                { 
                    text: lang === 'sv' ? "Dra bort de tal du vet fr√•n summan." : "Subtract the known numbers from the sum.",
                    latex: `${total} - (${knownValues.join(' + ')}) = ${missing}` 
                }
            ]
        };
    }

    // --- LEVEL 5: Frequency Table (VISUAL) ---
    private level5_FrequencyTable(lang: string): any {
        const vals = [1, 2, 3, 4, 5];
        const freqs = [
            MathUtils.randomInt(1, 3),
            MathUtils.randomInt(2, 5),
            MathUtils.randomInt(2, 5),
            MathUtils.randomInt(1, 3),
            MathUtils.randomInt(0, 2)
        ];
        
        let sumProd = 0;
        let totalCount = 0;
        const rows: any[] = [];
        
        vals.forEach((v, i) => {
            const f = freqs[i];
            if (f > 0) {
                sumProd += v * f;
                totalCount += f;
                rows.push([v, f]);
            }
        });

        // Calculate targets
        const mean = Math.round((sumProd / totalCount) * 10) / 10;
        
        const expanded: number[] = [];
        vals.forEach((v, i) => {
            for(let k=0; k<freqs[i]; k++) expanded.push(v);
        });
        const mid = Math.floor(expanded.length / 2);
        const median = expanded.length % 2 !== 0 ? expanded[mid] : (expanded[mid-1] + expanded[mid])/2;

        const isMean = MathUtils.randomInt(0, 1) === 1;
        const target = isMean ? mean : median;
        const targetName = isMean ? (lang==='sv'?'medelv√§rdet':'the mean') : (lang==='sv'?'medianen':'the median');

        const desc = lang === 'sv'
            ? `Tabellen visar resultat (V√§rde vs Antal). Ber√§kna ${targetName}.`
            : `The table shows results (Value vs Count). Calculate ${targetName}.`;

        const headers = lang === 'sv' ? ["V√§rde", "Antal"] : ["Value", "Count"];

        return {
            renderData: { 
                description: desc, 
                answerType: 'numeric',
                geometry: { 
                    type: 'frequency_table', 
                    headers: headers, 
                    rows: rows 
                }
            },
            token: this.toBase64(target.toString()),
            clues: [
                { 
                    text: isMean 
                        ? (lang==='sv' ? "Multiplicera v√§rde med antal f√∂r att f√• summan." : "Multiply value by count to get sum.")
                        : (lang==='sv' ? "Skriv ut alla talen p√• en rad: 1, 1, 2, 2, 2..." : "Write out all numbers: 1, 1, 2, 2, 2...")
                },
                {
                    latex: isMean 
                        ? `\\frac{${sumProd}}{${totalCount}}` 
                        : `\\text{Mitten} = ${target}`
                }
            ]
        };
    }

    // --- LEVEL 6: Real World Mixed ---
    private level6_RealWorldMixed(lang: string): any {
        const type = MathUtils.randomInt(1, 2);
        
        if (type === 1) {
            const desc = lang === 'sv'
                ? `L√∂ner: 20k, 21k, 22k, 20.5k, 1000k. Vilket m√•tt beskriver "vanlig l√∂n" b√§st: Medelv√§rde eller Median? (Svara med ordet)`
                : `Salaries: 20k, 21k, 22k, 20.5k, 1000k. Which measure fits best: Mean or Median? (Answer with word)`;
            
            return {
                renderData: { description: desc, answerType: 'text' },
                token: this.toBase64("Median"),
                clues: [{ text: lang === 'sv' ? "Medelv√§rdet p√•verkas mycket av det j√§ttestora talet (1000k)." : "The mean is heavily affected by the outlier (1000k)." }]
            };
        } else {
            const desc = lang === 'sv'
                ? `Talserie: 1, 1, 2, 8, 9. Ber√§kna differensen mellan Medelv√§rde och Median.`
                : `List: 1, 1, 2, 8, 9. Calculate the difference between Mean and Median.`;
            
            // Mean = 21/5 = 4.2. Median = 2. Diff = 2.2
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64("2.2"),
                clues: [
                    { latex: `\\text{Medel} = 21/5 = 4.2` },
                    { latex: `\\text{Median} = 2` },
                    { latex: `4.2 - 2 = 2.2` }
                ]
            };
        }
    }
}   

// FILE END: src\core\generators\StatisticsGen.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class TenPowersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_MultDivBig(lang);
            case 2: return this.level2_Concepts(lang);
            case 3: return this.level3_MixedFactors(lang);
            default: return this.level1_MultDivBig(lang);
        }
    }

    private fixFloat(n: number) { return parseFloat(n.toFixed(6)); }

    // Level 1: Mult/Div by 10, 100, 1000
    private level1_MultDivBig(lang: string): any {
        const power = MathUtils.randomChoice([10, 100, 1000]);
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const num = MathUtils.randomInt(2, 900);
        let ans = 0, latex = "";
        
        const zeros = power.toString().length - 1;
        const stepsText = lang === 'sv' ? "steg" : "steps";
        const dir = isMult 
            ? (lang === 'sv' ? "H√ñGER" : "RIGHT") 
            : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");

        if (isMult) {
            ans = num * power;
            latex = `${num} \\cdot ${power}`;
        } else {
            ans = this.fixFloat(num / power);
            latex = `${num} / ${power}`;
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna." : "Calculate.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [{ 
                text: lang === 'sv' 
                ? `Flytta kommatecknet ${zeros} ${stepsText} √•t ${dir} (l√§gg till nollor).` 
                : `Move decimal ${zeros} ${stepsText} ${dir} (add zeros).`,
                latex: "" 
            }]
        };
    }

    // Level 2: Conceptual Equivalence
    private level2_Concepts(lang: string): any {
        const scenarios = [
            // --- DECIMALS (0.1, 0.01, 0.001) ---
            { 
                op: 'mul', val: 0.1, equivOp: 'div', equivVal: 10,
                clueSv: "Att multiplicera med 0.1 √§r som att ta en tiondel av kakan. Det blir mindre, precis som n√§r man delar med 10.",
                clueEn: "Multiplying by 0.1 is like taking one tenth of a cake. It gets smaller, just like dividing by 10."
            },
            { 
                op: 'div', val: 0.1, equivOp: 'mul', equivVal: 10,
                clueSv: "Att dela med 0.1 betyder: 'Hur m√•nga sm√• 0.1-bitar f√•r plats i 1?' Det f√•r plats 10 stycken. Svaret blir stort.",
                clueEn: "Dividing by 0.1 means: 'How many small 0.1 pieces fit into 1?' It fits 10 times. The answer becomes large."
            },
            { 
                op: 'mul', val: 0.01, equivOp: 'div', equivVal: 100,
                clueSv: "Att multiplicera med 0.01 √§r som att ta en hundradel. Det √§r samma som att dela p√• 100.",
                clueEn: "Multiplying by 0.01 is like taking one hundredth. That's the same as dividing by 100."
            },
            { 
                op: 'div', val: 0.01, equivOp: 'mul', equivVal: 100,
                clueSv: "Att dela med en hundradel (0.01) g√∂r talet mycket st√∂rre. Hur m√•nga hundradelar g√•r det p√• en hel? Jo, 100.",
                clueEn: "Dividing by one hundredth (0.01) makes the number much bigger. How many hundredths fit in a whole? 100."
            },
            { 
                op: 'mul', val: 0.001, equivOp: 'div', equivVal: 1000,
                clueSv: "En tusendel √§r v√§ldigt litet. Att multiplicera med 0.001 √§r som att dela med 1000.",
                clueEn: "A thousandth is very small. Multiplying by 0.001 is like dividing by 1000."
            },
            { 
                op: 'div', val: 0.001, equivOp: 'mul', equivVal: 1000,
                clueSv: "Att dela med en tusendel betyder att vi ser hur m√•nga pyttesm√• bitar som f√•r plats. Det blir 1000 g√•nger fler.",
                clueEn: "Dividing by a thousandth means seeing how many tiny pieces fit. It becomes 1000 times more."
            },
            // --- INTEGERS (10, 100, 1000) ---
            { 
                op: 'mul', val: 10, equivOp: 'div', equivVal: 0.1,
                clueSv: "Att g√∂ra n√•got 10 g√•nger st√∂rre √§r samma som att se hur m√•nga tiondelar som ryms i det (division med 0.1).",
                clueEn: "Making something 10 times bigger is like seeing how many tenths fit inside it (dividing by 0.1)."
            },
            { 
                op: 'div', val: 10, equivOp: 'mul', equivVal: 0.1,
                clueSv: "Att dela upp i 10 h√∂gar √§r samma sak som att ta en tiondel (0.1) av h√∂gen.",
                clueEn: "Splitting into 10 piles is the same as taking one tenth (0.1) of the pile."
            },
            { 
                op: 'mul', val: 100, equivOp: 'div', equivVal: 0.01,
                clueSv: "G√•nger 100 √§r en stor √∂kning. Det √§r matematiskt samma som att dela med det lilla talet 0.01.",
                clueEn: "Times 100 is a big increase. Mathematically, it's the same as dividing by the tiny number 0.01."
            },
            { 
                op: 'div', val: 100, equivOp: 'mul', equivVal: 0.01,
                clueSv: "Att dela med 100 √§r samma som att ta en hundradel (0.01).",
                clueEn: "Dividing by 100 is the same as taking one hundredth (0.01)."
            },
             { 
                op: 'mul', val: 1000, equivOp: 'div', equivVal: 0.001,
                clueSv: "G√•nger 1000 √§r samma som att dela med en tusendel.",
                clueEn: "Times 1000 is the same as dividing by a thousandth."
            },
            { 
                op: 'div', val: 1000, equivOp: 'mul', equivVal: 0.001,
                clueSv: "Att dela med 1000 √§r samma som att ta en tusendel (0.001).",
                clueEn: "Dividing by 1000 is the same as taking one thousandth (0.001)."
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        
        let description = "";
        
        if (lang === 'sv') {
            const opStr = s.op === 'mul' ? "multiplicera med" : "dela med";
            const targetOpStr = s.equivOp === 'mul' ? "multiplicera med..." : "dela med...";
            description = `Att ${opStr} ${s.val} √§r samma sak som att ${targetOpStr}`;
        } else {
            const opStr = s.op === 'mul' ? "multiplying by" : "dividing by";
            const targetOpStr = s.equivOp === 'mul' ? "multiplying by..." : "dividing by...";
            description = `To ${opStr} ${s.val} is the same as ${targetOpStr}`;
        }

        // Fixed set of answer choices
        const choices = ["10", "100", "1000", "0.1", "0.01", "0.001"];
        const clueText = lang === 'sv' ? (s.clueSv || "") : (s.clueEn || "");

        return {
            renderData: { 
                latex: "", 
                description, 
                answerType: 'multiple_choice', 
                choices 
            },
            token: Buffer.from(s.equivVal.toString()).toString('base64'),
            clues: [
                { text: clueText, latex: "" }
            ]
        };
    }

    // Level 3: Mixed Factors (0.1...1000)
    private level3_MixedFactors(lang: string): any {
        const factor = MathUtils.randomChoice([0.1, 0.01, 0.001, 10, 100, 1000]);
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const num = MathUtils.randomFloat(2, 50, 1);
        
        let ans = 0, latex = "";
        let direction = "";
        let steps = 0;
        
        // Count decimal shift
        if (factor >= 10) steps = factor.toString().length - 1;
        else steps = factor.toString().length - 2;

        if (isMult) {
            ans = this.fixFloat(num * factor);
            latex = `${num} \\cdot ${factor}`;
            const isRight = factor >= 10;
            direction = isRight ? (lang === 'sv' ? "H√ñGER" : "RIGHT") : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");
        } else {
            ans = this.fixFloat(num / factor);
            latex = `${num} / ${factor}`;
            const isRight = factor < 1;
            direction = isRight ? (lang === 'sv' ? "H√ñGER" : "RIGHT") : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");
        }

        const clueText = lang === 'sv' 
            ? `Flytta kommatecknet ${steps} steg √•t ${direction}.` 
            : `Move decimal ${steps} steps ${direction}.`;

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna." : "Calculate.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [{ text: clueText, latex: `\\mathbf{${ans}}` }]
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class VolumeGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Cuboid(lang);
            case 2: return this.level2_TriPrism(lang);
            case 3: return this.level3_Cylinder(lang);
            case 4: return this.level4_PyramidCone(lang);
            case 5: return this.level5_SphereComposite(lang);
            case 6: return this.level6_Mixed(lang);
            case 7: return this.level7_Units(lang);
            default: return this.level1_Cuboid(lang);
        }
    }

    // Level 1: Rectangular Prism (Cuboid) & Cube
    private level1_Cuboid(lang: string): any {
        const w = MathUtils.randomInt(2, 10);
        const d = MathUtils.randomInt(2, 10);
        const h = MathUtils.randomInt(2, 10);
        const volume = w * d * h;

        return {
            renderData: {
                geometry: { type: 'cuboid', labels: { w, h, d } },
                description: lang === 'sv' ? "Ber√§kna volymen." : "Calculate the volume.",
                answerType: 'text',
                suffix: 'cm¬≥'
            },
            token: Buffer.from(volume.toString()).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Volymen = Bredd √ó Djup √ó H√∂jd" : "Volume = Width √ó Depth √ó Height", 
                    latex: `V = ${w} \\\\cdot ${d} \\\\cdot ${h}` 
                }
            ]
        };
    }

    // Level 2: Triangular Prism
    private level2_TriPrism(lang: string): any {
        const b = MathUtils.randomInt(3, 8);
        const hTri = MathUtils.randomInt(2, 6);
        const length = MathUtils.randomInt(5, 12);
        const areaBase = (b * hTri) / 2;
        const volume = areaBase * length;

        return {
            renderData: {
                geometry: { type: 'triangular_prism', labels: { b, h: hTri, l: length } },
                description: lang === 'sv' ? "Ber√§kna prismats volym." : "Calculate the prism's volume.",
                answerType: 'numeric',
                suffix: 'cm¬≥'
            },
            token: Buffer.from(volume.toString()).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "R√§kna ut basytan (triangeln) f√∂rst." : "Calculate the base area (triangle) first.", 
                    latex: `B = \\\\frac{${b} \\\\cdot ${hTri}}{2} = ${areaBase}` 
                },
                { 
                    text: lang === 'sv' ? "Multiplicera basytan med l√§ngden." : "Multiply base area by length.", 
                    latex: `V = ${areaBase} \\\\cdot ${length}` 
                }
            ]
        };
    }

    // Level 3: Cylinder
    private level3_Cylinder(lang: string): any {
        const r = MathUtils.randomInt(2, 6);
        const h = MathUtils.randomInt(5, 15);
        const volume = Math.round(Math.PI * r * r * h);

        return {
            renderData: {
                geometry: { type: 'cylinder', labels: { r, h } },
                description: lang === 'sv' ? "Ber√§kna cylinderns volym (avrunda till heltal)." : "Calculate volume (round to integer).",
                answerType: 'numeric',
                suffix: 'cm¬≥'
            },
            token: Buffer.from(volume.toString()).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Basytan √§r en cirkel." : "The base is a circle.", 
                    latex: `A = \\\\pi \\\\cdot r^2 = \\\\pi \\\\cdot ${r}^2 \\\\approx ${Math.round(Math.PI * r * r)}` 
                },
                { 
                    text: lang === 'sv' ? "Volym = Basytan √ó H√∂jden" : "Volume = Base Area √ó Height", 
                    latex: `V \\\\approx ${Math.round(Math.PI * r * r)} \\\\cdot ${h}` 
                }
            ]
        };
    }

    // Level 4: Pyramid & Cone
    private level4_PyramidCone(lang: string): any {
        const isCone = MathUtils.randomInt(0, 1) === 1;

        if (isCone) {
            const r = MathUtils.randomInt(3, 8);
            const h = MathUtils.randomInt(6, 15);
            const volume = Math.round((Math.PI * r * r * h) / 3);
            return {
                renderData: {
                    geometry: { type: 'cone', labels: { r, h } },
                    description: lang === 'sv' ? "Ber√§kna konens volym (avrunda till heltal)." : "Calculate cone volume (round to integer).",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    { text: "Formel:", latex: `V = \\\\frac{\\\\pi r^2 h}{3}` }
                ]
            };
        } else {
            const w = MathUtils.randomInt(3, 8);
            const d = MathUtils.randomInt(3, 8); // Explicit depth
            const h = MathUtils.randomInt(6, 12);
            // Square/Rect pyramid
            const volume = Math.round((w * d * h) / 3);
            return {
                renderData: {
                    geometry: { type: 'pyramid', labels: { w, d, h } }, // Pass 'd' explicitly
                    description: lang === 'sv' ? "Ber√§kna pyramidens volym." : "Calculate pyramid volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    { text: "Formel:", latex: `V = \\\\frac{B \\\\cdot h}{3}` },
                    { text: "Basytan:", latex: `B = ${w} \\\\cdot ${d} = ${w * d}` }
                ]
            };
        }
    }

    // Level 5: Sphere & Composite
    private level5_SphereComposite(lang: string): any {
        // Here we just delegate to the mixed/diameter logic in Level 6 essentially, 
        // but Level 5 is usually "intro to sphere".
        // Let's add Diameter logic here too if desired, but sticking to Level 6 request.
        // Actually, let's keep Level 5 standard (Radius) and Level 6 Mixed (Radius OR Diameter).
        
        const type = MathUtils.randomChoice(['sphere', 'silo', 'ice_cream']);

        if (type === 'sphere') {
            const r = MathUtils.randomInt(3, 9);
            const volume = Math.round((4 * Math.PI * Math.pow(r, 3)) / 3);
            return {
                renderData: {
                    geometry: { type: 'sphere', labels: { r } },
                    description: lang === 'sv' ? "Ber√§kna klotets volym." : "Calculate sphere volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [{ text: "Formel:", latex: `V = \\\\frac{4 \\\\pi r^3}{3}` }]
            };
        }
        else if (type === 'silo') {
            const r = MathUtils.randomInt(3, 6);
            const h = MathUtils.randomInt(Math.floor(r * 1.5), Math.floor(r * 2.5));
            const total = Math.round((Math.PI * r * r * h) + ((2 * Math.PI * Math.pow(r, 3)) / 3));

            return {
                renderData: {
                    geometry: { type: 'silo', labels: { r, h } }, 
                    description: lang === 'sv' ? "Ber√§kna silons volym (Cylinder + Halvklot)." : "Calculate silo volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(total.toString()).toString('base64'),
                clues: [{ text: "Total:", latex: `V_{cyl} + V_{halv}` }]
            };
        } 
        else {
            const r = MathUtils.randomInt(3, 6);
            const h = MathUtils.randomInt(Math.floor(r * 1.5), Math.floor(r * 2.5));
            const total = Math.round(((Math.PI * r * r * h) / 3) + ((2 * Math.PI * Math.pow(r, 3)) / 3));

            return {
                renderData: {
                    geometry: { type: 'ice_cream', labels: { r, h } },
                    description: lang === 'sv' ? "Ber√§kna volymen (Kon + Halvklot)." : "Calculate volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(total.toString()).toString('base64'),
                clues: [{ text: "Total:", latex: `V_{kon} + V_{halv}` }]
            };
        }
    }

    // Level 6: Mixed with DIAMETER Logic
    private level6_Mixed(lang: string): any {
        const type = MathUtils.randomChoice(['sphere', 'silo', 'ice_cream']);
        const useDiameter = MathUtils.randomInt(0, 1) === 1; // 50% chance of Diameter

        let r = MathUtils.randomInt(3, 8);
        let dLabel = r * 2;
        let h = MathUtils.randomInt(Math.floor(r * 1.5), Math.floor(r * 2.5)); // For composites

        let volume = 0;
        let labels: any = {};
        
        // Prepare Labels based on Mode
        if (useDiameter) labels = { d: dLabel, h };
        else labels = { r, h };

        // Helper to get R from D description
        const dimDesc = useDiameter ? `(d = ${dLabel})` : `(r = ${r})`;

        if (type === 'sphere') {
            volume = Math.round((4 * Math.PI * Math.pow(r, 3)) / 3);
            if (useDiameter) labels = { d: dLabel }; // No height for sphere
            else labels = { r };

            return {
                renderData: {
                    geometry: { type: 'sphere', labels, show: useDiameter ? 'diameter' : 'radius' },
                    description: lang === 'sv' 
                        ? `Ber√§kna klotets volym ${dimDesc}.` 
                        : `Calculate sphere volume ${dimDesc}.`,
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    useDiameter ? { text: lang === 'sv' ? "Radien √§r h√§lften av diametern." : "Radius is half the diameter.", latex: `r = ${dLabel}/2 = ${r}` } : null,
                    { text: "Formel:", latex: `V = \\\\frac{4 \\\\pi \\\\cdot ${r}^3}{3}` }
                ].filter(Boolean)
            };
        }
        else if (type === 'silo') {
            // Silo = Cylinder + Hemisphere
            const volCyl = Math.PI * r * r * h;
            const volHemi = (2 * Math.PI * Math.pow(r, 3)) / 3;
            volume = Math.round(volCyl + volHemi);

            return {
                renderData: {
                    geometry: { type: 'silo', labels, show: useDiameter ? 'diameter' : 'radius' },
                    description: lang === 'sv' ? "Ber√§kna silons volym." : "Calculate silo volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    useDiameter ? { text: "Hitta radien:", latex: `r = ${dLabel}/2 = ${r}` } : null,
                    { text: "Cylinder:", latex: `\\pi \\cdot ${r}^2 \\cdot ${h}` },
                    { text: "Halvklot:", latex: `\\frac{2 \\cdot \\pi \\cdot ${r}^3}{3}` }
                ].filter(Boolean)
            };
        }
        else {
            // Ice Cream = Cone + Hemisphere
            const volCone = (Math.PI * r * r * h) / 3;
            const volHemi = (2 * Math.PI * Math.pow(r, 3)) / 3;
            volume = Math.round(volCone + volHemi);

            return {
                renderData: {
                    geometry: { type: 'ice_cream', labels, show: useDiameter ? 'diameter' : 'radius' },
                    description: lang === 'sv' ? "Ber√§kna volymen." : "Calculate volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    useDiameter ? { text: "Hitta radien:", latex: `r = ${dLabel}/2 = ${r}` } : null,
                    { text: "Kon:", latex: `\\frac{\\pi \\cdot ${r}^2 \\cdot ${h}}{3}` },
                    { text: "Halvklot:", latex: `\\frac{2 \\cdot \\pi \\cdot ${r}^3}{3}` }
                ].filter(Boolean)
            };
        }
    }

    // Level 7: Mixed Units Conversion
    private level7_Units(lang: string): any {
        const scenario = MathUtils.randomChoice([0, 1, 2, 3]);

        if (scenario === 0 || scenario === 1) {
            const isCyl = scenario === 1;
            const dim1 = MathUtils.randomInt(2, 8) * 10; 
            const dim2 = MathUtils.randomInt(2, 8) * 10;
            const dim3 = MathUtils.randomInt(2, 8) * 10;

            const val1_dm = dim1 / 10;
            const val2_dm = dim2 / 10;
            const val3_dm = dim3 / 10;

            let volume = 0;
            let visual: any = {};
            let formula = "";

            if (isCyl) {
                volume = Math.round(Math.PI * val1_dm * val1_dm * val2_dm);
                visual = { type: 'cylinder', labels: { r: `${dim1} cm`, h: `${dim2} cm` } };
                formula = `V \\\\approx \\\\pi \\\\cdot ${val1_dm}^2 \\\\cdot ${val2_dm}`;
            } else {
                volume = val1_dm * val2_dm * val3_dm;
                visual = { type: 'cuboid', labels: { w: `${dim1} cm`, d: `${dim2} cm`, h: `${dim3} cm` } };
                formula = `V = ${val1_dm} \\\\cdot ${val2_dm} \\\\cdot ${val3_dm}`;
            }

            return {
                renderData: {
                    geometry: visual,
                    description: lang === 'sv' 
                        ? "Hur m√•nga liter rymmer figuren? (Tips: 1 liter = 1 dm¬≥)" 
                        : "How many liters does the shape hold? (Hint: 1 liter = 1 dm¬≥)",
                    answerType: 'numeric',
                    suffix: 'liter'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    { 
                        text: lang === 'sv' ? "G√∂r om sidorna till dm f√∂rst." : "Convert sides to dm first.", 
                        latex: `${dim1} \\\\text{ cm} = ${val1_dm} \\\\text{ dm}` 
                    },
                    { 
                        text: lang === 'sv' ? "Ber√§kna sedan volymen." : "Then calculate volume.", 
                        latex: formula 
                    }
                ]
            };
        } 
        
        else if (scenario === 2) {
            const w = MathUtils.randomInt(1, 5) * 100; 
            const d = MathUtils.randomInt(1, 4) * 100;
            const h = MathUtils.randomInt(1, 3) * 100;
            
            const w_m = w / 100;
            const d_m = d / 100;
            const h_m = h / 100;
            
            const volume = w_m * d_m * h_m;

            return {
                renderData: {
                    geometry: { type: 'cuboid', labels: { w: `${w} cm`, d: `${d} cm`, h: `${h} cm` } },
                    description: lang === 'sv' ? "Ber√§kna volymen i kubikmeter (m¬≥)." : "Calculate volume in cubic meters (m¬≥).",
                    answerType: 'numeric',
                    suffix: 'm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    { text: lang === 'sv' ? "Omvandla cm till m." : "Convert cm to m.", latex: `${w} \\\\text{ cm} = ${w_m} \\\\text{ m}` },
                    { text: "Volym:", latex: `${w_m} \\\\cdot ${d_m} \\\\cdot ${h_m} = ${volume}` }
                ]
            };
        } 
        
        else {
            const w = MathUtils.randomInt(2, 9) * 10; 
            const d = MathUtils.randomInt(2, 9) * 10;
            const h = MathUtils.randomInt(2, 9) * 10;

            const w_cm = w / 10;
            const d_cm = d / 10;
            const h_cm = h / 10;
            const volume = w_cm * d_cm * h_cm;

            return {
                renderData: {
                    geometry: { type: 'cuboid', labels: { w: `${w} mm`, d: `${d} mm`, h: `${h} mm` } },
                    description: lang === 'sv' ? "Ber√§kna volymen i cm¬≥." : "Calculate volume in cm¬≥.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: Buffer.from(volume.toString()).toString('base64'),
                clues: [
                    { text: lang === 'sv' ? "Omvandla mm till cm." : "Convert mm to cm.", latex: `${w} \\\\text{ mm} = ${w_cm} \\\\text{ cm}` },
                    { text: "Volym:", latex: `${w_cm} \\\\cdot ${d_cm} \\\\cdot ${h_cm} = ${volume}` }
                ]
            };
        }
    }
}

// FILE END: src\core\generators\VolumeGen.ts

// =======================================================
// FILE START: src\core\interfaces\Generator.ts
// =======================================================

export interface QuestionData {
    text?: string;
    renderData?: any; // Preferred
    visual?: any;     // Legacy
    answer: string | number;
    clues: string[];
}

export interface Generator {
    /**
     * Generates a new question.
     * @param level Difficulty level (1-9)
     * @param lang Language code ('sv' | 'en')
     */
    generate(level: number, lang: string): QuestionData;

    /**
     * Optional: Custom validation logic for answers.
     * @param userAnswer The user's input
     * @param systemAnswer The generated correct answer
     */
    validate?(userAnswer: string, systemAnswer: string): boolean;
}

// FILE END: src\core\interfaces\Generator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        exponents: 6,       // Added
        fraction_basics: 5, // Added
        fraction_arith: 5,  // Added
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 5,
        volume: 7,
        graph: 5,
        similarity: 4,
        percent: 6,
        probability: 6,
        statistics: 6,
        pythagoras: 6
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        // Fallback to 5 if topic not found, but we aim to list all
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export const UI_STRINGS = {
    sv: {
        // --- General UI ---
        submit: "Svara",
        next: "N√§sta fr√•ga",
        correct: "R√§tt!",
        incorrect: "Inte riktigt, f√∂rs√∂k igen",
        try_again: "F√∂rs√∂k igen",
        score: "Po√§ng",
        streak: "Svit",
        level: "Niv√•",
        loading: "Laddar...",
        error: "Fel vid laddning",
        dashboard_title: "V√§lj omr√•de att √∂va p√•",
        backBtn: "Meny",
        history: "Historik",
        noHistory: "Inga svar √§n.",
        btnHint: "Ledtr√•d",
        btnSolution: "Visa l√∂sning",
        btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        placeholder: "Skriv ditt svar...",
        hintsTitle: "Ledtr√•dar",
        clueUsed: "Hj√§lp",
        donow: "Startuppgift",
        donow_title: "Uppstart (Do Now)",
        donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
        donow_gen: "Generera",
        donow_show_all: "Visa alla",
        donow_hide_all: "D√∂lj alla",
        donow_regenerate: "Nytt Set",
        aboutBtn: "Om skaparen",
        levelUpTitle: "Niv√• upp?", 
        levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", 
        levelUpYes: "Ja, k√∂r!", 
        levelUpNo: "Nej, stanna h√§r",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Aritmetik",
            negative: "Negativa Tal",
            simplification: "F√∂renkling",
            linear_eq: "Ekvationer",
            linear_eq_prob: "Probleml√∂sning",
            geometry: "Geometri",
            volume: "Volym & Area",
            similarity: "Likformighet",
            scale: "Skala",
            linear_graph: "R√§ta Linjen",
            ten_powers: "Tiopotenser",
            percent: "Procent",           // NEW
            exponents: "Potenser",        // NEW
            probability: "Sannolikhet",   // NEW
            statistics: "Statistik",      // NEW
            pythagoras: "Pythagoras Sats" // NEW
        },

        // --- Math Vocabulary (Common) ---
        common: {
            calculate: "Ber√§kna",
            equation: "Ekvation",
            simplify: "F√∂renkla",
            solve: "L√∂s ut x",
            evaluate: "Ber√§kna",
            find_k: "Best√§m k-v√§rdet",
            find_m: "Best√§m m-v√§rdet",
            find_equation: "Best√§m linjens ekvation",
            match_graph: "Vilken ekvation h√∂r till grafen?",
            determine_equation: "Best√§m ekvationen f√∂r linjen som g√•r genom:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Ber√§kna summan",
            sub: "Ber√§kna differensen",
            mul: "Ber√§kna produkten",
            div: "Ber√§kna kvoten",
            mixed: "Ber√§kna",
            missing_term: "Hitta det saknade talet"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Vi har ekvationen: $${eq}$`,
            multiply: (k: any) => `Multiplicera b√•da sidor med $${k}$ f√∂r att bli av med divisionen.`,
            divide: (k: any) => `Dividera b√•da sidor med $${k}$ f√∂r att f√• $x$ ensamt.`,
            add: (k: any) => `Addera $${k}$ p√• b√•da sidor.`,
            subtract: (k: any) => `Subtrahera $${k}$ p√• b√•da sidor.`,
            distribute: (k: any) => `Multiplicera in $${k}$ i parentesen.`,
            sub_var: (term: string) => `Subtrahera $${term}$ fr√•n b√•da sidor f√∂r att samla $x$ p√• en sida.`,
            collect: "Samla lika termer",
            expand: "Utveckla parentesen",
            factorise: "Faktorisera uttrycket",
            substitute: "Ers√§tt och ber√§kna"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Att addera ett negativt tal √§r samma som subtraktion.",
            sub_neg: "Tv√• minus blir plus (‚Äì ‚Äì blir +).",
            mul_neg_neg: "Minus g√•nger minus blir plus.",
            mul_pos_neg: "Plus g√•nger minus blir minus.",
            div_sign_same: "Lika tecken ger positivt svar.",
            div_sign_diff: "Olika tecken ger negativt svar.",
            simple_calc: "Ber√§kna:", 
            step_calc: "Ber√§kna:",
            plus_plus: "Positivt + Positivt",
            plus_minus: "Positivt + Negativt",
            minus_plus: "Negativt + Positivt",
            minus_minus: "Negativt - Negativt",
            mixed: "Blandat",
            multiplication: "Multiplikation",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "Best√§m m-v√§rdet (d√§r linjen sk√§r y-axeln).", en: "Find the intercept (m)." },
            q_slope: { sv: "Best√§m k-v√§rdet (lutningen).", en: "Find the slope (k)." },
            q_func: { sv: "Best√§m linjens ekvation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Titta p√• grafen: Var sk√§r linjen y-axeln (d√§r $x=0$)?",
            step_intercept: (m:any) => `Linjen sk√§r y-axeln vid $y = ${m}$.`,
            step_delta: "Lutningen $k$ √§r skillnaden i $y$ delat med skillnaden i $x$.",
            step_slope_calc: "R√§kna rutor: Hur mycket √§ndras $y$ n√§r vi g√•r 1 steg √•t h√∂ger?",
            find_m: "Hitta m-v√§rdet (sk√§rning med y-axeln).",
            find_k: "Hitta k-v√§rdet (lutningen).",
            parallel: "Best√§m lutningen f√∂r en linje som √§r parallell med:",
            perpendicular: "Best√§m lutningen f√∂r en linje som √§r vinkelr√§t mot:",
            find_gradient: "Ber√§kna lutningen (k)",
            find_intercept: "Hitta y-axelsk√§rningen (m)"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Skala",
            real: "Verklig str√§cka",
            map_dist: "Avst√•nd p√• kartan",
            ratio: "Skala",
            problem_map_to_real: "Ber√§kna det verkliga avst√•ndet.",
            problem_real_to_map: "Ber√§kna avst√•ndet p√• kartan.",
            problem_find_scale: "Best√§m kartans skala.",
            reduction: "F√∂rminskning",
            enlargement: "F√∂rstoring",
            reality: "Verkligheten",
            drawing: "Bilden",
            rule_reduction: "N√§r skalan √§r 1:X √§r bilden mindre √§n verkligheten.",
            rule_enlargement: "N√§r skalan √§r X:1 √§r bilden st√∂rre √§n verkligheten.",
            step_plug_in: "S√§tt in v√§rdena i formeln: $\\frac{\\text{Bild}}{\\text{Verklighet}}$",
            calc_cm: "R√§kna f√∂rst ut det i cm.",
            conv_m: "Omvandla till meter (1 m = 100 cm).",
            conv_same: "Se till att b√•da m√•tten har samma enhet.",
            setup_ratio: "St√§ll upp f√∂rh√•llandet Bild : Verklighet.",
            step_simplify: "F√∂renkla br√•ket.",
            calc_area_img: "Ber√§kna bildens area.",
            calc_area_real: "Ber√§kna verklighetens area.",
            calc_area_scale: "Areaskalan √§r l√§ngdskalan i kvadrat."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "L√∂s ekvationen och ber√§kna $x$.",
            task_write: "Skriv en ekvation som beskriver situationen (du beh√∂ver inte l√∂sa den).",
            clue_var: "L√•t $x$ vara det vi s√∂ker.",
            clue_total: "S√§tt uttrycket lika med totalen.",
            expl_rate_val: "Pris per styck g√•nger antal.",
            expl_fixed_val: "L√§gg till den fasta avgiften.",
            expl_item_cost: "Kostnaden f√∂r varorna innan rabatt.",
            expl_discount_sub: "Subtrahera rabatten.",
            expl_person1: "Person 1 har $x$.",
            expl_person2_more: "Person 2 har mer.",
            expl_person2_less: "Person 2 har mindre.",
            expl_compare_sum: "Summan av b√•da √§r totalen.",
            a_buy: { sv: "Du k√∂per $a$ st {item} f√∂r $x$ kr/st och en p√•se f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $a$ {item} for $x$ kr each and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "En taxiresa kostar $b$ kr i startavgift och $a$ kr per km. Resan kostar totalt $c$ kr. Hur m√•nga km ($x$) √•kte du?", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "Du k√∂per $a$ st {item} som kostar $x$ kr/st. Du har en rabattkupong p√• $b$ kr. Du betalar totalt $c$ kr.", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "{name1} och {name2} samlar p√• {item}. {name2} har $a$ fler √§n {name1}. Tillsammans har de $c$ st. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "{name1} och {name2} har $c$ {item} tillsammans. {name2} har $b$ f√§rre √§n {name1}. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Ber√§kna arean",
            perimeter: "Ber√§kna omkretsen",
            circumference: "Ber√§kna omkretsen",
            volume: "Ber√§kna volymen",
            surface_area: "Ber√§kna begr√§nsningsarean",
            similarity: "Likformighet",
            scale_factor: "Hitta skalfaktorn (k)",
            missing_side: "Ber√§kna den saknade sidan",
            shape: "Figur",
            cube: "Kub",
            cuboid: "R√§tblock",
            cylinder: "Cylinder",
            sphere: "Klot",
            cone: "Kon",
            triangle: "Triangel",
            rectangle: "Rektangel",
            circle: "Cirkel",
            parallelogram: "Parallellogram",
            trapezium: "Trapets"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplikation med tiopotenser",
            div: "Division med tiopotenser",
            standard_form: "Grundpotensform",
            prefix: "Prefix"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Ber√§kna delen",
            find_whole: "Hitta det hela",
            change: "F√∂r√§ndring",
            visual: "Andel (Bild)"
        },
        statistics: {
            mean: "Medelv√§rde",
            median: "Median",
            mode: "Typv√§rde",
            range: "Variationsbredd",
            table: "Frekvenstabell"
        },
        probability: {
            chance: "Sannolikhet",
            complement: "Komplementh√§ndelse",
            compound: "Sammansatt h√§ndelse",
            marbles: "Kulor",
            spinner: "Snurrhjul"
        },
        pythagoras: {
            theorem: "Pythagoras sats",
            hypotenuse: "Hypotenusa",
            leg: "Katet",
            distance: "Avst√•nd"
        },
        exponents: {
            power: "Potens",
            base: "Bas",
            exponent: "Exponent",
            root: "Kvadratrot",
            sci_not: "Grundpotensform",
            zero_rule: "Nollregeln"
        },

        // --- Shapes ---
        shapes: {
            square: "kvadrat",
            rectangle: "rektangel",
            circle: "cirkel",
            triangle: "triangel",
            rhombus: "romb",
            parallelogram: "parallellogram",
            pentagon: "femh√∂rning",
            hexagon: "sexh√∂rning",
            octagon: "√•ttah√∂rning",
            star: "stj√§rna",
            arrow: "pil",
            heart: "hj√§rta",
            cross: "kors",
            lightning: "blixt",
            kite: "drake",
            cube: "kub",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "kon",
            sphere: "klot"
        },
        shapes_plural: {
            rectangle: "rektanglar",
            triangle: "trianglar",
            circle: "cirklar",
            semicircle: "halvcirklar",
            parallelogram: "parallellogram"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    },

    en: {
        // --- General UI ---
        submit: "Submit Answer",
        next: "Next Question",
        correct: "Correct!",
        incorrect: "Incorrect.",
        try_again: "Try Again",
        score: "Score",
        streak: "Streak",
        level: "Level",
        loading: "Loading...",
        error: "Error loading question",
        dashboard_title: "Choose a topic to practice",
        backBtn: "Menu",
        history: "History",
        noHistory: "No answers yet.",
        btnHint: "Hint",
        btnSolution: "Show Solution",
        btnSkip: "Skip",
        btnNext: "Next ‚û°",
        placeholder: "Enter your answer...",
        hintsTitle: "Hints",
        clueUsed: "Clue",
        donow: "Do Now",
        donow_title: "Do Now Activity",
        donow_desc: "Select up to 3 levels. System generates 6 questions total.",
        donow_gen: "Generate",
        donow_show_all: "Show All",
        donow_hide_all: "Hide All",
        donow_regenerate: "New Set",
        aboutBtn: "About",
        levelUpTitle: "Level Up?", 
        levelUpDesc: "You seem to know this! Do you want to skip to the next level?", 
        levelUpYes: "Yes, let's go!", 
        levelUpNo: "No, stay here",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Arithmetic",
            negative: "Negative Numbers",
            simplification: "Simplification",
            linear_eq: "Linear Equations",
            linear_eq_prob: "Equation Problems",
            geometry: "Geometry",
            volume: "Volume & Surface Area",
            similarity: "Similarity",
            scale: "Scale & Maps",
            linear_graph: "Linear Graphs",
            ten_powers: "Powers of 10",
            percent: "Percentage",
            exponents: "Exponents & Roots",
            probability: "Probability",
            statistics: "Statistics",
            pythagoras: "Pythagoras"
        },

        // --- Math Vocabulary ---
        common: {
            calculate: "Calculate",
            equation: "Equation",
            simplify: "Simplify",
            solve: "Solve for x",
            evaluate: "Evaluate",
            find_k: "Find the gradient (k)",
            find_m: "Find the y-intercept (m)",
            find_equation: "Find the equation of the line",
            match_graph: "Which equation matches the graph?",
            determine_equation: "Determine the equation of the line passing through:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Calculate the sum",
            sub: "Calculate the difference",
            mul: "Calculate the product",
            div: "Calculate the quotient",
            mixed: "Evaluate the expression",
            missing_term: "Find the missing number"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Equation: $${eq}$`,
            multiply: (k: any) => `Multiply both sides by $${k}$ to remove the division.`,
            divide: (k: any) => `Divide both sides by $${k}$ to isolate $x$.`,
            add: (k: any) => `Add $${k}$ to both sides.`,
            subtract: (k: any) => `Subtract $${k}$ from both sides.`,
            distribute: (k: any) => `Distribute $${k}$ into the parentheses.`,
            sub_var: (term: string) => `Subtract $${term}$ from both sides to collect $x$ on one side.`,
            collect: "Collect like terms",
            expand: "Expand the brackets",
            factorise: "Factorise the expression",
            substitute: "Substitute and evaluate"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Adding a negative number is the same as subtraction.",
            sub_neg: "Subtracting a negative number is the same as addition (‚Äì ‚Äì becomes +).",
            mul_neg_neg: "Negative times negative becomes positive.",
            mul_pos_neg: "Positive times negative becomes negative.",
            div_sign_same: "Same signs give a positive result.",
            div_sign_diff: "Different signs give a negative result.",
            simple_calc: "Calculate:",
            step_calc: "Calculate:",
            plus_plus: "Positive + Positive",
            plus_minus: "Positive + Negative",
            minus_plus: "Negative + Positive",
            minus_minus: "Negative - Negative",
            mixed: "Mixed",
            multiplication: "Multiplication",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "", en: "Find the intercept (m)." },
            q_slope: { sv: "", en: "Find the slope (k)." },
            q_func: { sv: "", en: "Find the line equation ($y = kx + m$)."},
            look_x0: "Look at the graph: Where does the line cross the y-axis (where $x=0$)?",
            step_intercept: (m:any) => `The line crosses the y-axis at $y = ${m}$.`,
            step_delta: "The slope $k$ is the change in $y$ divided by the change in $x$.",
            step_slope_calc: "Count squares: How much does $y$ change when we go 1 step to the right?",
            find_m: "Find the m-value (y-intercept).",
            find_k: "Find the k-value (slope).",
            parallel: "Find the slope of a line parallel to:",
            perpendicular: "Find the slope of a line perpendicular to:",
            find_gradient: "Calculate the gradient",
            find_intercept: "Find the intercept"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Map Scale",
            real: "Real Distance",
            map_dist: "Map Distance",
            ratio: "Ratio",
            problem_map_to_real: "Calculate the real world distance.",
            problem_real_to_map: "Calculate the distance on the map.",
            problem_find_scale: "Determine the scale of the map.",
            reduction: "Reduction",
            enlargement: "Enlargement",
            reality: "Reality",
            drawing: "Drawing",
            rule_reduction: "When the scale is 1:X, the image is smaller than reality.",
            rule_enlargement: "When the scale is X:1, the image is larger than reality.",
            step_plug_in: "Insert the values into the formula: $\\frac{\\text{Image}}{\\text{Reality}}$",
            calc_cm: "Calculate it in cm first.",
            conv_m: "Convert to meters (1 m = 100 cm).",
            conv_same: "Ensure both measurements have the same unit.",
            setup_ratio: "Set up the ratio Image : Reality.",
            step_simplify: "Simplify the fraction.",
            calc_area_img: "Calculate the area of the image.",
            calc_area_real: "Calculate the area of reality.",
            calc_area_scale: "The area scale is the length scale squared."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "Solve the equation and calculate $x$.",
            task_write: "Write an equation that describes the situation (you don't need to solve it).",
            clue_var: "Let $x$ be what we are looking for.",
            clue_total: "Set the expression equal to the total.",
            expl_rate_val: "Price per item times quantity.",
            expl_fixed_val: "Add the fixed fee.",
            expl_item_cost: "The cost of items before discount.",
            expl_discount_sub: "Subtract the discount.",
            expl_person1: "Person 1 has $x$.",
            expl_person2_more: "Person 2 has more.",
            expl_person2_less: "Person 2 has less.",
            expl_compare_sum: "The sum of both is the total.",
            a_buy: { sv: "", en: "You buy $a$ {item} for $x$ kr/st and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Calculate the Area",
            perimeter: "Calculate the Perimeter",
            circumference: "Calculate the Circumference",
            volume: "Calculate the Volume",
            surface_area: "Calculate the Surface Area",
            similarity: "Similarity",
            scale_factor: "Find the Scale Factor",
            missing_side: "Find the missing side length",
            shape: "Shape",
            cube: "Cube",
            cuboid: "Rectangular Prism",
            cylinder: "Cylinder",
            sphere: "Sphere",
            cone: "Cone",
            triangle: "Triangle",
            rectangle: "Rectangle",
            circle: "Circle",
            parallelogram: "Parallelogram",
            trapezium: "Trapezium"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplication by powers of 10",
            div: "Division by powers of 10",
            standard_form: "Standard Form (Scientific Notation)",
            prefix: "Unit Prefixes"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Calculate Part",
            find_whole: "Find Whole",
            change: "Change",
            visual: "Proportion (Visual)"
        },
        statistics: {
            mean: "Mean",
            median: "Median",
            mode: "Mode",
            range: "Range",
            table: "Frequency Table"
        },
        probability: {
            chance: "Probability",
            complement: "Complementary Event",
            compound: "Compound Event",
            marbles: "Marbles",
            spinner: "Spinner"
        },
        pythagoras: {
            theorem: "Pythagorean Theorem",
            hypotenuse: "Hypotenuse",
            leg: "Leg",
            distance: "Distance"
        },
        exponents: {
            power: "Power",
            base: "Base",
            exponent: "Exponent",
            root: "Square Root",
            sci_not: "Scientific Notation",
            zero_rule: "Zero Rule"
        },

        // --- Shapes ---
        shapes: {
            square: "square",
            rectangle: "rectangle",
            circle: "circle",
            triangle: "triangle",
            rhombus: "rhombus",
            parallelogram: "parallelogram",
            pentagon: "pentagon",
            hexagon: "hexagon",
            octagon: "octagon",
            star: "star",
            arrow: "arrow",
            heart: "heart",
            cross: "cross",
            lightning: "lightning",
            kite: "kite",
            cube: "cube",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "cone",
            sphere: "sphere"
        },
        shapes_plural: {
            rectangle: "rectangles",
            triangle: "triangles",
            circle: "circles",
            semicircle: "semicircles",
            parallelogram: "parallelograms"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    }
};

export const TERMS = UI_STRINGS;

// Helper to handle both string and object keys safely
export function t(lang: Language, keyOrObj: string | { sv: string, en: string }): string {
    const l = (lang === 'en') ? 'en' : 'sv';
    
    // Check if input is a localized object {sv:..., en:...}
    if (typeof keyOrObj === 'object' && keyOrObj !== null) {
        // @ts-ignore
        return keyOrObj[l] || keyOrObj['sv'] || "";
    }
    
    // Check if input is a dot-notation string "geometry.area"
    if (typeof keyOrObj === 'string') {
        if (keyOrObj.includes('.')) {
            const keys = keyOrObj.split('.');
            let value: any = UI_STRINGS[l];
            for (const k of keys) {
                if (value && value[k]) {
                    value = value[k];
                } else {
                    return keyOrObj; // Return key if missing
                }
            }
            return typeof value === 'string' ? value : keyOrObj;
        }
        
        // Direct key lookup in UI root
        // @ts-ignore
        return UI_STRINGS[l][keyOrObj] || keyOrObj;
    }
    
    return String(keyOrObj);
}

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\MathUtils.ts
// =======================================================

export class MathUtils {
    static randomInt(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static randomFloat(min: number, max: number, decimals: number = 1): number {
        const val = Math.random() * (max - min) + min;
        return Number(val.toFixed(decimals));
    }

    static randomChoice<T>(arr: T[]): T {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    static gcd(a: number, b: number): number {
        return b === 0 ? a : MathUtils.gcd(b, a % b);
    }
}

// FILE END: src\core\utils\MathUtils.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: src\index.css
// =======================================================

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
  -webkit-font-smoothing: antialiased;
  @apply bg-gray-50 text-gray-800;
}

/* Legacy Animations */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Custom Scrollbar from Legacy Code */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Print Styles for Do Now Grid */
.print-break-inside-avoid {
  break-inside: avoid;
}

/* Katex Adjustments */
.katex {
  font-size: 1.1em;
}

// FILE END: src\index.css

// =======================================================
// FILE START: src\main.jsx
// =======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// FILE END: src\main.jsx

// =======================================================
// FILE START: tailwind.config.js
// =======================================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Legacy Color Palette
        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
      },
      fontFamily: { 
        sans: ['Inter', 'sans-serif'] 
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      }
    },
  },
  plugins: [],
}

// FILE END: tailwind.config.js

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode for Vite + Vercel */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    
    /* Strictness settings - relaxed noImplicitAny to fix PercentGen build error */
    "strict": true,
    "noImplicitAny": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["src", "api"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/$1" },
    { "source": "/(.*)", "destination": "/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json

// =======================================================
// FILE START: vite.config.js
// =======================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@core': path.resolve(__dirname, './src/core'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  }
})

// FILE END: vite.config.js
