PROJECT EXPORT GENERATED AT 2026-01-27T07:07:32.249Z

--- FILE STRUCTURE ---
.vercel\project.json
api\answer.ts
api\batch.ts
api\curriculum.ts
api\question.ts
backup_UI.html
bundle_project.ts
create_context.js
package-lock.json
package.json
public\index.html
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\ScaleGenerator.ts
src\core\generators\SimilarityGenerator.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGenerator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
tsconfig.json
vercel.json

==================================================


// =======================================================
// FILE START: .vercel\project.json
// =======================================================

{"projectId":"prj_bAZRO01XQ7DU9a8O2vZDClzTSTHd","orgId":"team_HTxUb7ZViM2LYhSuJ6qkKEDI","projectName":"anpassa-math-platform"}

// FILE END: .vercel\project.json

// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { verifyAnswer } from '../src/core/utils/security'; 
import { getCorrectAnswer } from '../src/core/utils/security'; 
import { ProgressionRules } from '../src/core/rules/ProgressionRules';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  const { answer, token, streak, level, topic, usedHelp, solutionUsed, attempts } = req.body;

  if (!answer || !token) {
    return res.status(400).json({ error: 'Missing answer or token' });
  }

  const isCorrect = verifyAnswer(answer, token);
  
  let levelUpAvailable = false;
  let newStreak = Number(streak || 0);
  const currentAttempts = Number(attempts || 0) + 1; 

  let action = 'none'; 
  let correctAnswer = null; 

  if (isCorrect) {
      if (solutionUsed || currentAttempts >= 2) { // Changed 3 to 2
           newStreak = 0;
      } else if (!usedHelp && currentAttempts === 1) {
          newStreak += 1;
          if (level && topic) {
              levelUpAvailable = ProgressionRules.checkLevelUp(newStreak, Number(level), String(topic));
          }
      }
  } else {
      if (currentAttempts === 1) { // Changed 2 to 1 for first clue
          action = 'next_clue';
      } else if (currentAttempts >= 2) { // Changed 3 to 2 for show solution
          action = 'show_solution';
          newStreak = 0; 
          correctAnswer = getCorrectAnswer(token);
      }
      newStreak = 0; 
  }

  return res.status(200).json({
    correct: isCorrect,
    newStreak: newStreak,
    levelUp: levelUpAvailable,
    action: action,
    correctAnswer: correctAnswer
  });
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';

// Helper to format answers for display in the grid
function formatAnswer(answer: any): string {
    try {
        if (typeof answer === 'object' && answer !== null) {
            if ('k' in answer && 'm' in answer) {
                const { k, m } = answer;
                const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
                return `y = ${k}x ${mStr}`; 
            }
            if ('left' in answer && 'right' in answer) {
                return `${answer.left}:${answer.right}`; 
            }
            return JSON.stringify(answer);
        }
        return String(answer);
    } catch (e) {
        return String(answer);
    }
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  try {
      const { config, lang = 'sv' } = req.body;
      const generatedQuestions: any[] = [];
      const timestamp = Date.now();

      if (Array.isArray(config)) {
          // Iterate through the array. 
          // The frontend now ensures this array has 6 items to fill the grid.
          for (let i = 0; i < config.length; i++) {
              const item = config[i];
              const { topic, level } = item;
              
              // Seed includes index 'i' to guarantee uniqueness even if same topic/level is requested multiple times
              const seed = `batch-${timestamp}-${topic}-${level}-${i}`;
              const lvl = Number(level);

              try {
                  let qData: any = null;

                  switch (topic) {
                      case 'arithmetic': qData = BasicArithmeticGen.generate(lvl, seed, lang as any); break;
                      case 'negative': qData = NegativeNumbersGen.generate(lvl, seed, lang as any); break;
                      case 'equation': 
                          // FIXED: Route BOTH Level 5 and 6 (Word Problems) to the correct generator
                          if (lvl === 5 || lvl === 6) {
                              qData = LinearEquationProblemGen.generate(lvl, seed, lang as any);
                          } else {
                              qData = LinearEquationGenerator.generate(lvl, seed, lang as any); 
                          }
                          break;
                      case 'geometry': qData = GeometryGenerator.generate(lvl, seed, lang as any); break;
                      case 'volume': qData = VolumeGenerator.generate(lvl, seed, lang as any); break;
                      case 'graph': qData = LinearGraphGenerator.generate(lvl, seed, lang as any); break;
                      case 'simplify': 
                          // Simplification generator check
                          qData = ExpressionSimplificationGen.generate(lvl, seed, lang as any); 
                          break;
                      default: qData = ScaleGenerator.generate(lvl, seed, lang as any); break;
                  }

                  if (qData) {
                      // NORMALIZE DESCRIPTION:
                      // Some generators return {sv, en}, others return string.
                      // We resolve it to a single string here to simplify frontend.
                      let desc = qData.renderData.description;
                      if (typeof desc === 'object' && desc !== null) {
                          desc = desc[lang] || desc['sv'] || "";
                      }

                      generatedQuestions.push({
                          renderData: {
                              ...qData.renderData,
                              description: desc // Ensure this is always a string
                          },
                          displayAnswer: formatAnswer(qData.serverData.answer),
                          topic: topic,
                          level: lvl
                      });
                  }
              } catch (genError) {
                  console.error(`Error generating question for ${topic} level ${lvl}:`, genError);
                  generatedQuestions.push({
                      renderData: { description: "Error generating question", latex: "" },
                      displayAnswer: "Error",
                      topic: topic,
                      level: lvl
                  });
              }
          }
      }

      return res.status(200).json({ questions: generatedQuestions });

  } catch (e) {
      console.error("Batch generation fatal error:", e);
      return res.status(500).json({ error: "Generation failed" });
  }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang."
    ],

    // Mapping modules to "Centralt Inneh√•ll" (Core Content)
    mapping: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        modules: ["arithmetic", "negative"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.",
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform vid √∂verslagsr√§kning, huvudr√§kning samt vid ber√§kningar med skriftliga metoder.",
          "Tal i potensform. Grundpotensform."
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["equation", "simplify"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.",
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Metoder f√∂r ekvationsl√∂sning."
        ]
      },
      geometri: {
        category: "Geometri",
        modules: ["geometry", "scale", "volume"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt, s√•v√§l med som utan digitala verktyg. Skala och dess anv√§ndning i vardagliga situationer.",
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta."
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"],
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"], // Specifically word problems in equations
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  return res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen';

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: create_context.js
// =======================================================

const fs = require('fs');
const path = require('path');

// List of all critical files to include in the context
const files = [
    'README.md',
    'package.json',
    'tsconfig.json',
    'vercel.json',
    'api/answer.ts',
    'api/question.ts',
    'public/index.html',
    'src/core/types/generator.ts',
    'src/core/utils/i18n.ts',
    'src/core/utils/random.ts',
    'src/core/utils/security.ts',
    'src/core/utils/textEngine.ts',
    'src/core/rules/ProgressionRules.ts',
    'src/core/generators/ScaleGenerator.ts',
    'src/core/generators/GeometryGenerator.ts',
    'src/core/generators/LinearEquationGen.ts',
    'src/core/generators/LinearGraphGenerator.ts',
    'src/core/generators/ExpressionSimplificationGen.ts',
    'src/core/generators/LinearEquationProblemGen.ts'
];

const outputFile = 'AI_CONTEXT.md';
let output = "# Anpassa Project Context\n\n";

output += content;
            output += "\n```\n\n";
            console.log(`‚úÖ Added ${filePath}`);
        } else {
            console.warn(`‚ö†Ô∏è  File not found: ${filePath}`);
        }
    } catch (err) {
        console.error(`‚ùå Error reading ${filePath}:`, err.message);
    }
});

// Write the result to AI_CONTEXT.md
fs.writeFileSync(outputFile, output);
console.log(`\nüéâ Success! All files concatenated into ${outputFile}`);

// FILE END: create_context.js

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "version": "2.0.0",
  "description": "Adaptive Math Learning Platform",
  "main": "api/index.ts",
  "scripts": {
    "start": "echo 'Please use: vercel dev' && exit 1",
    "build": "echo 'No build step required for serverless functions' && exit 0"
  },
  "dependencies": {
    "katex": "^0.16.9"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@vercel/node": "^3.0.0",
    "typescript": "^5.3.0"
  },
  "engines": {
    "node": "20.x"
  }
}

// FILE END: package.json

// =======================================================
// FILE START: public\index.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Anpassa | Math Platform</title>

    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
        }

        .katex {
            font-size: 1.1em;
        }

        .drawer-enter {
            transform: translateX(-100%);
        }

        .drawer-enter-active {
            transform: translateX(0);
            transition: transform 300ms;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Modal Animation */
        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }

        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 300ms, transform 300ms;
        }

        /* Custom Scrollbar for inner elements */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Do Now specific */
        .print-break-inside-avoid {
            break-inside: avoid;
        }

        /* Mobile Input Fixes */
        input,
        button,
        select,
        textarea {
            touch-action: manipulation;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        /*******************************************************
         * 0. REACT SETUP & CONSTANTS
         *******************************************************/
        const { useState, useEffect, useRef } = React;

        const CATEGORIES = {
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink",
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
                    { id: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } }
                ]
            },
            algebra: {
                label: { sv: "Algebra", en: "Algebra" },
                color: "indigo",
                topics: [
                    { id: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
                    { id: 'equation', label: { sv: "Ekvationer", en: "Equations" } }                    
                ]
            },
            geometry: {
                label: { sv: "Geometri", en: "Geometry" },
                color: "emerald",
                topics: [
                    { id: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
                    { id: 'scale', label: { sv: "Skala", en: "Scale" } },
                    { id: 'volume', label: { sv: "Volym", en: "Volume" } },
                    { id: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } }
                ]
            },
            functions: {
                label: { sv: "Samband", en: "Functions" },
                color: "purple",
                topics: [
                    { id: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
                ]
            }
        };

        const LEVEL_DESCRIPTIONS = {
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            ten_powers: {
                1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
                2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
                3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
            },
            equation: {
                1: { sv: "Enstegsekvationer", en: "One-step equations" },
                2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
                3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
                4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
                5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
                6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
                7: { sv: "Blandat", en: "Mixed" }
            },
            simplify: {
                1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
                2: { sv: "Parenteser", en: "Distribute into parentheses" },
                3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
                4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
                5: { sv: "Textuppgifter", en: "Word Problems" },
                6: { sv: "Blandat", en: "Mixed" }
            },
            geometry: {
                1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
                2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
                3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
                4: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
                5: { sv: "Sammansatta figurer", en: "Composite shapes" }
            },
            scale: {
                1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
                2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
                3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
                4: { sv: "Ange skala", en: "Determine Scale" },
                5: { sv: "Utan bilder", en: "No Pictures" },
                6: { sv: "Areaskala", en: "Area Scale" },
                7: { sv: "Blandat", en: "Mixed" }
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            similarity: {
                1: { sv: "Likformig eller inte?", en: "Similar or not?" },
                2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
                3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
                4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" } // Added
            },
            graph: {
                1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
                2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
                3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
                4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
                5: { sv: "Blandat", en: "Mixed graphs" }
            }
        }; 

        const UI_TEXT = {
            sv: {
                streak: "",
                loading: "Laddar fr√•ga...", error: "Kunde inte ladda fr√•gan.",
                btnHint: "Ledtr√•d", btnSolution: "Visa l√∂sning", btnSkip: "Hoppa √∂ver",
                submit: "Svara", correct: "R√§tt! N√§sta...", incorrect: "Inte riktigt, f√∂rs√∂k igen", placeholder: "Skriv ditt svar...",
                level: "Niv√•", history: "Historik", noHistory: "Inga svar √§n.", clueUsed: "Hj√§lp",
                dashboardTitle: "V√§lj omr√•de att √∂va p√•",
                progressionInfo: "V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn: "B√∂rja √∂va", backBtn: "Meny", selectLevel: "V√§lj niv√•:",
                hintsTitle: "Ledtr√•dar", prevLevel: "F√∂reg√•ende", nextLevel: "N√§sta",
                levelUpTitle: "Bra jobbat! üî•", levelUpDesc: "Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?", levelUpYes: "N√§sta niv√•", levelUpNo: "Stanna p√• samma niv√•", levelUpHint: "Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn: "Om skaparen", aboutTitle: "Om skaparen", aboutText: "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink: "F√∂lj mig p√• LinkedIn",
                tagline: "R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng",
                menu_btn: "Meny",
                level_breakdown: "Niv√•detaljer",
                stat_skip: "Hoppad",
                stat_wrong: "Fel",
                stat_help: "Hj√§lp",
                stat_correct: "R√§tt",
                stat_total: "Totalt",
                lgr_btn: "LGR22",
                donow_btn: "Do Now",
                donow_title: "Uppstart (Do Now)",
                donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
                donow_gen: "Generera",
                donow_clear: "Rensa",
                donow_show_all: "Visa alla svar",
                donow_hide_all: "D√∂lj alla svar"
            },
            en: {
                streak: "",
                loading: "Loading question...", error: "Could not load question.",
                btnHint: "Hint", btnSolution: "Show Solution", btnSkip: "Skip",
                submit: "Submit", correct: "Correct! Next...", incorrect: "Not quite, try again", placeholder: "Enter your answer...",
                level: "Level", history: "History", noHistory: "No answers yet.", clueUsed: "Clue",
                dashboardTitle: "Choose a topic to practice",
                progressionInfo: "Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn: "Start Practice", backBtn: "Menu", selectLevel: "Select Level:",
                hintsTitle: "Hints", prevLevel: "Previous", nextLevel: "Next",
                levelUpTitle: "Great Job! üî•", levelUpDesc: "You've answered 8 in a row! Do you want to try the next level?", levelUpYes: "Next Level", levelUpNo: "Stay Here", levelUpHint: "Remember, you can always change difficulty manually at the top.",
                aboutBtn: "About the creator", aboutTitle: "About the creator", aboutText: "Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink: "Follow me on LinkedIn",
                tagline: "Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close",
                menu_btn: "Menu",
                level_breakdown: "Level Breakdown",
                stat_skip: "Skip",
                stat_wrong: "Wrong",
                stat_help: "Help",
                stat_correct: "Correct",
                stat_total: "Total",
                lgr_btn: "LGR22",
                donow_btn: "Do Now",
                donow_title: "Do Now Activity",
                donow_desc: "Select up to 3 levels. System generates 6 questions total.",
                donow_gen: "Generate",
                donow_clear: "Clear",
                donow_show_all: "Show all answers",
                donow_hide_all: "Hide all answers"
            }
        };

        /*******************************************************
         * 1. ATOMIC COMPONENTS (Helpers)
         *******************************************************/
        const MathText = ({ text, className = "", large = false }) => {
            if (!text) return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts = patchedText.split(/(\$[^\$]+\$)/g);
            return (<span className={className}>{parts.map((part, index) => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const tex = part.slice(1, -1);
                    try {
                        const html = katex.renderToString(tex, { throwOnError: false, displayMode: large });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) { return <span key={index} className="text-red-500">{part}</span>; }
                } else if (part.includes('\\')) {
                    try {
                        const html = katex.renderToString(part, { throwOnError: false, displayMode: false });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) { return <span key={index}>{part}</span>; }
                }
                return <span key={index}>{part}</span>;
            })}</span>);
        };

        /*******************************************************
         * 2. VISUALIZATION COMPONENTS
         *******************************************************/
        const GraphCanvas = ({ data }) => { const canvasRef = useRef(null); useEffect(() => { const canvas = canvasRef.current; if (!canvas || !data) return; const ctx = canvas.getContext('2d'); const width = canvas.width; const height = canvas.height; const range = data.range || 10; ctx.clearRect(0, 0, width, height); ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const toX = (val) => (val + range) * (width / (range * 2)); const toY = (val) => height - (val + range) * (height / (range * 2)); ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1; for (let i = -range; i <= range; i += data.gridStep || 1) { ctx.beginPath(); ctx.moveTo(toX(i), 0); ctx.lineTo(toX(i), height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, toY(i)); ctx.lineTo(width, toY(i)); ctx.stroke(); } ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(width, toY(0)); ctx.stroke(); ctx.fillStyle = '#6b7280'; const tickSize = 3; const step = data.labelStep || 2; for (let i = -range; i <= range; i += step) { if (i === 0) continue; const xPos = toX(i); const yOrigin = toY(0); ctx.beginPath(); ctx.moveTo(xPos, yOrigin - tickSize); ctx.lineTo(xPos, yOrigin + tickSize); ctx.stroke(); ctx.fillText(i.toString(), xPos, yOrigin + 12); const yPos = toY(i); const xOrigin = toX(0); ctx.beginPath(); ctx.moveTo(xOrigin - tickSize, yPos); ctx.lineTo(xOrigin + tickSize, yPos); ctx.stroke(); ctx.fillText(i.toString(), xOrigin - 12, yPos); } data.lines.forEach(line => { ctx.strokeStyle = line.color || '#dc2626'; ctx.lineWidth = 3; ctx.beginPath(); const x1 = -range; const y1 = line.slope * x1 + line.intercept; const x2 = range; const y2 = line.slope * x2 + line.intercept; ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke(); }); }, [data]); return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>; };

        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const cx = w / 2;
                const cy = h / 2;

                // Reset Canvas
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; 
                ctx.fillStyle = '#f3f4f6'; // Light gray fill
                ctx.lineWidth = 2; 
                ctx.lineJoin = 'round'; 
                ctx.font = "bold 14px Inter, sans-serif"; 
                ctx.textAlign = "center"; 
                ctx.textBaseline = "middle";

                // Helpers
                const drawLabel = (text, x, y, color='#dc2626') => { 
                    if (!text) return;
                    ctx.save(); 
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
                    const m = ctx.measureText(text);
                    ctx.fillRect(x - m.width/2 - 2, y - 10, m.width + 4, 20);
                    ctx.fillStyle = color; 
                    ctx.fillText(text, x, y); 
                    ctx.restore(); 
                };
                
                const drawDashed = (x1, y1, x2, y2) => { 
                    ctx.save(); 
                    ctx.setLineDash([5, 5]); 
                    ctx.beginPath(); 
                    ctx.moveTo(x1, y1); 
                    ctx.lineTo(x2, y2); 
                    ctx.stroke(); 
                    ctx.restore(); 
                };

                const drawDimLine = (x1, y1, x2, y2, label) => {
                    drawDashed(x1, y1, x2, y2);
                    drawLabel(label, (x1+x2)/2, (y1+y2)/2);
                };

                // --- SCALING LOGIC ---
                // We normalize the visual size so 1000mm fits just as well as 5cm
                // We use a target bounding box of approx 160px
                const TARGET_SIZE = 160;
                
                // Extract dimensions based on type to find max value
                let dims = [];
                if (data.labels) {
                   dims = Object.values(data.labels).map(v => parseInt(v)).filter(v => !isNaN(v));
                }
                const maxVal = Math.max(...dims, 10); // Avoid divide by zero
                const scale = TARGET_SIZE / maxVal;

                // Draw Logic based on Type
                if (data.type === 'cuboid') {
                    const dw = (parseInt(data.labels.w) || 10) * scale;
                    const dh = (parseInt(data.labels.h) || 10) * scale;
                    const dd = (parseInt(data.labels.d) || 10) * scale * 0.5; // Foreshorten depth

                    const x0 = cx - dw/2 - dd/2;
                    const y0 = cy + dh/2 + dd/2;

                    // Front Face
                    ctx.strokeRect(x0, y0 - dh, dw, dh);
                    
                    // Sides
                    ctx.beginPath();
                    ctx.moveTo(x0, y0 - dh); ctx.lineTo(x0 + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw, y0 - dh); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dd); ctx.lineTo(x0 + dw, y0); ctx.stroke();

                    drawLabel(data.labels.w, x0 + dw/2, y0 + 15);
                    drawLabel(data.labels.h, x0 - 20, y0 - dh/2);
                    drawLabel(data.labels.d, x0 + dw + dd/2 + 5, y0 - dd/2);
                } 
                else if (data.type === 'triangular_prism') {
                    const b = (parseInt(data.labels.b) || 10) * scale;
                    const hTri = (parseInt(data.labels.h) || 10) * scale;
                    const len = (parseInt(data.labels.l) || 20) * scale * 0.7; // Foreshorten length

                    const startX = cx - b/2 - len/2;
                    const startY = cy + hTri/2;

                    // Front Triangle
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(startX + b, startY);
                    ctx.lineTo(startX + b/2, startY - hTri);
                    ctx.closePath();
                    ctx.stroke();

                    // Connector Lines
                    const offX = len; const offY = -len * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(startX + b/2, startY - hTri); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(startX + b, startY); ctx.lineTo(startX + b + offX, startY + offY); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
                    
                    // Dashed Back
                    drawDashed(startX + b/2, startY, startX + b/2, startY - hTri); // Height
                    drawLabel(data.labels.h, startX + b/2 + 10, startY - hTri/2);
                    drawLabel(data.labels.b, startX + b/2, startY + 15);
                    drawLabel(data.labels.l, startX + b + offX/2 + 10, startY + offY/2);
                }
                else if (data.type === 'pyramid') {
                    const s = (parseInt(data.labels.s) || 10) * scale;
                    const hPyr = (parseInt(data.labels.h) || 10) * scale;
                    
                    // Draw base as parallelogram
                    const dx = s/2; const dy = s/4;
                    const bx = cx; const by = cy + hPyr/3;
                    
                    const vApex = { x: bx, y: by - hPyr };
                    const vFL = { x: bx - dx, y: by + dy }; // Front Left
                    const vFR = { x: bx + dx, y: by + dy }; // Front Right
                    const vBL = { x: bx - dx + 20, y: by - dy }; // Back Left
                    const vBR = { x: bx + dx + 20, y: by - dy }; // Back Right (Hidden mostly)

                    ctx.beginPath(); ctx.moveTo(vFL.x, vFL.y); ctx.lineTo(vFR.x, vFR.y); ctx.lineTo(vApex.x, vApex.y); ctx.closePath(); ctx.stroke(); // Front Face
                    ctx.beginPath(); ctx.moveTo(vFL.x, vFL.y); ctx.lineTo(vBL.x, vBL.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); // Side Face

                    drawDashed(bx, by, vApex.x, vApex.y); // Height
                    drawLabel(data.labels.h, bx + 15, by - hPyr/2);
                    drawLabel(data.labels.s, bx, by + dy + 15);
                }
                else {
                    // SPHERES, CONES, CYLINDERS, COMPOSITES
                    // Standard radius for visual if not strictly scaled, or scaled if available
                    // For these shapes, usually r and h are key.
                    
                    // Base visual radius (scaled)
                    let r = 50; 
                    if(data.labels.r) r = parseInt(data.labels.r) * scale;
                    if(data.labels.d) r = (parseInt(data.labels.d)/2) * scale;
                    // Clamp visual radius so it doesn't get too tiny or huge
                    r = Math.max(30, Math.min(r, 80));

                    const drawCircleData = (centerY, showLabel=true) => {
                     const val = data.labels.val || (data.labels.r ? `r=${data.labels.r}` : `d=${data.labels.d}`);
                     
                     // Check for both 'diameter' AND 'd' to ensure the line is drawn across the full width
                     if (data.show === 'diameter' || data.show === 'd') {
                         drawDashed(cx - r, centerY, cx + r, centerY);
                         if(showLabel) drawLabel(val, cx, centerY - 10);
                            } 
                        else {
                         // Radius - Draw from center to right
                         ctx.beginPath(); ctx.arc(cx, centerY, 2, 0, 2*Math.PI); ctx.fill(); // Center dot
                         drawDashed(cx, centerY, cx + r, centerY);
                         if(showLabel) drawLabel(val, cx + r/2, centerY - 10);
                            }
                     };

                    if (data.type === 'sphere' || data.type === 'hemisphere') {
                        const isHemi = data.type === 'hemisphere';
                        const yBase = isHemi ? cy + 10 : cy;
                        
                        ctx.beginPath(); ctx.arc(cx, yBase, r, isHemi ? Math.PI : 0, isHemi ? 0 : 2*Math.PI); ctx.stroke();
                        
                        // Equator / Base ellipse
                        ctx.beginPath(); ctx.ellipse(cx, yBase, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                        
                        // Draw diameter/radius line
                        drawCircleData(yBase);
                    }
                    else if (data.type === 'cylinder') {
                        const hCyl = (parseInt(data.labels.h) || 10) * scale;
                        const topY = cy - hCyl/2;
                        const botY = cy + hCyl/2;

                        ctx.beginPath(); ctx.ellipse(cx, topY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                        ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke(); // Bottom half
                        ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore(); // Hidden back

                        ctx.beginPath(); ctx.moveTo(cx-r, topY); ctx.lineTo(cx-r, botY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx+r, topY); ctx.lineTo(cx+r, botY); ctx.stroke();

                        drawLabel(data.labels.h, cx + r + 15, cy);
                        drawCircleData(topY, true);
                    }
                    else if (data.type === 'cone') {
                         const hCone = (parseInt(data.labels.h) || 10) * scale;
                         const botY = cy + hCone/2;
                         const topY = cy - hCone/2;

                         ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                         ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                         
                         ctx.beginPath(); ctx.moveTo(cx-r, botY); ctx.lineTo(cx, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                         
                         drawDashed(cx, topY, cx, botY); // Height line
                         drawLabel(data.labels.h, cx + 5, cy);
                         drawCircleData(botY, true);
                    }
                    else if (data.type === 'silo') {
                        // Cylinder body + Hemisphere Top
                        const hCyl = 80; 
                        const topY = cy - hCyl/2;
                        const botY = cy + hCyl/2;

                        // Cylinder Body
                        ctx.beginPath(); ctx.moveTo(cx-r, topY); ctx.lineTo(cx-r, botY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx+r, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                        
                        // Bottom Ellipse
                        ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                        ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();

                        // Top Hemisphere
                        ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke();
                        // Top Ellipse (seam)
                        ctx.beginPath(); ctx.ellipse(cx, topY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();

                        drawLabel(data.labels.h, cx + r + 15, cy);
                        drawCircleData(botY);
                    }
                    else if (data.type === 'ice_cream') {
                         // Cone Bottom + Hemisphere Top
                         const hCone = 100;
                         const midY = cy - 20;
                         const botY = midY + hCone;

                         // Cone
                         ctx.beginPath(); ctx.moveTo(cx-r, midY); ctx.lineTo(cx, botY); ctx.lineTo(cx+r, midY); ctx.stroke();
                         
                         // Hemisphere Top
                         ctx.beginPath(); ctx.arc(cx, midY, r, Math.PI, 0); ctx.stroke();
                         
                         // Seam Ellipse
                         ctx.beginPath(); ctx.ellipse(cx, midY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();

                         drawLabel(data.labels.h, cx + r + 10, midY + hCone/2);
                         drawCircleData(midY);
                    }
                }
            }, [data]);

            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w = 300, h = 200, viewBox = "0 0 300 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[300px] mx-auto">{children}</svg>;
            
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                // Auto-scale to fit 180x180 box
                const size = Math.max(w, h, r * 2);
                const scale = 120 / (size || 1);
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;

                // Helper for text - INCREASED FONT SIZE to 24
                const mkTxt = (x, y, txt, anchor="middle", baseline="middle") => 
                    <text x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill="#374151" fontSize="24">{txt}</text>;

                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') 
                        return (<><rect x={cx - sw / 2} y={cy - sh / 2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy + sh / 2 + 25} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="24">{dims.width}</text><text x={cx + sw / 2 + 10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151" fontSize="24">{dims.height}</text></>)}</>);
                    
                    if (type === 'triangle') {
                        // Coordinates based on orientation
                        const orient = data.orientation || 'up';
                        // Bounding Box
                        const L = cx - sw/2, R = cx + sw/2, T = cy - sh/2, B = cy + sh/2;
                        
                        let points="", hLine=null, bLabel=null, hLabel=null;

                        // Simple Triangle Logic for Shapes (Standard Up)
                        points = `${L},${B} ${R},${B} ${cx},${T}`;
                        hLine = <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />;
                        bLabel = mkTxt(cx, B + 25, dims.width); 
                        hLabel = <text x={cx + 5} y={cy} textAnchor="start" dominantBaseline="middle" fontWeight="bold" fill="#374151" fontSize="24">h={dims.height}</text>;

                        return (<>{hLine}<polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />{bLabel}{hLabel}</>);
                    }

                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="24">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx - sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx + sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="24">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[150px] md:max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="20" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };

            // --- SCALE LEVELS 1-4 (Emojis/Icons) ---
            if (data.type === 'scale_single' || data.type === 'scale_compare') { 
                const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; 
                const emoji = shapeEmojis[data.shape] || 'üì¶'; 
                const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl select-none" style={{ fontSize: size }}>{emoji}</div>; 
                
                if (data.type === 'scale_single') 
                    // INCREASED TEXT SIZE: text-sm -> text-3xl
                    return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="80px" /><span className="bg-white px-4 py-2 rounded shadow text-3xl font-bold font-mono border border-gray-200">{data.label}</span></div>; 
                
                return (
                    <div className="flex items-center justify-center gap-4 sm:gap-8 my-6">
                        {/* INCREASED TEXT SIZES: text-xs -> text-base, text-sm -> text-2xl */}
                        <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="60px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.leftValue}</span></div>
                        <div className="text-gray-300 text-3xl">‚Üí</div>
                        <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="100px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.rightValue}</span></div>
                    </div>
                ); 
            }

            // --- SCALE LEVEL 5-6 (Geometric Shapes) - COMPACTED FOR DO NOW ---
            if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { 
                const showLabels = data.type === 'compare_shapes'; 
                const showArea = data.type === 'compare_shapes_area'; 
                return (
                    <div className="flex justify-center items-center gap-2 my-2 w-full">
                        <div className="flex flex-col items-center">
                            {/* INCREASED LABEL SIZE: text-[10px] -> text-sm */}
                            <span className="text-sm font-bold uppercase text-gray-400 mb-1">{data.left.label}</span>
                            <div className="scale-90 origin-top">
                                <RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} />
                            </div>
                        </div>
                        <div className="text-gray-300 text-2xl mx-1 shrink-0">‚Üí</div>
                        <div className="flex flex-col items-center">
                             {/* INCREASED LABEL SIZE: text-[10px] -> text-sm */}
                            <span className="text-sm font-bold uppercase text-gray-400 mb-1">{data.right.label}</span>
                            <div className="scale-90 origin-top">
                                <RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} />
                            </div>
                        </div>
                    </div>
                ); 
            }

            // --- SIMILARITY COMPARISON (Side-by-Side) ---
            if (data.type === 'similarity_compare') {
                const isRect = data.shapeType === 'rectangle';
                // Helper to draw angle arc
                const drawAngle = (x, y, r, startAng, endAng, label) => {
                    const x1 = x + r * Math.cos(startAng); const y1 = y - r * Math.sin(startAng);
                    const x2 = x + r * Math.cos(endAng); const y2 = y - r * Math.sin(endAng);
                    const pathData = `M ${x1} ${y1} A ${r} ${r} 0 0 0 ${x2} ${y2}`;
                    return (<g><path d={pathData} fill="none" stroke="#ef4444" strokeWidth="2" />{label && <text x={x + (r*1.8)*Math.cos((startAng+endAng)/2)} y={y - (r*1.8)*Math.sin((startAng+endAng)/2)} textAnchor="middle" dominantBaseline="middle" fontSize="14" fill="#ef4444" fontWeight="bold">{label}</text>}</g>);
                };
                return (
                    <SvgContainer viewBox="-10 0 370 200">
                        {/* INCREASED SVG TEXT SIZES to 16/18 */}
                        <g transform="translate(30, 50)">{isRect ? (<><rect x="0" y="0" width="100" height="70" fill="#ecfdf5" stroke="#10b981" strokeWidth="2" /><text x="50" y="-12" textAnchor="middle" fontSize="18" fontWeight="bold" fill="#374151">{data.left.labels?.b}</text><text x="-12" y="35" textAnchor="end" fontSize="18" dominantBaseline="middle" fontWeight="bold" fill="#374151">{data.left.labels?.h}</text></>) : (<><polygon points="0,100 80,100 20,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="2" />{data.left.labels?.s1 && <text x="40" y="115" textAnchor="middle" fontSize="18" fontWeight="bold" fill="#374151">{data.left.labels.s1}</text>}{data.left.labels?.s2 && <text x="60" y="55" textAnchor="start" fontSize="18" fontWeight="bold" fill="#374151">{data.left.labels.s2}</text>}</>)}</g>
                        <text x="170" y="90" fontSize="24" fill="#cbd5e1" fontWeight="bold">‚Üí</text>
                        <g transform="translate(220, 30)">{isRect ? (<><rect x="0" y="0" width="130" height="90" fill="#ecfdf5" stroke="#10b981" strokeWidth="2" /><text x="65" y="-12" textAnchor="middle" fontSize="18" fontWeight="bold" fill="#374151">{data.right.labels?.b}</text><text x="-12" y="45" textAnchor="end" fontSize="18" dominantBaseline="middle" fontWeight="bold" fill="#374151">{data.right.labels?.h}</text></>) : (<><polygon points="0,120 120,120 30,0" fill="#ecfdf5" stroke="#10b981" strokeWidth="2" />{data.right.labels?.s1 && <text x="60" y="135" textAnchor="middle" fontSize="18" fontWeight="bold" fill="#374151">{data.right.labels.s1}</text>}{data.right.labels?.s2 && <text x="90" y="60" textAnchor="start" fontSize="18" fontWeight="bold" fill="#374151">{data.right.labels.s2}</text>}</>)}</g>
                    </SvgContainer>
                );
            } 

            if (data.type === 'rectangle' || data.type === 'square' || data.type === 'parallelogram') {
                return (<div className="flex justify-center my-4"><RenderShape type={data.type} dims={data} labels={true} areaText={null} /></div>);
            }

            // --- TRANSVERSAL & HOURGLASS ---
            if (data.type === 'transversal' || data.type === 'hourglass') {
                 const isT = data.type === 'transversal';
                 // INCREASED FONT SIZES 12 -> 16
                 return (
                    <SvgContainer viewBox="0 0 200 200">
                        <defs><marker id="arrow" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto"><path d="M0,0 L6,3 L0,6" fill="#6b7280" /></marker></defs>
                        <g transform="translate(50, 20)">
                           {isT ? (<><polygon points="50,0 0,150 100,150" fill="none" stroke="#e5e7eb" strokeWidth="2" /><line x1="16.5" y1="50" x2="83.5" y2="50" stroke="#10b981" strokeWidth="2" /><path d="M 50 50 l 4 0" stroke="#065f46" strokeWidth="2" markerEnd="url(#arrow)" /><path d="M 50 150 l 4 0" stroke="#065f46" strokeWidth="2" markerEnd="url(#arrow)" /><text x="50" y="45" textAnchor="middle" fontSize="16" fontWeight="bold">{data.labels.base_top}</text><text x="50" y="165" textAnchor="middle" fontSize="16" fontWeight="bold">{data.labels.base_bot}</text><text x="5" y="30" textAnchor="end" fontSize="16" fontWeight="bold">{data.labels.left_top}</text><text x="-10" y="80" textAnchor="end" fontSize="16" fontWeight="bold">{data.labels.left_tot}</text></>) 
                           : (<><polygon points="0,0 80,0 40,40" fill="#ecfdf5" stroke="#10b981" strokeWidth="2" /><polygon points="40,40 0,100 120,100" fill="#f0f9ff" stroke="#3b82f6" strokeWidth="2" /><text x="40" y="-5" textAnchor="middle" fontSize="16" fontWeight="bold">{data.labels.top_base}</text><text x="60" y="115" textAnchor="middle" fontSize="16" fontWeight="bold">{data.labels.bot_base}</text></>)}
                        </g>
                    </SvgContainer>
                 );
            }
            
            // --- TRIANGLES (Pythagoras & Area) ---
            if (data.type === 'triangle') { 
                const w = data.width || 0, h = data.height || 0; 
                const maxDim = Math.max(w, h); 
                const scale = 140 / (maxDim || 1); 
                const bVal = w * scale; 
                const hVal = h * scale; 
                const cx = 150, cy = 100; 

                // Bounding Box Corners
                const L = cx - bVal/2; // Left
                const R = cx + bVal/2; // Right
                const T = cy - hVal/2; // Top
                const B = cy + hVal/2; // Bottom
                
                let points = "", rightAngle = null, hLine = null;
                let bLabel = null, hLabel = null, hypLabel = null;
                
                const orient = data.orientation || 'up'; 
                const isRight = data.subtype === 'right'; 

                // Helper for text - INCREASED FONT SIZE to 22
                const mkTxt = (x, y, txt, anchor="middle", baseline="middle") => 
                    <text x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill="#374151" fontSize="22">{txt}</text>;

                if (orient === 'up') { 
                    if (isRight) {
                        points = `${L},${B} ${R},${B} ${L},${T}`;
                        rightAngle = <path d={`M ${L+10} ${B} L ${L+10} ${B-10} L ${L} ${B-10}`} fill="none" stroke="#6b7280" strokeWidth="1.5" />;
                        bLabel = mkTxt(cx, B + 25, data.labels.base, "middle");
                        hLabel = mkTxt(L - 15, cy, data.labels.height, "end");
                        if(data.labels.hypotenuse) hypLabel = mkTxt((R+L)/2 + 10, (B+T)/2 - 10, data.labels.hypotenuse, "start");
                    } else {
                        points = `${L},${B} ${R},${B} ${cx},${T}`;
                        hLine = <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />;
                        bLabel = mkTxt(cx, B + 25, data.labels.base, "middle");
                        hLabel = <text x={cx + 5} y={cy} textAnchor="start" dominantBaseline="middle" fontWeight="bold" fill="#374151" fontSize="22">h={data.labels.height}</text>;
                    }
                } 
                else if (orient === 'down') {
                    points = `${R},${T} ${L},${T} ${R},${B}`;
                    if (isRight) rightAngle = <path d={`M ${R-10} ${T} L ${R-10} ${T+10} L ${R} ${T+10}`} fill="none" stroke="#6b7280" strokeWidth="1.5" />;
                    bLabel = mkTxt(cx, T - 25, data.labels.base, "middle");
                    hLabel = mkTxt(R + 15, cy, data.labels.height, "start");
                    if(data.labels.hypotenuse) hypLabel = mkTxt((L+R)/2 - 10, (B+T)/2 + 10, data.labels.hypotenuse, "end");
                }
                else if (orient === 'left') {
                    points = `${R},${B} ${L},${B} ${R},${T}`;
                    if (isRight) rightAngle = <path d={`M ${R-10} ${B} L ${R-10} ${B-10} L ${R} ${B-10}`} fill="none" stroke="#6b7280" strokeWidth="1.5" />;
                    bLabel = mkTxt(cx, B + 25, data.labels.base, "middle");
                    hLabel = mkTxt(R + 15, cy, data.labels.height, "start");
                    if(data.labels.hypotenuse) hypLabel = mkTxt((L+R)/2 - 10, (B+T)/2 - 10, data.labels.hypotenuse, "end");
                }
                else if (orient === 'right') {
                    points = `${L},${T} ${R},${T} ${L},${B}`;
                    if (isRight) rightAngle = <path d={`M ${L+10} ${T} L ${L+10} ${T+10} L ${L} ${T+10}`} fill="none" stroke="#6b7280" strokeWidth="1.5" />;
                    bLabel = mkTxt(cx, T - 25, data.labels.base, "middle");
                    hLabel = mkTxt(L - 15, cy, data.labels.height, "end");
                    if(data.labels.hypotenuse) hypLabel = mkTxt((L+R)/2 + 10, (B+T)/2 + 10, data.labels.hypotenuse, "start");
                }
                
                return ( <SvgContainer>{rightAngle}<polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />{hLine}{bLabel}{hLabel}{hypLabel}</SvgContainer> ); 
            }
            
            if (data.type === 'circle') { const cx = 100, cy = 100, r = 70; return (<SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx - r} y1={cy} x2={cx + r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx + r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx + r / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">r = {data.value}</text></>)}</SvgContainer>); } 
            
            // --- COMPOSITES ---
            if (data.type === 'composite') {
                if (data.subtype === 'house') {
                    // INCREASED FONT SIZES
                    return (<SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h_roof}</text></SvgContainer>);
                }
                if (data.subtype === 'portal') {
                    // INCREASED FONT SIZES
                    return (<SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text><text x="160" y="120" textAnchor="start" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text></SvgContainer>);
                }
            }
            
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>;
        };

        const StaticGeometryVisual = ({ description }) => { if (!description) return null; const d = description.toLowerCase(); if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; return null; };

        /*******************************************************
         * 3. UI COMPONENTS (Modals, Panels)
         * DEFINED BEFORE USE to avoid Hoisting Errors
         *******************************************************/

        // NEW: LGR22 Modal
        const LgrModal = ({ visible, onClose, ui }) => {
            const [data, setData] = useState(null);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if (visible && !data) {
                    setLoading(true);
                    fetch('/api/curriculum')
                        .then(res => res.json())
                        .then(d => { setData(d); setLoading(false); })
                        .catch(err => { console.error(err); setLoading(false); });
                }
            }, [visible, data]);

            if (!visible) return null;

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
                    <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden">
                        <div className="flex justify-between items-start mb-6 shrink-0">
                            <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                            <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600">‚úï</button>
                        </div>

                        <div className="overflow-y-auto custom-scrollbar flex-1 pr-2">
                            {loading ? (
                                <div className="py-10 text-center text-slate-400">Laddar l√§roplan...</div>
                            ) : data ? (
                                <div className="space-y-8">
                                    <p className="text-slate-600 italic">{data.description}</p>

                                    <div>
                                        <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                        <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700">
                                            {data.syfte.map((s, i) => <li key={i}>{s}</li>)}
                                        </ul>
                                    </div>

                                    <div>
                                        <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Centralt Inneh√•ll (√•k 7-9)</h4>
                                        <div className="grid gap-6">
                                            {Object.entries(data.mapping).map(([key, section]) => (
                                                <div key={key} className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                                    <h5 className="font-bold text-slate-900 mb-2 text-sm">{section.category}</h5>
                                                    <ul className="list-disc pl-5 space-y-1 text-xs text-slate-600">
                                                        {section.content.map((c, i) => <li key={i}>{c}</li>)}
                                                    </ul>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            ) : (
                                <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                            )}
                        </div>

                        <div className="mt-6 pt-4 border-t border-slate-100 text-center">
                            <a href="https://www.skolverket.se" target="_blank" className="text-xs text-sky-600 hover:underline">K√§lla: Skolverket (Lgr22)</a>
                        </div>
                    </div>
                </div>
            );
        };

        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        }; 

        // NEW: Granular Breakdown Component (Updated Layout for Segmented Progress)
        const LevelBreakdown = ({ granularStats, ui, lang }) => {
            const topics = Object.keys(granularStats);
            if (topics.length === 0) return null;

            return (
                <div className="mt-6 border-t border-gray-100 pt-4 w-full">
                    <h4 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-4">
                        {ui.level_breakdown}
                    </h4>
                    <div className="space-y-4">
                        {topics.map(topicKey => {
                            const topicLevels = granularStats[topicKey];
                            const levels = Object.keys(topicLevels).sort((a, b) => Number(a) - Number(b));

                            // Find category label
                            let topicLabel = topicKey;
                            for (const catKey in CATEGORIES) {
                                const found = CATEGORIES[catKey].topics.find(t => t.id === topicKey);
                                if (found) {
                                    topicLabel = found.label[lang];
                                    break;
                                }
                            }

                            return (
                                <div key={topicKey} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                                    <h5 className="font-bold text-gray-700 text-sm mb-2 capitalize">{topicLabel}</h5>
                                    <div className="space-y-2">
                                        {levels.map(lvl => {
                                            const stats = topicLevels[lvl];
                                            const total = stats.skipped + stats.incorrect + stats.correctHelp + stats.correctNoHelp;

                                            if (total === 0) return null;

                                            const pSkip = (stats.skipped / total) * 100;
                                            const pWrong = (stats.incorrect / total) * 100;
                                            const pHelp = (stats.correctHelp / total) * 100;
                                            const pCorrect = (stats.correctNoHelp / total) * 100;

                                            // Calculate unassisted percentage for the summary text
                                            const unassistedPct = Math.round(pCorrect);

                                            return (
                                                <div key={lvl} className="flex flex-col gap-1 mb-3 last:mb-0">
                                                    <div className="flex justify-between items-center text-xs font-medium text-gray-500 mb-1">
                                                        <span>{lang === 'sv' ? 'Niv√•' : 'Level'} {lvl}</span>
                                                    </div>

                                                    {/* Segmented Progress Bar */}
                                                    <div className="flex w-full h-3 rounded-full overflow-hidden bg-gray-200">
                                                        {pSkip > 0 && <div style={{ width: `${pSkip}%` }} className="bg-gray-400" />}
                                                        {pWrong > 0 && <div style={{ width: `${pWrong}%` }} className="bg-red-500" />}
                                                        {pHelp > 0 && <div style={{ width: `${pHelp}%` }} className="bg-yellow-400" />}
                                                        {pCorrect > 0 && <div style={{ width: `${pCorrect}%` }} className="bg-green-500" />}
                                                    </div>

                                                    {/* Detailed text stats below */}
                                                    <div className="flex flex-wrap gap-x-3 text-[10px] text-gray-500 mt-1">
                                                        <span className="text-gray-500 font-semibold">{ui.stat_skip}: {stats.skipped}</span>
                                                        <span className="text-red-600 font-semibold">{ui.stat_wrong}: {stats.incorrect}</span>
                                                        <span className="text-yellow-600 font-semibold">{ui.stat_help}: {stats.correctHelp}</span>
                                                        <span className="text-green-600 font-semibold">{ui.stat_correct}: {stats.correctNoHelp}</span>
                                                    </div>
                                                    <div className="text-[10px] text-gray-400 italic">
                                                        {ui.stat_total}: {total} ({unassistedPct}% unassisted)
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // UPDATED: Stats Modal with Vertical Stack Scroll
        const StatsModal = ({ visible, stats, granularStats, ui, onClose, title, lang }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

            return (
                <div className="fixed inset-0 z-[100] flex sm:items-center justify-center sm:p-4 bg-white sm:bg-black/50 sm:backdrop-blur-sm fade-in">
                    {/* Modal Container: Scrollable as one unit */}
                    <div className="bg-white w-full h-full sm:h-auto sm:max-h-[90vh] sm:rounded-2xl sm:shadow-2xl sm:max-w-md p-6 relative flex flex-col sm:border-4 sm:border-blue-500 overflow-y-auto custom-scrollbar">

                        <div className="flex justify-between items-center mb-6 shrink-0">
                            <h3 className="text-2xl font-bold text-gray-900">{title || ui.stats_title}</h3>
                            <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 sm:hidden">‚úï</button>
                        </div>

                        {/* Global Stats Grid */}
                        <div className="shrink-0 grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>

                        {/* Level Breakdown - Stacked underneath */}
                        <LevelBreakdown granularStats={granularStats} ui={ui} lang={lang} />

                        <button onClick={onClose} className="mt-8 w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg shrink-0 hidden sm:block">
                            {ui.stats_close}
                        </button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1">‚úï</button>

                        <div className="mb-4 flex justify-center">
                            <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100">
                                <img
                                    src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                                    alt="Creator"
                                    className="w-full h-full object-cover"
                                />
                            </div>
                        </div>

                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" /></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList = ({ history, ui }) => (<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length === 0 ? <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p> : history.map((entry, i) => (<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct ? 'border-primary-500 bg-primary-50' : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text} /></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`} /></div>}<div>{entry.clueUsed && <span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer = ({ open, onClose, history, ui }) => (<>{open && <div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui} /></div></div></>);

        const CluePanel = ({ revealedClues, question, ui, isSolutionRevealed }) => {
            if (!revealedClues || revealedClues.length === 0) return null;
            return (
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue, i) => {
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text} />
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true} />
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        /*******************************************************
         * 4. DO NOW COMPONENTS (New Feature)
         *******************************************************/

        const DoNowConfig = ({ ui, onBack, onGenerate, lang }) => {
            const [selected, setSelected] = useState([]);

            const handleToggle = (topicId, level) => {
                setSelected(prev => {
                    const exists = prev.find(p => p.topic === topicId && p.level === level);
                    if (exists) {
                        return prev.filter(p => !(p.topic === topicId && p.level === level));
                    } else {
                        if (prev.length >= 3) return prev; // Max 3
                        return [...prev, { topic: topicId, level }];
                    }
                });
            };

            return (
                <div className="max-w-5xl mx-auto p-6 h-full flex flex-col">
                    <div className="flex justify-between items-center mb-6">
                        <button onClick={onBack} className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2">
                            <span>‚Üê</span> {ui.backBtn}
                        </button>
                        <h2 className="text-2xl font-bold text-slate-800">{ui.donow_title}</h2>
                        <button
                            onClick={() => onGenerate(selected)}
                            disabled={selected.length === 0}
                            className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
                        >
                            {ui.donow_gen} ({selected.length}/3)
                        </button>
                    </div>

                    <p className="text-slate-500 mb-6 text-center">{ui.donow_desc}</p>

                    <div className="grid grid-cols-2 md:grid-cols-4 gap-6 overflow-y-auto custom-scrollbar pb-10">
                        {Object.entries(CATEGORIES).map(([catKey, category]) => (
                            <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                                <h3 className="font-bold text-slate-700 mb-3 border-b pb-2">{category.label[lang]}</h3>
                                <div className="space-y-4">
                                    {category.topics.map(topic => (
                                        <div key={topic.id}>
                                            <div className="text-xs font-bold text-slate-400 uppercase mb-2">{topic.label[lang]}</div>
                                            <div className="flex flex-col gap-2">
                                                {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                    if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                    const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);
                                                    return (
                                                        <button
                                                            key={lvl}
                                                            onClick={() => handleToggle(topic.id, lvl)}
                                                            className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${isSelected ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'}`}
                                                        >
                                                            <span className="font-mono font-bold w-6 text-center bg-white/50 rounded">{lvl}</span>
                                                            <span className="truncate">{LEVEL_DESCRIPTIONS[topic.id][lvl][lang]}</span>
                                                        </button>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const DoNowCard = ({ q, index, showAnswer, onToggle, lang }) => {
            // Need description text
            const desc = typeof q.renderData.description === 'object' ? q.renderData.description[lang] : q.renderData.description;

            return (
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 flex flex-col h-full overflow-hidden print-break-inside-avoid relative">
                    <div className="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center shrink-0">
                        <span className="text-xs font-bold text-slate-400 uppercase">Q{index + 1} ‚Ä¢ {q.topic} L{q.level}</span>
                    </div>

                    <div className="p-4 flex-1 flex flex-col gap-4 relative">
                        {/* 1. VISUALIZATION ZONE */}
                        <div className="flex-1 bg-slate-50/50 rounded-lg border border-slate-100 flex items-center justify-center min-h-[150px] p-2 relative overflow-hidden">
                            <div className="scale-90 origin-center w-full flex justify-center">
                                {q.renderData.graph ? (
                                    <GraphCanvas data={q.renderData.graph} />
                                ) : q.renderData.geometry ? (
                                    ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(q.renderData.geometry.type)
                                        ? <VolumeVisualization data={q.renderData.geometry} />
                                        : <GeometryVisual data={q.renderData.geometry} />
                                ) : (
                                    q.topic === 'geometry' ? <StaticGeometryVisual description={desc} /> :
                                        <div className="text-4xl text-slate-200 font-bold select-none opacity-20">#</div>
                                )}
                            </div>
                        </div>

                        {/* 2. TEXT ZONE - IMPROVED VISIBILITY FOR PROJECTORS */}
                        <div className="shrink-0 text-center space-y-3 min-h-[6rem] flex flex-col justify-center py-2">
                            {q.renderData.latex && (
                                <div className="text-3xl md:text-5xl font-mono text-slate-900 font-bold tracking-wider">
                                    <MathText text={`$${q.renderData.latex}$`} large={false} />
                                </div>
                            )}
                            {desc && (
                                <div className="text-lg md:text-2xl font-medium text-slate-700 leading-snug max-w-prose mx-auto">
                                    <MathText text={desc} />
                                </div>
                            )}
                        </div>

                        {/* ANSWER OVERLAY (Inside content area) */}
                        <div className={`absolute inset-0 bg-white/95 backdrop-blur-sm z-10 flex items-center justify-center transition-opacity duration-300 ${showAnswer ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                            <div className="text-center transform scale-110">
                                <div className="text-sm text-slate-400 uppercase font-bold mb-2">Facit</div>
                                <div className="text-4xl font-bold text-emerald-600 font-mono px-4">{q.displayAnswer}</div>
                            </div>
                        </div>
                    </div>

                    <button
                        onClick={onToggle}
                        className="w-full py-4 bg-slate-50 hover:bg-slate-100 border-t border-slate-100 text-sm font-bold text-slate-500 transition-colors shrink-0 z-20"
                    >
                        {showAnswer ? (lang === 'sv' ? "D√∂lj" : "Hide") : (lang === 'sv' ? "Visa svar" : "Show Answer")}
                    </button>
                </div>
            );
        };

        const DoNowGrid = ({ questions, ui, onBack, lang }) => {
            const [revealed, setRevealed] = useState({}); // { 0: true, 1: false }
            const [showAll, setShowAll] = useState(false);

            const toggleOne = (idx) => {
                setRevealed(prev => ({ ...prev, [idx]: !prev[idx] }));
            };

            const toggleAll = () => {
                if (showAll) {
                    setRevealed({});
                    setShowAll(false);
                } else {
                    const all = {};
                    questions.forEach((_, i) => all[i] = true);
                    setRevealed(all);
                    setShowAll(true);
                }
            };

            return (
                <div className="h-screen flex flex-col bg-slate-100">
                    <header className="bg-white border-b border-slate-200 px-6 py-3 flex justify-between items-center shadow-sm z-20">
                        <button onClick={onBack} className="flex items-center gap-2 text-slate-600 font-bold hover:text-slate-900">
                            <span>‚Üê</span> {ui.donow_title}
                        </button>
                        <div className="flex gap-4">
                            <button onClick={toggleAll} className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg font-bold text-sm transition-colors">
                                {showAll ? ui.donow_hide_all : ui.donow_show_all}
                            </button>
                        </div>
                    </header>
                    <div className="flex-1 p-6 overflow-y-auto">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 h-full auto-rows-fr">
                            {questions.map((q, i) => (
                                <DoNowCard
                                    key={i}
                                    index={i}
                                    q={q}
                                    showAnswer={!!revealed[i]}
                                    onToggle={() => toggleOne(i)}
                                    lang={lang}
                                />
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        /*******************************************************
         * 5. MAIN VIEWS (Dashboard, PracticeView)
         *******************************************************/

        const Dashboard = ({ lang, onStart, selectedTopic, selectedLevel, onSelect, timerSettings, toggleTimer, resetTimer, ui, onLgrOpen, onDoNowOpen, toggleLang }) => {
            const getCategoryColorClass = (category, type) => { const colorMap = { pink: 'pink', indigo: 'indigo', emerald: 'emerald', purple: 'purple' }; const color = colorMap[category.color] || 'primary'; if (type === 'bg-light') return `bg-${color}-50`; if (type === 'bg-dark') return `bg-${color}-500`; if (type === 'border') return `border-${color}-100`; if (type === 'text') return `text-${color}-700`; if (type === 'ring') return `ring-${color}-500`; if (type === 'border-solid') return `border-${color}-500`; return ''; };
            return (
                <div className="max-w-6xl mx-auto w-full p-4 fade-in flex flex-col min-h-screen">
                    <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4 relative overflow-hidden">
                        <h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight relative z-10">Anpassa</h1>
                        <p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide relative z-10">{ui.tagline}</p>

                        {/* TIMER SELECTOR - MOVED INTO DASHBOARD HEADER */}
                        <div className="mt-8 flex justify-center relative z-10">
                            <div className="bg-white/80 backdrop-blur-sm rounded-xl p-2 px-4 shadow-sm border border-gray-100 flex items-center gap-3">
                                <span className="font-bold text-gray-700 text-xs uppercase tracking-wider">{ui.timer_title}</span>
                                <div className="relative group">
                                    <select
                                        value={timerSettings.duration / 60}
                                        onChange={(e) => toggleTimer(Number(e.target.value))}
                                        className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                    >
                                        <option value="0">{ui.timer_off}</option>
                                        {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                    </select>
                                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                    </div>
                                </div>
                                {timerSettings.duration > 0 && (
                                    <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">
                        {Object.entries(CATEGORIES).map(([catKey, category]) => {
                            const bgLight = getCategoryColorClass(category, 'bg-light');
                            const border = getCategoryColorClass(category, 'border');
                            const text = getCategoryColorClass(category, 'text');
                            const bgDark = getCategoryColorClass(category, 'bg-dark');
                            return (
                                <div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}>
                                    <div className={`${bgLight} p-4 border-b ${border}`}>
                                        <h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3>
                                    </div>
                                    <div className="p-4 space-y-4 flex-1">
                                        {category.topics.map(topic => {
                                            const ring = getCategoryColorClass(category, 'ring');
                                            const borderSolid = getCategoryColorClass(category, 'border-solid');
                                            return (
                                                <div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                                                    <div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div>
                                                    <div className="relative">
                                                        <select value={selectedTopic === topic.id ? selectedLevel : 0} onChange={(e) => onSelect(topic.id, Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic === topic.id ? `ring-2 ${ring} ${borderSolid}` : `focus:${ring}`}`}>
                                                            <option value={0} disabled>{ui.selectLevel}</option>
                                                            {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                                if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                                return <option key={lvl} value={lvl}>{lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang] || ""}</option>;
                                                            })}
                                                        </select>
                                                        <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                            <svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" /></svg>
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20">
                        <button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic ? 'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200' : 'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>
                            {ui.startBtn} <span>üöÄ</span>
                        </button>
                    </div>

                    <footer className="mt-auto py-6 border-t border-gray-200 flex flex-col md:flex-row justify-between items-center px-4 gap-4">
                        {/* DO NOW BUTTON - Left Aligned */}
                        <button onClick={onDoNowOpen} className="w-full md:w-auto bg-slate-800 hover:bg-slate-900 text-white font-bold py-2 px-6 rounded-full text-sm transition-colors shadow-sm order-2 md:order-1">
                            {ui.donow_btn}
                        </button>

                        {/* Right Side Group: Language Switch + LGR22 */}
                        <div className="flex items-center gap-3 order-1 md:order-2 w-full md:w-auto justify-center md:justify-end">
                            <button
                                onClick={toggleLang}
                                className="px-4 py-2 rounded-full text-sm font-bold border border-slate-200 bg-white text-slate-600 hover:bg-slate-50 transition-all shadow-sm flex items-center gap-2"
                                title={lang === 'sv' ? "Byt spr√•k" : "Switch Language"}
                            >
                                <span className="text-lg">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span>
                                <span>{lang === 'sv' ? 'SE' : 'ENG'}</span>
                            </button>

                            <button onClick={onLgrOpen} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-sky-200 shadow-sm">
                                {ui.lgr_btn}
                            </button>
                        </div>
                    </footer>
                </div>
            );
        };

        const PracticeView = ({ lang, ui, question, loading, feedback, streak, input, setInput, handleSubmit, handleHint, handleSolution, handleSkip, handleChangeLevel, revealedClues, uiState, actions, levelUpAvailable, setLevelUpAvailable, isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect, timerSettings, formatTime, setMobileHistoryOpen }) => {
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const inputRef = useRef(null);

            const descriptionText = typeof question?.renderData?.description === 'object' ? question.renderData.description[lang] : question?.renderData?.description;
            const handleChoiceClick = (choice) => { if (feedback === 'correct') return; setInput(choice); handleSubmit({ preventDefault: () => { } }, choice); };
            const handleFormSubmit = (e) => {
                if (question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };

            // Mobile-safe focus logic
            useEffect(() => {
                if (question) {
                    setScaleInputLeft('');
                    setScaleInputRight('');
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    const isMobile = window.innerWidth < 768;
                    if (!isMobile && inputRef.current) {
                        inputRef.current.focus();
                    }
                }
            }, [question]);

            const maxLevels = Object.keys(LEVEL_DESCRIPTIONS[uiState.topic] || {}).length;

            return (
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    
                    {/* UPDATED LEVEL UP MODAL: Handles forced refetching */}
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { 
                            handleChangeLevel(1); 
                            setLevelUpAvailable(false); 
                        }} 
                        onStay={() => { 
                            setLevelUpAvailable(false); 
                            // Force retry (fetch) when staying
                            actions.retry(true); 
                        }} 
                    />

                    <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={() => { setShowStreakModal(false); actions.retry(true); }} />
                    <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={() => { setShowTotalModal(false); }} />

                    <div className="flex-1 w-full min-w-0">
                        {/* SINGLE HEADER BAR */}
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            {/* Left: Back Button */}
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>

                            {/* Right: Controls */}
                            <div className="flex items-center gap-3">
                                {/* Timer Display */}
                                {timerSettings.duration > 0 && (
                                    <div className={`font-mono text-sm font-bold px-3 py-1.5 rounded-lg border hidden sm:block ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                        {formatTime(timerSettings.remaining)}
                                    </div>
                                )}

                                {/* Level Navigation */}
                                <div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200">
                                    <button onClick={() => handleChangeLevel(-1)} disabled={uiState.level <= 1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button>
                                    <span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span>
                                    <button onClick={() => handleChangeLevel(1)} disabled={uiState.level >= maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button>
                                </div>

                                {/* Mobile History Toggle */}
                                <button onClick={() => setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500 hover:bg-gray-200 transition-colors">
                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                </button>
                            </div>
                        </div>

                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading ? (<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>) : question ? (<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph} />
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type)
                                            ? <VolumeVisualization data={question.renderData.geometry} />
                                            : <GeometryVisual data={question.renderData.geometry} />
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic === 'geometry' && <StaticGeometryVisual description={descriptionText} />}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true} /></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText} /></h2></div>
                                {question.renderData.answerType === 'multiple_choice' ? (<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice, idx) => (<button key={idx} onClick={() => handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback === 'correct' && choice === input ? 'bg-green-500 border-green-500 text-white' : feedback === 'incorrect' && choice === input ? 'bg-red-500 border-red-500 text-white' : 'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback === 'correct'}>{choice}</button>))}</div>) : (<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                    {question.renderData.answerType === 'scale' ? (
                                        <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus={false} disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                    ) : (
                                        <div className="relative"><input ref={inputRef} type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus={false} disabled={feedback === 'correct'} /></div>
                                    )}
                                    <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback === 'correct' ? 'bg-primary-500 shadow-green-200 cursor-default' : 'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback === 'correct' ? ui.correct : feedback === 'incorrect' ? ui.incorrect : ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues || revealedClues.length >= question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues || isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>) : (<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={() => actions.retry(true)} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui} /></div>
                    </div>
                </div>
            );
        };

        /*******************************************************
         * 5. ROOT CONTROLLER (App)
         *******************************************************/

        function App() {
            const [view, setView] = useState('dashboard'); // 'dashboard', 'practice', 'donow_config', 'donow_grid'
            const [lang, setLang] = useState('sv');
            const [topic, setTopic] = useState('');
            const [level, setLevel] = useState(0);

            const [question, setQuestion] = useState(null);
            const [input, setInput] = useState('');
            const [feedback, setFeedback] = useState(null);
            const [loading, setLoading] = useState(false);

            // Session Stats
            const [streak, setStreak] = useState(0);
            const [totalCorrect, setTotalCorrect] = useState(0);
            const [sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });
            // Granular Stats
            const [granularStats, setGranularStats] = useState({});

            const [history, setHistory] = useState([]);
            const [revealedClues, setRevealedClues] = useState([]);
            const [levelUpAvailable, setLevelUpAvailable] = useState(false);
            const [aboutOpen, setAboutOpen] = useState(false);
            const [statsOpen, setStatsOpen] = useState(false);
            const [timeUpOpen, setTimeUpOpen] = useState(false);
            const [lgrOpen, setLgrOpen] = useState(false);

            // Do Now State
            const [doNowQuestions, setDoNowQuestions] = useState([]);

            // Modals State
            const [showStreakModal, setShowStreakModal] = useState(false);
            const [showTotalModal, setShowTotalModal] = useState(false);
            const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);

            const [usedHelp, setUsedHelp] = useState(false);
            const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);

            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui = UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };

            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({ ...prev, maxStreak: streak }));
                }
            }, [streak]);

            // UPDATED: Added 'force' parameter to bypass modal checks
            const fetchQuestion = async (t = topic, l = level, lg = lang, force = false) => {
                if (!force && (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen)) return;
                if (!t || !l) return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]);
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try {
                    const res = await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data = await res.json();
                    if (data.error) throw new Error(data.error);
                    setQuestion(data);
                } catch (e) {
                    console.error(e);
                    setQuestion(null);
                } finally {
                    setLoading(false);
                }
            };

            const startPractice = () => {
                if (topic && level) {
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic, level, lang);
                }
            };

            const quitPractice = () => {
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            // DO NOW LOGIC
            const handleDoNowGenerate = async (selected) => {
                if (selected.length === 0) return;
                setLoading(true);

                // FORCE 6 QUESTIONS: Cycle through selections to fill the grid
                const fullConfig = [];
                for (let i = 0; i < 6; i++) {
                    fullConfig.push(selected[i % selected.length]);
                }

                try {
                    const res = await fetch('/api/batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config: fullConfig, lang })
                    });
                    const data = await res.json();
                    if (data.questions) {
                        setDoNowQuestions(data.questions);
                        setView('donow_grid');
                    }
                } catch (e) {
                    console.error(e);
                } finally {
                    setLoading(false);
                }
            };

            const handleSelection = (t, l) => { setTopic(t); setLevel(l); };
            const handleHint = () => {
                if (question?.clues) {
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if (currentLen < question.clues.length) {
                        setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution = () => {
                if (question?.clues) {
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };

            const updateStats = (type) => {
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            // Granular Stats Updater
            const updateGranularStats = (topicId, levelId, resultType) => {
                setGranularStats(prev => {
                    const topicData = prev[topicId] || {};
                    const levelData = topicData[levelId] || { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 };
                    return {
                        ...prev,
                        [topicId]: {
                            ...topicData,
                            [levelId]: {
                                ...levelData,
                                [resultType]: (levelData[resultType] || 0) + 1
                            }
                        }
                    };
                });
            };

            const handleSkip = () => {
                const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
                // FIX: Use LaTeX if available for history text
                const historyText = question.renderData.latex || descText;

                // Prevent duplicate skips logic if needed, but usually skip forces new question anyway
                setHistory(prev => [{ topic, level, correct: false, skipped: true, text: historyText, clueUsed: revealedClues.length > 0 || isSolutionRevealed, time: Date.now() }, ...prev]);
                setStreak(0);
                updateStats('skipped');
                updateGranularStats(topic, level, 'skipped');
                fetchQuestion(topic, level, lang);
            };

            // UPDATED: Pass 'true' to force fetch even if modal was just open
            const handleChangeLevel = (delta) => { 
                const newLevel = level + delta; 
                const max = Object.keys(LEVEL_DESCRIPTIONS[topic] || {}).length; 
                if (newLevel >= 1 && newLevel <= max) { 
                    setStreak(0); 
                    setLevel(newLevel); 
                    fetchQuestion(topic, newLevel, lang, true); 
                } 
            };

            const handleSubmit = async (e, directInput) => {
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Prevent duplicate submission if already correct
                if (feedback === 'correct') return;

                let finalInput = directInput !== undefined ? directInput : input;

                if (!question || !finalInput) return;

                // Track if stats should be locked (prevent cheating)
                const isStatsLocked = isSolutionRevealed;
                const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

                try {
                    const res = await fetch('/api/answer', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ answer: finalInput, token: question.token, streak: streak, level: level, topic: topic, usedHelp: helpUsed, solutionUsed: isSolutionRevealed, attempts: question.attempts }) });
                    const result = await res.json();

                    const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
                    const historyText = question.renderData.latex || descText;

                    if (result.correct) {
                        // ONLY update history/stats if the solution wasn't already revealed
                        if (!isStatsLocked) {
                            setHistory(prev => [{ topic, level, correct: true, text: historyText, clueUsed: helpUsed, time: Date.now() }, ...prev]);
                            setStreak(result.newStreak);

                            if (!helpUsed) {
                                updateStats('correctNoHelp');
                                updateGranularStats(topic, level, 'correctNoHelp');
                            } else {
                                updateStats('correctHelp');
                                updateGranularStats(topic, level, 'correctHelp');
                            }

                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }

                            if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                                setShowStreakModal(true);
                            } else {
                                if (result.levelUp) setLevelUpAvailable(true);
                                setTimeout(() => {
                                    if (!showTotalModal && !showStreakModal) {
                                        if (!result.levelUp) fetchQuestion(topic, level, lang);
                                    }
                                }, 1500);
                            }
                        }

                        setFeedback('correct');

                    } else {
                        // Incorrect
                        question.attempts = (question.attempts || 0) + 1;

                        // Logic for 2 attempts max
                        if (question.attempts >= 2) {
                            handleSolution(); // Reveal solution - LOCKS STATS
                            if (!isStatsLocked) {
                                updateStats('incorrect');
                                updateGranularStats(topic, level, 'incorrect');
                                setHistory(prev => [{
                                    topic,
                                    level,
                                    correct: false,
                                    text: historyText,
                                    clueUsed: true,
                                    correctAnswer: result.correctAnswer || "See Solution",
                                    time: Date.now()
                                }, ...prev]);
                            }
                        } else {
                            // Attempt 1 fail: Show clue if available
                            handleHint();
                        }

                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch (e) { console.error(e); }
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            const toggleLang = () => setLang(prev => prev === 'sv' ? 'en' : 'sv');

            // VIEW ROUTING
            if (view === 'donow_config') {
                return (
                    <div className="min-h-screen bg-gray-50 font-sans">
                        <DoNowConfig
                            ui={ui}
                            lang={lang}
                            onBack={() => setView('dashboard')}
                            onGenerate={handleDoNowGenerate}
                        />
                    </div>
                );
            }

            if (view === 'donow_grid') {
                return (
                    <DoNowGrid
                        questions={doNowQuestions}
                        ui={ui}
                        onBack={() => setView('donow_config')}
                        lang={lang}
                    />
                );
            }

            return (
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={() => setAboutOpen(false)} ui={ui} />
                    <LgrModal visible={lgrOpen} onClose={() => setLgrOpen(false)} ui={ui} />
                    <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} ui={ui} />
                    <StatsModal visible={statsOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />

                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>
                                <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>
                                <button 
                                    onClick={() => setLang(prev => prev === 'sv' ? 'en' : 'sv')} 
                                    className="px-3 py-1 rounded-md text-xs font-bold border border-slate-200 bg-white text-slate-600 hover:bg-slate-50 transition-all shadow-sm flex items-center gap-1.5"
                                    title={lang === 'sv' ? "Byt spr√•k" : "Switch Language"}
                                >
                                    <span className="text-sm">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span>
                                    <span>{lang === 'sv' ? 'SE' : 'ENG'}</span>
                                </button>
                                <button onClick={() => setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={() => setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>

                    <div className="flex-1 flex flex-col">
                        {view === 'dashboard' ? (
                            <Dashboard
                                lang={lang}
                                selectedTopic={topic}
                                selectedLevel={level}
                                onSelect={handleSelection}
                                onStart={startPractice}
                                timerSettings={timerSettings}
                                toggleTimer={toggleTimer}
                                resetTimer={resetTimer}
                                ui={ui}
                                onLgrOpen={() => setLgrOpen(true)}
                                onDoNowOpen={() => setView('donow_config')}
                                toggleLang={toggleLang}
                            />
                        ) : (
                            <PracticeView
                                lang={lang}
                                ui={ui}
                                question={question}
                                loading={loading}
                                feedback={feedback}
                                streak={streak}
                                input={input}
                                setInput={setInput}
                                handleSubmit={handleSubmit}
                                handleHint={handleHint}
                                handleSolution={handleSolution}
                                handleSkip={handleSkip}
                                handleChangeLevel={handleChangeLevel}
                                revealedClues={revealedClues}
                                uiState={{ history, topic, level }}
                                // UPDATED: Pass force=true to retry to ensure fetch happens even if modal state lingers slightly
                                actions={{ retry: (force) => fetchQuestion(topic, level, lang, force), goBack: quitPractice }}
                                levelUpAvailable={levelUpAvailable}
                                setLevelUpAvailable={setLevelUpAvailable}
                                isSolutionRevealed={isSolutionRevealed}
                                showStreakModal={showStreakModal}
                                setShowStreakModal={setShowStreakModal}
                                showTotalModal={showTotalModal}
                                setShowTotalModal={setShowTotalModal}
                                totalCorrect={totalCorrect}
                                timerSettings={timerSettings}
                                formatTime={formatTime}
                                setMobileHistoryOpen={setMobileHistoryOpen}
                            />
                        )}
                    </div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
    </script>
</body>

</html>

// FILE END: public\index.html

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class BasicArithmeticGen {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let mode = level;

        // --- LEVEL 8: Mixed Integers (1, 2, 4, 7) ---
        if (level === 8) {
            mode = rng.pick([1, 2, 4, 7]);
        }
        
        // --- LEVEL 9: Mixed All (1-7) ---
        if (level === 9) {
            mode = rng.intBetween(1, 7);
        }

        let steps: Clue[] = [];
        let answer: number = 0;
        let latex = "";
        
        // Description defaults
        let description = { sv: "Ber√§kna", en: "Calculate" };

        // Helper for vertical layout
        const makeVertical = (top: number | string, bottom: number | string, op: string) => {
            return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
        };

        // --- LEVEL 1: Addition (1-3 digits) ---
        if (mode === 1) {
            const a = rng.intBetween(1, 999);
            const b = rng.intBetween(1, 999);
            answer = a + b;
            
            if (rng.intBetween(0, 1) === 1) {
                latex = makeVertical(a, b, '+');
                description = { sv: "St√§ll upp och addera.", en: "Set up and add." };
            } else {
                latex = `${a} + ${b} =`;
                description = { sv: "Addera.", en: "Add." };
            }

            steps = [
                { text: t(lang, TERMS.common.calculate), latex: `${a} + ${b} = ${formatColor(answer)}` }
            ];
        }

        // --- LEVEL 2: Subtraction (1-3 digits, a > b) ---
        else if (mode === 2) {
            const a = rng.intBetween(2, 999);
            const b = rng.intBetween(1, a - 1); 
            answer = a - b;

            if (rng.intBetween(0, 1) === 1) {
                latex = makeVertical(a, b, '-');
                description = { sv: "St√§ll upp och subtrahera.", en: "Set up and subtract." };
            } else {
                latex = `${a} - ${b} =`;
                description = { sv: "Subtrahera.", en: "Subtract." };
            }

            steps = [
                { text: t(lang, TERMS.common.calculate), latex: `${a} - ${b} = ${formatColor(answer)}` }
            ];
        }

        // --- LEVEL 3: Decimal (+/-) ---
        else if (mode === 3) {
            const isAdd = rng.intBetween(0, 1) === 1;
            
            const getDec = () => {
                const num = rng.intBetween(1, 4900); 
                return num / 100; 
            };

            let a = getDec();
            let b = getDec();
            
            if (isAdd) {
                while (Math.floor(a + b) > 50) { a = getDec(); b = getDec(); }
                answer = Math.round((a + b) * 100) / 100;
                latex = `${a} + ${b} =`;
            } else {
                if (b > a) [a, b] = [b, a];
                while (Math.floor(a - b) > 50) { a = getDec(); b = getDec(); if (b>a) [a,b]=[b,a];}
                answer = Math.round((a - b) * 100) / 100;
                latex = `${a} - ${b} =`;
            }

            description = { sv: "Ber√§kna decimaltalen.", en: "Calculate the decimals." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${latex} ${formatColor(answer)}` }];
        }

        // --- LEVEL 4: Multiplication Easy (<= 10) ---
        else if (mode === 4) {
            const a = rng.intBetween(1, 10);
            const b = rng.intBetween(1, 10);
            answer = a * b;

            if (rng.intBetween(0, 1) === 1) {
                const top = Math.max(a, b);
                const bot = Math.min(a, b);
                latex = makeVertical(top, bot, '\\times');
            } else {
                latex = `${a} \\cdot ${b} =`;
            }

            description = { sv: "Multiplicera.", en: "Multiply." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${a} \\cdot ${b} = ${formatColor(answer)}` }];
        }

        // --- LEVEL 5: Multiplication Medium (<= 20) ---
        else if (mode === 5) {
            const a = rng.intBetween(2, 20);
            const b = rng.intBetween(2, 20);
            answer = a * b;

            if (rng.intBetween(0, 1) === 1) {
                const top = Math.max(a, b);
                const bot = Math.min(a, b);
                latex = makeVertical(top, bot, '\\times');
            } else {
                latex = `${a} \\cdot ${b} =`;
            }

            description = { sv: "Multiplicera.", en: "Multiply." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${a} \\cdot ${b} = ${formatColor(answer)}` }];
        }

        // --- LEVEL 6: Multiplication Hard (Decimals) ---
        else if (mode === 6) {
            const type = rng.intBetween(1, 4);
            let a = 0, b = 0;

            if (type === 1) { // 0.x * 0.y
                a = rng.intBetween(1, 9) / 10;
                b = rng.intBetween(1, 9) / 10;
            } else if (type === 2) { // Int * 0.x
                a = rng.intBetween(2, 20);
                b = rng.intBetween(1, 9) / 10;
            } else if (type === 3) { // 0.x * 0.yz
                a = rng.intBetween(1, 9) / 10;
                b = rng.intBetween(1, 99) / 100;
            } else { // Int * 0.yz
                a = rng.intBetween(2, 20);
                b = rng.intBetween(1, 99) / 100;
            }

            answer = Math.round((a * b) * 1000) / 1000;
            latex = `${a} \\cdot ${b} =`;
            description = { sv: "Multiplicera decimaltalen.", en: "Multiply the decimals." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${a} \\cdot ${b} = ${formatColor(answer)}` }];
        }

        // --- LEVEL 7: Division (Tables) ---
        else if (mode === 7) {
            const f1 = rng.intBetween(1, 10);
            const f2 = rng.intBetween(1, 10);
            const product = f1 * f2;
            
            const divisor = rng.intBetween(0, 1) === 1 ? f1 : f2;
            answer = product / divisor; 

            latex = `\\frac{${product}}{${divisor}} =`;
            description = { sv: "Dividera.", en: "Divide." };
            
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `\\frac{${product}}{${divisor}} = ${formatColor(answer)}` }];
        }

        return {
            questionId: `arith-l${level}-${seed}`,
            renderData: {
                text_key: "arithmetic",
                description: description,
                latex: latex,
                answerType: "numeric",
                variables: {}
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language } from "../utils/i18n";

export class ExpressionSimplificationGen {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let mode = level;
        if (level === 6) mode = rng.intBetween(1, 5); // Mixed level

        let expr = "";
        let steps: Clue[] = [];
        let answer = "";
        let description: string | { sv: string, en: string } = { sv: "", en: "" };

        // --- LEVEL 1: Combine like terms (addition) ---
        // 3x + 5x
        if (mode === 1) {
            const v = rng.pick(['x', 'y', 'a', 'b']);
            const c1 = rng.intBetween(2, 9);
            const c2 = rng.intBetween(2, 9);
            
            expr = `${c1}${v} + ${c2}${v}`;
            answer = `${c1+c2}${v}`;
            
            steps.push({
                text: t(lang, { sv: "Addera koefficienterna (siffrorna framf√∂r variabeln).", en: "Add the coefficients (numbers in front of the variable)." }),
                latex: `${c1} + ${c2} = ${c1+c2}`
            });
            steps.push({
                text: t(lang, { sv: "Svaret beh√•ller variabeln.", en: "The answer keeps the variable." }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 2: Parentheses (Distribution) ---
        // 3(2x + 4)
        else if (mode === 2) {
            const v = 'x';
            const outer = rng.intBetween(2, 5);
            const innerC = rng.intBetween(2, 5);
            const innerK = rng.intBetween(1, 5);
            
            expr = `${outer}(${innerC}${v} + ${innerK})`;
            const resC = outer * innerC;
            const resK = outer * innerK;
            answer = `${resC}${v} + ${resK}`; // e.g. 6x + 12

            steps.push({
                text: t(lang, { sv: "Multiplicera in talet utanf√∂r parentesen med b√•da termerna inuti.", en: "Multiply the number outside the parentheses with both terms inside." }),
                latex: `${outer} \\cdot ${innerC}${v} + ${outer} \\cdot ${innerK}`
            });
            steps.push({
                text: t(lang, { sv: "Ber√§kna produkterna.", en: "Calculate the products." }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 3: Distribute & Combine ---
        // 2(3x + 1) + 4x
        else if (mode === 3) {
            const outer = rng.intBetween(2, 4);
            const inC = rng.intBetween(2, 4);
            const inK = rng.intBetween(1, 5);
            const extraX = rng.intBetween(2, 6);
            
            expr = `${outer}(${inC}x + ${inK}) + ${extraX}x`;
            
            const distX = outer * inC;
            const distK = outer * inK;
            const totalX = distX + extraX;
            
            answer = `${totalX}x + ${distK}`;
            
            steps.push({
                text: t(lang, { sv: "B√∂rja med att multiplicera in i parentesen.", en: "Start by distributing into the parentheses." }),
                latex: `${distX}x + ${distK} + ${extraX}x`
            });
            steps.push({
                text: t(lang, { sv: "L√§gg ihop x-termerna.", en: "Combine the x-terms." }),
                latex: `${distX}x + ${extraX}x = ${totalX}x`
            });
            steps.push({
                text: t(lang, { sv: "S√§tt ihop allt.", en: "Put it all together." }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 4: Subtracting Parentheses ---
        // 5x - (2x + 3)
        else if (mode === 4) {
            const startX = rng.intBetween(5, 10);
            const subX = rng.intBetween(1, startX - 1);
            const subK = rng.intBetween(1, 5);
            
            expr = `${startX}x - (${subX}x + ${subK})`;
            const resX = startX - subX;
            const resK = -subK; // Minus becomes negative
            
            answer = `${resX}x - ${Math.abs(resK)}`;
            
            steps.push({
                text: t(lang, { sv: "Minus framf√∂r en parentes √§ndrar tecken p√• allt inuti n√§r vi tar bort parentesen.", en: "A minus in front of parentheses changes the sign of everything inside when removed." }),
                latex: `${startX}x - ${subX}x - ${subK}`
            });
            steps.push({
                text: t(lang, { sv: "F√∂renkla x-termerna.", en: "Simplify the x-terms." }),
                latex: `${startX}x - ${subX}x = ${resX}x`
            });
            steps.push({
                text: t(lang, { sv: "Resultat", en: "Result" }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 5: Word Problems (Text) ---
        else if (mode === 5) {
            
            // Constants for the logic: Ax + Cx +/- B
            const A = rng.intBetween(2, 6);  // Variable group 1
            const B = rng.intBetween(5, 30); // Constant
            const C = rng.intBetween(2, 6);  // Variable group 2
            
            const totalX = A + C;

            // Define Scenarios with Subtraction (Loss/Cost) and Addition (Gain/Total)
            const scenarios = [
                // --- ADDITION SCENARIOS (ax + b) ---
                {
                    type: 'add',
                    sv: `Du har ${A} p√•sar med godis (x) och k√∂per ${C} p√•sar till. Du har ocks√• ${B} l√∂sa godisar.`,
                    en: `You have ${A} bags of candy (x) and buy ${C} more bags. You also have ${B} loose candies.`,
                    unitSv: "godisar", unitEn: "candies", varSv: "p√•sar", varEn: "bags",
                    explSv: "l√∂sa godisar l√§ggs till (+)", explEn: "loose candies are added (+)"
                },
                {
                    type: 'add',
                    sv: `Du sparar x kr i ${A} veckor och sedan i ${C} veckor till. Du f√•r ocks√• ${B} kr i present.`,
                    en: `You save x kr for ${A} weeks and then for ${C} more weeks. You also get ${B} kr as a gift.`,
                    unitSv: "kr", unitEn: "kr", varSv: "veckor", varEn: "weeks",
                    explSv: "presenten l√§ggs till sparandet (+)", explEn: "the gift adds to the savings (+)"
                },
                {
                    type: 'add',
                    sv: `Du bygger ett staket med ${A} sektioner av l√§ngden x och ${C} sektioner till. Du har ocks√• en grind p√• ${B} meter.`,
                    en: `You build a fence with ${A} sections of length x and ${C} more sections. You also have a gate of ${B} meters.`,
                    unitSv: "meter", unitEn: "meters", varSv: "sektioner", varEn: "sections",
                    explSv: "grinden l√§gger till l√§ngd (+)", explEn: "the gate adds length (+)"
                },
                // --- SUBTRACTION SCENARIOS (ax - b) ---
                {
                    type: 'sub',
                    sv: `Du k√∂per ${A} tr√∂jor och ${C} byxor som alla kostar x kr styck. Du har en rabattkupong p√• ${B} kr.`,
                    en: `You buy ${A} shirts and ${C} pants that all cost x kr each. You have a discount coupon for ${B} kr.`,
                    unitSv: "kr", unitEn: "kr", varSv: "plagg", varEn: "items",
                    explSv: "en rabatt dras bort fr√•n priset (-)", explEn: "a discount is subtracted from the price (-)"
                },
                {
                    type: 'sub',
                    sv: `Du plockar ${A} korgar med jordgubbar och din kompis plockar ${C} korgar (x liter per korg). Ni r√•kar spilla ut ${B} liter.`,
                    en: `You pick ${A} baskets of strawberries and your friend picks ${C} baskets (x liters per basket). You accidentally spill ${B} liters.`,
                    unitSv: "liter", unitEn: "liters", varSv: "korgar", varEn: "baskets",
                    explSv: "det utspillda dras bort (-)", explEn: "the spilled amount is subtracted (-)"
                },
                {
                    type: 'sub',
                    sv: `Du har sparat x kr i veckan i ${A} veckor plus ${C} veckor till. Sedan k√∂per du en sak f√∂r ${B} kr.`,
                    en: `You saved x kr a week for ${A} weeks plus ${C} more weeks. Then you buy an item for ${B} kr.`,
                    unitSv: "kr", unitEn: "kr", varSv: "veckor", varEn: "weeks",
                    explSv: "kostnaden dras bort fr√•n sparandet (-)", explEn: "the cost is subtracted from savings (-)"
                },
                {
                    type: 'sub',
                    sv: `En snickare har ${A} l√•nga plankor och ${C} korta plankor som alla √§r x meter l√•nga. Han s√•gar bort totalt ${B} meter spillvirke.`,
                    en: `A carpenter has ${A} long boards and ${C} short boards that are all x meters long. He cuts off a total of ${B} meters waste.`,
                    unitSv: "meter", unitEn: "meters", varSv: "plankor", varEn: "boards",
                    explSv: "spillvirket dras bort (-)", explEn: "the waste is subtracted (-)"
                },
                {
                    type: 'sub',
                    sv: `Du prenumererar p√• en tj√§nst (x kr/m√•n) i ${A} m√•nader √•t dig sj√§lv och ${C} m√•nader √•t en v√§n. Du f√•r ${B} kr i √•terb√§ring.`,
                    en: `You subscribe to a service (x kr/mo) for ${A} months for yourself and ${C} months for a friend. You get ${B} kr cash back.`,
                    unitSv: "kr", unitEn: "kr", varSv: "m√•nader", varEn: "months",
                    explSv: "√•terb√§ringen minskar kostnaden (-)", explEn: "cash back reduces the cost (-)"
                }
            ];

            const s = rng.pick(scenarios);
            const isSub = s.type === 'sub';
            const operator = isSub ? "-" : "+";
            
            // Construct Answer: e.g. "8x - 20"
            answer = `${totalX}x ${operator} ${B}`;

            // Adjust the final question text based on type
            const totalTextSv = isSub ? "det som √•terst√•r/slutsumman" : "totalen";
            const totalTextEn = isSub ? "what remains/net total" : "the total";
            
            description = {
                sv: `${s.sv} Skriv ett uttryck f√∂r ${totalTextSv} och f√∂renkla det.`,
                en: `${s.en} Write an expression for ${totalTextEn} and simplify it.`
            };
            
            // Pedagogical Steps (Explaining how to get each term)
            steps = [
                { 
                    text: t(lang, { 
                        sv: `Steg 1: Hitta x-termerna. Du har ${A} ${s.varSv} och ${C} ${s.varSv}. Det blir ${A}x + ${C}x.`, 
                        en: `Step 1: Find the x-terms. You have ${A} ${s.varEn} and ${C} ${s.varEn}. That makes ${A}x + ${C}x.` 
                    }), 
                    latex: `${A}x + ${C}x` 
                },
                { 
                    text: t(lang, { 
                        sv: `Steg 2: Hantera konstanten (${B} ${s.unitSv}). Eftersom ${s.explSv}, skriver vi ${operator} ${B}.`, 
                        en: `Step 2: Handle the constant (${B} ${s.unitEn}). Since ${s.explEn}, we write ${operator} ${B}.` 
                    }), 
                    latex: isSub ? `- ${B}` : `+ ${B}`
                },
                { 
                    text: t(lang, { 
                        sv: `Steg 3: S√§tt ihop och f√∂renkla. ${A}x plus ${C}x blir ${totalX}x.`, 
                        en: `Step 3: Combine and simplify. ${A}x plus ${C}x becomes ${totalX}x.` 
                    }), 
                    latex: `${totalX}x ${operator} ${B} = ${formatColor(answer)}` 
                }
            ];
            
            return {
                questionId: `simp-l${level}-${seed}`,
                renderData: {
                    text_key: "simplify_word",
                    description: description,
                    latex: "", 
                    answerType: "text",
                    variables: {}
                },
                serverData: {
                    answer: answer,
                    solutionSteps: steps
                }
            };
        }

        return {
            questionId: `simp-l${level}-${seed}`,
            renderData: {
                text_key: "simplify",
                description: description,
                latex: expr,
                answerType: "text",
                variables: {}
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language } from "../utils/i18n";

export class GeometryGenerator {
  public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
    const rng = new Random(seed);
    const s = (val: number) => Math.round(val * multiplier);
    const piApprox = 3.14;

    const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

    let mode = level;
    if (level >= 6) mode = rng.intBetween(3, 5);

    let steps: Clue[] = [];
    let qData: { text_key: string, description: string | { sv: string, en: string }, latex: string, answer: number } = { text_key: "", description: "", latex: "", answer: 0 };
    let geometry: any = undefined;

    // --- LEVEL 1: Perimeter (Rectangles) ---
    if (mode === 1) {
        const w = rng.intBetween(s(3), s(12));
        const h = rng.intBetween(s(2), s(8));
        qData.answer = 2 * (w + h);
        qData.description = { sv: "Ber√§kna omkretsen.", en: "Calculate the perimeter." };
        geometry = { type: 'rectangle', width: w, height: h, labels: { width: w, height: h } };
        
        steps = [
            { 
                text: t(lang, { 
                    sv: "Omkretsen √§r str√§ckan runt hela figuren. En rektangel har tv√• baser och tv√• h√∂jder.", 
                    en: "Perimeter is the distance around the shape. A rectangle has two bases and two heights." 
                }), 
                latex: "" 
            },
            { 
                text: t(lang, { 
                    sv: "Addera alla fyra sidor.", 
                    en: "Add all four sides together." 
                }), 
                latex: `${w} + ${w} + ${h} + ${h} = ${formatColor(qData.answer)}` 
            }
        ];
    }

    // --- LEVEL 2: Area (Rectangles) ---
    else if (mode === 2) {
        const w = rng.intBetween(s(3), s(12));
        const h = rng.intBetween(s(2), s(8));
        qData.answer = w * h;
        qData.description = { sv: "Ber√§kna arean.", en: "Calculate the area." };
        geometry = { type: 'rectangle', width: w, height: h, labels: { width: w, height: h } };
        
        steps = [
            { 
                text: t(lang, { 
                    sv: "Arean ber√§ttar hur stor yta figuren t√§cker. F√∂r en rektangel multiplicerar vi basen med h√∂jden.", 
                    en: "Area tells us how much surface the shape covers. For a rectangle, we multiply the base by the height." 
                }), 
                latex: "Area = b \\cdot h" 
            },
            { 
                text: t(lang, { 
                    sv: "S√§tt in v√§rdena och r√§kna ut.", 
                    en: "Insert the values and calculate." 
                }), 
                latex: `${w} \\cdot ${h} = ${formatColor(qData.answer)}` 
            }
        ];
    }

    // --- LEVEL 3: Area (Triangles) ---
    else if (mode === 3) {
        const b = rng.intBetween(s(4), s(14));
        const h = rng.intBetween(s(3), s(10));
        qData.answer = (b * h) / 2;
        qData.description = { sv: "Ber√§kna arean.", en: "Calculate the area." };
        
        const subtype = rng.pick(['right', 'isosceles', 'scalene']);
        geometry = { type: 'triangle', subtype: subtype, width: b, height: h, labels: { base: b, height: h } };
        
        steps = [
            { 
                text: t(lang, { 
                    sv: "En triangel √§r alltid h√§lften av en rektangel med samma bas och h√∂jd.", 
                    en: "A triangle is always half of a rectangle with the same base and height." 
                }), 
                latex: "Area = \\frac{b \\cdot h}{2}" 
            },
            { 
                text: t(lang, { 
                    sv: "Multiplicera basen med h√∂jden och dela sedan med 2.", 
                    en: "Multiply the base by the height, then divide by 2." 
                }), 
                latex: `\\frac{${b} \\cdot ${h}}{2} = \\frac{${b*h}}{2} = ${formatColor(qData.answer)}` 
            }
        ];
    }

    // --- LEVEL 4: Circles (Area & Circumference) ---
    else if (mode === 4) {
        const isArea = rng.intBetween(0, 1) === 1;
        const showDiameter = rng.intBetween(0, 1) === 1; // 50% chance to show diameter
        const r = rng.intBetween(s(3), s(10));
        const d = r * 2;
        
        if (isArea) {
            const area = Math.PI * r * r;
            qData.answer = Math.round(area * 10) / 10;
            qData.description = { sv: "Ber√§kna arean (avrunda till 1 decimal).", en: "Calculate the area (round to 1 decimal)." };
            
            if (showDiameter) {
                // Diameter given, ask for Area
                steps = [
                    { 
                        text: t(lang, { 
                            sv: "F√∂r att r√§kna ut arean beh√∂ver vi radien (r). Radien √§r h√§lften av diametern (d).", 
                            en: "To calculate the area we need the radius (r). The radius is half of the diameter (d)." 
                        }), 
                        latex: `r = \\frac{d}{2} = \\frac{${d}}{2} = ${r}` 
                    },
                    { 
                        text: t(lang, { sv: "Anv√§nd formeln f√∂r cirkelns area.", en: "Use the formula for the area of a circle." }), 
                        latex: "Area = \\pi \\cdot r^2" 
                    },
                    { 
                        text: t(lang, { sv: "S√§tt in radien och r√§kna ut.", en: "Insert the radius and calculate." }), 
                        latex: `3.14 \\cdot ${r}^2 = 3.14 \\cdot ${r*r} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Radius given, ask for Area
                steps = [
                    { 
                        text: t(lang, { sv: "F√∂r att r√§kna ut ytan (arean) p√• en cirkel anv√§nder vi radien (r) och talet Pi (œÄ ‚âà 3.14).", en: "To find the surface (area) of a circle, we use the radius (r) and Pi (œÄ ‚âà 3.14)." }), 
                        latex: "Area = \\pi \\cdot r^2" 
                    },
                    { 
                        text: t(lang, { sv: "Radien i kvadrat betyder radien g√•nger sig sj√§lv.", en: "Radius squared means radius times itself." }), 
                        latex: `r^2 = ${r} \\cdot ${r} = ${r*r}` 
                    },
                    { 
                        text: t(lang, { sv: "Multiplicera med Pi.", en: "Multiply by Pi." }), 
                        latex: `3.14 \\cdot ${r*r} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
        } else {
            // Circumference
            const circ = 2 * Math.PI * r;
            qData.answer = Math.round(circ * 10) / 10;
            qData.description = { sv: "Ber√§kna omkretsen (avrunda till 1 decimal).", en: "Calculate the circumference (round to 1 decimal)." };
            
            if (showDiameter) {
                // Diameter given, ask for Circumference
                steps = [
                    { 
                        text: t(lang, { sv: "Omkretsen √§r str√§ckan runt cirkeln. Med diametern (d) √§r formeln enkel.", en: "Circumference is the distance around the circle. With diameter (d), the formula is simple." }), 
                        latex: "Omkrets = \\pi \\cdot d" 
                    },
                    { 
                        text: t(lang, { sv: "Multiplicera diametern med Pi (‚âà 3.14).", en: "Multiply the diameter by Pi (‚âà 3.14)." }), 
                        latex: `3.14 \\cdot ${d} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Radius given, ask for Circumference
                steps = [
                    { 
                        text: t(lang, { sv: "Omkretsen √§r str√§ckan runt cirkeln. Vi kan anv√§nda diametern (som √§r 2 g√•nger radien) eller formeln med radien.", en: "Circumference is the distance around the circle. We can use the diameter (2 times radius) or the radius formula." }), 
                        latex: "Omkrets = 2 \\cdot \\pi \\cdot r" 
                    },
                    { 
                        text: t(lang, { sv: "R√§kna ut diametern f√∂rst (dubbla radien).", en: "Calculate the diameter first (double the radius)." }), 
                        latex: `d = 2 \\cdot ${r} = ${2*r}` 
                    },
                    { 
                        text: t(lang, { sv: "Multiplicera diametern med Pi (‚âà 3.14).", en: "Multiply the diameter by Pi (‚âà 3.14)." }), 
                        latex: `${2*r} \\cdot 3.14 \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
        }
        
        geometry = { type: 'circle', radius: r, value: showDiameter ? d : r, show: showDiameter ? 'diameter' : 'radius' };
    }

    // --- LEVEL 5: Composite Shapes ---
    else {
        // Example: Rectangle + Semicircle (Portal) or Triangle on Rectangle (House)
        const type = rng.pick(['portal', 'house']);
        const width = rng.intBetween(s(4), s(12)); // Base
        const height = rng.intBetween(s(4), s(10)); // Side height
        
        let shapeNameSv = "", shapeNameEn = "";
        
        const isArea = rng.intBetween(0, 1) === 1;

        if (type === 'house') {
            const hRoof = rng.intBetween(s(3), s(8));
            shapeNameSv = "huset"; shapeNameEn = "the house";
            
            if (isArea) {
                const areaRect = width * height;
                const areaTri = (width * hRoof) / 2;
                qData.answer = areaRect + areaTri;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Dela upp figuren i tv√• delar: en rektangel i botten och en triangel p√• toppen.", en: "Split the shape into two parts: a rectangle at the bottom and a triangle on top." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "R√§kna ut arean f√∂r rektangeln.", en: "Calculate the area of the rectangle." }), 
                        latex: `${width} \\cdot ${height} = ${areaRect}` 
                    },
                    { 
                        text: t(lang, { sv: "R√§kna ut arean f√∂r taket (triangeln).", en: "Calculate the area of the roof (triangle)." }), 
                        latex: `\\frac{${width} \\cdot ${hRoof}}{2} = ${areaTri}` 
                    },
                    { 
                        text: t(lang, { sv: "Addera delarna f√∂r att f√• totalen.", en: "Add the parts to get the total." }), 
                        latex: `${areaRect} + ${areaTri} = ${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Perimeter of house (Base + 2 sides + 2 roof slopes)
                // Pythagoras for roof slope
                const halfBase = width / 2;
                const slope = Math.sqrt(halfBase*halfBase + hRoof*hRoof);
                const total = width + 2*height + 2*slope;
                qData.answer = Math.round(total * 10) / 10;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Omkretsen √§r v√§gen runt huset (golvet + v√§ggarna + taket).", en: "The perimeter is the path around the house (floor + walls + roof)." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "F√∂r att hitta takets l√§ngd anv√§nder vi Pythagoras sats p√• halva taket.", en: "To find the roof length, we use Pythagoras theorem on half the roof." }), 
                        latex: `\\sqrt{${halfBase}^2 + ${hRoof}^2} \\approx ${Math.round(slope*10)/10}` 
                    },
                    { 
                        text: t(lang, { sv: "Addera alla sidor runt om.", en: "Add all sides around the outside." }), 
                        latex: `${width} + ${height} + ${height} + ${Math.round(slope*10)/10} + ${Math.round(slope*10)/10} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
            geometry = { type: 'composite', subtype: 'house', labels: { w: width, h: height, h_roof: hRoof } };
        } 
        else { // Portal
            shapeNameSv = "portalen"; shapeNameEn = "the portal";
            // Rectangle with semicircle on top
            if (isArea) {
                const areaRect = width * height;
                const r = width / 2;
                const areaSemi = (Math.PI * r * r) / 2;
                qData.answer = Math.round((areaRect + areaSemi) * 10) / 10;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Dela upp figuren: en rektangel och en halvcirkel.", en: "Split the shape: a rectangle and a semicircle." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "Rektangelns area:", en: "Rectangle area:" }), 
                        latex: `${width} \\cdot ${height} = ${areaRect}` 
                    },
                    { 
                        text: t(lang, { sv: "Halvcirkelns area (radien √§r h√§lften av bredden).", en: "Semicircle area (radius is half the width)." }), 
                        latex: `\\frac{\\pi \\cdot ${r}^2}{2} \\approx ${Math.round(areaSemi*10)/10}` 
                    },
                    { 
                        text: t(lang, { sv: "Addera dem.", en: "Add them together." }), 
                        latex: `${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Perimeter: Base + 2 sides + Arc (half circumference)
                const arc = (Math.PI * width) / 2;
                qData.answer = Math.round((width + 2 * height + arc) * 10) / 10;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Vi ska g√• runt figuren: botten + tv√• sidor + den b√•gformade toppen.", en: "We walk around the shape: bottom + two sides + the curved top." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "Toppen √§r en halvcirkel. R√§kna ut omkretsen f√∂r en hel cirkel och dela med 2.", en: "The top is a semicircle. Calculate circumference for a full circle and divide by 2." }), 
                        latex: `\\frac{\\pi \\cdot ${width}}{2} \\approx ${Math.round(arc*10)/10}` 
                    },
                    { 
                        text: t(lang, { sv: "L√§gg ihop alla delar.", en: "Sum all the parts." }), 
                        latex: `${width} + ${height} + ${height} + ${Math.round(arc*10)/10} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
            // FIXED: Added 'h' to labels so frontend can draw vertical sides
            geometry = { type: 'composite', subtype: 'portal', w: width, labels: { w: width, h: height } };
        }
        
        qData.text_key = isArea ? "calc_area" : "calc_perim";
        qData.description = {
            sv: `Ber√§kna ${isArea ? 'arean' : 'omkretsen'} av ${shapeNameSv}.`,
            en: `Calculate the ${isArea ? 'area' : 'perimeter'} of ${shapeNameEn}.`
        };
            
        if (!geometry) geometry = { type: 'composite', subtype: 'ice_cream', width: width, height: height, labels: { top: width, side: height } };
    }

    return {
        questionId: `geo-l${level}-${seed}`,
        renderData: {
            text_key: qData.text_key,
            description: qData.description,
            latex: "",
            answerType: "numeric",
            geometry: geometry,
            variables: {}
        },
        serverData: {
            answer: qData.answer,
            solutionSteps: steps
        }
    };
  }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class LinearEquationGenerator {
  public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
    const rng = new Random(seed);
    const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

    let mode = level;
    // Level 7 is now the Mixed Level for drills
    if (level >= 7) mode = rng.intBetween(1, 4); 

    const s = (val: number) => Math.round(val * multiplier);
    let eq = "", answer = 0, steps: Clue[] = [];
    let description = { sv: "L√∂s ekvationen", en: "Solve the equation" };

    // --- LEVEL 1: One-Step Equations ---
    if (mode === 1) {
        const type = rng.intBetween(1, 4); 
        
        if (type === 1) { // x / k = res
            const k = rng.intBetween(s(2), s(9));
            const res = rng.intBetween(s(2), s(10)); 
            answer = res * k;
            eq = `\\frac{x}{${k}} = ${res}`;
            
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.multiply(k)), latex: `x = ${res} \\cdot ${k} = ${formatColor(answer)}` }
            ];
        } else if (type === 2) { // k * x = res
            const k = rng.intBetween(s(2), s(9));
            const x = rng.intBetween(s(2), s(10));
            answer = x;
            const res = k * x;
            eq = `${k}x = ${res}`;
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.divide(k)), latex: `x = \\frac{${res}}{${k}} = ${formatColor(answer)}` }
            ];
        } else if (type === 3) { // x + k = res
            const k = rng.intBetween(s(1), s(20));
            const x = rng.intBetween(s(1), s(20));
            answer = x;
            eq = `x + ${k} = ${x + k}`;
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.subtract(k)), latex: `x = ${x+k} - ${k} = ${formatColor(answer)}` }
            ];
        } else { // x - k = res
            const k = rng.intBetween(s(1), s(20));
            const x = rng.intBetween(s(1), s(20));
            answer = x;
            eq = `x - ${k} = ${x - k}`;
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.add(k)), latex: `x = ${x-k} + ${k} = ${formatColor(answer)}` }
            ];
        }
    }

    // --- LEVEL 2: Two-Step Equations ---
    // Variations: ax+b=c, ax-b=c, x/a+b=c, x/a-b=c
    else if (mode === 2) {
        const type = rng.intBetween(1, 4);
        const x = rng.intBetween(2, 12); // Solution

        if (type === 1) { // ax + b = c
            const a = rng.intBetween(2, 9);
            const b = rng.intBetween(1, 15);
            const c = a * x + b;
            answer = x;
            eq = `${a}x + ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a}x = ${c} - ${b} = ${c-b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = \\frac{${c-b}}{${a}} = ${formatColor(answer)}` }
            ];
        } 
        else if (type === 2) { // ax - b = c
            const a = rng.intBetween(2, 9);
            const b = rng.intBetween(1, 15);
            const c = a * x - b;
            answer = x;
            eq = `${a}x - ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.add(b)), latex: `${a}x = ${c} + ${b} = ${c+b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = \\frac{${c+b}}{${a}} = ${formatColor(answer)}` }
            ];
        }
        else if (type === 3) { // x/a + b = c
            const a = rng.intBetween(2, 8);
            const b = rng.intBetween(1, 10);
            const realX = x * a; 
            answer = realX;
            const c = x + b;
            eq = `\\frac{x}{${a}} + ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.subtract(b)), latex: `\\frac{x}{${a}} = ${c} - ${b} = ${c-b}` },
                { text: t(lang, TERMS.algebra.multiply(a)), latex: `x = ${c-b} \\cdot ${a} = ${formatColor(answer)}` }
            ];
        }
        else { // x/a - b = c
            const a = rng.intBetween(2, 8);
            const b = rng.intBetween(1, 10);
            const realX = x * a;
            answer = realX;
            const c = x - b; 
            eq = `\\frac{x}{${a}} - ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.add(b)), latex: `\\frac{x}{${a}} = ${c} + ${b} = ${c+b}` },
                { text: t(lang, TERMS.algebra.multiply(a)), latex: `x = ${c+b} \\cdot ${a} = ${formatColor(answer)}` }
            ];
        }
    }

    // --- LEVEL 3: Parentheses (Moved from Level 4) ---
    // Variations: a(x+b)=c, a(x-b)=c, a(bx-c)=d, a(bx+c)=d
    else if (mode === 3) {
        const type = rng.intBetween(1, 4);
        const a = rng.intBetween(2, 6);
        
        if (type === 1) { // a(x + b) = c
            const x = rng.intBetween(1, 10);
            const b = rng.intBetween(1, 9);
            const c = a * (x + b);
            answer = x;
            eq = `${a}(x + ${b}) = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a}x + ${a*b} = ${c}` },
                { text: t(lang, TERMS.algebra.subtract(a*b)), latex: `${a}x = ${c - a*b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 2) { // a(x - b) = c
            const x = rng.intBetween(5, 15);
            const b = rng.intBetween(1, x - 1); 
            const c = a * (x - b);
            answer = x;
            eq = `${a}(x - ${b}) = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a}x - ${a*b} = ${c}` },
                { text: t(lang, TERMS.algebra.add(a*b)), latex: `${a}x = ${c + a*b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 3) { // a(bx - c) = d
            const bVar = rng.intBetween(2, 5);
            const x = rng.intBetween(2, 8);
            const cVar = rng.intBetween(1, bVar * x - 1);
            const d = a * (bVar * x - cVar);
            answer = x;
            eq = `${a}(${bVar}x - ${cVar}) = ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a*bVar}x - ${a*cVar} = ${d}` },
                { text: t(lang, TERMS.algebra.add(a*cVar)), latex: `${a*bVar}x = ${d + a*cVar}` },
                { text: t(lang, TERMS.algebra.divide(a*bVar)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else { // a(bx + c) = d
            const bVar = rng.intBetween(2, 5);
            const x = rng.intBetween(1, 8);
            const cVar = rng.intBetween(1, 9);
            const d = a * (bVar * x + cVar);
            answer = x;
            eq = `${a}(${bVar}x + ${cVar}) = ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a*bVar}x + ${a*cVar} = ${d}` },
                { text: t(lang, TERMS.algebra.subtract(a*cVar)), latex: `${a*bVar}x = ${d - a*cVar}` },
                { text: t(lang, TERMS.algebra.divide(a*bVar)), latex: `x = ${formatColor(answer)}` }
            ];
        }
    }

    // --- LEVEL 4: X on Both Sides (Moved from Level 3) ---
    // Constraints: x > 0.
    // Variations: ax+b=cx+d, ax-b=cx+d, ax+b=cx-d, ax-b=cx-d
    else if (mode === 4) {
        const type = rng.intBetween(1, 4);
        const x = rng.intBetween(1, 10); // x > 0 constraint
        let a = rng.intBetween(3, 9);
        let c = rng.intBetween(2, a - 1); // Ensure a > c to keep x positive
        
        if (a === c) a++;
        
        if (type === 1) { // ax + b = cx + d
            const b = rng.intBetween(1, 15);
            const d = a*x + b - c*x;
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x + ${b} = ${c}x + ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${c}x`)), latex: `${a-c}x + ${b} = ${d}` },
                { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a-c}x = ${d-b}` },
                { text: t(lang, TERMS.algebra.divide(a-c)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 2) { // ax - b = cx + d
            const b = rng.intBetween(1, 15);
            const d = a*x - b - c*x;
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x - ${b} = ${c}x + ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${c}x`)), latex: `${a-c}x - ${b} = ${d}` },
                { text: t(lang, TERMS.algebra.add(b)), latex: `${a-c}x = ${d+b}` },
                { text: t(lang, TERMS.algebra.divide(a-c)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 3) { // ax + b = cx - d
            const temp = a; a = c; c = temp; // Swap so c > a (negative x term on left, or we solve differently)
            // Wait, if we want a positive answer with form ax + b = cx - d, then cx - d > b.
            // Also ax < cx.
            
            const b = rng.intBetween(1, 15);
            const d = c*x - a*x - b;
            
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x + ${b} = ${c}x - ${d}`;
            // Move ax to right: b + d = (c-a)x
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${a}x`)), latex: `${b} = ${c-a}x - ${d}` },
                { text: t(lang, TERMS.algebra.add(d)), latex: `${b+d} = ${c-a}x` },
                { text: t(lang, TERMS.algebra.divide(c-a)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else { // ax - b = cx - d
            if (a < c) { const t = a; a = c; c = t; }
            
            const b = rng.intBetween(5, 20);
            const d = b - (a*x - c*x);
            
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x - ${b} = ${c}x - ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${c}x`)), latex: `${a-c}x - ${b} = -${d}` },
                { text: t(lang, TERMS.algebra.add(b)), latex: `${a-c}x = ${b} - ${d} = ${b-d}` },
                { text: t(lang, TERMS.algebra.divide(a-c)), latex: `x = ${formatColor(answer)}` }
            ];
        }
    }

    return {
        questionId: `leq-l${level}-${seed}`,
        renderData: {
            text_key: "solve_eq",
            description: description,
            latex: eq,
            answerType: "numeric",
            variables: {}
        },
        serverData: {
            answer: answer,
            solutionSteps: steps
        }
    };
  }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";
import { TextEngine, ContextKey, CONTEXTS } from "../utils/textEngine";

interface ProblemScenario {
    id: string;
    type: 'A' | 'B' | 'C' | 'D';
    logic: (rng: Random) => MathData;
    templates: { sv: string, en: string }[];
    context: ContextKey;
}

interface MathData {
    vars: Record<string, number>; // Constants a, b, c
    solution: number; // x
    equation: string;
    stepsSolve: (lang: Language, formatColor: (v:any)=>string) => Clue[];
    stepsWrite: (lang: Language, formatColor: (v:any)=>string) => Clue[];
}

export class LinearEquationProblemGen {
    
    private static getScenarios(): ProblemScenario[] {
        return [
            // --- TYPE A: ax + b = c (Shopping/Taxi) ---
            {
                id: 'shopping_bag',
                type: 'A',
                context: 'shopping',
                templates: [ TERMS.problem_solving.a_buy ],
                logic: (rng) => {
                    const x = rng.intBetween(3, 15); 
                    const a = rng.intBetween(5, 25); 
                    const b = rng.pick([2, 5, 10]); 
                    const c = a * x + b;
                    
                    // x IS NOT PASSED in vars to prevent auto-replacement in text
                    return {
                        vars: { a, b, c }, 
                        solution: x,
                        equation: `${a}x + ${b} = ${c}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.clue_var), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_rate_val), latex: `\\text{Pris} \\cdot \\text{Antal} = ${a} \\cdot x = ${a}x` },
                            { text: t(lang, TERMS.problem_solving.expl_fixed_val), latex: `+ ${b}` },
                            { text: t(lang, TERMS.problem_solving.clue_total), latex: `${a}x + ${b} = ${c}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `${a}x + ${b} = ${c}` },
                            { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a}x = ${c - b} = ${c - b}` },
                            { text: t(lang, TERMS.algebra.divide(a)), latex: `x = \\frac{${c - b}}{${a}} = ${fc(x)}` }
                        ]
                    };
                }
            },
            {
                id: 'taxi',
                type: 'A',
                context: 'shopping',
                templates: [ TERMS.problem_solving.a_taxi ],
                logic: (rng) => {
                    const x = rng.intBetween(5, 30); 
                    const a = rng.intBetween(10, 50); 
                    const b = rng.pick([45, 50, 75, 100]); 
                    const c = a * x + b;
                    return {
                        vars: { a, b, c },
                        solution: x,
                        equation: `${a}x + ${b} = ${c}`,
                        stepsWrite: (lang, fc) => [
                             { text: t(lang, TERMS.problem_solving.clue_var), latex: "x" },
                             { text: t(lang, TERMS.problem_solving.expl_rate_val), latex: `${a} \\cdot x` },
                             { text: t(lang, TERMS.problem_solving.expl_fixed_val), latex: `+ ${b}` },
                             { text: t(lang, TERMS.problem_solving.clue_total), latex: `${a}x + ${b} = ${c}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `${a}x + ${b} = ${c}` },
                            { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a}x = ${c - b}` },
                            { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            },

            // --- TYPE B: ax - b = c (Discount) ---
            {
                id: 'shopping_discount',
                type: 'B',
                context: 'shopping',
                templates: [ TERMS.problem_solving.b_discount ],
                logic: (rng) => {
                    const x = rng.intBetween(2, 10); 
                    const a = rng.intBetween(50, 200); 
                    const b = rng.pick([20, 50, 100]); 
                    const c = a * x - b;
                    return {
                        vars: { a, b, c }, // x excluded
                        solution: x,
                        equation: `${a}x - ${b} = ${c}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.clue_var), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_item_cost), latex: `${a}x` },
                            { text: t(lang, TERMS.problem_solving.expl_discount_sub), latex: `-${b}` },
                            { text: t(lang, TERMS.problem_solving.clue_total), latex: `${a}x - ${b} = ${c}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `${a}x - ${b} = ${c}` },
                            { text: t(lang, TERMS.algebra.add(b)), latex: `${a}x = ${c + b}` },
                            { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            },

            // --- TYPE C: x + (x + a) = c (Comparison Sum) ---
            {
                id: 'compare_sum',
                type: 'C',
                context: 'hobbies',
                templates: [ TERMS.problem_solving.c_compare ],
                logic: (rng) => {
                    const x = rng.intBetween(5, 20); 
                    const a = rng.intBetween(2, 10); 
                    const total = x + (x + a);
                    return {
                        vars: { a, c: total }, // x excluded
                        solution: x,
                        equation: `2x + ${a} = ${total}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.expl_person1), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_person2_more), latex: `x + ${a}` },
                            { text: t(lang, TERMS.problem_solving.expl_compare_sum), latex: `x + (x + ${a}) = ${total}` },
                            { text: t(lang, TERMS.common.simplify), latex: `2x + ${a} = ${total}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `2x + ${a} = ${total}` },
                            { text: t(lang, TERMS.algebra.subtract(a)), latex: `2x = ${total - a}` },
                            { text: t(lang, TERMS.algebra.divide(2)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            },

            // --- TYPE D: x + (x - b) = c (Comparison Diff) ---
            {
                id: 'compare_diff',
                type: 'D',
                context: 'hobbies',
                templates: [ TERMS.problem_solving.d_compare ],
                logic: (rng) => {
                    const x = rng.intBetween(10, 30); 
                    const b = rng.intBetween(2, 8);   
                    const total = x + (x - b);
                    return {
                        vars: { b, c: total }, // x excluded
                        solution: x,
                        equation: `2x - ${b} = ${total}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.expl_person1), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_person2_less), latex: `x - ${b}` },
                            { text: t(lang, TERMS.problem_solving.expl_compare_sum), latex: `x + (x - ${b}) = ${total}` },
                            { text: t(lang, TERMS.common.simplify), latex: `2x - ${b} = ${total}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `2x - ${b} = ${total}` },
                            { text: t(lang, TERMS.algebra.add(b)), latex: `2x = ${total + b}` },
                            { text: t(lang, TERMS.algebra.divide(2)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            }
        ];
    }

    public static generate(level: number, seed: string, lang: Language = 'sv'): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        const scenarios = this.getScenarios();
        const scenario = rng.pick(scenarios);
        
        // Generate math - x is NOT in math.vars
        const math = scenario.logic(rng);
        
        const rawTemplateObj = rng.pick(scenario.templates);
        let text = t(lang, rawTemplateObj);

        // Replace math variables ($a$, $b$, $c$)
        Object.entries(math.vars).forEach(([key, val]) => {
            text = text.replace(new RegExp(`\\$${key}\\$`, 'g'), `$${val}$`);
            text = text.replace(new RegExp(`\\$${key}`, 'g'), `$${val}`);
        });

        // Replace Context
        const ctxData = CONTEXTS[scenario.context];
        if (ctxData) {
            const itemObj = rng.pick(ctxData.items);
            const itemStr = t(lang, itemObj);
            const name1 = rng.pick(ctxData.people);
            let name2 = rng.pick(ctxData.people);
            while (name1 === name2) name2 = rng.pick(ctxData.people);

            text = text.replace(/{item}/g, itemStr);
            text = text.replace(/{name1}/g, name1);
            text = text.replace(/{name2}/g, name2);
        }

        const isWriteMode = level === 5;
        const taskText = isWriteMode ? t(lang, TERMS.problem_solving.task_write) : t(lang, TERMS.problem_solving.task_solve);
        
        return {
            questionId: `prob-l${level}-${seed}`,
            renderData: {
                text_key: "problem_solving",
                description: `${text} ${taskText}`,
                latex: "",
                answerType: isWriteMode ? 'text' : 'numeric', 
                variables: {}
            },
            serverData: {
                answer: isWriteMode ? math.equation : math.solution,
                solutionSteps: isWriteMode ? math.stepsWrite(lang, formatColor) : math.stepsSolve(lang, formatColor)
            }
        };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language, TERMS } from "../utils/i18n";

export class LinearGraphGenerator {
    public static generate(level: number, seed: string, lang: Language = 'sv'): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;
        
        let mode = level;
        if (level >= 5) mode = rng.intBetween(1, 4);

        let k = 1, m = 0, steps: Clue[] = [];
        let answer: string | number = 0; 
        let answerType: any = 'numeric';
        let description = { sv: "", en: "" };

        const getSlope = (min: number, max: number) => rng.intBetween(min, max);

        // --- LEVEL 1: Find m (intercept) ---
        if (mode === 1) {
            k = getSlope(-3, 3); 
            m = rng.intBetween(-5, 5); 
            
            answer = m;
            description = TERMS.graph.q_intercept;
            
            steps = [
                { text: t(lang, TERMS.graph.look_x0), latex: "(0, y)" }, 
                { text: t(lang, TERMS.graph.step_intercept(m)), latex: `m = ${formatColor(m)}` }
            ];
        } 
        
        // --- LEVEL 2: Find k (positive slope) ---
        else if (mode === 2) {
            k = rng.intBetween(0, 3); 
            m = rng.intBetween(-5, 5); 
            
            answer = k;
            description = TERMS.graph.q_slope;
            
            steps = [
                { text: t(lang, TERMS.graph.step_delta), latex: "k = \\frac{\\Delta y}{\\Delta x}" },
                { text: t(lang, TERMS.graph.step_slope_calc), latex: `k = ${formatColor(k)}` }
            ];
        }

        // --- LEVEL 3: Find k (negative slope) ---
        else if (mode === 3) {
            k = rng.intBetween(-3, 0);
            m = rng.intBetween(-5, 5); 
            
            answer = k;
            description = TERMS.graph.q_slope;
            
            steps = [
                { text: t(lang, TERMS.graph.step_delta), latex: "k = \\frac{\\Delta y}{\\Delta x}" },
                { text: t(lang, TERMS.graph.step_slope_calc), latex: `k = ${formatColor(k)}` }
            ];
        }

        // --- LEVEL 4: Find Equation (y = kx + m) ---
        else {
            k = getSlope(-3, 3); 
            m = rng.intBetween(-5, 5); 
            
            let eqStr = "";
            if (k === 0) {
                eqStr = `y=${m}`;
            } else {
                const mPart = m >= 0 ? `+${m}` : `${m}`; 
                eqStr = `y=${k}x${mPart}`; 
            }
            
            answer = eqStr;
            answerType = 'function_model'; 

            description = TERMS.graph.q_func;
            
            const eqDisplay = k === 0 
                ? `y = ${formatColor(m)}` 
                : `y = ${formatColor(k)}x ${m >= 0 ? '+' : ''}${formatColor(m)}`;

            steps = [
                { text: t(lang, TERMS.graph.find_m), latex: `m = ${m}` }, 
                { text: t(lang, TERMS.graph.find_k), latex: `k = ${k}` }, 
                { text: t(lang, TERMS.graph.q_func), latex: eqDisplay }
            ];
        }

        const lines = [{ slope: k, intercept: m, color: '#2563eb' }];

        return {
            questionId: `graph-l${level}-${seed}`,
            renderData: {
                text_key: "graph_gen",
                description: description,
                latex: "",
                answerType: answerType,
                graph: {
                    lines: lines,
                    range: 10, 
                    gridStep: 1
                }
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class NegativeNumbersGen {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let mode = level;
        // Level 5: Mixed (1-4)
        if (level === 5) mode = rng.intBetween(1, 4);

        let steps: Clue[] = [];
        let answer: number = 0;
        let latex = "";
        let description = { sv: "Ber√§kna.", en: "Calculate." };

        const p = (n: number) => n < 0 ? `(${n})` : `${n}`;

        // --- LEVELS 1 & 2: Add/Sub ---
        if (mode === 1 || mode === 2) {
            const range = mode === 1 ? 10 : 50;
            const min = mode === 1 ? -10 : -20;
            const numCount = mode === 1 ? rng.intBetween(2, 3) : rng.intBetween(3, 4);
            
            let nums: number[] = [];
            let ops: string[] = []; // '+' or '-'

            // Generate first number
            nums.push(rng.intBetween(min, range));
            
            // Generate rest
            for(let i=1; i<numCount; i++) {
                nums.push(rng.intBetween(min, range));
                ops.push(rng.pick(['+', '-']));
            }

            // Build full expression string
            latex = `${nums[0]}`;
            for(let i=0; i<ops.length; i++) {
                latex += ` ${ops[i]} ${p(nums[i+1])}`;
            }
            latex += " =";

            // Calculate Answer & Generate Iterative Steps
            let runningVal = nums[0];
            
            for(let i=0; i<ops.length; i++) {
                const nextNum = nums[i+1];
                const op = ops[i];
                let stepExpl = "";
                let stepLatex = "";

                if (op === '+') {
                    if (nextNum < 0) {
                        // Adding a negative -> Subtract
                        stepExpl = "add_neg";
                        stepLatex = `${runningVal} + (${nextNum}) = ${runningVal} - ${Math.abs(nextNum)}`;
                        runningVal += nextNum;
                    } else {
                        // Standard addition
                        stepExpl = "simple_calc";
                        stepLatex = `${runningVal} + ${nextNum}`;
                        runningVal += nextNum;
                    }
                } else { // op === '-'
                    if (nextNum < 0) {
                        // Subtracting a negative -> Add
                        stepExpl = "sub_neg";
                        stepLatex = `${runningVal} - (${nextNum}) = ${runningVal} + ${Math.abs(nextNum)}`;
                        runningVal -= nextNum;
                    } else {
                        // Standard subtraction
                        stepExpl = "simple_calc";
                        stepLatex = `${runningVal} - ${nextNum}`;
                        runningVal -= nextNum;
                    }
                }

                if (stepExpl) {
                    steps.push({ text: t(lang, TERMS.neg_signs[stepExpl]), latex: stepLatex });
                }
                
                // Show intermediate result
                steps.push({ text: t(lang, TERMS.neg_signs.step_calc), latex: `= ${formatColor(runningVal)}` });
            }
            
            answer = runningVal;
        }

        // --- LEVEL 3: Multiplication ---
        else if (mode === 3) {
            const count = rng.intBetween(2, 3); // a*b or a*b*c
            const nums: number[] = [];
            for(let i=0; i<count; i++) nums.push(rng.intBetween(-10, 10));
            // Ensure no zeros for clearer sign rules
            nums.forEach((n, i) => { if(n===0) nums[i] = 2; });

            latex = nums.map(n => p(n)).join(' \\cdot ') + " =";
            
            let runningVal = nums[0];
            
            for(let i=1; i<nums.length; i++) {
                const prev = runningVal;
                const next = nums[i];
                // Check signs for rule explanation
                const isPrevNeg = prev < 0;
                const isNextNeg = next < 0;
                
                let explKey = "";
                // Logic: 
                // + * - = -
                // - * + = -
                // - * - = +
                // + * + = + (no special rule needed, usually)

                if (isPrevNeg && isNextNeg) explKey = "mul_neg_neg";
                else if (isPrevNeg !== isNextNeg) explKey = "mul_pos_neg";
                else explKey = "simple_calc";
                
                runningVal *= next;
                
                steps.push({ 
                    text: t(lang, TERMS.neg_signs[explKey]), 
                    latex: `${p(prev)} \\cdot ${p(next)} = ${formatColor(runningVal)}` 
                });
            }
            answer = runningVal;
        }

        // --- LEVEL 4: Division (a/b) ---
        else { 
            let b = 0;
            while(b === 0) b = rng.intBetween(-10, 10);
            
            const maxRes = Math.floor(100 / Math.abs(b));
            let res = 0;
            while(res === 0) res = rng.intBetween(-maxRes, maxRes);
            
            const a = res * b;
            answer = res;
            
            latex = `\\frac{${a}}{${b}} =`;

            const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);
            const explKey = sameSign ? "div_sign_same" : "div_sign_diff";
            
            steps.push({
                text: t(lang, TERMS.neg_signs[explKey]),
                latex: `${a} / ${b} = ${formatColor(answer)}`
            });
        }

        return {
            questionId: `neg-l${level}-${seed}`,
            renderData: {
                text_key: "arithmetic", 
                description: description,
                latex: latex,
                answerType: "numeric",
                variables: {}
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class ScaleGenerator {
    
    // --- CONSTANTS & DATA ---

    private static readonly SHAPES = [
        'square', 'rectangle', 'circle', 'triangle', 
        'rhombus', 'parallelogram', 'pentagon', 'hexagon', 'octagon',
        'star', 'arrow', 'heart', 'cross', 'lightning', 'kite',
        'cube', 'cylinder', 'pyramid', 'cone', 'sphere'
    ];

    private static readonly AREA_SHAPES = ['rectangle', 'triangle', 'circle', 'semicircle', 'parallelogram'];

    /**
     * Generate diverse scale factors:
     * - Small integers (2-25)
     * - Medium multiples of 5 (30-100)
     * - Large multiples of 10 (100-1000)
     */
    private static getScaleFactor(rng: Random): number {
        const type = rng.intBetween(1, 10);
        if (type <= 4) return rng.intBetween(2, 25);
        if (type <= 7) return rng.intBetween(6, 20) * 5;
        return rng.intBetween(10, 100) * 10;
    }

    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        
        // Correct LaTeX color formatting
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;
        
        let mode = level;
        
        // --- LEVEL 7: MIXED ---
        if (level === 7) {
            mode = rng.intBetween(1, 6); 
        }

        // --- LEVEL 1: CONCEPTUAL (Multiple Choice) ---
        if (mode === 1) {
            const isReduction = rng.intBetween(0, 1) === 1; 
            const ratio = rng.pick([2, 5, 10, 20, 50, 100]); // Keep Level 1 simple
            const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
            const qType = rng.intBetween(1, 2);
            let descObj = { sv: "", en: "" }, correct = "", choices: string[] = [], expl = "";

            if (qType === 1) {
                descObj = { sv: `Visar skalan ${scaleStr} en f√∂rstoring eller en f√∂rminskning?`, en: `Does the scale ${scaleStr} show an enlargement or a reduction?` };
                correct = isReduction ? t(lang, TERMS.scale.reduction) : t(lang, TERMS.scale.enlargement);
                const wrong = isReduction ? t(lang, TERMS.scale.enlargement) : t(lang, TERMS.scale.reduction);
                choices = rng.intBetween(0,1) ? [wrong, correct] : [correct, wrong];
                expl = isReduction ? t(lang, TERMS.scale.rule_reduction) : t(lang, TERMS.scale.rule_enlargement);
            } else {
                descObj = { sv: `Skalan √§r ${scaleStr}. Vad √§r st√∂rst: bilden eller verkligheten?`, en: `The scale is ${scaleStr}. Which is larger: the image or reality?` };
                correct = isReduction ? t(lang, TERMS.scale.reality) : t(lang, TERMS.scale.drawing);
                const wrong = isReduction ? t(lang, TERMS.scale.drawing) : t(lang, TERMS.scale.reality);
                choices = rng.intBetween(0,1) ? [wrong, correct] : [correct, wrong];
                expl = isReduction ? t(lang, TERMS.scale.rule_reduction) : t(lang, TERMS.scale.rule_enlargement);
            }
            return {
                questionId: `scale-l1-${seed}`,
                renderData: { 
                    text_key: "concept", 
                    description: descObj, 
                    latex: scaleStr, 
                    answerType: 'multiple_choice', 
                    choices: choices,
                    variables: {} 
                },
                serverData: { answer: correct, solutionSteps: [{ text: expl, latex: scaleStr }] }
            };
        }

        // Shared Setup for L2-6
        const shape = rng.pick(this.SHAPES);
        const svShape = t('sv', TERMS.shapes[shape]) || shape;
        const enShape = t('en', TERMS.shapes[shape]) || shape;
        
        const scaleFactor = ScaleGenerator.getScaleFactor(rng);

        // --- LEVEL 2: FIND LENGTH (EASY - SAME UNITS) ---
        if (mode === 2) {
            // Support X:1
            const isReduction = rng.intBetween(0, 1) === 1;
            const scaleStr = isReduction ? `1:${scaleFactor}` : `${scaleFactor}:1`;
            
            const subType = rng.intBetween(0, 1);
            let drawingVal = 0, realVal = 0, answer = 0;
            let steps: Clue[] = [];
            let geomLabel = "";
            let descriptionObj = { sv: "", en: "" };

            // Base integer to ensure clean numbers
            const baseInt = rng.intBetween(2, 15);

            if (isReduction) {
                // 1:X
                if (subType === 0) { // Find Real
                    drawingVal = baseInt; 
                    realVal = drawingVal * scaleFactor; 
                    answer = realVal;
                    descriptionObj = { sv: `En ${svShape} √§r ${drawingVal} cm p√• ritningen. Skalan √§r ${scaleStr}. Hur l√•ng √§r den i verkligheten? (Svara i cm)`, en: `A ${enShape} is ${drawingVal} cm on the drawing. Scale is ${scaleStr}. How long is it in reality? (Answer in cm)` };
                    geomLabel = `${drawingVal} cm`;
                    steps = [{ text: t(lang, TERMS.common.calculate), latex: `${drawingVal} \\cdot ${scaleFactor} = ${formatColor(realVal)}` }];
                } else { // Find Drawing
                    answer = baseInt; // Drawing is the small base int
                    realVal = answer * scaleFactor;
                    descriptionObj = { sv: `I verkligheten √§r en ${svShape} ${realVal} cm l√•ng. Hur l√•ng blir den p√• en ritning i skala ${scaleStr}? (Svara i cm)`, en: `In reality, a ${enShape} is ${realVal} cm long. How long will it be on a drawing with scale ${scaleStr}? (Answer in cm)` };
                    geomLabel = `${realVal} cm`;
                    steps = [{ text: t(lang, TERMS.scale.step_plug_in), latex: `\\frac{${realVal}}{${scaleFactor}} = ${formatColor(answer)}` }];
                }
            } else {
                // X:1 (Enlargement)
                if (subType === 0) { // Find Drawing
                    realVal = baseInt; 
                    drawingVal = realVal * scaleFactor; 
                    answer = drawingVal;
                    descriptionObj = { sv: `I verkligheten √§r en ${svShape} ${realVal} cm l√•ng. Skalan √§r ${scaleStr}. Hur l√•ng blir den p√• en ritning? (Svara i cm)`, en: `In reality, a ${enShape} is ${realVal} cm long. Scale is ${scaleStr}. How long on the drawing? (Answer in cm)` };
                    geomLabel = `${realVal} cm`;
                    steps = [{ text: t(lang, TERMS.common.calculate), latex: `${realVal} \\cdot ${scaleFactor} = ${formatColor(drawingVal)}` }];
                } else { // Find Reality
                    answer = baseInt;
                    drawingVal = answer * scaleFactor; 
                    descriptionObj = { sv: `En ${svShape} √§r ${drawingVal} cm p√• ritningen. Skalan √§r ${scaleStr}. Hur l√•ng √§r den i verkligheten? (Svara i cm)`, en: `A ${enShape} is ${drawingVal} cm on the drawing. Scale is ${scaleStr}. Find reality (cm).` };
                    geomLabel = `${drawingVal} cm`;
                    steps = [{ text: t(lang, TERMS.scale.step_plug_in), latex: `\\frac{${drawingVal}}{${scaleFactor}} = ${formatColor(answer)}` }];
                }
            }

            return {
                questionId: `scale-l2-${seed}`,
                renderData: { 
                    text_key: "calc_len_easy", 
                    description: descriptionObj, 
                    latex: scaleStr, 
                    answerType: 'numeric', 
                    geometry: { type: 'scale_single', shape, label: geomLabel }
                },
                serverData: { answer, solutionSteps: steps }
            };
        }

        // --- LEVEL 3: FIND LENGTH (HARD - MIXED UNITS) ---
        if (mode === 3) {
            // Usually map scales (1:X)
            const subType = rng.intBetween(0, 1);
            let answer = 0;
            let steps: Clue[] = [];
            let geomLabel = "";
            let descriptionObj = { sv: "", en: "" };
            const baseInt = rng.intBetween(2, 9);

            if (subType === 0) { // Find Real (Answer in m)
                const drawingVal = baseInt; 
                const realValCm = drawingVal * scaleFactor;
                const realValM = realValCm / 100;
                answer = realValM;

                descriptionObj = { sv: `En ${svShape} √§r ${drawingVal} cm p√• ritningen. Skalan √§r 1:${scaleFactor}. Hur l√•ng √§r den i verkligheten? (Svara i m)`, en: `A ${enShape} is ${drawingVal} cm on the drawing. Scale is 1:${scaleFactor}. How long is it in reality? (Answer in m)` };
                geomLabel = `${drawingVal} cm`;
                steps = [
                    { text: t(lang, TERMS.scale.calc_cm), latex: `${drawingVal} \\cdot ${scaleFactor} = ${realValCm} \\text{ cm}` },
                    { text: t(lang, TERMS.scale.conv_m), latex: `\\frac{${realValCm}}{100} = ${formatColor(realValM)}` }
                ];
            } else { // Find Drawing
                const drawingVal = baseInt; 
                const realValCm = drawingVal * scaleFactor;
                const realValM = realValCm / 100;
                answer = drawingVal;

                descriptionObj = { sv: `I verkligheten √§r en ${svShape} ${realValM} m l√•ng. Skalan √§r 1:${scaleFactor}. Hur l√•ng p√• ritningen? (Svara i cm)`, en: `In reality a ${enShape} is ${realValM} m long. Scale 1:${scaleFactor}. Find drawing (cm).` };
                geomLabel = `${realValM} m`;
                steps = [
                    { text: t(lang, TERMS.scale.conv_same), latex: `${realValM} \\text{ m} = ${realValCm} \\text{ cm}` },
                    { text: t(lang, TERMS.scale.step_plug_in), latex: `\\frac{${realValCm}}{${scaleFactor}} = ${formatColor(answer)}` }
                ];
            }

            return {
                questionId: `scale-l3-${seed}`,
                renderData: { 
                    text_key: "calc_len_hard", 
                    description: descriptionObj, 
                    latex: `1:${scaleFactor}`, 
                    answerType: 'numeric', 
                    geometry: { type: 'scale_single', shape, label: geomLabel }
                },
                serverData: { answer, solutionSteps: steps }
            };
        }

        // --- LEVEL 4: FIND SCALE (RANDOM POSITIONING & TYPE) ---
        if (mode === 4) {
            const base = rng.intBetween(2, 5); 
            const factor = ScaleGenerator.getScaleFactor(rng);
            
            // Randomize Reduction (1:X) vs Enlargement (X:1)
            const isReduction = rng.intBetween(0, 1) === 1;
            
            let drawVal, realVal;
            let ansLeft, ansRight;
            let steps: Clue[] = [];

            if (isReduction) {
                drawVal = base;
                realVal = base * factor; 
                ansLeft = 1;
                ansRight = factor;
                
                const realUnit = factor >= 100 ? 'm' : 'cm';
                const realDisplay = realUnit === 'm' ? realVal / 100 : realVal;

                steps = [
                    { text: t(lang, TERMS.scale.conv_same), latex: `${realDisplay} ${realUnit} = ${realVal} \\text{ cm}` },
                    { text: t(lang, TERMS.scale.setup_ratio), latex: `\\text{Bild} : \\text{Verklighet} = ${drawVal} : ${realVal}` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `1 : \\frac{${realVal}}{${drawVal}} \\implies ${formatColor('1:' + factor)}` }
                ];
            } else {
                // Enlargement
                realVal = base;
                drawVal = base * factor; 
                ansLeft = factor;
                ansRight = 1;

                steps = [
                    { text: t(lang, TERMS.scale.setup_ratio), latex: `\\text{Bild} : \\text{Verklighet} = ${drawVal} : ${realVal}` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `\\frac{${drawVal}}{${realVal}} : 1 \\implies ${formatColor(factor + ':1')}` }
                ];
            }

            const descriptionObj = { sv: `Best√§m skalan.`, en: `Determine the scale.` };
            
            // Visual Randomization
            const leftIsDrawing = rng.intBetween(0, 1) === 1;
            const leftLabel = leftIsDrawing ? t(lang, TERMS.scale.drawing) : t(lang, TERMS.scale.reality);
            const rightLabel = leftIsDrawing ? t(lang, TERMS.scale.reality) : t(lang, TERMS.scale.drawing);
            
            // Value Formatting
            const realUnit = (!isReduction && factor < 100) ? 'cm' : (factor >= 100 ? 'm' : 'cm');
            const realDisplay = (realUnit === 'm' ? realVal / 100 : realVal);

            const leftValue = leftIsDrawing ? `${drawVal} cm` : `${realDisplay} ${realUnit}`;
            const rightValue = leftIsDrawing ? `${realDisplay} ${realUnit}` : `${drawVal} cm`;

            return {
                questionId: `scale-l4-${seed}`,
                renderData: {
                    text_key: "find_scale",
                    description: descriptionObj,
                    latex: "",
                    answerType: 'scale',
                    geometry: { type: 'scale_compare', shape, leftLabel, rightLabel, leftValue, rightValue }
                },
                serverData: { answer: { left: ansLeft, right: ansRight }, solutionSteps: steps }
            };
        }

        // --- LEVEL 5: TEXT ONLY (FIND SCALE) ---
        if (mode === 5) {
            const base = rng.intBetween(3, 8); 
            const factor = ScaleGenerator.getScaleFactor(rng); 
            
            const isReduction = rng.intBetween(0, 1) === 1;

            let drawVal, realVal, ansLeft, ansRight;
            let descriptionObj = { sv: "", en: "" };
            let steps: Clue[] = [];

            if (isReduction) {
                drawVal = base;
                realVal = base * factor; // cm
                const realM = realVal / 100;
                const showM = factor >= 100;
                
                ansLeft = 1; ansRight = factor;

                descriptionObj = {
                    sv: `P√• en ritning √§r en ${svShape} ${drawVal} cm l√•ng. I verkligheten √§r den ${showM ? realM + ' m' : realVal + ' cm'}. Vad √§r skalan?`,
                    en: `On a drawing, a ${enShape} is ${drawVal} cm long. In reality it is ${showM ? realM + ' m' : realVal + ' cm'}. What is the scale?`
                };
                
                if (showM) {
                    steps.push({ text: t(lang, TERMS.scale.conv_same), latex: `${realM} \\text{ m} = ${realVal} \\text{ cm}` });
                }
                steps.push({ text: t(lang, TERMS.scale.setup_ratio), latex: `${drawVal} : ${realVal}` });
                steps.push({ text: t(lang, TERMS.scale.step_simplify), latex: `1 : \\frac{${realVal}}{${drawVal}} \\implies ${formatColor('1:' + factor)}` });

            } else {
                // Enlargement
                realVal = base;
                drawVal = base * factor; 
                ansLeft = factor; ansRight = 1;

                descriptionObj = {
                    sv: `I verkligheten √§r en ${svShape} ${realVal} cm l√•ng. P√• en ritning √§r den ${drawVal} cm. Vad √§r skalan?`,
                    en: `In reality a ${enShape} is ${realVal} cm long. On a drawing it is ${drawVal} cm. What is the scale?`
                };

                steps = [
                    { text: t(lang, TERMS.scale.setup_ratio), latex: `${drawVal} : ${realVal}` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `\\frac{${drawVal}}{${realVal}} : 1 \\implies ${formatColor(factor + ':1')}` }
                ];
            }

            return {
                questionId: `scale-l5-${seed}`,
                renderData: { text_key: "find_scale_text", description: descriptionObj, latex: "", answerType: 'scale', variables: {} },
                serverData: { answer: { left: ansLeft, right: ansRight }, solutionSteps: steps }
            };
        }

        // --- LEVEL 6: AREA SCALE ---
        if (mode === 6) {
            const areaShape = rng.pick(ScaleGenerator.AREA_SHAPES);
            const subType = rng.intBetween(1, 4);
            const lengthScale = rng.pick([2, 3, 4, 5, 10]); // Keep square roots clean
            const areaScale = lengthScale * lengthScale;

            const isReduction = rng.intBetween(0, 1) === 1;

            let steps: Clue[] = [];
            let qDesc: { sv: string, en: string } = { sv: "", en: "" };
            let geomData: any = {};
            let answer: any = 0;
            let answerType: any = 'numeric';

            const shapePluralSv = (t('sv', TERMS.shapes_plural[areaShape]) || areaShape);
            const shapePluralEn = (t('en', TERMS.shapes_plural[areaShape]) || areaShape);

            if (subType === 1) { // Find Scale (Visual)
                const w = rng.intBetween(2, 6);
                const h = (areaShape === 'rectangle' || areaShape === 'parallelogram' || areaShape === 'triangle') ? rng.intBetween(2, 6) : 0;
                const wReal = w * lengthScale; const hReal = h * lengthScale;
                let areaDraw = 0, areaReal = 0;

                if (areaShape === 'rectangle' || areaShape === 'parallelogram') { areaDraw = w * h; areaReal = wReal * hReal; }
                else if (areaShape === 'triangle') { areaDraw = (w * h) / 2; areaReal = (wReal * hReal) / 2; }
                else if (areaShape === 'circle') { areaDraw = Math.PI * w * w; areaReal = Math.PI * wReal * wReal; } 
                else if (areaShape === 'semicircle') { areaDraw = (Math.PI * w * w) / 2; areaReal = (Math.PI * wReal * wReal) / 2; }

                const dispAreaDraw = Math.round(areaDraw * 10) / 10;
                const dispAreaReal = Math.round(areaReal * 10) / 10;

                qDesc = {
                    sv: `H√§r √§r tv√• ${shapePluralSv}. Den f√∂rsta √§r en avbildning och den andra √§r verkligheten. Vad √§r areaskalan?`,
                    en: `Here are two ${shapePluralEn}. The first is a drawing, the second is reality. What is the area scale?`
                };

                steps = [
                    { text: t(lang, TERMS.scale.calc_area_img), latex: `A_{bild} = ${dispAreaDraw} \\text{ cm}^2` },
                    { text: t(lang, TERMS.scale.calc_area_real), latex: `A_{verklighet} = ${dispAreaReal} \\text{ cm}^2` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `${dispAreaDraw} : ${dispAreaReal} \\implies ${formatColor('1:' + areaScale)}` }
                ];
                answer = { left: 1, right: areaScale };
                answerType = 'scale';
                geomData = { type: 'compare_shapes', shapeType: areaShape, left: { width: w, height: h, radius: w, label: t(lang, TERMS.scale.drawing) }, right: { width: wReal, height: hReal, radius: wReal, label: t(lang, TERMS.scale.reality) } };
            } 
            else if (subType === 2) { // Find Real Area
                const baseArea = rng.pick([2, 3, 4, 5, 10]);
                const realArea = baseArea * areaScale;
                qDesc = {
                    sv: `Den lilla figuren har arean ${baseArea} cm$^2$. Hur stor √§r arean i den stora figuren om l√§ngdskalan √§r 1:${lengthScale}?`,
                    en: `The small shape has an area of ${baseArea} cm$^2$. How big is the area of the large shape if the length scale is 1:${lengthScale}?`
                };
                steps = [
                    { text: t(lang, TERMS.scale.calc_area_scale), latex: `(1:${lengthScale})^2 = 1:${areaScale}` },
                    { text: t(lang, TERMS.common.calculate), latex: `${baseArea} \\cdot ${areaScale} = ${formatColor(realArea)}` }
                ];
                answer = realArea;
                answerType = 'numeric';
                geomData = { type: 'compare_shapes_area', shapeType: areaShape, left: { area: baseArea, label: t(lang, TERMS.scale.drawing) }, right: { area: "?", label: t(lang, TERMS.scale.reality) } };
            }
            else if (subType === 3) { // Length -> Area Scale
                const lScaleStr = isReduction ? `1:${lengthScale}` : `${lengthScale}:1`;
                const aScaleLeft = isReduction ? 1 : areaScale;
                const aScaleRight = isReduction ? areaScale : 1;
                
                qDesc = { sv: `L√§ngdskalan √§r ${lScaleStr}. Vad √§r areaskalan?`, en: `The length scale is ${lScaleStr}. What is the area scale?` };
                const clueLatex = isReduction ? `(1^2 : ${lengthScale}^2)` : `(${lengthScale}^2 : 1^2)`;
                steps = [{ text: {sv: "Areaskala = (L√§ngdskala)¬≤", en: "Area Scale = (Length Scale)¬≤"}, latex: `${clueLatex} = ${formatColor(aScaleLeft + ':' + aScaleRight)}` }];

                answer = { left: aScaleLeft, right: aScaleRight };
                answerType = 'scale';
            }
            else { // Area -> Length Scale
                const aScaleStr = isReduction ? `1:${areaScale}` : `${areaScale}:1`;
                const lScaleLeft = isReduction ? 1 : lengthScale;
                const lScaleRight = isReduction ? lengthScale : 1;

                qDesc = { sv: `Areaskalan √§r ${aScaleStr}. Vad √§r l√§ngdskalan?`, en: `The area scale is ${aScaleStr}. What is the length scale?` };
                const clueLatex = isReduction ? `(\\sqrt{1} : \\sqrt{${areaScale}})` : `(\\sqrt{${areaScale}} : \\sqrt{1})`;
                steps = [{ text: {sv: "L√§ngdskala = ‚àöAreaskala", en: "Length Scale = ‚àöArea Scale"}, latex: `${clueLatex} = ${formatColor(lScaleLeft + ':' + lScaleRight)}` }];

                answer = { left: lScaleLeft, right: lScaleRight };
                answerType = 'scale';
            }

            return {
                questionId: `scale-l6-${seed}`,
                renderData: { text_key: "area_scale", description: qDesc, latex: "", answerType: answerType, geometry: geomData, variables: {} },
                serverData: { answer: answer, solutionSteps: steps }
            };
        }

        // Fallback or restart if mode is out of bounds
        return ScaleGenerator.generate(1, seed, lang, multiplier); 
    }
}

// FILE END: src\core\generators\ScaleGenerator.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class SimilarityGenerator {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let steps: Clue[] = [];
        let qData: any = { 
            text_key: "", 
            description: "", 
            latex: "", 
            answer: 0,
            answerType: "numeric"
        };

        // --- LEVEL 1: Similar or Not? (Visual/Concept) ---
        if (level === 1) {
            const isSimilar = rng.intBetween(0, 1) === 1;
            const type = rng.pick(['rect_sides', 'tri_sides', 'tri_angles']);
            
            let shapeData: any = { type: 'similarity_compare', shapeType: 'triangle', left: {}, right: {} };
            
            qData.answerType = 'multiple_choice';
            qData.choices = lang === 'sv' ? ['Ja', 'Nej'] : ['Yes', 'No'];
            qData.answer = isSimilar ? qData.choices[0] : qData.choices[1];

            if (type === 'rect_sides') {
                shapeData.shapeType = 'rectangle';
                const w1 = rng.intBetween(2, 5) * 10;
                const h1 = rng.intBetween(2, 5) * 10;
                
                const k = isSimilar ? rng.pick([1.5, 2, 0.5]) : rng.pick([1.2, 1.8, 0.8]);
                const w2 = Math.round(w1 * k);
                const h2 = isSimilar ? Math.round(h1 * k) : Math.round(h1 * (k + 0.5));

                shapeData.left = { labels: { b: w1, h: h1 } };
                shapeData.right = { labels: { b: w2, h: h2 } };
                
                qData.description = { sv: "√Ñr rektanglarna likformiga?", en: "Are the rectangles similar?" };
                steps.push({ 
                    text: t(lang, { 
                        sv: `F√∂r att de ska vara likformiga m√•ste f√∂rh√•llandet mellan sidorna vara samma. J√§mf√∂r baserna och h√∂jderna.`, 
                        en: `For them to be similar, the ratio of sides must be the same. Compare the bases and heights.` 
                    }), 
                    latex: `\\frac{${w2}}{${w1}} \\text{ vs } \\frac{${h2}}{${h1}}` 
                });
            } 
            else if (type === 'tri_angles') {
                shapeData.shapeType = 'triangle';
                const a1 = rng.intBetween(40, 75);
                const a2 = rng.intBetween(40, 75);
                
                const b1 = isSimilar ? a1 : a1 + rng.pick([-15, 15]);
                const b2 = isSimilar ? a2 : a2;

                shapeData.left = { angles: [a1, a2, null], labels: { a1: `${a1}¬∞`, a2: `${a2}¬∞` } };
                shapeData.right = { angles: [b1, b2, null], labels: { a1: `${b1}¬∞`, a2: `${b2}¬∞` } };

                qData.description = { sv: "√Ñr trianglarna likformiga?", en: "Are the triangles similar?" };
                steps.push({ 
                    text: t(lang, { 
                        sv: "Likformiga trianglar m√•ste ha exakt samma vinklar. J√§mf√∂r vinklarna i figurerna.", 
                        en: "Similar triangles must have exactly the same angles. Compare the angles in the figures." 
                    }), 
                    latex: "" 
                });
            }
            else { // tri_sides
                shapeData.shapeType = 'triangle';
                const s1 = rng.intBetween(4, 9);
                const s2 = rng.intBetween(4, 9);
                
                const k = isSimilar ? 2 : 1.5;
                const r1 = s1 * k;
                const r2 = isSimilar ? s2 * k : Math.floor(s2 * (k + 0.4));

                shapeData.left = { labels: { s1: s1, s2: s2 } };
                shapeData.right = { labels: { s1: r1, s2: r2 } };
                qData.description = { sv: "√Ñr trianglarna likformiga?", en: "Are the triangles similar?" };
                
                steps.push({ 
                    text: t(lang, { 
                        sv: "Kolla om b√•da sidorna har v√§xt lika mycket (samma multiplikationstabell).", 
                        en: "Check if both sides have grown by the same amount (same multiplication table)." 
                    }), 
                    latex: `\\frac{${r1}}{${s1}} \\text{ vs } \\frac{${r2}}{${s2}}` 
                });
            }

            qData.renderData = { text_key: "sim_check", description: qData.description, latex: "", answerType: "multiple_choice", choices: qData.choices, geometry: shapeData };
        }

        // --- LEVEL 2: Find Side (x) in Similar Shapes ---
        else if (level === 2) {
            const k = rng.pick([2, 3, 4, 1.5]);
            const isRect = rng.intBetween(0, 1) === 1;
            
            let w1 = rng.intBetween(3, 8);
            let h1 = rng.intBetween(4, 10);
            let w2 = Math.round(w1 * k * 10) / 10;
            let h2 = Math.round(h1 * k * 10) / 10;

            const missing = rng.pick(['w2', 'h2']);
            let answerVal = 0;

            let lLabels: any = {};
            let rLabels: any = {};

            if (isRect) {
                lLabels = { b: w1, h: h1 };
                rLabels = { b: w2, h: h2 };
                if (missing === 'w2') { rLabels.b = 'x'; answerVal = w2; }
                else { rLabels.h = 'x'; answerVal = h2; }
            } else {
                lLabels = { s1: w1, s2: h1 };
                rLabels = { s1: w2, s2: h2 };
                if (missing === 'w2') { rLabels.s1 = 'x'; answerVal = w2; }
                else { rLabels.s2 = 'x'; answerVal = h2; }
            }

            qData.answer = answerVal;
            qData.description = { sv: "Figurerna √§r likformiga. Ber√§kna x.", en: "The shapes are similar. Calculate x." };
            
            steps.push({
                text: t(lang, { 
                    sv: "F√∂rst r√§knar vi ut hur m√•nga g√•nger st√∂rre den stora figuren √§r (skalan). Vi j√§mf√∂r de sidor vi vet.", 
                    en: "First, figure out how many times bigger the large shape is (the scale). Compare the known sides." 
                }),
                latex: missing === 'w2' ? `k = \\frac{${h2}}{${h1}} = ${k}` : `k = \\frac{${w2}}{${w1}} = ${k}`
            });
            steps.push({
                text: t(lang, { 
                    sv: "Nu anv√§nder vi skalan f√∂r att hitta x. Vi multiplicerar den lilla sidan med skalan.", 
                    en: "Now use the scale to find x. Multiply the small side by the scale." 
                }),
                latex: `x = ${missing === 'w2' ? w1 : h1} \\cdot ${k} = ${formatColor(answerVal)}`
            });

            qData.renderData = {
                text_key: "sim_calc", description: qData.description, latex: "", answerType: "numeric",
                geometry: { type: 'similarity_compare', shapeType: isRect ? 'rectangle' : 'triangle', left: { labels: lLabels }, right: { labels: rLabels } }
            };
        }

        // --- LEVEL 3: Top Triangle Theorem (Transversal) ---
        else if (level === 3) {
            const topSide = rng.intBetween(5, 12);
            const addSide = rng.intBetween(4, 10);
            const totSide = topSide + addSide;
            const k = totSide / topSide; 
            
            const baseTop = rng.intBetween(6, 14);
            const baseBot = Math.round(baseTop * k * 10) / 10;

            const mode = rng.pick(['find_base', 'find_side']);
            let answerVal = 0;
            let geom: any = { labels: { base_top: baseTop, base_bot: baseBot, left_top: topSide, left_tot: totSide } };

            if (mode === 'find_base') {
                answerVal = baseBot;
                geom.labels.base_bot = 'x';
                steps = [
                    { 
                        text: t(lang, { 
                            sv: "Den lilla triangeln i toppen √§r likformig med den stora triangeln. J√§mf√∂r lilla sidan med hela stora sidan.", 
                            en: "The small triangle at the top is similar to the big triangle. Compare the small side to the full big side." 
                        }), 
                        latex: `\\frac{\\text{Liten}}{\\text{Stor}} = \\frac{${topSide}}{${totSide}}` 
                    },
                    { 
                        text: t(lang, { 
                            sv: "Samma f√∂rh√•llande g√§ller f√∂r baserna. St√§ll upp en ekvation.", 
                            en: "The same ratio applies to the bases. Set up an equation." 
                        }), 
                        latex: `\\frac{${topSide}}{${totSide}} = \\frac{${baseTop}}{x}` 
                    },
                    { 
                        text: t(lang, { sv: "L√∂s ut x.", en: "Solve for x." }), 
                        latex: `x = \\frac{${baseTop} \\cdot ${totSide}}{${topSide}} = ${formatColor(answerVal)}` 
                    }
                ];
            } else {
                answerVal = totSide;
                geom.labels.left_tot = 'x';
                steps = [
                    { 
                        text: t(lang, { 
                            sv: "R√§kna ut hur mycket basen har v√§xt (skalan).", 
                            en: "Calculate how much the base has grown (the scale)." 
                        }), 
                        latex: `k = \\frac{${baseBot}}{${baseTop}}` 
                    },
                    { 
                        text: t(lang, { 
                            sv: "Multiplicera den lilla sidan med skalan f√∂r att f√• den stora sidan.", 
                            en: "Multiply the small side by the scale to get the big side." 
                        }), 
                        latex: `x = ${topSide} \\cdot ${Math.round(k*100)/100} = ${formatColor(answerVal)}` 
                    }
                ];
            }

            qData.answer = answerVal;
            qData.description = { sv: "Linjen i mitten √§r parallell med basen. Ber√§kna x.", en: "The middle line is parallel to the base. Calculate x." };
            qData.renderData = { text_key: "top_tri", description: qData.description, latex: "", answerType: "numeric", geometry: { type: 'transversal', ...geom } };
        }

        // --- LEVEL 4: Pythagorean Theorem (NEW) ---
        else {
            // 1. Generate Primitive Triple using Euclid's Formula
            // m > n > 0.
            const m = rng.intBetween(2, 6);
            const n = rng.intBetween(1, m - 1);
            
            let a = m*m - n*n;
            let b = 2*m*n;
            let c = m*m + n*n;

            // 2. Scale the triple to create answer variety (multiples)
            const k = rng.pick([1, 1, 1, 2, 2, 3, 4, 5, 10]);
            a *= k;
            b *= k;
            c *= k;

            // 3. Randomize leg orientation (swap a and b visuals)
            // Use intBetween instead of bool() to be safe if random.ts isn't updated
            if (rng.intBetween(0, 1) === 1) [a, b] = [b, a];

            // 4. Select Question Type
            const mode = rng.pick(['find_hyp', 'find_leg_a', 'find_leg_b']);
            let qDesc: any;
            let labels: any = {};
            
            if (mode === 'find_hyp') {
                // a^2 + b^2 = x^2
                qData.answer = c;
                labels = { base: a, height: b, hypotenuse: 'x' };
                qDesc = { sv: "Ber√§kna hypotenusan (den l√•nga sidan).", en: "Calculate the hypotenuse (the long side)." };
                
                steps.push({
                    text: t(lang, { sv: "Anv√§nd Pythagoras sats:", en: "Use the Pythagorean theorem:" }),
                    latex: "a^2 + b^2 = c^2"
                });
                steps.push({
                    text: t(lang, { sv: "S√§tt in v√§rdena:", en: "Substitute the values:" }),
                    latex: `${a}^2 + ${b}^2 = x^2`
                });
                steps.push({
                    text: t(lang, { sv: "Ber√§kna och dra roten ur:", en: "Calculate and take the square root:" }),
                    latex: `x = \\sqrt{${a*a + b*b}} = ${formatColor(c)}`
                });
            } 
            else {
                // Find a Leg.  c^2 - b^2 = a^2
                // Visual variation: sometimes finding base, sometimes height
                const findingBase = (mode === 'find_leg_a');
                
                qData.answer = findingBase ? a : b;
                labels = {
                    base: findingBase ? 'x' : a,
                    height: findingBase ? b : 'x',
                    hypotenuse: c
                };
                
                qDesc = { sv: "Ber√§kna kateten (den korta sidan).", en: "Calculate the leg (the short side)." };
                
                const knownLeg = findingBase ? b : a;
                
                steps.push({
                    text: t(lang, { sv: "N√§r vi s√∂ker en kort sida, subtraherar vi:", en: "When finding a short side, we subtract:" }),
                    latex: "c^2 - b^2 = a^2"
                });
                steps.push({
                    text: t(lang, { sv: "S√§tt in v√§rdena:", en: "Substitute the values:" }),
                    latex: `${c}^2 - ${knownLeg}^2 = x^2`
                });
                steps.push({
                    text: t(lang, { sv: "Ber√§kna och dra roten ur:", en: "Calculate and take the square root:" }),
                    latex: `x = \\sqrt{${c*c - knownLeg*knownLeg}} = ${formatColor(qData.answer)}`
                });
            }

            // Visual Orientation
            const orient = rng.pick(['up', 'left', 'right', 'down']); // Ensure frontend handles these

            qData.description = qDesc;
            qData.renderData = {
                text_key: "pythagoras",
                description: qData.description,
                latex: "",
                answerType: "numeric",
                geometry: {
                    type: 'triangle',
                    subtype: 'right', // Frontend triggers square marker
                    orientation: orient,
                    width: a,
                    height: b,
                    labels: labels
                }
            };
        }

        return {
            questionId: `sim-l${level}-${seed}`,
            renderData: qData.renderData,
            serverData: { answer: qData.answer, solutionSteps: steps }
        };
    }
}

// FILE END: src\core\generators\SimilarityGenerator.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language } from "../utils/i18n";

export class TenPowersGenerator {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        // Helper to fix floating point issues (e.g. 0.1 + 0.2 = 0.300000004)
        const fixFloat = (n: number) => parseFloat(n.toFixed(6));

        let qData: any = { 
            text_key: "", 
            description: "", 
            latex: "", 
            answer: 0,
            answerType: "numeric"
        };
        let steps: Clue[] = [];

        // --- LEVEL 1: Basic 10, 100, 1000 ---
        if (level === 1) {
            const power = rng.pick([10, 100, 1000]);
            const isMult = rng.intBetween(0, 1) === 1;
            
            // Generate a number (integer or decimal)
            // Case A: Integer (e.g. 532)
            // Case B: Decimal (e.g. 0.13, 1.305)
            const isDecimal = rng.intBetween(0, 1) === 1;
            let num = 0;
            
            if (isDecimal) {
                // Generate something like 0.13 or 13.05
                const base = rng.intBetween(1, 9999);
                const div = rng.pick([10, 100, 1000]);
                num = base / div;
            } else {
                num = rng.intBetween(2, 900);
            }

            // Calculation
            let answer = 0;
            let zeros = power.toString().length - 1; // 10->1, 100->2, 1000->3

            if (isMult) {
                // Multiplication
                answer = fixFloat(num * power);
                qData.latex = `${num} \\cdot ${power} =`;
                
                const direction = lang === 'sv' ? "h√∂ger" : "right";
                steps.push({
                    text: t(lang, {
                        sv: `N√§r du multiplicerar med ${power} flyttar du kommatecknet ${zeros} steg √•t ${direction}.`,
                        en: `When multiplying by ${power}, move the decimal point ${zeros} steps to the ${direction}.`
                    }),
                    latex: `${num} \\cdot ${power} = ${formatColor(answer)}`
                });
            } else {
                // Division
                // Ensure we don't divide 10 by 1000 (0.01) if we want to keep it somewhat simple, 
                // but requirements say "variations with up to 3 decimal places".
                answer = fixFloat(num / power);
                qData.latex = `${num} / ${power} =`; // Horizontal division as requested

                const direction = lang === 'sv' ? "v√§nster" : "left";
                steps.push({
                    text: t(lang, {
                        sv: `N√§r du dividerar med ${power} flyttar du kommatecknet ${zeros} steg √•t ${direction}.`,
                        en: `When dividing by ${power}, move the decimal point ${zeros} steps to the ${direction}.`
                    }),
                    latex: `${num} / ${power} = ${formatColor(answer)}`
                });
            }

            qData.description = { sv: "Ber√§kna.", en: "Calculate." };
            qData.answer = answer;
        }

        // --- LEVEL 2: Conceptual Equivalence (Multiple Choice) ---
        else if (level === 2) {
            // Mappings
            // Mult 10 = Div 0.1
            // Mult 100 = Div 0.01
            // Mult 1000 = Div 0.001
            // Div 10 = Mult 0.1
            // ...
            
            const pairs = [
                { op: 'mul', val: 10, equivOp: 'div', equivVal: 0.1 },
                { op: 'mul', val: 100, equivOp: 'div', equivVal: 0.01 },
                { op: 'mul', val: 1000, equivOp: 'div', equivVal: 0.001 },
                { op: 'mul', val: 0.1, equivOp: 'div', equivVal: 10 },
                { op: 'mul', val: 0.01, equivOp: 'div', equivVal: 100 },
                { op: 'mul', val: 0.001, equivOp: 'div', equivVal: 1000 },
                // Division variants
                { op: 'div', val: 10, equivOp: 'mul', equivVal: 0.1 },
                { op: 'div', val: 100, equivOp: 'mul', equivVal: 0.01 },
                { op: 'div', val: 1000, equivOp: 'mul', equivVal: 0.001 },
                { op: 'div', val: 0.1, equivOp: 'mul', equivVal: 10 },
                { op: 'div', val: 0.01, equivOp: 'mul', equivVal: 100 },
                { op: 'div', val: 0.001, equivOp: 'mul', equivVal: 1000 },
            ];

            const scenario = rng.pick(pairs);
            
            const opStr = (op: string) => {
                if (lang === 'sv') return op === 'mul' ? "Multiplicera med" : "Dividera med";
                return op === 'mul' ? "Multiplying by" : "Dividing by";
            };
            
            const targetOpStr = (op: string) => {
                if (lang === 'sv') return op === 'div' ? "dividera med..." : "multiplicera med...";
                return op === 'div' ? "dividing by..." : "multiplying by...";
            };

            qData.description = {
                sv: `${opStr(scenario.op)} ${scenario.val} √§r samma sak som att ${targetOpStr(scenario.equivOp)}`,
                en: `${opStr(scenario.op)} ${scenario.val} is the same as ${targetOpStr(scenario.equivOp)}`
            };

            qData.answerType = 'multiple_choice';
            qData.choices = [10, 100, 1000, 0.1, 0.01, 0.001].map(String); // Ensure strings for MC comparison
            qData.answer = String(scenario.equivVal);

            // Clue
            const fraction = scenario.equivVal < 1 ? `1/${1/scenario.equivVal}` : `1/${1/scenario.equivVal}`; // e.g. 1/10
            steps.push({
                text: t(lang, { 
                    sv: "T√§nk p√• br√•kformen. Att dividera med ett tal √§r samma som att multiplicera med dess invers.",
                    en: "Think about fractions. Dividing by a number is the same as multiplying by its inverse."
                }),
                latex: ""
            });
        }

        // --- LEVEL 3: 0.1, 0.01, 0.001 Calculations ---
        else {
            const power = rng.pick([0.1, 0.01, 0.001]);
            const isMult = rng.intBetween(0, 1) === 1;
            
            // Pick a number
            const num = rng.intBetween(2, 900);
            
            // Determine zeros for explanation (0.1 -> 1 step, 0.01 -> 2 steps)
            let stepsCount = 0;
            if (power === 0.1) stepsCount = 1;
            else if (power === 0.01) stepsCount = 2;
            else stepsCount = 3;

            let answer = 0;

            if (isMult) {
                // Mult by 0.1 = Div by 10 = Left shift
                answer = fixFloat(num * power);
                qData.latex = `${num} \\cdot ${power} =`;
                
                const direction = lang === 'sv' ? "v√§nster" : "left";
                steps.push({
                    text: t(lang, {
                        sv: `Att multiplicera med ${power} √§r samma som att dividera med ${1/power}. Flytta kommatecknet ${stepsCount} steg √•t ${direction}.`,
                        en: `Multiplying by ${power} is the same as dividing by ${1/power}. Move the decimal ${stepsCount} steps to the ${direction}.`
                    }),
                    latex: `${num} / ${1/power} = ${formatColor(answer)}`
                });
            } else {
                // Div by 0.1 = Mult by 10 = Right shift
                answer = fixFloat(num / power);
                qData.latex = `${num} / ${power} =`;

                const direction = lang === 'sv' ? "h√∂ger" : "right";
                steps.push({
                    text: t(lang, {
                        sv: `Att dividera med ${power} √§r samma som att multiplicera med ${1/power}. Flytta kommatecknet ${stepsCount} steg √•t ${direction}.`,
                        en: `Dividing by ${power} is the same as multiplying by ${1/power}. Move the decimal ${stepsCount} steps to the ${direction}.`
                    }),
                    latex: `${num} \\cdot ${1/power} = ${formatColor(answer)}`
                });
            }

            qData.description = { sv: "Ber√§kna.", en: "Calculate." };
            qData.answer = answer;
        }

        return {
            questionId: `ten-l${level}-${seed}`,
            renderData: {
                text_key: "ten_powers",
                description: qData.description,
                latex: qData.latex,
                answerType: qData.answerType,
                choices: qData.choices,
                variables: {}
            },
            serverData: {
                answer: qData.answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class VolumeGenerator {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;
        const piApprox = 3.14;

        // Helper to constrain values preventing extreme aspect ratios
        const getConstrainedValues = (count: number, min: number, max: number): number[] => {
            const vals: number[] = [];
            for(let i = 0; i < count; i++) vals.push(rng.intBetween(min, max));
            return vals;
        };

        let mode = level;
        const isUnitConversion = level === 7;
        if (level >= 6) mode = rng.intBetween(1, 5); 

        const UNITS = [
            { id: 'mm', factor: 0.001 },
            { id: 'cm', factor: 0.01 },
            { id: 'dm', factor: 0.1 },
            { id: 'm', factor: 1.0 }
        ];

        let qData: any = { answer: 0, description: "", latex: "", answerType: "numeric" };
        let geometry: any = undefined;
        let steps: Clue[] = [];

        // --- LEVEL 1: Prisms & Cubes ---
        if (mode === 1) {
            const isCube = rng.intBetween(0, 1) === 1;
            const s = (val: number) => Math.round(val * multiplier);
            
            if (isCube) {
                const side = rng.intBetween(s(2), s(10));
                qData.answer = Math.pow(side, 3);
                qData.description = { sv: "Ber√§kna volymen (Kub).", en: "Calculate the volume (Cube)." };
                geometry = { type: 'cuboid', labels: { w: side, h: side, d: side } };
                
                steps.push({ text: t(lang, { sv: "Volym = sida ¬∑ sida ¬∑ sida", en: "Volume = side ¬∑ side ¬∑ side" }), latex: "V = s^3" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `${side}^3 = ${formatColor(qData.answer)}` });
            } else {
                const [w, h, d] = getConstrainedValues(3, s(3), s(10));
                qData.answer = w * h * d;
                qData.description = { sv: "Ber√§kna volymen (R√§tblock).", en: "Calculate the volume (Rectangular Prism)." };
                geometry = { type: 'cuboid', labels: { w: w, h: h, d: d } };

                steps.push({ text: t(lang, { sv: "Volym = Bredd ¬∑ H√∂jd ¬∑ Djup", en: "Volume = Width ¬∑ Height ¬∑ Depth" }), latex: "V = b \\cdot h \\cdot d" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `${w} \\cdot ${h} \\cdot ${d} = ${formatColor(qData.answer)}` });
            }
        }

        // --- LEVEL 2: Triangular Prism ---
        else if (mode === 2) {
            const b = rng.intBetween(3, 10);
            const hTri = rng.intBetween(3, 8);
            const len = rng.intBetween(5, 15);
            
            const areaBase = (b * hTri) / 2;
            qData.answer = areaBase * len;
            qData.description = { sv: "Ber√§kna volymen.", en: "Calculate the volume." };
            geometry = { type: 'triangular_prism', b: b, h_tri: hTri, len: len, labels: { b: b, h: hTri, l: len } };

            steps.push({ text: t(lang, { sv: "1. R√§kna ut basytan (triangeln).", en: "1. Calculate base area (triangle)." }), latex: `A = \\frac{${b} \\cdot ${hTri}}{2} = ${areaBase}` });
            steps.push({ text: t(lang, { sv: "2. Multiplicera med l√§ngden.", en: "2. Multiply by the length." }), latex: `${areaBase} \\cdot ${len} = ${formatColor(qData.answer)}` });
        }

        // --- LEVEL 3: Cylinder ---
        else if (mode === 3) {
            const r = rng.intBetween(2, 6);
            const h = rng.intBetween(5, 15);
            const areaBase = piApprox * r * r;
            qData.answer = Math.round(areaBase * h * 10) / 10;
            
            // Randomly show radius or diameter
            const showDiameter = rng.intBetween(0, 1) === 1;
            const d = r * 2;
            
            qData.description = { sv: "Ber√§kna volymen (avrunda till 1 decimal).", en: "Calculate the volume (round to 1 decimal)." };
            geometry = { 
                type: 'cylinder', 
                labels: { r: r, h: h, val: showDiameter ? `d=${d}` : `r=${r}` }, 
                show: showDiameter ? 'diameter' : 'radius' 
            };

            if (showDiameter) {
                steps.push({ text: t(lang, { sv: "Radien √§r h√§lften av diametern.", en: "Radius is half the diameter." }), latex: `r = ${d}/2 = ${r}` });
            }
            steps.push({ text: t(lang, { sv: "Volym = Basytan ¬∑ H√∂jden", en: "Volume = Base Area ¬∑ Height" }), latex: "V = \\pi r^2 \\cdot h" });
            steps.push({ text: t(lang, TERMS.common.calculate), latex: `3.14 \\cdot ${r}^2 \\cdot ${h} \\approx ${formatColor(qData.answer)}` });
        }

        // --- LEVEL 4: Pyramid & Cone ---
        else if (mode === 4) {
            const isCone = rng.intBetween(0, 1) === 1;
            const h = rng.intBetween(5, 15);
            
            if (isCone) {
                const r = rng.intBetween(3, 8);
                const baseArea = piApprox * r * r;
                qData.answer = Math.round((baseArea * h / 3) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Kon).", en: "Calculate the volume (Cone)." };
                geometry = { type: 'cone', labels: { r: r, h: h, val: `r=${r}` }, show: 'radius' }; // Explicitly set show radius

                steps.push({ text: t(lang, { sv: "Volym = (Basytan ¬∑ H√∂jden) / 3", en: "Volume = (Base Area ¬∑ Height) / 3" }), latex: "V = \\frac{\\pi r^2 h}{3}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\frac{3.14 \\cdot ${r}^2 \\cdot ${h}}{3} \\approx ${formatColor(qData.answer)}` });
            } else {
                const side = rng.intBetween(4, 10);
                const baseArea = side * side;
                qData.answer = Math.round((baseArea * h / 3) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Pyramid med kvadratisk bas).", en: "Calculate volume (Square-based Pyramid)." };
                geometry = { type: 'pyramid', labels: { s: side, h: h } };

                steps.push({ text: t(lang, { sv: "Volym = (Basytan ¬∑ H√∂jden) / 3", en: "Volume = (Base Area ¬∑ Height) / 3" }), latex: "V = \\frac{s^2 \\cdot h}{3}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\frac{${side}^2 \\cdot ${h}}{3} \\approx ${formatColor(qData.answer)}` });
            }
        }

        // --- LEVEL 5: Sphere & Composite ---
        else if (mode === 5) {
            // Restore variety: Sphere, Hemisphere, Ice Cream, Silo
            const type = rng.pick(['sphere', 'hemisphere', 'ice_cream', 'silo']);
            const r = rng.intBetween(3, 8);
            const d = r * 2;
            const showDiameter = rng.intBetween(0, 1) === 1; // Randomize presentation
            
            const labelVal = showDiameter ? `d=${d}` : `r=${r}`;

            if (type === 'sphere') {
                qData.answer = Math.round((4 * piApprox * Math.pow(r, 3) / 3) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Klot).", en: "Calculate volume (Sphere)." };
                geometry = { type: 'sphere', labels: { val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                if (showDiameter) steps.push({ text: t(lang, { sv: "Radien √§r h√§lften av diametern.", en: "Radius is half the diameter." }), latex: `r = ${r}` });
                steps.push({ text: "Formel", latex: "V = \\frac{4 \\pi r^3}{3}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\frac{4 \\cdot 3.14 \\cdot ${r}^3}{3} \\approx ${formatColor(qData.answer)}` });
            }
            else if (type === 'hemisphere') {
                const sphereVol = (4 * piApprox * Math.pow(r, 3) / 3);
                qData.answer = Math.round((sphereVol / 2) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Halvklot).", en: "Calculate volume (Hemisphere)." };
                geometry = { type: 'hemisphere', labels: { val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                steps.push({ text: t(lang, { sv: "R√§kna ut volymen f√∂r ett helt klot och dela med 2.", en: "Calc volume for full sphere and divide by 2." }), latex: "V = \\frac{4 \\pi r^3}{3} \\cdot \\frac{1}{2}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\approx ${formatColor(qData.answer)}` });
            }
            else if (type === 'ice_cream') {
                // Cone + Hemisphere
                const hCone = rng.intBetween(r + 2, r * 3);
                const volCone = (piApprox * r * r * hCone) / 3;
                const volHemi = (4 * piApprox * Math.pow(r, 3) / 3) / 2;
                qData.answer = Math.round((volCone + volHemi) * 10) / 10;
                qData.description = { sv: "Ber√§kna totala volymen.", en: "Calculate total volume." };
                geometry = { type: 'ice_cream', labels: { h: hCone, val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                steps.push({ text: t(lang, { sv: "Total = Kon + Halvklot", en: "Total = Cone + Hemisphere" }), latex: "" });
                steps.push({ text: "Kon", latex: `V_{kon} = \\frac{\\pi \\cdot ${r}^2 \\cdot ${hCone}}{3} \\approx ${Math.round(volCone)}` });
                steps.push({ text: "Halvklot", latex: `V_{halv} \\approx ${Math.round(volHemi)}` });
                steps.push({ text: "Summa", latex: `${Math.round(volCone)} + ${Math.round(volHemi)} \\approx ${formatColor(qData.answer)}` });
            }
            else { // Silo
                // Cylinder + Hemisphere
                const hCyl = rng.intBetween(r + 2, r * 3);
                const volCyl = piApprox * r * r * hCyl;
                const volHemi = (4 * piApprox * Math.pow(r, 3) / 3) / 2;
                qData.answer = Math.round((volCyl + volHemi) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Silo).", en: "Calculate volume (Silo)." };
                geometry = { type: 'silo', labels: { h: hCyl, val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                steps.push({ text: t(lang, { sv: "Total = Cylinder + Halvklot", en: "Total = Cylinder + Hemisphere" }), latex: "" });
                steps.push({ text: "Cylinder", latex: `V_{cyl} = \\pi \\cdot ${r}^2 \\cdot ${hCyl} \\approx ${Math.round(volCyl)}` });
                steps.push({ text: "Halvklot", latex: `V_{halv} \\approx ${Math.round(volHemi)}` });
                steps.push({ text: "Summa", latex: `${formatColor(qData.answer)}` });
            }
        }

        // --- LEVEL 7: Unit Conversion (Volume) ---
        else if (isUnitConversion) {
            // e.g. Convert 2 m^3 to dm^3
            // Scale factor k=10 -> Volume factor k^3 = 1000
            
            const unitInIdx = rng.intBetween(1, 3); // cm, dm, m
            const unitOutIdx = unitInIdx - 1; // Step down (larger number)
            
            const unitIn = UNITS[unitInIdx];
            const unitOut = UNITS[unitOutIdx];
            const k = 10;
            const volRatio = 1000;

            const val = rng.intBetween(1, 10);
            qData.answer = val * volRatio;
            
            const uVol = (u: string) => `${u}^3`;
            
            qData.description = { 
                sv: `Omvandla ${val} ${uVol(unitIn.id)} till ${uVol(unitOut.id)}.`, 
                en: `Convert ${val} ${uVol(unitIn.id)} to ${uVol(unitOut.id)}.` 
            };
            
            // To make the visual interesting, show a cube with side 1 unit vs 10 smaller units
            geometry = { 
                type: 'cuboid', 
                labels: { w: `1${unitIn.id}`, h: `1${unitIn.id}`, d: `1${unitIn.id}` } 
            };
            
            const originalAns = qData.answer;
            const convertedAns = Math.round(originalAns * volRatio * 1000) / 1000;
            
            qData.answer = convertedAns;
            qData.description = { 
                sv: `Svara i enheten ${uVol(unitOut.id)}. (Nuvarande m√•tt i ${unitIn.id})`, 
                en: `Answer in ${uVol(unitOut.id)}. (Current dims in ${unitIn.id})` 
            };

            steps.push({
                text: t(lang, { sv: "Omvandla enheterna. Volymskalan √§r l√§ngdskalan upph√∂jt till 3.", en: "Convert units. Volume scale is length scale cubed." }), 
                latex: `1 \\text{ ${uVol(unitIn.id)}} = ${volRatio} \\text{ ${uVol(unitOut.id)}}`
            });
            steps.push({
                text: t(lang, { sv: "Multiplicera resultatet med omvandlingsfaktorn.", en: "Multiply result by conversion factor." }),
                latex: `${originalAns} \\cdot ${volRatio} = ${formatColor(convertedAns)}`
            });
        }

        return {
            questionId: `vol-l${level}-${seed}`,
            renderData: {
                text_key: "vol_calc",
                description: qData.description,
                latex: "",
                answerType: "numeric",
                geometry: geometry,
                variables: {}
            },
            serverData: {
                answer: qData.answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\VolumeGenerator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 5,
        volume: 7,
        graph: 5,
        similarity: 4 // UPDATED to 4
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export function t(lang: Language, keyOrObj: string | { sv: string, en: string } | undefined): string {
    if (!keyOrObj) return "";
    if (typeof keyOrObj === 'string') return keyOrObj;
    return lang === 'sv' ? keyOrObj.sv : keyOrObj.en;
}

export const TERMS = {
    ui: {
        hints: { sv: "Ledtr√•dar", en: "Hints" },
        streak_modal_title: { sv: "Fantastiskt! üî•", en: "Awesome! üî•" },
        streak_modal_msg: { sv: "Du har n√•tt en streak p√• {streak}!", en: "You hit a streak of {streak}!" },
        total_modal_title: { sv: "Snyggt jobbat! ‚úÖ", en: "Great work! ‚úÖ" },
        total_modal_msg: { sv: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!", en: "You answered {total} questions correctly! Great job!" },
        btn_close_streak: { sv: "Bra jobbat!", en: "Great job!" },
        btn_close_total: { sv: "Forts√§tt", en: "Continue" }
    },
    common: {
        solve: { sv: "L√∂s ut", en: "Solve for" },
        calculate: { sv: "Ber√§kna", en: "Calculate" },
        find: { sv: "Hitta", en: "Find" },
        result: { sv: "Svar:", en: "Answer:" },
        drawing: { sv: "Avbildning", en: "Drawing" },
        reality: { sv: "Verklighet", en: "Reality" },
        distribute: { sv: "Distribuera", en: "Distribute" },
        equation: { sv: "Ekvation", en: "Equation" },
        simplify: { sv: "F√∂renkla", en: "Simplify" },
        identify_var: { sv: "Identifiera variabeln", en: "Identify the variable" },
        identify_const: { sv: "Identifiera konstanterna", en: "Identify constants" },
        combine_like: { sv: "Kombinera termer", en: "Combine like terms" }
    },
    // NEW: Detailed explanations for negative number logic
    neg_signs: {
        sub_neg: { sv: "Minus ett negativt tal blir plus. Vi adderar ist√§llet.", en: "Minus a negative number becomes plus. We add instead." },
        add_neg: { sv: "Plus ett negativt tal blir minus. Vi subtraherar ist√§llet.", en: "Plus a negative number becomes minus. We subtract instead." },
        simple_calc: { sv: "Ber√§kna.", en: "Calculate." },
        
        mul_pos_neg: { sv: "Olika tecken ger ett negativt svar.", en: "Different signs give a negative answer." },
        mul_neg_neg: { sv: "Lika tecken (tv√• minus) ger ett positivt svar.", en: "Same signs (two minuses) give a positive answer." },
        
        div_sign_same: { sv: "Lika tecken ger alltid ett positivt svar.", en: "Same signs always give a positive answer." },
        div_sign_diff: { sv: "Olika tecken ger alltid ett negativt svar.", en: "Different signs always give a negative answer." },
        
        step_calc: { sv: "Ber√§kna n√§sta steg.", en: "Calculate the next step." }
    },
    // ADDED FOR SIMILARITY MODULE
    similarity: {
        ratio: { sv: "F√∂rh√•llande", en: "Ratio" },
        scale: { sv: "Skala", en: "Scale" },
        
        // Basic Rules
        rule_sides: { sv: "F√∂r att vara likformiga m√•ste kvoten av motsvarande sidor vara densamma.", en: "To be similar, the ratio of corresponding sides must be constant." },
        rule_angles: { sv: "F√∂r att vara likformiga m√•ste motsvarande vinklar vara lika stora.", en: "To be similar, corresponding angles must be equal." },
        step_k: { sv: "Hitta skalan (k) genom att j√§mf√∂ra motsvarande sidor.", en: "Find the scale factor (k) by comparing corresponding sides." },
        step_calc: { sv: "Anv√§nd skalan f√∂r att ber√§kna den ok√§nda sidan.", en: "Use the scale factor to calculate the unknown side." },
        rule_top: { sv: "Topptriangeln och hela triangeln delar en vinkel och har parallella baser, allts√• √§r de likformiga.", en: "The top triangle and the whole triangle share an angle and have parallel bases, so they are similar." },
        rule_hourglass: { sv: "Vertikalvinklar √§r lika och alternatvinklar √§r lika (parallella linjer), s√• trianglarna √§r likformiga.", en: "Vertical angles are equal and alternate interior angles are equal (parallel lines), so the triangles are similar." },
        
        // Pythagoras sats
        pythagoras_rule: { sv: "Pythagoras sats: $a^2 + b^2 = c^2$ (c √§r hypotenusan).", en: "Pythagorean theorem: $a^2 + b^2 = c^2$ (c is the hypotenuse)." },
        calc_hyp: { sv: "Vi s√∂ker hypotenusan (l√•ng sida) -> Addera kvadraterna.", en: "Finding hypotenuse (long side) -> Add the squares." },
        calc_leg: { sv: "Vi s√∂ker en katet (kort sida) -> Subtrahera kvadraterna.", en: "Finding a leg (short side) -> Subtract the squares." },
        step_root: { sv: "Dra roten ur:", en: "Take the square root:" }

        // Detailed pedagogical explanations (The "Why")
        expl_sides_rule: { 
            sv: "F√∂r likformighet kr√§vs att kvoten mellan alla motsvarande sidor √§r densamma.", 
            en: "For similarity, the ratio between all corresponding sides must be equal." 
        },
        expl_sides_check: {
            sv: "Vi kontrollerar skalfaktorn f√∂r varje par av sidor:",
            en: "We check the scale factor for each pair of sides:"
        },
        expl_conclusion: { sv: "Slutsats:", en: "Conclusion:" },
        
        expl_angles_rule: {
            sv: "Likformiga figurer m√•ste ha exakt samma vinklar.",
            en: "Similar shapes must have exactly the same angles."
        },
        expl_angles_calc: {
            sv: "Vi vet att triangelns vinkelsumma √§r 180¬∞. Vi ber√§knar den saknade vinkeln:",
            en: "We know the sum of angles in a triangle is 180¬∞. We calculate the missing angle:"
        },
        
        expl_scale_k: { 
            sv: "Hur m√•nga g√•nger st√∂rre √§r den stora figuren? Vi r√§knar ut skalan (k):", 
            en: "How many times bigger is the large shape? We calculate the scale (k):" 
        },
        
        expl_calc_mult: { sv: "Multiplicera den lilla sidan med skalan:", en: "Multiply the small side by the scale:" },
        expl_calc_div: { sv: "Dividera den stora sidan med skalan:", en: "Divide the large side by the scale:" },
        
        expl_top_tri_rule: {
            sv: "Eftersom baserna √§r parallella har trianglarna samma vinklar och √§r d√§rf√∂r likformiga.",
            en: "Since the bases are parallel, the triangles share the same angles and are therefore similar."
        },
        expl_hourglass_rule: {
            sv: "Vertikalvinklar √§r lika stora. Parallella linjer ger lika alternatvinklar. Trianglarna √§r likformiga.",
            en: "Vertical angles are equal. Parallel lines give equal alternate angles. The triangles are similar."
        }
    },
    scale: {
        scale: { sv: "Skala", en: "Scale" },
        drawing: { sv: "Bild", en: "Image" },
        reality: { sv: "Verklighet", en: "Reality" },
        step_plug_in: { sv: "St√§ll upp f√∂rh√•llandet:", en: "Set up the ratio:" },
        step_simplify: { sv: "F√∂renkla:", en: "Simplify:" },
        enlargement: { sv: "F√∂rstoring", en: "Enlargement" },
        reduction: { sv: "F√∂rminskning", en: "Reduction" },
        rule_reduction: { sv: "Eftersom det f√∂rsta talet √§r 1, √§r det en f√∂rminskning.", en: "Since the first number is 1, it is a reduction." },
        rule_enlargement: { sv: "Eftersom det f√∂rsta talet √§r st√∂rre √§n 1, √§r det en f√∂rstoring.", en: "Since the first number is greater than 1, it is an enlargement." },
        
        calc_cm: { sv: "Ber√§kna cm", en: "Calculate cm" },
        conv_m: { sv: "Omvandla till meter", en: "Convert to m" },
        conv_units: { sv: "Omvandla enheter", en: "Convert units" },
        div_scale: { sv: "Dividera med skalan", en: "Divide by scale" },
        conv_same: { sv: "Omvandla till samma enhet (cm)", en: "Convert to same unit (cm)" },
        setup_ratio: { sv: "St√§ll upp f√∂rh√•llandet", en: "Set up ratio" },
        
        calc_area_img: { sv: "Ber√§kna bildens area", en: "Calculate image area" },
        calc_area_real: { sv: "Ber√§kna verklighetens area", en: "Calculate reality area" },
        calc_area_scale: { sv: "Ber√§kna areaskala (l√§ngdskala¬≤)", en: "Calculate area scale (length scale¬≤)" },
        calc_new_area: { sv: "Ber√§kna ny area", en: "Calculate new area" }
    },
    volume: {
        formula_cube: { sv: "Volym = sida¬≥", en: "Volume = side¬≥" },
        formula_rect_prism: { sv: "Volym = l√§ngd ¬∑ bredd ¬∑ h√∂jd", en: "Volume = length ¬∑ width ¬∑ height" },
        formula_prism_base: { sv: "Volym = Basytan ¬∑ h√∂jden", en: "Volume = Base Area ¬∑ height" },
        formula_cylinder: { sv: "Volym = œÄ ¬∑ r¬≤ ¬∑ h", en: "Volume = œÄ ¬∑ r¬≤ ¬∑ h" },
        formula_cone: { sv: "Volym = (œÄ ¬∑ r¬≤ ¬∑ h) / 3", en: "Volume = (œÄ ¬∑ r¬≤ ¬∑ h) / 3" },
        formula_pyramid: { sv: "Volym = (Basytan ¬∑ h) / 3", en: "Volume = (Base Area ¬∑ h) / 3" },
        formula_sphere: { sv: "Volym = (4 ¬∑ œÄ ¬∑ r¬≥) / 3", en: "Volume = (4 ¬∑ œÄ ¬∑ r¬≥) / 3" },
        step_calc_base: { sv: "Ber√§kna basytan (B)", en: "Calculate Base Area (B)" },
        
        expl_prism_vol: { sv: "Multiplicera basytan med h√∂jden.", en: "Multiply the base area by the height." },
        expl_cone_fraction: { sv: "En kon √§r en tredjedel av en cylinder.", en: "A cone is one third of a cylinder." },
        expl_sphere_formula: { sv: "Anv√§nd formeln f√∂r klot.", en: "Use the formula for a sphere." },
        expl_hemi_split: { sv: "Dela klotets volym med tv√•.", en: "Divide the sphere's volume by two." },
        expl_total_add: { sv: "Addera delarna f√∂r att f√• totalen.", en: "Add the parts to get the total." },
        
        expl_prism_base: { sv: "Basytan √§r en triangel (b*h)/2.", en: "The base is a triangle (b*h)/2." },
        expl_cylinder_base: { sv: "Basytan √§r en cirkel (pi*r^2).", en: "The base is a circle (pi*r^2)." },
        expl_cone_vol: { sv: "Konens volym", en: "Cone Vol" },
        
        radius: { sv: "Radie", en: "Radius" },
        find_radius: { sv: "Hitta radien (r = d/2)", en: "Find radius (r = d/2)" },
        volume: { sv: "Volym", en: "Volume" },
        sphere_vol: { sv: "Klotets volym", en: "Sphere Vol" },
        hemi_vol: { sv: "Halvklotets volym", en: "Hemisphere Vol" },
        cone_vol: { sv: "Konens volym", en: "Cone Vol" },
        cyl_vol: { sv: "Cylinderns volym", en: "Cylinder Vol" },
        total: { sv: "Totalt", en: "Total" },
        half: { sv: "H√§lften", en: "Half" }
    },
    shapes: {
        square: { sv: "kvadrat", en: "square" },
        rectangle: { sv: "rektangel", en: "rectangle" },
        circle: { sv: "cirkel", en: "circle" },
        semicircle: { sv: "halvcirkel", en: "semicircle" }, 
        triangle: { sv: "triangel", en: "triangle" },
        rhombus: { sv: "romb", en: "rhombus" },
        parallelogram: { sv: "parallellogram", en: "parallelogram" },
        pentagon: { sv: "femh√∂rning", en: "pentagon" },
        hexagon: { sv: "sexh√∂rning", en: "hexagon" },
        octagon: { sv: "√•ttah√∂rning", en: "octagon" },
        kite: { sv: "drake", en: "kite" },
        star: { sv: "stj√§rna", en: "star" },
        arrow: { sv: "pil", en: "arrow" },
        heart: { sv: "hj√§rta", en: "heart" },
        cross: { sv: "kors", en: "cross" },
        lightning: { sv: "blixt", en: "lightning" },
        cube: { sv: "kub", en: "cube" },
        rect_prism: { sv: "r√§tblock", en: "rectangular prism" }, 
        tri_prism: { sv: "triangul√§rt prisma", en: "triangular prism" },
        triangular_prism: { sv: "triangul√§rt prisma", en: "triangular prism" },
        cylinder: { sv: "cylinder", en: "cylinder" },
        pyramid: { sv: "pyramid", en: "pyramid" },
        cone: { sv: "kon", en: "cone" },
        sphere: { sv: "klot", en: "sphere" } 
    } as Record<string, {sv:string, en:string}>,
    shapes_plural: {
        square: { sv: "kvadrater", en: "squares" },
        rectangle: { sv: "rektanglar", en: "rectangles" },
        circle: { sv: "cirklar", en: "circles" },
        semicircle: { sv: "halvcirklar", en: "semicircles" },
        triangle: { sv: "trianglar", en: "triangles" },
        parallelogram: { sv: "parallellogrammer", en: "parallelograms" },
        rhombus: { sv: "romber", en: "rhombuses" }
    } as Record<string, {sv:string, en:string}>,
    geometry: {
        desc_rect: { sv: "En rektangel", en: "A rectangle" },
        desc_para: { sv: "En parallellogram", en: "A parallelogram" },
        desc_tri: { sv: "En triangel", en: "A triangle" },
        desc_circle: { sv: "En cirkel", en: "A circle" },
        desc_composite: { sv: "En sammansatt figur", en: "A composite shape" },
        
        calc_area_tri: { sv: "Area = (basen ¬∑ h√∂jden) / 2", en: "Area = (base ¬∑ height) / 2" },
        formula_rect_perim: { sv: "Omkrets = 2 ¬∑ (bredd + h√∂jd)", en: "Perimeter = 2 ¬∑ (width + height)" },
        formula_para_perim: { sv: "Omkrets = 2 ¬∑ (sida A + sida B)", en: "Perimeter = 2 ¬∑ (side A + side B)" },
        formula_rect_perim_latex: "O = 2(b + h)",
        formula_para_perim_latex: "O = 2(a + b)",
        
        step_sub: { sv: "S√§tt in v√§rdena i formeln:", en: "Substitute values into the formula:" },
        step_calc: { sv: "Ber√§kna resultatet:", en: "Calculate the result:" },
        calc_perim: { sv: "Ber√§kna omkretsen", en: "Calculate perimeter" },
        calc_area: { sv: "Ber√§kna arean", en: "Calculate area" },
        
        step_comp_tri_sides: { sv: "Addera sidorna:", en: "Add the sides:" },
        step_comp_arc_verbose: { sv: "Ber√§kna b√•gen:", en: "Calculate the arc:" },
        step_comp_total_perim: { sv: "Total omkrets:", en: "Total perimeter:" },
        step_comp_semi_area: { sv: "Halvcirkelns area:", en: "Semicircle area:" },
        step_comp_total_area: { sv: "Total area:", en: "Total area:" },
        
        comp_rect_area: { sv: "Rektangelns area:", en: "Rectangle area:" },
        comp_tri_area: { sv: "Triangelns area:", en: "Triangle area:" },
        comp_total_area: { sv: "Total area:", en: "Total area:" },

        sides_3: { sv: "3 Sidor", en: "3 Sides" },
        arc: { sv: "B√•ge", en: "Arc" }
    },
    simplification: {
        intro: (expr: string) => ({ sv: `F√∂renkla uttrycket: $${expr}$`, en: `Simplify the expression: $${expr}$` }),
        group_terms: { sv: "Gruppera termer (x med x, tal med tal)", en: "Group like terms" },
        calc_result: (ans: string) => ({ sv: `Resultat: $${ans}$`, en: `Result: $${ans}$` }),
        start_unknown: { sv: "Vi b√∂rjar med talet $x$.", en: "We start with the number $x$." },
        translate_math: { sv: "√ñvers√§tt texten till matematik:", en: "Translate text to math:" },
        cost_unknown: (item: string) => ({ sv: `Priset per ${item} √§r ok√§nt, s√• $x$.`, en: `Price per ${item} is unknown, so $x$.` }),
        final_expr: { sv: "Slutgiltigt uttryck:", en: "Final expression:" },
        simplify_const: { sv: "F√∂renkla konstanterna:", en: "Simplify constants:" },
        
        expl_var_basic: { sv: "Variabeln (x) representerar det ok√§nda antalet.", en: "The variable (x) represents the unknown number." },
        expl_fixed_cost: { sv: "Detta √§r den fasta avgiften/kostnaden.", en: "This is the fixed fee/cost." },
        expl_rate_val: { sv: "Detta √§r priset per styck (multipliceras med x).", en: "This is the price per item (multiplied by x)." },
        expl_total: { sv: "Detta √§r summan av alla delar.", en: "This is the sum of all parts." },
        expl_discount: { sv: "Rabatten dras bort fr√•n totalen.", en: "The discount is subtracted from the total." },
        expl_compare: { sv: "Vi j√§mf√∂r tv√• m√§ngder.", en: "We are comparing two quantities." },
        
        expl_distribute: (val: number) => ({ sv: `Multiplicera in ${val} i parentesen.`, en: `Multiply ${val} into the parentheses.` }),
        expl_group: { sv: "Samla alla x-termer och alla vanliga tal.", en: "Collect all x-terms and all number terms." }
    },
    algebra: {
        intro: (eq: string) => ({ sv: `Ekvation: $${eq}$`, en: `Equation: $${eq}$` }),
        subtract: (val: number) => ({ sv: `Subtrahera ${val} fr√•n b√•da sidor`, en: `Subtract ${val} from both sides` }),
        add: (val: number) => ({ sv: `Addera ${val} till b√•da sidor`, en: `Add ${val} to both sides` }),
        divide: (val: number) => ({ sv: `Dela b√•da sidor med ${val}`, en: `Divide both sides by ${val}` }),
        multiply: (val: number) => ({ sv: `Multiplicera b√•da sidor med ${val}`, en: `Multiply both sides by ${val}` }),
        distribute: (val: number) => ({ sv: `Multiplicera in ${val} i parentesen`, en: `Distribute ${val} into the parentheses` }),
        sub_var: (term: string) => ({ sv: `Subtrahera ${term} fr√•n b√•da sidor`, en: `Subtract ${term} from both sides` })
    },
    graph: {
        q_intercept: { sv: "Hitta m-v√§rdet (sk√§rning med y-axeln):", en: "Find the Y-Intercept (m):" },
        q_slope: { sv: "Ber√§kna lutningen (k):", en: "Calculate the slope (k):" },
        q_func: { sv: "Skriv funktionen p√• formen y = kx + m", en: "Write the function as y = kx + m" },
        step_intercept: (m: number) => ({ sv: `Avl√§s m-v√§rdet d√§r linjen sk√§r y-axeln. m = ${m}`, en: `Read the y-intercept (m) where line crosses y-axis. m = ${m}` }),
        step_func: (k: number, m: number) => ({ sv: `S√§tt in k och m i formeln: y = ${k}x + ${m}`, en: `Insert k and m into formula: y = ${k}x + ${m}` }),
        step_delta: { sv: "Skillnad i y / Skillnad i x", en: "Change in y / Change in x" },
        step_slope_calc: { sv: "Ber√§kna k", en: "Calculate k" },
        look_x0: { sv: "Titta p√• x = 0", en: "Look at x = 0" },
        find_m: { sv: "Hitta m", en: "Find m" },
        find_k: { sv: "Hitta k", en: "Find k" }
    },
    problem_solving: {
        task_solve: { sv: "Vad √§r x?", en: "What is x?" },
        task_write: { sv: "Teckna en ekvation f√∂r att ber√§kna x.", en: "Write an equation to calculate x." },
        task_write_expr: { sv: "Teckna ett f√∂renklat uttryck.", en: "Write a simplified expression." },

        a_buy: { sv: "Du k√∂per $x$ st {item} f√∂r $a$ kr styck och en kasse f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $x$ {item} for $a$ kr each and a bag for $b$ kr. In total, you pay $c$ kr." },
        a_taxi: { sv: "En taxi kostar $b$ kr i startavgift och sedan $a$ kr per km. Du √•ker $x$ km och betalar totalt $c$ kr.", en: "A taxi charges a start fee of $b$ kr and then $a$ kr per km. You travel $x$ km and pay a total of $c$ kr." },
        b_discount: { sv: "Du k√∂per $x$ st {item} som kostar $a$ kr styck. Du f√•r $b$ kr i rabatt p√• totalen. Du betalar $c$ kr.", en: "You buy $x$ {item} costing $a$ kr each. You get a discount of $b$ kr on the total. You pay $c$ kr." },
        b_points: { sv: "Du samlar $a$ po√§ng per niv√• i ett spel. Du klarar $x$ niv√•er men f√∂rlorar $b$ po√§ng i straff. Du har totalt $c$ po√§ng.", en: "You earn $a$ points per level in a game. You clear $x$ levels but lose $b$ points as a penalty. You have $c$ points in total." },
        c_compare: { sv: "{name1} har $x$ st {item}. {name2} har $a$ fler {item} √§n {name1}. Tillsammans har de $c$ st.", en: "{name1} has $x$ {item}. {name2} has $a$ more {item} than {name1}. Together they have $c$." },
        d_compare: { sv: "{name1} har $x$ st {item}. {name2} har $b$ f√§rre {item} √§n {name1}. Tillsammans har de $c$ st.", en: "{name1} has $x$ {item}. {name2} has $b$ fewer {item} than {name1}. Together they have $c$." },

        clue_var: { sv: "L√•t x vara antalet.", en: "Let x be the number." },
        clue_setup: { sv: "St√§ll upp ekvationen.", en: "Set up the equation." },
        clue_total: { sv: "Totalt √§r det", en: "The total is" },
        
        expl_fixed_val: { sv: "Detta √§r det fasta v√§rdet (t.ex. startavgift eller p√•se).", en: "This is the fixed value (e.g. start fee or bag)." },
        expl_rate_val: { sv: "Detta √§r det r√∂rliga v√§rdet (pris per styck ¬∑ antal).", en: "This is the variable value (price per item ¬∑ quantity)." },
        expl_person1: { sv: "Den f√∂rsta personen har x.", en: "The first person has x." },
        expl_person2_more: { sv: "Den andra personen har mer √§n den f√∂rsta.", en: "The second person has more than the first." },
        expl_person2_less: { sv: "Den andra personen har mindre √§n den f√∂rsta.", en: "The second person has less than the first." },
        expl_item_cost: { sv: "Priset f√∂r varorna √§r:", en: "The price for the items is:" },
        expl_discount_sub: { sv: "Rabatten dras bort:", en: "The discount is subtracted:" },
        expl_compare_sum: { sv: "Vi adderar b√•da personernas antal:", en: "We add both amounts:" },
        expl_compare_diff: { sv: "Summan av b√•da personerna √§r:", en: "The sum of both people is:" }
    }
};

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020", "DOM"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["api/**/*", "src/**/*"]
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/:match*", "destination": "/api/:match*" },
    { "source": "/(.*)", "destination": "/public/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json
