PROJECT EXPORT GENERATED AT 2026-02-08T20:49:38.539Z

--- FILE STRUCTURE ---
api\answer.ts
api\batch.ts
api\curriculum.ts
api\debug.ts
api\question.ts
backup_UI.html
bundle_project.ts
dev-server.ts
index.html
package-lock.json
package.json
postcss.config.js
src\App.jsx
src\components\modals\AboutModal.jsx
src\components\modals\ContentModal.jsx
src\components\modals\LevelUpModal.jsx
src\components\modals\LgrModal.jsx
src\components\modals\StatsModal.jsx
src\components\modals\StreakModal.jsx
src\components\practice\CluePanel.jsx
src\components\practice\HistoryList.jsx
src\components\practice\MobileDrawer.jsx
src\components\ui\Button.jsx
src\components\ui\InputComponents.jsx
src\components\ui\MathText.jsx
src\components\views\AuthView.jsx
src\components\views\Dashboard.jsx
src\components\views\DoNowConfig.jsx
src\components\views\DoNowGrid.jsx
src\components\views\PracticeView.jsx
src\components\visuals\AngleComponents.jsx
src\components\visuals\ComplexGeometry.jsx
src\components\visuals\GeometryComponents.jsx
src\components\visuals\GeometryShapes.jsx
src\components\visuals\GraphCanvas.jsx
src\components\visuals\PatternComponents.jsx
src\components\visuals\ProbabilityTree.jsx
src\components\visuals\ProbabilityVisuals.jsx
src\components\visuals\ScaleVisuals.jsx
src\components\visuals\SimpleTextLevel.jsx
src\components\visuals\StatisticsVisuals.jsx
src\components\visuals\VolumeVisualization.jsx
src\constants\content_map.js
src\constants\curriculum.js
src\constants\localization.js
src\core\generators\AnglesGen.ts
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ChangeFactorGen.ts
src\core\generators\ExponentsGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\FractionArithGen.ts
src\core\generators\FractionBasicsGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\PatternsGen.ts
src\core\generators\PercentGen.ts
src\core\generators\ProbabilityGen.ts
src\core\generators\PythagorasGen.ts
src\core\generators\ScaleGen.ts
src\core\generators\SimilarityGen.ts
src\core\generators\StatisticsGen.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGen.ts
src\core\interfaces\Generator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\MathUtils.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
src\index.css
src\lib\supabaseClient.js
src\main.jsx
tailwind.config.js
tsconfig.json
vercel.json
vite.config.js

==================================================


// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: "Method not allowed. Use POST." });
    }

    try {
        const { answer, token, streak = 0 } = req.body;

        if (!token) {
            return res.status(400).json({ error: "Missing token" });
        }

        // 1. Decode the correct answer from the Base64 token
        const correctAnswer = Buffer.from(token, 'base64').toString('utf-8');

        // 2. Normalize inputs for comparison
        // We remove spaces and convert to lowercase to be forgiving
        // e.g. "x + 5" should match "x+5"
        const normalize = (str: any) => String(str).toLowerCase().replace(/\s+/g, '').replace(',', '.');
        
        const userClean = normalize(answer);
        const correctClean = normalize(correctAnswer);

        const isCorrect = userClean === correctClean;

        let newStreak = streak;
        let levelUp = false;

        // 3. Update Streak Logic
        if (isCorrect) {
            newStreak++;
            // Propose level up every 8 correct answers
            if (newStreak > 0 && newStreak % 8 === 0) {
                levelUp = true;
            }
        } else {
            newStreak = 0;
        }

        return res.status(200).json({
            correct: isCorrect,
            correctAnswer, // Send back correct answer so UI can display it if wrong
            newStreak,
            levelUp
        });

    } catch (error) {
        console.error("Answer Validation Error:", error);
        return res.status(500).json({ error: "Validation failed." });
    }
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// IMPORTS
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExponentsGen } from '../src/core/generators/ExponentsGen.js';
import { PercentGen } from '../src/core/generators/PercentGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { PythagorasGen } from '../src/core/generators/PythagorasGen.js';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen.js';
import { StatisticsGen } from '../src/core/generators/StatisticsGen.js';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen.js';
import { FractionArithGen } from '../src/core/generators/FractionArithGen.js';
import { ChangeFactorGen } from '../src/core/generators/ChangeFactorGen.js';
import { AnglesGen } from '../src/core/generators/AnglesGen.js';
import { PatternsGen } from '../src/core/generators/PatternsGen.js';

interface VercelRequest extends IncomingMessage {
    body: any;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
};

const generators: any = {
    arithmetic: new BasicArithmeticGen(),
    negative: new NegativeNumbersGen(),
    ten_powers: new TenPowersGen(),
    exponents: new ExponentsGen(),
    percent: new PercentGen(),
    fraction_basics: new FractionBasicsGen(),
    fraction_arith: new FractionArithGen(),
    simplify: new ExpressionSimplificationGen(),
    equation: new LinearEquationGen(),
    graph: new LinearGraphGenerator(),
    geometry: new GeometryGenerator(),
    scale: new ScaleGen(),
    volume: new VolumeGen(),
    similarity: new SimilarityGen(),
    pythagoras: new PythagorasGen(),
    probability: new ProbabilityGen(),
    statistics: new StatisticsGen(),
    change_factor: new ChangeFactorGen(),
    angles: new AnglesGen(),
    patterns: new PatternsGen()
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    const { requests } = req.body;

    if (!Array.isArray(requests)) {
        return res.status(400).json({ error: 'Invalid request format' });
    }

    try {
        const results = requests
            .map((item: any) => {
                const topicId = item.topic || item.category;
                const level = Number(item.level);
                const lang = item.lang || 'sv';
                
                if (!generators[topicId]) {
                    console.warn(`Generator not found for: ${topicId}`);
                    return null;
                }

                const questionData = generators[topicId].generate(level, lang);

                // FIX: Inject topic/level/lang so DoNowGrid logic functions correctly
                return {
                    ...questionData,
                    topic: topicId,
                    level: level,
                    lang: lang
                };
            })
            .filter(q => q !== null); // Remove failed generations to prevent UI crashes

        // FIX: Return the array directly to match DoNowGrid's expectation of questions.map()
        res.status(200).json(results);
    } catch (error) {
        console.error("Batch generation error:", error);
        res.status(500).json({ error: 'Batch generation failed' });
    }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang.",
      "F√∂rm√•ga att anv√§nda matematikens uttrycksformer f√∂r att samtala om, argumentera och redog√∂ra f√∂r fr√•gest√§llningar, ber√§kningar och slutsatser."
    ],

    // Centralt Inneh√•ll (Core Content)
    // Mapped to specific modules in the app
    centralt_innehall: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        modules: ["arithmetic", "negative", "ten_powers", "exponents", "percent", "fraction_basics", "fraction_arith"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.", // arithmetic
          "Talsystemets utveckling fr√•n naturliga tal till reella tal.", // negative
          "Tal i br√•k- och decimalform samt deras anv√§ndning i vardagliga och matematiska situationer.", // fraction_basics
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform.", // fraction_arith
          "Procent f√∂r att uttrycka f√∂r√§ndring och f√∂r√§ndringsfaktor samt ber√§kningar med procent i vardagliga situationer och i situationer inom olika √§mnesomr√•den.", // percent, change_factor
          "Potensform f√∂r att uttrycka sm√• och stora tal samt anv√§ndning av prefix." // ten_powers, exponents
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["simplify", "equation", "linear_graph"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.", // simplify
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Algebraiska m√∂nster och hur de kan beskrivas med uttryck.",
          "Metoder f√∂r ekvationsl√∂sning.", // equation
          "Funktioner och r√§ta linjens ekvation." // linear_graph
        ]
      },
      geometri: {
        category: "Geometri",
        modules: ["geometry", "scale", "volume", "similarity", "pythagoras","angles"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt. Skala vid f√∂rminskning och f√∂rstoring av en- och tv√•dimensionella objekt.", // scale
          "Likformighet och symmetri i planet.", // similarity
          "Geometriska satser och formler och behovet av argumentation f√∂r deras giltighet. Pythagoras sats.", // pythagoras
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta.", // geometry, volume
          "Vinkelbegreppet och vinkelm√§tning. Vinkelsumman i m√•ngh√∂rningar." // Vinklar
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"], // change_factor fits here too conceptually, but mapped to statistics in app structure
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      statistik: {
        category: "Sannolikhet och statistik",
        modules: ["probability", "statistics", "change_factor"], // Added change_factor here as requested
        content: [
          "Likformig sannolikhet och metoder f√∂r att ber√§kna sannolikhet i vardagliga situationer.", // probability
          "Tabeller och diagram f√∂r att beskriva resultat fr√•n unders√∂kningar.", // statistics
          "L√§gesm√•tt: medelv√§rde, median och typv√§rde.", // statistics
          "Spridningsm√•tt: variationsbredd.", // statistics
          "F√∂r√§ndringsfaktor och procentuella f√∂r√§ndringar." // change_factor
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"],
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\debug.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import fs from 'fs';
import path from 'path';

export default function handler(req: VercelRequest, res: VercelResponse) {
    try {
        // Look for the generators folder relative to this executing function
        const generatorsPath = path.join(process.cwd(), 'src/core/generators');
        
        let files: string[] = [];
        if (fs.existsSync(generatorsPath)) {
            files = fs.readdirSync(generatorsPath);
        } else {
            files = ["Generators folder not found at: " + generatorsPath];
        }

        res.status(200).json({
            status: "Debug Online",
            cwd: process.cwd(),
            foundFiles: files
        });
    } catch (error) {
        res.status(500).json({ error: String(error) });
    }
}

// FILE END: api\debug.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// IMPORTS: Pointing to ../src/core/generators/ with .js extension for Vercel/ESM
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExponentsGen } from '../src/core/generators/ExponentsGen.js';
import { PercentGen } from '../src/core/generators/PercentGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { PythagorasGen } from '../src/core/generators/PythagorasGen.js';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen.js';
import { StatisticsGen } from '../src/core/generators/StatisticsGen.js';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen.js';
import { FractionArithGen } from '../src/core/generators/FractionArithGen.js';
import { ChangeFactorGen } from '../src/core/generators/ChangeFactorGen.js';
import { AnglesGen } from '../src/core/generators/AnglesGen.js'; 
import { PatternsGen } from '../src/core/generators/PatternsGen.js';

interface VercelRequest extends IncomingMessage {
    body: any;
    query: Partial<{ [key: string]: string | string[] }>;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
    send: (data: any) => VercelResponse;
};

// Instantiate generators
const graphGen = new LinearGraphGenerator();

const generators: any = {
    arithmetic: new BasicArithmeticGen(),
    negative: new NegativeNumbersGen(),
    ten_powers: new TenPowersGen(),
    exponents: new ExponentsGen(),
    percent: new PercentGen(),
    fraction_basics: new FractionBasicsGen(),
    fraction_arith: new FractionArithGen(),
    simplify: new ExpressionSimplificationGen(),
    equation: new LinearEquationGen(),
    
    // FIX: Map both 'graph' and 'linear_graph' to the same generator
    graph: graphGen,
    linear_graph: graphGen, 

    geometry: new GeometryGenerator(),
    scale: new ScaleGen(),
    volume: new VolumeGen(),
    similarity: new SimilarityGen(),
    pythagoras: new PythagorasGen(),
    probability: new ProbabilityGen(),
    statistics: new StatisticsGen(),
    change_factor: new ChangeFactorGen(),
    angles: new AnglesGen(),
    patterns: new PatternsGen()
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Handling
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,POST');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    // Handle both GET (query) and POST (body)
    const body = req.body || {};
    const query = req.query || {};

    // Normalize parameters (Frontend uses 'topic', API uses 'category')
    const category = body.category || body.topic || query.category || query.topic;
    const level = body.level || query.level;
    const lang = body.lang || query.lang || 'sv';

    // Debug log
    console.log(`[API] Generating: ${category} Level ${level} (${lang})`);

    if (!category) {
        return res.status(400).json({ error: "Missing 'topic' or 'category' parameter" });
    }

    if (!generators[category]) {
        return res.status(400).json({ error: `Generator not found: ${category}` });
    }

    try {
        const question = generators[category].generate(Number(level), String(lang));
        res.status(200).json(question);
    } catch (error) {
        console.error(`[API] Generation error for ${category}:`, error);
        res.status(500).json({ error: 'Generation failed', details: String(error) });
    }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: dev-server.ts
// =======================================================

import express, { Request, Response } from 'express';
import cors from 'cors';
import { register } from 'tsconfig-paths';
import path from 'path';

// 1. Register Path Aliases (@core/*) from tsconfig
// This ensures the backend logic can find files in src/core
import tsConfig from './tsconfig.json' assert { type: "json" };

const baseUrl = path.resolve(process.cwd(), tsConfig.compilerOptions.baseUrl || '.');
const cleanup = register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths,
});

// 2. Import API Handlers
// We import these AFTER registering paths so they resolve correctly
import questionHandler from './api/question';
import answerHandler from './api/answer';
import curriculumHandler from './api/curriculum';

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// 3. Vercel -> Express Adapter
// Vercel functions are (req, res) => void, which matches Express,
// but we wrap them to ensure errors are caught.
const adapter = (handler: any) => async (req: Request, res: Response) => {
    try {
        await handler(req, res);
    } catch (err) {
        console.error("API Error:", err);
        res.status(500).json({ error: 'Internal Server Error', details: String(err) });
    }
};

// 4. Define Routes
// These must match the filenames in your /api folder
app.get('/api/question', adapter(questionHandler));
app.post('/api/answer', adapter(answerHandler));
app.get('/api/curriculum', adapter(curriculumHandler));

// 5. Start Server
app.listen(PORT, () => {
    console.log(`\nüöÄ Backend Simulation running at http://localhost:${PORT}`);
    console.log(`   - /api/question`);
    console.log(`   - /api/answer`);
    console.log(`   - /api/curriculum`);
    console.log(`\nüé® Frontend running at http://localhost:5173 (Proxy active)\n`);
});

// FILE END: dev-server.ts

// =======================================================
// FILE START: index.html
// =======================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <title>Anpassa | Math Platform</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// FILE END: index.html

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"vite\"",
    "dev:frontend": "vite",
    "dev:server": "tsx watch dev-server.ts",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.95.3",
    "katex": "^0.16.9",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vercel/node": "^5.5.28",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.7.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.6"
  }
}


// FILE END: package.json

// =======================================================
// FILE START: postcss.config.js
// =======================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// FILE END: postcss.config.js

// =======================================================
// FILE START: src\App.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import { supabase } from './lib/supabaseClient';

// Views
import Dashboard from './components/views/Dashboard';
import PracticeView from './components/views/PracticeView';
import DoNowConfig from './components/views/DoNowConfig';
import DoNowGrid from './components/views/DoNowGrid';
import AuthView from './components/views/AuthView';

// Modals
import AboutModal from './components/modals/AboutModal';
import LgrModal from './components/modals/LgrModal';
import StatsModal from './components/modals/StatsModal';
import StreakModal from './components/modals/StreakModal'; 
import ContentModal from './components/modals/ContentModal'; 
import MobileDrawer from './components/practice/MobileDrawer';

// Data & Constants
import { UI_TEXT, LEVEL_DESCRIPTIONS } from './constants/localization';

function App() {
    // --- 1. AUTH & PROFILE STATE ---
    const [session, setSession] = useState(null);
    const [profile, setProfile] = useState(null);
    const [loadingProfile, setLoadingProfile] = useState(true);

    // --- 2. UI NAVIGATION STATE ---
    const [view, setView] = useState('dashboard');
    const [lang, setLang] = useState('sv');
    const [topic, setTopic] = useState('');
    const [level, setLevel] = useState(0);

    // --- 3. GAMEPLAY STATE ---
    const [question, setQuestion] = useState(null);
    const [input, setInput] = useState('');
    const [feedback, setFeedback] = useState(null);
    const [loading, setLoading] = useState(false);
    const [streak, setStreak] = useState(0);
    const [totalCorrect, setTotalCorrect] = useState(0);
    const [revealedClues, setRevealedClues] = useState([]);
    const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);
    const [usedHelp, setUsedHelp] = useState(false);

    // --- 4. SESSION STATS & HISTORY ---
    const [sessionStats, setSessionStats] = useState({
        attempted: 0,
        correctNoHelp: 0,
        correctHelp: 0,
        incorrect: 0,
        skipped: 0,
        maxStreak: 0
    });
    const [granularStats, setGranularStats] = useState({});
    const [history, setHistory] = useState([]);
    const [levelUpAvailable, setLevelUpAvailable] = useState(false);
    
    // --- 5. MODALS & UI STATE ---
    const [aboutOpen, setAboutOpen] = useState(false);
    const [statsOpen, setStatsOpen] = useState(false);
    const [timeUpOpen, setTimeUpOpen] = useState(false);
    const [lgrOpen, setLgrOpen] = useState(false);
    const [contentOpen, setContentOpen] = useState(false); 
    const [showStreakModal, setShowStreakModal] = useState(false);
    const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);

    // --- 6. DO NOW STATE ---
    const [doNowQuestions, setDoNowQuestions] = useState([]);
    const [doNowConfig, setDoNowConfig] = useState([]); 

    // --- 7. TIMER STATE ---
    const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

    const ui = UI_TEXT[lang];

    // --- EFFECT: AUTH & PROFILE LISTENER ---
    useEffect(() => {
        // Initial session check
        supabase.auth.getSession().then(({ data: { session } }) => {
            setSession(session);
            if (session) fetchProfile(session.user.id);
            else setLoadingProfile(false);
        });

        // Listen for real-time auth changes
        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            setSession(session);
            if (session) fetchProfile(session.user.id);
            else {
                setProfile(null);
                setLoadingProfile(false);
            }
        });

        return () => subscription.unsubscribe();
    }, []);

    const fetchProfile = async (userId) => {
    // 1. Check if profile exists
    const { data, error } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', userId)
            .single();

        if (error && error.code === 'PGRST116') { // Error code for "not found"
            // 2. If it doesn't exist (Social User), create it!
            const { data: { user } } = await supabase.auth.getUser();
            
            // Pull metadata we sent during handleSocialLogin
            const userRole = user.user_metadata?.role || 'student';
            const fullName = user.user_metadata?.full_name || user.email.split('@')[0];

            const { data: newProfile, error: createError } = await supabase
                .from('profiles')
                .insert([{ 
                    id: userId, 
                    full_name: fullName, 
                    role: userRole,
                    alias: userRole === 'student' ? `User-${Math.floor(Math.random() * 10000)}` : null
                }])
                .select()
                .single();
                
            if (newProfile) setProfile(newProfile);
        } else if (data) {
            setProfile(data);
        }
        setLoadingProfile(false);
    };

    const handleLogout = async () => {
        await supabase.auth.signOut();
        setView('dashboard');
        setStreak(0);
    };

    // --- DATA PERSISTENCE: RECORD PROGRESS (The Skill Bucket Bridge) ---
    const recordProgress = async (isCorrect, metadata) => {
        if (!session?.user || !metadata) return;

        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        const { error } = await supabase.from('student_progress').insert({
            student_id: session.user.id,
            topic_id: topic,
            variation_key: metadata.variation || 'unknown',
            is_correct: isCorrect,
            help_used: helpUsed,
            // assignment_id logic can be wired here in future phases
        });

        if (error) console.error("Database persistence error:", error.message);
    };

    // --- TIMER LOGIC ---
    useEffect(() => {
        let interval = null;
        if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
            interval = setInterval(() => {
                setTimerSettings(prev => {
                    if (prev.remaining <= 1) {
                        clearInterval(interval);
                        setTimeUpOpen(true);
                        return { ...prev, remaining: 0, isActive: false };
                    }
                    return { ...prev, remaining: prev.remaining - 1 };
                });
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [timerSettings.isActive, view, timerSettings.remaining]);

    const toggleTimer = (minutes) => {
        const seconds = minutes * 60;
        setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
    };

    const resetTimer = () => {
        setTimerSettings({ duration: 0, remaining: 0, isActive: false });
    };

    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    };

    useEffect(() => {
        if (streak > sessionStats.maxStreak) {
            setSessionStats(prev => ({ ...prev, maxStreak: streak }));
        }
    }, [streak]);

    // --- GAMEPLAY HANDLERS ---
    const fetchQuestion = async (t = topic, l = level, lg = lang, force = false) => {
        if (!force && (showStreakModal || levelUpAvailable || timeUpOpen)) return;
        if (!t || !l) return;
        
        setLoading(true);
        setFeedback(null);
        setInput('');
        setRevealedClues([]);
        setUsedHelp(false);
        setIsSolutionRevealed(false);
        setLevelUpAvailable(false);
        
        try {
            const timestamp = new Date().getTime();
            const res = await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}${force ? `&force=true&t=${timestamp}` : ''}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            setQuestion(data);
        } catch (e) {
            console.error(e);
            setQuestion(null);
        } finally {
            setLoading(false);
        }
    };

    const startPractice = () => {
        if (topic && level) {
            setStreak(0);
            setView('practice');
            if (timerSettings.duration > 0) {
                setTimerSettings(prev => ({ ...prev, isActive: true }));
            }
            fetchQuestion(topic, level, lang);
        }
    };

    const quitPractice = () => {
        setStreak(0);
        setView('dashboard');
        setQuestion(null);
    };

    const handleHint = () => {
        if (question?.clues) {
            setUsedHelp(true);
            const currentLen = revealedClues.length;
            if (currentLen < question.clues.length) {
                setRevealedClues([...revealedClues, question.clues[currentLen]]);
            }
        }
    };

    const handleSolution = () => {
        if (question?.clues) {
            setUsedHelp(true);
            setRevealedClues(question.clues);
            if (!isSolutionRevealed) {
                updateStats('incorrect');
                updateGranularStats(topic, level, 'incorrect');
            }
            setIsSolutionRevealed(true);
            setStreak(0);
        }
    };

    const updateStats = (type) => {
        setSessionStats(prev => ({
            ...prev,
            attempted: prev.attempted + 1,
            [type]: prev[type] + 1
        }));
    };

    const updateGranularStats = (topicId, levelId, resultType) => {
        setGranularStats(prev => {
            const topicData = prev[topicId] || {};
            const levelData = topicData[levelId] || { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 };
            return {
                ...prev,
                [topicId]: {
                    ...topicData,
                    [levelId]: {
                        ...levelData,
                        [resultType]: (levelData[resultType] || 0) + 1
                    }
                }
            };
        });
    };

    const handleSkip = () => {
        setStreak(0);
        updateStats('skipped');
        updateGranularStats(topic, level, 'skipped');
        fetchQuestion(topic, level, lang);
    };

    const handleChangeLevel = (delta) => { 
        const newLevel = level + delta; 
        const max = Object.keys(LEVEL_DESCRIPTIONS[topic] || {}).length; 
        if (newLevel >= 1 && newLevel <= max) { 
            setLevel(newLevel); 
            fetchQuestion(topic, newLevel, lang, true); 
        } 
    };

    const handleSubmit = async (e, directInput) => {
        e.preventDefault();
        if (showStreakModal || timeUpOpen) return;
        if (feedback === 'correct') return;
        
        let finalInput = directInput !== undefined ? directInput : input;
        if (!question || !finalInput) return;

        const isStatsLocked = isSolutionRevealed;
        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        try {
            const res = await fetch('/api/answer', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ 
                    answer: finalInput, 
                    token: question.token, 
                    streak: streak, 
                    level: level, 
                    topic: topic, 
                    usedHelp: helpUsed, 
                    solutionUsed: isSolutionRevealed, 
                    attempts: question.attempts 
                }) 
            });
            const result = await res.json();
            
            // üî• DB RECORDING FIRE
            await recordProgress(result.correct, question.metadata);

            if (result.correct) {
                if (!isStatsLocked) {
                    setHistory(prev => [{ topic, level, correct: true, text: question.renderData.latex || question.renderData.description, clueUsed: helpUsed, time: Date.now() }, ...prev]);
                    setStreak(result.newStreak);
                    updateStats(helpUsed ? 'correctHelp' : 'correctNoHelp');
                    updateGranularStats(topic, level, helpUsed ? 'correctHelp' : 'correctNoHelp');
                    setTotalCorrect(prev => prev + 1);

                    if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                        setShowStreakModal(true);
                    } else if (result.levelUp) {
                        setLevelUpAvailable(true);
                    } else {
                        setTimeout(() => fetchQuestion(topic, level, lang), 1500);
                    }
                }
                setFeedback('correct');
            } else {
                question.attempts = (question.attempts || 0) + 1;
                if (question.attempts >= 2) {
                    if (!isStatsLocked) {
                        setHistory(prev => [{ topic, level, correct: false, text: question.renderData.latex || question.renderData.description, clueUsed: true, time: Date.now() }, ...prev]);
                    }
                    handleSolution(); 
                } else {
                    handleHint();
                }
                setFeedback('incorrect');
                setStreak(0);
            }
        } catch (e) { console.error(e); }
    };

    // --- DO NOW LOGIC ---
    const handleDoNowGenerate = async (selected) => {
        if (selected.length === 0) return;
        setDoNowConfig(selected);
        setLoading(true);
        const requests = [];
        for (let i = 0; i < 6; i++) {
            const selection = selected[i % selected.length];
            requests.push({ topic: selection.topic, level: selection.level, lang });
        }
        try {
            const res = await fetch('/api/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ requests })
            });
            const data = await res.json();
            if (Array.isArray(data)) {
                setDoNowQuestions(data);
                setView('donow_grid');
            }
        } catch (e) { console.error("Do Now Error:", e); } finally { setLoading(false); }
    };

    // --- RENDER LOGIC: AUTH GUARD ---
    if (session && loadingProfile) {
        return <div className="h-screen flex items-center justify-center bg-white text-indigo-600 font-black animate-pulse">ANPASSA...</div>;
    }

    if (!session) {
        return <AuthView ui={ui} lang={lang} onGuestMode={() => {}} />; // Add guest mode if desired
    }

    // --- RENDER LOGIC: VIEW SWITCHER ---
    if (view === 'donow_config') {
        return <div className="min-h-screen bg-gray-50"><DoNowConfig ui={ui} lang={lang} onBack={() => setView('dashboard')} onGenerate={handleDoNowGenerate} /></div>;
    }
    if (view === 'donow_grid') {
        return <DoNowGrid questions={doNowQuestions} ui={ui} onBack={() => setView('donow_config')} lang={lang} onRefreshAll={() => handleDoNowGenerate(doNowConfig)} onRefreshOne={(i, t, l) => {}} />;
    }

    return (
        <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
            <AboutModal visible={aboutOpen} onClose={() => setAboutOpen(false)} ui={ui} />
            <LgrModal visible={lgrOpen} onClose={() => setLgrOpen(false)} ui={ui} />
            <ContentModal visible={contentOpen} onClose={() => setContentOpen(false)} /> 
            <StatsModal visible={statsOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setStatsOpen(false)} title={ui.stats_title} />
            <StatsModal visible={timeUpOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setTimeUpOpen(false)} title={ui.stats_times_up} />
            <StreakModal visible={showStreakModal} onClose={() => setShowStreakModal(false)} streak={streak} ui={ui} />
            <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} ui={ui} />

            <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                    <div className="flex items-center gap-4">
                        <h1 className="text-xl font-black text-indigo-600 tracking-tighter cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                        {view === 'dashboard' && timerSettings.remaining > 0 && (
                            <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                <span>‚è∏ {ui.timer_paused}</span>
                                <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                            </div>
                        )}
                    </div>
                    <div className="flex items-center gap-3">
                        <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold">‚úÖ {totalCorrect}</div>
                        <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold">üî• {streak}</div>
                        <button onClick={handleLogout} className="text-xs font-bold text-slate-400 hover:text-red-500 uppercase ml-2">Logga ut</button>
                    </div>
                </div>
            </header>

            <div className="flex-1 flex flex-col">
                {view === 'dashboard' ? (
                    <Dashboard
                        lang={lang} selectedTopic={topic} selectedLevel={level} profile={profile}
                        onSelect={(t, l) => { setTopic(t); setLevel(l); }} onStart={startPractice} 
                        timerSettings={timerSettings} toggleTimer={toggleTimer} resetTimer={resetTimer} ui={ui} 
                        onLgrOpen={() => setLgrOpen(true)} onContentOpen={() => setContentOpen(true)} 
                        onDoNowOpen={() => setView('donow_config')} toggleLang={() => setLang(l => l === 'sv' ? 'en' : 'sv')}
                    />
                ) : (
                    <PracticeView
                        lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} 
                        handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip}
                        handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{ history, topic, level }} 
                        actions={{ retry: (force) => fetchQuestion(topic, level, lang, force), goBack: quitPractice }} 
                        levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} 
                        timerSettings={timerSettings} formatTime={formatTime} setMobileHistoryOpen={setMobileHistoryOpen}
                    />
                )}
            </div>
        </div>
    );
}

export default App;

// FILE END: src\App.jsx

// =======================================================
// FILE START: src\components\modals\AboutModal.jsx
// =======================================================

import React from 'react';

const AboutModal = ({ visible, onClose, ui }) => {
    if (!visible) return null;
    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1">‚úï</button>

                <div className="mb-4 flex justify-center">
                    <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100">
                        <img
                            src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                            alt="Creator"
                            className="w-full h-full object-cover"
                        />
                    </div>
                </div>

                <div className="text-center mb-6">
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                    <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                    <hr className="my-4 border-gray-200" />
                    <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" /></svg>
                        {ui.contactLink}
                    </a>
                </div>
            </div>
        </div>
    );
};

export default AboutModal;

// FILE END: src\components\modals\AboutModal.jsx

// =======================================================
// FILE START: src\components\modals\ContentModal.jsx
// =======================================================

import React from 'react';
import { CONTENT_MAP } from '../../constants/content_map';

const ContentModal = ({ visible, onClose }) => {
    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-4xl max-h-[85vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden animate-bounce-in border border-slate-200">
                
                {/* Header */}
                <div className="bg-slate-50 border-b border-slate-200 p-6 flex justify-between items-center shrink-0">
                    <div>
                        <h2 className="text-2xl font-black text-slate-800 tracking-tight">Inneh√•llsf√∂rteckning</h2>
                        <p className="text-slate-500 text-sm mt-1">√ñversikt √∂ver alla omr√•den och niv√•er</p>
                    </div>
                    <button 
                        onClick={onClose} 
                        className="w-10 h-10 flex items-center justify-center rounded-full bg-white border border-slate-200 text-slate-400 hover:text-slate-700 hover:border-slate-300 transition-all text-xl font-bold"
                    >
                        ‚úï
                    </button>
                </div>

                {/* Scrollable Content */}
                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
                    <div className="space-y-12">
                        {Object.entries(CONTENT_MAP).map(([catKey, category]) => (
                            <div key={catKey}>
                                <h3 className="text-xl font-bold text-slate-900 uppercase tracking-widest border-b-2 border-slate-100 pb-2 mb-6">
                                    {category.title}
                                </h3>
                                
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    {category.topics.map(topic => (
                                        <div key={topic.id} className="bg-slate-50 rounded-xl p-5 border border-slate-100 hover:border-indigo-100 transition-colors">
                                            <h4 className="font-bold text-indigo-700 mb-4 flex items-center gap-2">
                                                <span className="w-2 h-2 rounded-full bg-indigo-500"></span>
                                                {topic.title}
                                            </h4>
                                            
                                            <div className="space-y-3">
                                                {topic.levels.map(lvl => (
                                                    <div key={lvl.lvl} className="flex items-start gap-3 text-sm">
                                                        <div className="font-mono font-bold text-slate-400 bg-white px-2 py-0.5 rounded border border-slate-200 text-xs mt-0.5">
                                                            {lvl.lvl}
                                                        </div>
                                                        <div>
                                                            <div className="font-semibold text-slate-700">{lvl.desc}</div>
                                                            <div className="text-slate-500 text-xs italic mt-0.5">Ex: {lvl.ex}</div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Footer */}
                <div className="bg-slate-50 border-t border-slate-200 p-4 flex justify-end shrink-0">
                    <button 
                        onClick={onClose} 
                        className="px-6 py-2 bg-slate-800 hover:bg-slate-900 text-white rounded-lg font-bold text-sm transition-colors"
                    >
                        St√§ng
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ContentModal;

// FILE END: src\components\modals\ContentModal.jsx

// =======================================================
// FILE START: src\components\modals\LevelUpModal.jsx
// =======================================================

import React from 'react';

const LevelUpModal = ({ visible, ui, onNext, onStay, lang }) => {
    if (!visible) return null;

    // Robust Fallback Logic: Ensure text exists even if UI keys are missing
    // We use the 'lang' prop to determine the default language
    const currentLang = lang || 'sv'; 
    
    const defaultTitle = currentLang === 'sv' ? "Niv√• upp?" : "Level Up?";
    const defaultDesc = currentLang === 'sv' 
        ? "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?" 
        : "You seem to know this! Do you want to skip to the next level?";
    const defaultYes = currentLang === 'sv' ? "Ja, k√∂r!" : "Yes, let's go!";
    const defaultNo = currentLang === 'sv' ? "Nej, stanna h√§r" : "No, stay here";

    const title = ui?.levelUpTitle || defaultTitle;
    const desc = ui?.levelUpDesc || defaultDesc;
    const btnYes = ui?.levelUpYes || defaultYes;
    const btnNo = ui?.levelUpNo || defaultNo;

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <div className="text-center mb-6">
                    <div className="text-5xl mb-4">üöÄ</div>
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{title}</h3>
                    <p className="text-gray-600">{desc}</p>
                </div>
                <div className="flex flex-col gap-3">
                    <button 
                        onClick={onNext} 
                        className="w-full py-4 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                    >
                        {btnYes}
                    </button>
                    <button 
                        onClick={onStay} 
                        className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95"
                    >
                        {btnNo}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default LevelUpModal;

// FILE END: src\components\modals\LevelUpModal.jsx

// =======================================================
// FILE START: src\components\modals\LgrModal.jsx
// =======================================================

import React, { useState, useEffect } from 'react';

const LgrModal = ({ visible, onClose, ui }) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (visible && !data) {
            setLoading(true);
            fetch('/api/curriculum')
                .then(res => res.json())
                .then(d => { setData(d); setLoading(false); })
                .catch(err => { console.error(err); setLoading(false); });
        }
    }, [visible, data]);

    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden animate-bounce-in">
                <div className="flex justify-between items-start mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                    <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600 transition-colors text-xl font-bold">‚úï</button>
                </div>

                <div className="flex-1 overflow-y-auto custom-scrollbar pr-2">
                    {loading ? (
                        <div className="flex justify-center items-center py-12">
                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-sky-600"></div>
                        </div>
                    ) : data ? (
                        <div className="space-y-8">
                            <p className="text-slate-600 italic border-l-4 border-sky-200 pl-4 py-1">{data.description}</p>
                            
                            {/* Syfte */}
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                <ul className="space-y-2">
                                    {data.syfte.map((item, i) => (
                                        <li key={i} className="flex gap-3 text-sm text-slate-700">
                                            <span className="text-sky-500 font-bold">‚Ä¢</span>
                                            {item}
                                        </li>
                                    ))}
                                </ul>
                            </div>

                            {/* Centralt Inneh√•ll */}
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Centralt Inneh√•ll (√•k 7-9)</h4>
                                <div className="grid gap-6">
                                    {/* FIX: Changed data.mapping to data.centralt_innehall */}
                                    {data.centralt_innehall && Object.entries(data.centralt_innehall).map(([key, section]) => (
                                        <div key={key} className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                            <h5 className="font-bold text-slate-900 mb-2 text-sm">{section.category}</h5>
                                            <ul className="list-disc pl-5 space-y-1 text-xs text-slate-600">
                                                {section.content.map((c, i) => <li key={i}>{c}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                    )}
                </div>

                <div className="mt-6 pt-4 border-t border-slate-100 text-center shrink-0">
                    <a href="https://www.skolverket.se" target="_blank" rel="noreferrer" className="text-xs text-sky-600 hover:underline">K√§lla: Skolverket (Lgr22)</a>
                </div>
            </div>
        </div>
    );
};

export default LgrModal;

// FILE END: src\components\modals\LgrModal.jsx

// =======================================================
// FILE START: src\components\modals\StatsModal.jsx
// =======================================================

import React from 'react';
import { CATEGORIES } from '../../constants/localization';

const LevelBreakdown = ({ granularStats, ui, lang }) => {
    const topics = Object.keys(granularStats);
    if (topics.length === 0) return null;

    return (
        <div className="mt-6 border-t border-gray-100 pt-4 w-full">
            <h4 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-4">
                {ui.level_breakdown}
            </h4>
            <div className="space-y-4">
                {topics.map(topicKey => {
                    const topicLevels = granularStats[topicKey];
                    const levels = Object.keys(topicLevels).sort((a, b) => Number(a) - Number(b));

                    let topicLabel = topicKey;
                    for (const catKey in CATEGORIES) {
                        const found = CATEGORIES[catKey].topics.find(t => t.id === topicKey);
                        if (found) {
                            topicLabel = found.label[lang];
                            break;
                        }
                    }

                    return (
                        <div key={topicKey} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                            <h5 className="font-bold text-gray-700 text-sm mb-2 capitalize">{topicLabel}</h5>
                            <div className="space-y-2">
                                {levels.map(lvl => {
                                    const stats = topicLevels[lvl];
                                    const total = stats.skipped + stats.incorrect + stats.correctHelp + stats.correctNoHelp;
                                    if (total === 0) return null;

                                    const pSkip = (stats.skipped / total) * 100;
                                    const pWrong = (stats.incorrect / total) * 100;
                                    const pHelp = (stats.correctHelp / total) * 100;
                                    const pCorrect = (stats.correctNoHelp / total) * 100;
                                    const unassistedPct = Math.round(pCorrect);

                                    return (
                                        <div key={lvl} className="flex flex-col gap-1 mb-3 last:mb-0">
                                            <div className="flex justify-between items-center text-xs font-medium text-gray-500 mb-1">
                                                <span>{lang === 'sv' ? 'Niv√•' : 'Level'} {lvl}</span>
                                            </div>
                                            <div className="flex w-full h-3 rounded-full overflow-hidden bg-gray-200">
                                                {pSkip > 0 && <div style={{ width: `${pSkip}%` }} className="bg-gray-400" />}
                                                {pWrong > 0 && <div style={{ width: `${pWrong}%` }} className="bg-red-500" />}
                                                {pHelp > 0 && <div style={{ width: `${pHelp}%` }} className="bg-yellow-400" />}
                                                {pCorrect > 0 && <div style={{ width: `${pCorrect}%` }} className="bg-green-500" />}
                                            </div>
                                            <div className="flex flex-wrap gap-x-3 text-[10px] text-gray-500 mt-1">
                                                <span className="text-gray-500 font-semibold">{ui.stat_skip}: {stats.skipped}</span>
                                                <span className="text-red-600 font-semibold">{ui.stat_wrong}: {stats.incorrect}</span>
                                                <span className="text-yellow-600 font-semibold">{ui.stat_help}: {stats.correctHelp}</span>
                                                <span className="text-green-600 font-semibold">{ui.stat_correct}: {stats.correctNoHelp}</span>
                                            </div>
                                            <div className="text-[10px] text-gray-400 italic">
                                                {ui.stat_total}: {total} ({unassistedPct}% unassisted)
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const StatsModal = ({ visible, stats, granularStats, ui, onClose, title, lang }) => {
    if (!visible) return null;
    const attemptCount = stats.attempted || 0;
    const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

    return (
        <div className="fixed inset-0 z-[100] flex sm:items-center justify-center sm:p-4 bg-white sm:bg-black/50 sm:backdrop-blur-sm fade-in">
            <div className="bg-white w-full h-full sm:h-auto sm:max-h-[90vh] sm:rounded-2xl sm:shadow-2xl sm:max-w-md p-6 relative flex flex-col sm:border-4 sm:border-blue-500 overflow-y-auto custom-scrollbar">
                <div className="flex justify-between items-center mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-gray-900">{title || ui.stats_title}</h3>
                    <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 sm:hidden">‚úï</button>
                </div>

                <div className="shrink-0 grid grid-cols-2 gap-4 text-left text-sm mb-6">
                    <div className="text-gray-500">{ui.stats_longest_streak}</div>
                    <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                    <div className="text-gray-500">{ui.stats_attempted}</div>
                    <div className="font-bold text-right">{stats.attempted}</div>
                    <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                    <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_correct_help}</div>
                    <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_incorrect}</div>
                    <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                    <div className="text-gray-500">{ui.stats_skipped}</div>
                    <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                </div>

                <LevelBreakdown granularStats={granularStats} ui={ui} lang={lang} />

                <button onClick={onClose} className="mt-8 w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg shrink-0 hidden sm:block">
                    {ui.stats_close}
                </button>
            </div>
        </div>
    );
};

export default StatsModal;

// FILE END: src\components\modals\StatsModal.jsx

// =======================================================
// FILE START: src\components\modals\StreakModal.jsx
// =======================================================

import React from 'react';

const StreakModal = ({ visible, streak, ui, onClose }) => {
    if (!visible) return null;

    let icon = "ü•â";
    if (streak >= 50) icon = "üëë";
    else if (streak >= 40) icon = "üèÜ";
    else if (streak >= 30) icon = "ü•á";
    else if (streak >= 20) icon = "ü•à";
    else if (streak >= 15) icon = "ü•â";

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                <button 
                    onClick={onClose} 
                    className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                >
                    {ui.btn_close_streak}
                </button>
            </div>
        </div>
    );
};

export default StreakModal;

// FILE END: src\components\modals\StreakModal.jsx

// =======================================================
// FILE START: src\components\practice\CluePanel.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const CluePanel = ({ revealedClues, question, ui, isSolutionRevealed }) => {
    if (!revealedClues || revealedClues.length === 0) return null;

    // We need the total count to identify which clue is the "final" one
    const totalCluesCount = question.clues ? question.clues.length : 0;

    return (
        <div className="bg-orange-50 border border-orange-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
            <div className="flex items-center gap-2 mb-4 text-orange-800 font-bold border-b border-orange-200 pb-2">
                <span>üí° {ui.hintsTitle} ({revealedClues.length}/{totalCluesCount})</span>
            </div>
            <div className="space-y-6">
                {revealedClues.map((clue, i) => {
                    // Identify if this is the absolute last clue in the sequence
                    const isTheFinalClue = i === totalCluesCount - 1;
                    
                    // RESTORED LOGIC: 
                    // Hide the latex box for the final clue unless the solution is unlocked.
                    // This forces the student to perform the final step themselves.
                    const showLatex = !isTheFinalClue || isSolutionRevealed;

                    return (
                        <div key={i} className="group animate-slide-down">
                            {/* 1. Text Description (Always shown) */}
                            <div className="text-sm text-orange-900 mb-2 font-medium leading-relaxed">
                                <MathText text={clue.text} />
                            </div>
                            
                            {/* 2. Math Box (Conditional) */}
                            {clue.latex && showLatex && (
                                <div className="bg-white p-3 rounded-lg border border-orange-200 text-center shadow-sm overflow-x-auto mt-2">
                                    <MathText text={`$${clue.latex}$`} large={true} />
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default CluePanel;

// FILE END: src\components\practice\CluePanel.jsx

// =======================================================
// FILE START: src\components\practice\HistoryList.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const HistoryList = ({ history, ui }) => {
    return (
        <div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                <h2 className="font-bold text-gray-700">{ui.history}</h2>
                <span className="text-xs text-gray-400">{history.length}</span>
            </div>
            <div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px] custom-scrollbar">
                {history.length === 0 ? (
                    <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>
                ) : (
                    history.map((entry, i) => (
                        <div 
                            key={i} 
                            className={`p-3 rounded-lg border-l-4 text-sm ${
                                entry.correct 
                                    ? 'border-emerald-500 bg-emerald-50' 
                                    : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')
                            }`}
                        >
                            <div className="flex justify-between items-start mb-1">
                                <span className="font-semibold capitalize text-gray-700">
                                    {entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span>
                                </span>
                                <span className="text-xs text-gray-400">
                                    {new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                            </div>
                            
                            <div className="text-gray-600 mb-1 line-clamp-2">
                                <MathText text={entry.text} />
                            </div>

                            {!entry.correct && !entry.skipped && entry.correctAnswer && (
                                <div className="text-xs text-red-600 mt-1 font-medium">
                                    <MathText text={`Correct: ${entry.correctAnswer}`} />
                                </div>
                            )}

                            <div className="mt-2">
                                {entry.clueUsed && (
                                    <span className="inline-block px-1.5 py-0.5 bg-orange-100 text-orange-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">
                                        {ui.clueUsed}
                                    </span>
                                )} 
                                <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${
                                    entry.correct 
                                        ? 'bg-emerald-100 text-emerald-700' 
                                        : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')
                                }`}>
                                    {entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}
                                </span>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default HistoryList;

// FILE END: src\components\practice\HistoryList.jsx

// =======================================================
// FILE START: src\components\practice\MobileDrawer.jsx
// =======================================================

import React from 'react';
import HistoryList from './HistoryList';

const MobileDrawer = ({ open, onClose, history, ui }) => {
    return (
        <>
            {open && <div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}
            <div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}>
                <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                    <h2 className="font-bold text-gray-700">{ui.history}</h2>
                    <button onClick={onClose} className="text-gray-400">‚úï</button>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                    <HistoryList history={history} ui={ui} />
                </div>
            </div>
        </>
    );
};

export default MobileDrawer;

// FILE END: src\components\practice\MobileDrawer.jsx

// =======================================================
// FILE START: src\components\ui\Button.jsx
// =======================================================

import React from 'react';

export const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  className = '', 
  disabled = false,
  fullWidth = false 
}) => {
  const baseStyles = "px-4 py-2 rounded-lg font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-math-blue text-white hover:bg-blue-600 focus:ring-math-blue shadow-sm",
    secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500",
    success: "bg-math-green text-white hover:bg-green-600 focus:ring-math-green shadow-sm",
    danger: "bg-math-red text-white hover:bg-red-600 focus:ring-math-red shadow-sm",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
    >
      {children}
    </button>
  );
};

// FILE END: src\components\ui\Button.jsx

// =======================================================
// FILE START: src\components\ui\InputComponents.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

// =====================================================================
// FRACTION INPUT COMPONENT
// =====================================================================
export const FractionInput = ({ value, onChange, allowMixed = false, autoFocus = false }) => {
    const wholeRef = useRef(null);
    const numRef = useRef(null);
    const denRef = useRef(null);

    // Safe parsing of the value
    let w = "", n = "", d = "";
    const strVal = value || "";

    if (strVal.includes(' ')) {
        const parts = strVal.split(' ');
        w = parts[0];
        if (parts[1] && parts[1].includes('/')) {
            [n, d] = parts[1].split('/');
        } else {
            n = parts[1] || "";
        }
    } else if (strVal.includes('/')) {
        [n, d] = strVal.split('/');
    } else {
        n = strVal;
    }

    const update = (newW, newN, newD) => {
        let res = "";
        if (newW) {
            res += newW;
            if (newN || newD) res += " ";
        }
        if (newN || newD) {
            res += `${newN}/${newD}`;
        }
        onChange(res);
    };

    // Auto-focus logic
    useEffect(() => {
        if (autoFocus) {
            if (allowMixed) wholeRef.current?.focus();
            else numRef.current?.focus();
        }
    }, [autoFocus, allowMixed]);

    return (
        <div className="inline-flex items-center gap-2 font-mono text-xl text-slate-800">
            {allowMixed && (
                <input
                    ref={wholeRef}
                    className="w-12 h-14 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                    value={w}
                    onChange={(e) => update(e.target.value, n, d)}
                    placeholder="0"
                />
            )}
            <div className="flex flex-col items-center gap-1">
                <input
                    ref={numRef}
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={n}
                    onChange={(e) => update(w, e.target.value, d)}
                    placeholder="n"
                />
                <div className="w-full h-0.5 bg-slate-800 rounded-full"></div>
                <input
                    ref={denRef}
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={d}
                    onChange={(e) => update(w, n, e.target.value)}
                    placeholder="d"
                />
            </div>
        </div>
    );
};

// =====================================================================
// EXPONENT INPUT COMPONENT
// =====================================================================
export const ExponentInput = ({ value, onChange, autoFocus = false }) => {
    const baseRef = useRef(null);
    const expRef = useRef(null);

    let base = "", exp = "";
    const strVal = value || "";
    
    if (strVal.includes('^')) {
        [base, exp] = strVal.split('^');
    } else {
        base = strVal;
    }

    const update = (newBase, newExp) => {
        if (newExp) onChange(`${newBase}^${newExp}`);
        else onChange(newBase);
    };

    useEffect(() => {
        if (autoFocus) baseRef.current?.focus();
    }, [autoFocus]);

    return (
        <div className="inline-flex items-start font-mono text-xl text-slate-800 pt-4">
            <input
                ref={baseRef}
                className="w-16 h-12 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                value={base}
                onChange={(e) => update(e.target.value, exp)}
                placeholder="x"
            />
            <input
                ref={expRef}
                className="w-10 h-8 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-sm relative -top-3 ml-1 shadow-sm"
                value={exp}
                onChange={(e) => update(base, e.target.value)}
                placeholder="n"
            />
        </div>
    );
};

// FILE END: src\components\ui\InputComponents.jsx

// =======================================================
// FILE START: src\components\ui\MathText.jsx
// =======================================================

import React from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css'; // Ensure CSS is imported

const MathText = ({ text, className = "", large = false }) => {
    if (!text) return null;

    // 1. Patch common LaTeX color syntax differences if necessary
    const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');

    // 2. Split by $ delimiters
    const parts = patchedText.split(/(\$[^\$]+\$)/g);

    return (
        <span className={className}>
            {parts.map((part, index) => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const tex = part.slice(1, -1);
                    try {
                        const html = katex.renderToString(tex, { 
                            throwOnError: false, 
                            displayMode: large 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index} className="text-red-500">{part}</span>;
                    }
                } else if (part.includes('\\')) {
                    // Catch-all for stray LaTeX without $ delimiters (legacy support)
                    try {
                        const html = katex.renderToString(part, { 
                            throwOnError: false, 
                            displayMode: false 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index}>{part}</span>;
                    }
                }
                return <span key={index}>{part}</span>;
            })}
        </span>
    );
};

export default MathText;

// FILE END: src\components\ui\MathText.jsx

// =======================================================
// FILE START: src\components\views\AuthView.jsx
// =======================================================

import React, { useState } from 'react';
import { supabase } from '../../lib/supabaseClient';

const AuthView = ({ ui, lang }) => {
    const [loading, setLoading] = useState(false);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [fullName, setFullName] = useState('');
    const [role, setRole] = useState('student');
    const [isSignUp, setIsSignUp] = useState(false);
    const [message, setMessage] = useState(null);

    const handleAuth = async (e) => {
        e.preventDefault();
        setLoading(true);
        setMessage(null);

        if (isSignUp && password !== confirmPassword) {
            setMessage({ 
                type: 'error', 
                text: lang === 'sv' ? "L√∂senorden matchar inte!" : "Passwords do not match!" 
            });
            setLoading(false);
            return;
        }

        try {
            if (isSignUp) {
                const { data, error: authError } = await supabase.auth.signUp({ 
                    email, 
                    password,
                    options: {
                        data: { full_name: fullName, role: role }
                    }
                });
                if (authError) throw authError;

                if (data.user) {
                    await supabase.from('profiles').insert([{ 
                        id: data.user.id, 
                        full_name: fullName, 
                        role: role,
                        alias: role === 'student' ? `User-${Math.floor(Math.random() * 10000)}` : null
                    }]);
                }
                setMessage({ 
                    type: 'success', 
                    text: lang === 'sv' ? "Konto skapat! Kolla din e-post." : "Account created! Check your email." 
                });
            } else {
                const { error: signInError } = await supabase.auth.signInWithPassword({ email, password });
                if (signInError) throw signInError;
            }
        } catch (error) {
            setMessage({ type: 'error', text: error.message });
        } finally {
            setLoading(false);
        }
    };

    const handleSocialLogin = async (provider) => {
        setLoading(true);
        const { error } = await supabase.auth.signInWithOAuth({
            provider: provider,
            options: {
                redirectTo: window.location.origin,
                data: { role: role } 
            }
        });
        if (error) setMessage({ type: 'error', text: error.message });
        setLoading(false);
    };

    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-slate-50 p-6">
            <div className="w-full max-w-md bg-white rounded-3xl shadow-2xl p-8 border border-slate-200">
                <div className="text-center mb-6">
                    <h1 className="text-4xl font-black text-indigo-600 mb-1 tracking-tighter">Anpassa</h1>
                    <p className="text-slate-500 text-sm font-medium font-mono">
                        {isSignUp ? (lang === 'sv' ? "SKAPA KONTO" : "CREATE ACCOUNT") : (lang === 'sv' ? "V√ÑLKOMMEN TILLBAKA" : "WELCOME BACK")}
                    </p>
                </div>

                <div className="mb-6">
                    <label className="block text-[10px] font-black uppercase tracking-widest text-slate-400 mb-2 text-center">
                        {lang === 'sv' ? "Jag √§r en..." : "I am a..."}
                    </label>
                    <div className="flex gap-2 p-1 bg-slate-100 rounded-2xl">
                        <button type="button" onClick={() => setRole('student')} className={`flex-1 py-2 rounded-xl text-sm font-bold transition-all ${role === 'student' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500'}`}>
                            {lang === 'sv' ? "Elev" : "Student"}
                        </button>
                        <button type="button" onClick={() => setRole('teacher')} className={`flex-1 py-2 rounded-xl text-sm font-bold transition-all ${role === 'teacher' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500'}`}>
                            {lang === 'sv' ? "L√§rare" : "Teacher"}
                        </button>
                    </div>
                </div>

                <div className="mb-6">
                    <button 
                        onClick={() => handleSocialLogin('google')}
                        className="w-full flex items-center justify-center gap-3 p-4 border-2 border-slate-100 rounded-2xl hover:bg-slate-50 hover:border-indigo-100 transition-all font-bold text-slate-600 shadow-sm"
                    >
                        <svg className="w-6 h-6" viewBox="0 0 24 24"><path fill="#EA4335" d="M12 5c1.6 0 3 .6 4.1 1.6l3.1-3.1C17.3 1.6 14.8 1 12 1 7.7 1 4.1 3.5 2.3 7.1l3.7 2.9C6.9 7.1 9.3 5 12 5z"/><path fill="#4285F4" d="M23.5 12.3c0-.8-.1-1.6-.2-2.3H12v4.4h6.5c-.3 1.5-1.2 2.7-2.4 3.5l3.8 3c2.2-2 3.6-5 3.6-8.6z"/><path fill="#FBBC05" d="M6 14.7c-.2-.7-.4-1.5-.4-2.3s.2-1.6.4-2.3L2.3 7.1C1.4 8.7 1 10.3 1 12s.4 3.3 1.3 4.9l3.7-2.2z"/><path fill="#34A853" d="M12 23c3 0 5.5-1 7.4-2.7l-3.8-3c-1 .7-2.3 1.2-3.6 1.2-2.7 0-5.1-2.1-5.9-4.9l-3.7 2.9C4.1 20.5 7.7 23 12 23z"/></svg>
                        {lang === 'sv' ? "Logga in med Google" : "Continue with Google"}
                    </button>
                </div>

                <div className="relative mb-6">
                    <div className="absolute inset-0 flex items-center"><span className="w-full border-t border-slate-100"></span></div>
                    <div className="relative flex justify-center text-[10px] uppercase tracking-tighter"><span className="bg-white px-3 text-slate-300 font-black">{lang === 'sv' ? "Eller e-post" : "Or Email"}</span></div>
                </div>

                <form onSubmit={handleAuth} className="space-y-3">
                    {isSignUp && (
                        <div>
                            <input type="text" placeholder={lang === 'sv' ? "Namn" : "Name"} className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" value={fullName} onChange={(e) => setFullName(e.target.value)} required />
                        </div>
                    )}
                    <input type="email" placeholder="Email" className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" value={email} onChange={(e) => setEmail(e.target.value)} required />
                    <input type="password" placeholder={lang === 'sv' ? "L√∂senord" : "Password"} className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" value={password} onChange={(e) => setPassword(e.target.value)} required />
                    
                    {isSignUp && (
                        <input 
                            type="password" 
                            placeholder={lang === 'sv' ? "Bekr√§fta l√∂senord" : "Confirm password"} 
                            className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" 
                            value={confirmPassword} 
                            onChange={(e) => setConfirmPassword(e.target.value)} 
                            required 
                        />
                    )}

                    <button disabled={loading} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-black py-4 rounded-2xl shadow-lg shadow-indigo-100 transition-all active:scale-[0.98] disabled:opacity-50 mt-2">
                        {loading ? '...' : (isSignUp ? (lang === 'sv' ? "SKAPA KONTO" : "CREATE ACCOUNT") : (lang === 'sv' ? "LOGGA IN" : "LOG IN"))}
                    </button>
                </form>

                {message && (
                    <div className={`mt-4 p-4 rounded-2xl text-xs font-bold text-center ${message.type === 'error' ? 'bg-red-50 text-red-600 border border-red-100' : 'bg-green-50 text-green-600 border border-green-100'}`}>
                        {message.text}
                    </div>
                )}

                <div className="mt-8 text-center border-t border-slate-50 pt-6">
                    <button onClick={() => setIsSignUp(!isSignUp)} className="text-indigo-600 hover:text-indigo-800 text-sm font-bold transition-colors">
                        {isSignUp ? (lang === 'sv' ? "Har redan ett konto? Logga in" : "Already have an account? Log In") : (lang === 'sv' ? "Inget konto? G√• med h√§r" : "No account? Join here")}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default AuthView;

// FILE END: src\components\views\AuthView.jsx

// =======================================================
// FILE START: src\components\views\Dashboard.jsx
// =======================================================

import React from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const COLOR_VARIANTS = {
    pink: {
        bgLight: 'bg-pink-50', bgDark: 'bg-pink-500', border: 'border-pink-100', text: 'text-pink-700', ring: 'ring-pink-500', borderSolid: 'border-pink-500', selectFocus: 'focus:ring-pink-500'
    },
    indigo: {
        bgLight: 'bg-indigo-50', bgDark: 'bg-indigo-500', border: 'border-indigo-100', text: 'text-indigo-700', ring: 'ring-indigo-500', borderSolid: 'border-indigo-500', selectFocus: 'focus:ring-indigo-500'
    },
    emerald: {
        bgLight: 'bg-emerald-50', bgDark: 'bg-emerald-500', border: 'border-emerald-100', text: 'text-emerald-700', ring: 'ring-emerald-500', borderSolid: 'border-emerald-500', selectFocus: 'focus:ring-emerald-500'
    },
    purple: {
        bgLight: 'bg-purple-50', bgDark: 'bg-purple-500', border: 'border-purple-100', text: 'text-purple-700', ring: 'ring-purple-500', borderSolid: 'border-purple-500', selectFocus: 'focus:ring-purple-500'
    },
    yellow: {
        bgLight: 'bg-yellow-50', bgDark: 'bg-yellow-500', border: 'border-yellow-100', text: 'text-yellow-700', ring: 'ring-yellow-500', borderSolid: 'border-yellow-500', selectFocus: 'focus:ring-yellow-500'
    }
};

const Dashboard = ({ 
    lang, 
    selectedTopic, 
    selectedLevel, 
    onSelect, 
    onStart, 
    timerSettings, 
    toggleTimer, 
    resetTimer, 
    ui, 
    onLgrOpen, 
    onContentOpen, // New Prop
    onDoNowOpen, 
    toggleLang 
}) => {
    
    const getStyles = (category) => {
        const color = category.color || 'emerald';
        return COLOR_VARIANTS[color] || COLOR_VARIANTS.emerald;
    };

    return (
        <div className="max-w-6xl mx-auto w-full p-4 fade-in flex flex-col min-h-[calc(100vh-80px)]">
            
            <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-emerald-50/50 rounded-3xl mx-4 relative overflow-hidden">
                <h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight relative z-10">Anpassa</h1>
                <p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide relative z-10">{ui.tagline}</p>

                <div className="mt-8 flex justify-center relative z-10">
                    <div className="bg-white/80 backdrop-blur-sm rounded-xl p-2 px-4 shadow-sm border border-gray-100 flex items-center gap-3">
                        <span className="font-bold text-gray-700 text-xs uppercase tracking-wider">{ui.timer_title}</span>
                        <div className="relative group">
                            <select
                                value={timerSettings.duration / 60}
                                onChange={(e) => toggleTimer(Number(e.target.value))}
                                className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-emerald-500 cursor-pointer"
                            >
                                <option value="0">{ui.timer_off}</option>
                                {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                            </select>
                            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                        </div>
                        {timerSettings.duration > 0 && (
                            <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                        )}
                    </div>
                </div>
            </div>

            <div className="text-center mb-10">
                <p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">
                {Object.entries(CATEGORIES).map(([catKey, category]) => {
                    const styles = getStyles(category);
                    
                    return (
                        <div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}>
                            <div className={`${styles.bgLight} p-4 border-b ${styles.border}`}>
                                <h3 className={`text-lg font-bold ${styles.text} uppercase tracking-wide flex items-center gap-2`}>
                                    <span className={`w-3 h-3 rounded-full ${styles.bgDark}`}></span>
                                    {category.label[lang]}
                                </h3>
                            </div>
                            
                            <div className="p-4 space-y-4 flex-1">
                                {category.topics.map(topic => {
                                    return (
                                        <div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                                            <div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div>
                                            <div className="relative">
                                                <select 
                                                    value={selectedTopic === topic.id ? selectedLevel : 0} 
                                                    onChange={(e) => onSelect(topic.id, Number(e.target.value))} 
                                                    className={`
                                                        w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none appearance-none cursor-pointer
                                                        ${selectedTopic === topic.id ? `ring-2 ${styles.ring} ${styles.borderSolid}` : styles.selectFocus}
                                                    `}
                                                >
                                                    <option value={0} disabled>{ui.selectLevel}</option>
                                                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                        if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                        return (
                                                            <option key={lvl} value={lvl}>
                                                                {lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang] || ""}
                                                            </option>
                                                        );
                                                    })}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" /></svg>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>

            <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20">
                <button 
                    onClick={onStart} 
                    className={`
                        px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 
                        ${selectedTopic 
                            ? 'bg-orange-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-orange-600 shadow-orange-200' 
                            : 'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}
                    `}
                >
                    {ui.startBtn} <span>üöÄ</span>
                </button>
            </div>

            <footer className="mt-auto py-6 border-t border-gray-200 flex flex-col md:flex-row justify-between items-center px-4 gap-4">
                <button onClick={onDoNowOpen} className="w-full md:w-auto bg-slate-800 hover:bg-slate-900 text-white font-bold py-2 px-6 rounded-full text-sm transition-colors shadow-sm order-2 md:order-1">
                    {ui.donow_btn}
                </button>

                <div className="flex items-center gap-3 order-1 md:order-2 w-full md:w-auto justify-center md:justify-end">
                    {/* NEW CONTENT BUTTON */}
                    <button onClick={onContentOpen} className="bg-emerald-100 hover:bg-emerald-200 text-emerald-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-emerald-200 shadow-sm">
                        Inneh√•ll
                    </button>
                    <button onClick={onLgrOpen} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-sky-200 shadow-sm">
                        {ui.lgr_btn}
                    </button>
                </div>
            </footer>
        </div>
    );
};

export default Dashboard;

// FILE END: src\components\views\Dashboard.jsx

// =======================================================
// FILE START: src\components\views\DoNowConfig.jsx
// =======================================================

import React, { useState } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const DoNowConfig = ({ ui, onBack, onGenerate, lang }) => {
    const [selected, setSelected] = useState([]);

    const handleToggle = (topicId, level) => {
        setSelected(prev => {
            const exists = prev.find(p => p.topic === topicId && p.level === level);
            if (exists) {
                return prev.filter(p => !(p.topic === topicId && p.level === level));
            } else {
                if (prev.length >= 3) return prev; // Max 3
                return [...prev, { topic: topicId, level }];
            }
        });
    };

    return (
        <div className="max-w-5xl mx-auto p-6 h-full flex flex-col">
            <div className="flex justify-between items-center mb-6">
                <button onClick={onBack} className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2">
                    <span>‚Üê</span> {ui.backBtn}
                </button>
                <h2 className="text-2xl font-bold text-slate-800">{ui.donow_title}</h2>
                <button
                    onClick={() => onGenerate(selected)}
                    disabled={selected.length === 0}
                    className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
                >
                    {ui.donow_gen} ({selected.length}/3)
                </button>
            </div>

            <p className="text-slate-500 mb-6 text-center">{ui.donow_desc}</p>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-6 overflow-y-auto custom-scrollbar pb-10">
                {Object.entries(CATEGORIES).map(([catKey, category]) => (
                    <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                        <h3 className="font-bold text-slate-700 mb-3 border-b pb-2">{category.label[lang]}</h3>
                        <div className="space-y-4">
                            {category.topics.map(topic => (
                                <div key={topic.id}>
                                    <div className="text-xs font-bold text-slate-400 uppercase mb-2">{topic.label[lang]}</div>
                                    <div className="flex flex-col gap-2">
                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                            if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                            const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);
                                            return (
                                                <button
                                                    key={lvl}
                                                    onClick={() => handleToggle(topic.id, lvl)}
                                                    className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${isSelected ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'}`}
                                                >
                                                    <span className="font-mono font-bold w-6 text-center bg-white/50 rounded">{lvl}</span>
                                                    <span className="truncate">{LEVEL_DESCRIPTIONS[topic.id][lvl][lang]}</span>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default DoNowConfig;

// FILE END: src\components\views\DoNowConfig.jsx

// =======================================================
// FILE START: src\components\views\DoNowGrid.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual } from '../visuals/GeometryComponents';

const DoNowCard = ({ q, index, showAnswer, onToggle, lang, onRefresh }) => {
    const desc = typeof q.renderData.description === 'object' ? q.renderData.description[lang] : q.renderData.description;
    const latex = q.renderData.latex;

    // --- Adaptive Layout Logic ---
    const isTextOnly = 
        (q.topic === 'equation' && (q.level === 5 || q.level === 6)) ||
        (q.topic === 'simplify' && q.level === 5);

    // --- Dynamic Text Scaling ---
    const getDescSize = (text) => {
        if (!text) return 'text-xl md:text-3xl';
        const len = text.length;
        if (isTextOnly) {
            if (len > 200) return 'text-base md:text-xl leading-relaxed';
            if (len > 100) return 'text-lg md:text-2xl leading-relaxed';
            if (len > 50) return 'text-xl md:text-3xl leading-relaxed';
            return 'text-2xl md:text-4xl leading-relaxed';
        } else {
            if (len > 80) return 'text-sm md:text-base leading-snug';
            if (len > 40) return 'text-base md:text-xl leading-normal';
            return 'text-lg md:text-2xl font-medium';
        }
    };

    const hasVisualData = (q.renderData.geometry || q.renderData.graph) && !isTextOnly;

    const renderVisual = () => {
        if (!hasVisualData) return null;

        if (q.renderData.graph) {
            return <GraphCanvas data={q.renderData.graph} width={300} height={200} />;
        }

        const geom = q.renderData.geometry;
        if (!geom) return null;

        const volumeTypes = ['cuboid', 'cylinder', 'cone', 'sphere', 'hemisphere', 'pyramid', 'triangular_prism', 'silo', 'ice_cream'];
        if (volumeTypes.includes(geom.type)) {
            return <VolumeVisualization data={geom} width={300} height={200} />;
        }

        return <GeometryVisual data={geom} />;
    };

    // Calculate rotation for refresh icon interaction
    const [isSpinning, setIsSpinning] = useState(false);
    
    // Auto-stop spinning if the question data actually changes (detected by token or description change)
    useEffect(() => {
        if (isSpinning) {
            const timer = setTimeout(() => setIsSpinning(false), 500); // Minimum spin time
            return () => clearTimeout(timer);
        }
    }, [q.token, q.renderData.description]); // Dependency ensures spin stops when new data arrives

    const handleRefreshClick = (e) => {
        e.stopPropagation();
        if (isSpinning) return; // Prevent double-clicks
        
        setIsSpinning(true);
        if (onRefresh) onRefresh();
        
        // Safety timeout in case props don't change (e.g. same question generated)
        setTimeout(() => setIsSpinning(false), 2000); 
    };

    return (
        <div 
            onClick={onToggle}
            className={`
                relative flex flex-col justify-between 
                bg-white rounded-2xl shadow-sm border-2 transition-all duration-300 cursor-pointer overflow-hidden group
                ${showAnswer ? 'border-indigo-500 ring-4 ring-indigo-500/20 scale-[1.02]' : 'border-slate-200 hover:border-indigo-300 hover:shadow-md'}
            `}
        >
            {/* Card Content */}
            <div className="p-5 flex flex-col flex-1 h-full">
                
                {/* Refresh Button (New) */}
                <button
                    onClick={handleRefreshClick}
                    disabled={isSpinning}
                    className={`
                        absolute top-3 right-3 w-8 h-8 rounded-full flex items-center justify-center transition-colors z-20 border 
                        ${isSpinning ? 'bg-indigo-50 border-indigo-200 cursor-wait' : 'bg-slate-50 hover:bg-indigo-100 text-slate-400 hover:text-indigo-600 border-slate-200'}
                    `}
                    title={lang === 'sv' ? "Ny fr√•ga" : "New question"}
                >
                    <span className={`text-sm ${isSpinning ? 'animate-spin' : ''}`}>üîÑ</span>
                </button>

                {/* Visual Container */}
                {hasVisualData && (
                    <div className="mb-4 bg-slate-50 rounded-xl border border-slate-100 overflow-hidden flex justify-center items-center py-4 min-h-[160px]">
                        {renderVisual()}
                    </div>
                )}

                {/* Text Content */}
                <div className="flex-1 flex flex-col justify-center items-center text-center">
                    <p className={`font-medium text-slate-700 mb-3 ${getDescSize(desc)}`}>
                        {desc}
                    </p>
                    
                    {latex && (
                        <div className="mt-2 text-2xl md:text-4xl font-black text-slate-800 tracking-wide">
                            <MathText text={latex} />
                        </div>
                    )}
                </div>
            </div>

            {/* Answer Overlay */}
            {showAnswer && (
                <div className="absolute inset-0 z-10 bg-white/95 backdrop-blur-sm flex flex-col items-center justify-center p-6 animate-in fade-in duration-200">
                    <div className="text-xs font-bold text-indigo-500 uppercase tracking-widest mb-2">
                        {lang === 'sv' ? 'FACIT' : 'ANSWER'}
                    </div>
                    <div className="text-3xl md:text-5xl font-black text-indigo-900 text-center break-words w-full">
                        {tryDecode(q.token)} <span className="text-xl text-slate-400 font-medium ml-1">{q.renderData.suffix}</span>
                    </div>
                </div>
            )}

            {/* Number Badge */}
            <div className={`absolute top-3 left-3 w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold transition-colors ${showAnswer ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-400 group-hover:bg-slate-200'}`}>
                {index + 1}
            </div>
        </div>
    );
};

const tryDecode = (str) => {
    try { return atob(str); } catch (e) { return "Error"; }
};

const DoNowGrid = ({ questions, ui, lang, onBack, onRefreshAll, onRefreshOne }) => {
    const [revealed, setRevealed] = useState({});
    const [showAll, setShowAll] = useState(false);
    const [isRegenerating, setIsRegenerating] = useState(false);

    const toggleOne = (idx) => {
        setRevealed(prev => ({ ...prev, [idx]: !prev[idx] }));
    };

    const toggleAll = () => {
        if (showAll) {
            setRevealed({});
            setShowAll(false);
        } else {
            const all = {};
            questions.forEach((_, i) => all[i] = true);
            setRevealed(all);
            setShowAll(true);
        }
    };

    const handleRegenerateAll = () => {
        setIsRegenerating(true);
        setRevealed({});
        setShowAll(false);
        
        if (onRefreshAll) {
            onRefreshAll().finally(() => setIsRegenerating(false));
        } else {
            setTimeout(() => setIsRegenerating(false), 500);
        }
    };

    return (
        <div className="h-screen flex flex-col bg-slate-50">
            {/* Header */}
            <header className="bg-white border-b border-slate-200 px-6 py-4 flex justify-between items-center shadow-sm z-20 sticky top-0">
                <div className="flex items-center gap-4">
                    <button onClick={onBack} className="flex items-center gap-2 text-slate-500 font-bold hover:text-indigo-600 transition-colors">
                        <span className="text-xl">‚Üê</span> 
                        <span>{ui.backBtn || "Back"}</span>
                    </button>
                    <h2 className="text-lg font-black text-slate-800 hidden md:block tracking-tight border-l border-slate-200 pl-4 ml-2">
                        {ui.donow_title}
                    </h2>
                </div>

                <div className="flex items-center gap-3">
                    {/* Regenerate All Button (New) */}
                    <button 
                        onClick={handleRegenerateAll}
                        disabled={isRegenerating}
                        className="px-4 py-2 rounded-full font-bold text-sm bg-slate-100 text-slate-600 hover:bg-slate-200 hover:text-indigo-600 transition-all flex items-center gap-2"
                        title={ui.donow_regenerate || "Regenerate all"}
                    >
                        <span className={isRegenerating ? 'animate-spin' : ''}>üîÑ</span>
                        <span className="hidden sm:inline">{ui.donow_regenerate || "New Set"}</span>
                    </button>

                    <button 
                        onClick={toggleAll} 
                        className={`
                            px-5 py-2 rounded-full font-bold text-sm transition-all shadow-sm flex items-center gap-2
                            ${showAll 
                                ? 'bg-slate-800 text-white hover:bg-black' 
                                : 'bg-indigo-600 text-white hover:bg-indigo-700 hover:shadow-md'}
                        `}
                    >
                        <span>{showAll ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è'}</span>
                        {showAll ? (ui.donow_hide_all || "Hide All") : (ui.donow_show_all || "Show All")}
                    </button>
                </div>
            </header>

            {/* Scrollable Grid Area */}
            <div className="flex-1 p-4 md:p-8 overflow-y-auto">
                {/* STRICT 3 COLUMN GRID */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-3 gap-6 max-w-8xl mx-auto pb-10">
                    {questions.map((q, i) => (
                        <DoNowCard
                            key={i}
                            index={i}
                            q={q}
                            showAnswer={!!revealed[i]}
                            onToggle={() => toggleOne(i)}
                            lang={lang}
                            onRefresh={() => onRefreshOne && onRefreshOne(i, q.topic, q.level)}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
};

export default DoNowGrid;

// FILE END: src\components\views\DoNowGrid.jsx

// =======================================================
// FILE START: src\components\views\PracticeView.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual, StaticGeometryVisual } from '../visuals/GeometryComponents';
import CluePanel from '../practice/CluePanel';
import HistoryList from '../practice/HistoryList';
import LevelUpModal from '../modals/LevelUpModal';
import { LEVEL_DESCRIPTIONS, CATEGORIES } from '../../constants/localization'; 
import { FractionInput } from '../ui/InputComponents';

// --- SECURITY HELPERS ---

const isValidInput = (val, type) => {
    if (val === '') return true;
    const numericRegex = /^-?[\d\s]*([.,:]\d*)?$/;
    
    if (type === 'numeric' || type === 'scale' || type === 'range' || type === 'fraction') {
        return numericRegex.test(val) || (type === 'fraction' && val.includes('/'));
    }
    
    const dangerousRegex = /[<>{}]/g;
    return !dangerousRegex.test(val);
};

const sanitize = (val) => {
    return val.replace(/[<>{}]/g, "");
};

const PracticeView = ({ 
    lang, 
    ui, 
    question, 
    loading, 
    feedback, 
    input, 
    setInput, 
    handleSubmit, 
    handleHint, 
    handleSolution, 
    handleSkip, 
    handleChangeLevel, 
    revealedClues, 
    uiState, 
    actions, 
    levelUpAvailable, 
    setLevelUpAvailable, 
    isSolutionRevealed, 
    timerSettings, 
    formatTime, 
    setMobileHistoryOpen 
}) => {
    // --- STATE FOR STRUCTURED INPUTS ---
    const [scaleInputLeft, setScaleInputLeft] = useState('');
    const [scaleInputRight, setScaleInputRight] = useState('');
    
    const [powerBase, setPowerBase] = useState('');
    const [powerExp, setPowerExp] = useState('');
    const [sciMantissa, setSciMantissa] = useState('');
    const [sciExp, setSciExp] = useState('');
    const [rangeLower, setRangeLower] = useState('');
    const [rangeUpper, setRangeUpper] = useState('');

    const inputRef = useRef(null);
    const [shake, setShake] = useState(false);

    // Auto-advance logic
    const retryRef = useRef(actions.retry);
    useEffect(() => { retryRef.current = actions.retry; }, [actions.retry]);
    
    useEffect(() => {
        if (feedback === 'correct' && isSolutionRevealed) {
            const timer = setTimeout(() => {
                retryRef.current(); 
            }, 1500);
            return () => clearTimeout(timer);
        }
    }, [feedback, isSolutionRevealed]);

    // Auto-focus logic
    useEffect(() => {
        if (!loading && !feedback && !levelUpAvailable && inputRef.current) {
            setTimeout(() => inputRef.current?.focus(), 50);
        }
    }, [question, loading, feedback, levelUpAvailable]);

    const descriptionText = typeof question?.renderData?.description === 'object' ? question.renderData.description[lang] : question?.renderData?.description;
    
    const handleChoiceClick = (choice) => { 
        if (feedback === 'correct') return; 
        setInput(choice); 
        handleSubmit({ preventDefault: () => { } }, choice); 
    };
    
    // --- SUBMIT HANDLER ---
    const handleFormSubmit = (e) => {
        e.preventDefault();
        
        if (feedback === 'correct') {
            actions.retry(true);
            return;
        }

        let finalInput = input;
        const type = question.renderData.answerType;

        if (type === 'scale') {
            if (scaleInputLeft === '' || scaleInputRight === '') return;
            finalInput = `${scaleInputLeft}:${scaleInputRight}`;
        } 
        else if (type === 'structured_power') {
            if (powerBase === '' || powerExp === '') return;
            finalInput = `${powerBase}^${powerExp}`;
        }
        else if (type === 'structured_scientific') {
            if (sciMantissa === '' || sciExp === '') return;
            finalInput = `${sciMantissa}*10^${sciExp}`;
        }
        else if (type === 'structured_range') {
            if (rangeLower === '' || rangeUpper === '') return;
            finalInput = `${rangeLower}:${rangeUpper}`;
        }
        else if (type === 'fraction') {
             if (!input) return;
             finalInput = input; 
        }
        else {
            if (!isValidInput(input, type === 'numeric' ? 'numeric' : 'text')) {
                setShake(true);
                setTimeout(() => setShake(false), 500);
                return;
            }
            if (type !== 'numeric') finalInput = sanitize(input);
        }

        if (!finalInput || finalInput.trim() === '') return;

        handleSubmit(e, finalInput);
    };

    const handleInputChange = (e, setter, type) => {
        const val = e.target.value;
        if (isValidInput(val, type)) {
            setter(val);
        }
    };

    // Reset specialized inputs on new question
    useEffect(() => {
        if (question && !loading) {
            setScaleInputLeft(''); setScaleInputRight('');
            setPowerBase(question.renderData.prefillBase || '');
            setPowerExp('');
            setSciMantissa('');
            setSciExp('');
            setRangeLower('');
            setRangeUpper('');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            const isMobile = window.innerWidth < 768;
            if (!isMobile && inputRef.current) {
                inputRef.current.focus();
            }
        }
    }, [question, loading]);

    const maxLevels = Object.keys(LEVEL_DESCRIPTIONS[uiState.topic] || {}).length;

    const renderVisual = () => {
        if (!question?.renderData) return null;

        if (question.renderData.graph) return <GraphCanvas data={question.renderData.graph} />;
        
        const geom = question.renderData.geometry;
        if (geom) {
            if (geom.type === 'frequency_table') return <GeometryVisual data={geom} />; 
            const volumeTypes = ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'];
            if (volumeTypes.includes(geom.type)) return <VolumeVisualization data={geom} />;
            return <GeometryVisual data={geom} />;
        }

        if (uiState.topic === 'geometry') return <StaticGeometryVisual description={descriptionText} />;

        if (question.renderData.latex) {
             return <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center overflow-x-auto py-2"><MathText text={`$$${question.renderData.latex}$$`} large={true} /></div>;
        }

        return <div className="flex flex-col items-center justify-center w-full min-h-[100px]"></div>;
    };

    const getSubmitLabel = () => {
        if (feedback === 'correct') return ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°");
        if (feedback === 'incorrect') return ui.tagWrong || "Incorrect";
        return ui.btnCheck || (lang === 'sv' ? "Svara" : "Submit");
    };

    const isDisabled = feedback === 'correct';

    if (!question && !loading) {
        return (
            <div className="flex flex-col items-center justify-center min-h-[50vh]">
                <p className="text-red-400 mb-4">{ui.error || "Error loading question"}</p>
                <button onClick={() => actions.retry(true)} className="bg-indigo-600 text-white px-6 py-2 rounded-full hover:bg-indigo-700 transition">
                    Retry
                </button>
            </div>
        );
    }

    return (
        <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in relative">
            
            <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => { setLevelUpAvailable(false); actions.retry(true); }} lang={lang} />
            
            <div className="flex-1 w-full min-w-0">
                {/* HEADER */}
                <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100 sticky top-0 z-20">
                    <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>

                    <div className="flex items-center gap-3">
                        {timerSettings.isActive && (
                            <div className={`font-mono text-sm font-bold px-3 py-1.5 rounded-lg border hidden sm:block ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                {formatTime(timerSettings.remaining)}
                            </div>
                        )}
                        <div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200">
                            <button onClick={() => handleChangeLevel(-1)} disabled={uiState.level <= 1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel || "<"}>&lt;</button>
                            <span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">
                                {(CATEGORIES && CATEGORIES[uiState.topic.toUpperCase()]?.label[lang]) || uiState.topic} ‚Ä¢ Lvl {uiState.level}
                            </span>
                            <button onClick={() => handleChangeLevel(1)} disabled={uiState.level >= maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel || ">"}>&gt;</button>
                        </div>
                        
                        <button onClick={() => setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500 hover:bg-gray-200 transition-colors">
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                    </div>
                </div>

                <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                    {loading ? (
                        <div className="p-20 text-center flex flex-col items-center gap-4">
                            <div className="w-10 h-10 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"></div>
                        </div>
                    ) : question ? (
                        <div className="p-4 sm:p-6">
                            <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                {renderVisual()}
                            </div>
                            
                            <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText} /></h2></div>
                            
                            {question.renderData.answerType === 'multiple_choice' ? (
                                <div className="max-w-md mx-auto grid grid-cols-2 gap-4">
                                    {(question.renderData.options || question.renderData.choices || []).map((choice, idx) => (
                                        <button key={idx} onClick={() => handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback === 'correct' && choice === input ? 'bg-green-500 border-green-500 text-white' : feedback === 'incorrect' && choice === input ? 'bg-red-500 border-red-500 text-white' : 'bg-white border-gray-200 text-gray-700 hover:border-indigo-500 hover:text-indigo-600'}`} disabled={feedback !== null}>{choice}</button>
                                    ))}
                                    {feedback === 'correct' && <div className="col-span-2 mt-4"><button onClick={() => actions.retry(true)} className="w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 bg-primary-500 shadow-green-200 hover:bg-primary-600">{ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°")}</button></div>}
                                </div>
                            ) : (
                                <form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                    <div className={`relative transition-transform ${shake ? 'animate-shake' : ''}`}>
                                        
                                        {question.renderData.answerType === 'fraction' && (
                                            <div className="flex justify-center py-2">
                                                <FractionInput 
                                                    value={input} 
                                                    onChange={setInput} 
                                                    allowMixed={true}
                                                    autoFocus={!loading && !feedback} 
                                                />
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'scale' && (
                                            <div className="flex items-center justify-center gap-2">
                                                <input type="text" value={scaleInputLeft} onChange={(e) => handleInputChange(e, setScaleInputLeft, 'numeric')} className="w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm focus:border-indigo-500" placeholder="X" disabled={isDisabled} />
                                                <span className="text-2xl font-bold text-gray-400">:</span>
                                                <input type="text" value={scaleInputRight} onChange={(e) => handleInputChange(e, setScaleInputRight, 'numeric')} className="w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm focus:border-indigo-500" placeholder="X" disabled={isDisabled} />
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'structured_power' && (
                                            <div className="flex items-end justify-center gap-1">
                                                <input type="text" value={powerBase} onChange={(e) => handleInputChange(e, setPowerBase, 'text')} className="w-24 p-4 text-center text-2xl font-bold border-2 rounded-xl outline-none focus:border-indigo-500" placeholder="Base" disabled={isDisabled} />
                                                <div className="mb-8">
                                                    <input type="text" value={powerExp} onChange={(e) => handleInputChange(e, setPowerExp, 'numeric')} className="w-16 p-2 text-center text-lg font-bold border-2 rounded-lg outline-none focus:border-indigo-500 bg-gray-50" placeholder="exp" disabled={isDisabled} />
                                                </div>
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'structured_scientific' && (
                                            <div className="flex items-center justify-center gap-2 text-2xl font-bold text-gray-600">
                                                <input type="text" value={sciMantissa} onChange={(e) => handleInputChange(e, setSciMantissa, 'numeric')} className="w-28 p-3 text-center border-2 rounded-xl outline-none focus:border-indigo-500" placeholder="a" disabled={isDisabled} />
                                                <span>¬∑ 10</span>
                                                <div className="mb-8">
                                                    <input type="text" value={sciExp} onChange={(e) => handleInputChange(e, setSciExp, 'numeric')} className="w-16 p-2 text-center text-lg border-2 rounded-lg outline-none focus:border-indigo-500 bg-gray-50" placeholder="n" disabled={isDisabled} />
                                                </div>
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'structured_range' && (
                                            <div className="flex items-center justify-center gap-3 text-xl font-bold text-gray-500">
                                                <input type="text" value={rangeLower} onChange={(e) => handleInputChange(e, setRangeLower, 'numeric')} className="w-20 p-3 text-center border-2 rounded-xl" placeholder="min" disabled={isDisabled} />
                                                <span>&lt;</span>
                                                <span className="text-black"><MathText text={question.renderData.latex} /></span>
                                                <span>&lt;</span>
                                                <input type="text" value={rangeUpper} onChange={(e) => handleInputChange(e, setRangeUpper, 'numeric')} className="w-20 p-3 text-center border-2 rounded-xl" placeholder="max" disabled={isDisabled} />
                                            </div>
                                        )}

                                        {!['scale', 'structured_power', 'structured_scientific', 'structured_range', 'fraction'].includes(question.renderData.answerType) && (
                                            <div className="relative">
                                                <input ref={inputRef} type="text" value={input} onChange={(e) => handleInputChange(e, setInput, question.renderData.answerType)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-green-500 bg-green-50 text-green-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-indigo-500 focus:ring-4 focus:ring-indigo-50'}`} placeholder={ui.placeholder || "..."} disabled={isDisabled} />
                                                {question.renderData.suffix && <span className="absolute right-6 top-1/2 -translate-y-1/2 text-slate-400 font-bold text-lg pointer-events-none">{question.renderData.suffix}</span>}
                                            </div>
                                        )}

                                        {feedback === 'correct' && <div className="absolute right-4 top-1/2 -translate-y-1/2 text-2xl animate-bounce-in">‚úÖ</div>}
                                        {feedback === 'incorrect' && <div className="absolute right-4 top-1/2 -translate-y-1/2 text-2xl animate-shake">‚ùå</div>}
                                    </div>
                                    
                                    <button 
                                        type="submit" 
                                        className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback === 'correct' ? 'bg-green-500 shadow-green-200 hover:bg-green-600' : 'bg-indigo-600 hover:bg-indigo-700 shadow-indigo-200 hover:shadow-lg'}`}
                                        disabled={loading}
                                    >
                                        {getSubmitLabel()}
                                    </button>
                                </form>
                            )}

                            <div className="mt-6 flex gap-3 justify-center flex-wrap">
                                <button type="button" onClick={handleHint} disabled={!question.clues || revealedClues.length >= question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-yellow-50 text-yellow-700 border border-yellow-200 hover:bg-yellow-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button>
                                <button type="button" onClick={handleSolution} disabled={!question.clues || isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button>
                                <button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button>
                            </div>
                        </div>
                    ) : (
                        <div className="p-12 text-center text-red-400">
                            <p>{ui.error || "Failed to load question."}</p>
                            <button onClick={() => actions.retry(true)} className="text-indigo-600 underline text-sm mt-2">Retry</button>
                        </div>
                    )}
                </main>

                <div className="lg:hidden mt-6 w-full">
                    {(revealedClues.length > 0 || isSolutionRevealed) && (
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                    )}
                </div>

            </div>
            
            <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui} /></div>
            </div>
        </div>
    );
};

export default PracticeView;

// FILE END: src\components\views\PracticeView.jsx

// =======================================================
// FILE START: src\components\visuals\AngleComponents.jsx
// =======================================================

import React from 'react';

// =====================================================================
// ANGLE VISUALIZATION COMPONENT
// Handles drawing rays, arcs, and labels for angle geometry problems.
// =====================================================================

const AngleVisual = ({ data }) => {
    // Data expected structure:
    // {
    //   type: 'angle',
    //   lines: [[p1, p2], ...],
    //   arcs: [{center, startAngle, endAngle, radius, label, color}],
    //   labels: [{x, y, text}],
    //   polygons: [{points: "x1,y1 x2,y2..."}]
    // }

    if (!data) return null;

    const { lines = [], arcs = [], labels = [], polygons = [] } = data;
    const width = 300;
    const height = 250;
    
    // Helper to draw an arc
    const drawArc = (arc, i) => {
        const { x, y } = arc.center;
        const r = arc.radius || 30;
        
        // Convert to radians (SVG Y is down, so standard math angles are inverted)
        const start = -arc.startAngle * (Math.PI / 180);
        const end = -arc.endAngle * (Math.PI / 180);
        
        const x1 = x + r * Math.cos(start);
        const y1 = y + r * Math.sin(start);
        const x2 = x + r * Math.cos(end);
        const y2 = y + r * Math.sin(end);
        
        let diff = arc.endAngle - arc.startAngle;
        while(diff < 0) diff += 360;
        
        const largeArc = diff > 180 ? 1 : 0;
        const sweep = 0; // Inverted Y logic
        
        const d = `M ${x} ${y} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} ${sweep} ${x2} ${y2} Z`;
        
        const midAngle = -(arc.startAngle + arc.endAngle) / 2 * (Math.PI / 180);
        const lx = x + (r + 25) * Math.cos(midAngle);
        const ly = y + (r + 25) * Math.sin(midAngle);

        return (
            <g key={`arc-${i}`}>
                <path d={d} fill={arc.color || "rgba(255, 165, 0, 0.2)"} stroke={arc.stroke || "orange"} strokeWidth="2" />
                {arc.label && (
                    <text x={lx} y={ly} textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#374151">
                        {arc.label}
                    </text>
                )}
            </g>
        );
    };

    return (
        <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} className="mx-auto bg-white rounded-lg shadow-sm border border-slate-100">
            {/* Draw Polygons (if any) */}
            {polygons.map((poly, i) => (
                <polygon 
                    key={`poly-${i}`} 
                    points={poly.points} 
                    fill="rgba(59, 130, 246, 0.1)" 
                    stroke="#3b82f6" 
                    strokeWidth="2" 
                />
            ))}

            {/* Draw Lines */}
            {lines.map((line, i) => (
                <line 
                    key={`line-${i}`} 
                    x1={line.x1} y1={line.y1} 
                    x2={line.x2} y2={line.y2} 
                    stroke="#1e293b" 
                    strokeWidth="3" 
                    strokeLinecap="round" 
                />
            ))}

            {/* Draw Arcs/Angles */}
            {arcs.map((arc, i) => drawArc(arc, i))}

            {/* Draw Independent Labels */}
            {labels.map((lbl, i) => (
                <text 
                    key={`lbl-${i}`} 
                    x={lbl.x} y={lbl.y} 
                    textAnchor="middle" 
                    fontSize={lbl.size || "18"} 
                    fontWeight="bold" 
                    fill={lbl.color || "#1f2937"}
                >
                    {lbl.text}
                </text>
            ))}
        </svg>
    );
};

export default AngleVisual;

// FILE END: src\components\visuals\AngleComponents.jsx

// =======================================================
// FILE START: src\components\visuals\ComplexGeometry.jsx
// =======================================================

import React from 'react';

export const TransversalVisual = ({ data }) => {
    const labels = data.labels;
    return (
        <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
            <polygon points="150,30 50,220 250,220" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.3" />
            <line x1="100" y1="125" x2="200" y2="125" stroke="#059669" strokeWidth="3" />
            <path d="M 150 125 l -5 -5 m 5 5 l -5 5" stroke="#059669" strokeWidth="2" fill="none"/>
            <path d="M 150 220 l -5 -5 m 5 5 l -5 5" stroke="#10b981" strokeWidth="2" fill="none"/>

            {/* Standard Labels */}
            <text x="85" y="80" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_top}</text>
            <text x="150" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_top}</text>
            <text x="150" y="240" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_bot}</text>

            {/* Conditional Labels: Total Bracket OR Bottom Extension */}
            {labels.left_tot && (
                <g transform="translate(-10, 0)"> 
                    <line x1="110" y1="20" x2="10" y2="210" stroke="#64748b" strokeWidth="2" />
                    <line x1="110" y1="20" x2="120" y2="25" stroke="#64748b" strokeWidth="2" />
                    <line x1="10" y1="210" x2="20" y2="215" stroke="#64748b" strokeWidth="2" />
                    <text x="50" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end" dominantBaseline="middle">{labels.left_tot}</text>
                </g>
            )}
            {labels.left_bot && (
                <text x="65" y="170" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_bot}</text>
            )}
        </svg>
    );
};

export const CompositeVisual = ({ data }) => {
    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200" className="border border-gray-100 rounded-lg bg-white shadow-sm">
                {data.subtype === 'house' ? (
                    <>
                        <rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <text x="160" y="120" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                        <text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                        <text x="130" y="60" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h_roof}</text>
                    </>
                ) : (
                    <>
                        <rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                        <text x="160" y="120" textAnchor="start" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                    </>
                )}
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\ComplexGeometry.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryComponents.jsx
// =======================================================

import React from 'react';

// 3D & Graphing
import { GraphCanvas } from './GraphCanvas';
import { VolumeVisualization } from './VolumeVisualization';

// Statistics & Probability
import { FrequencyTable, PercentGrid } from './StatisticsVisuals';
import { ProbabilityMarbles, ProbabilitySpinner } from './ProbabilityVisuals';
import ProbabilityTree from './ProbabilityTree';

// 2D Geometry & Utilities
import { RenderShape } from './GeometryShapes';
import { ScaleVisual, SimilarityCompare, CompareShapesArea } from './ScaleVisuals';
import { TransversalVisual, CompositeVisual } from './ComplexGeometry';
import PatternVisual from './PatternComponents';
import AngleVisual from './AngleComponents';

export const GeometryVisual = ({ data }) => {
    if (!data) return null;

    // --- ANGLE VISUAL ---
    if (data.type === 'angle') {
        return <AngleVisual data={data} />;
    }
    // --- PATTERNS ---
    if (data.type === 'pattern') {
        return <PatternVisual data={data} />;
    }
    // --- PROBABILITY TREES ---
    if (data.type === 'probability_tree') {
        return <ProbabilityTree data={data} />;
    }

    // --- FREQUENCY TABLE ---
    if (data.type === 'frequency_table') {
        return <FrequencyTable data={data} />;
    }

    // --- PROBABILITY MARBLES ---
    if (data.type === 'probability_marbles') {
        return <ProbabilityMarbles data={data} />;
    }

    // --- PROBABILITY SPINNER ---
    if (data.type === 'probability_spinner') {
        return <ProbabilitySpinner data={data} />;
    }

    // --- PERCENT GRID ---
    if (data.type === 'percent_grid') {
        return <PercentGrid data={data} />;
    }

    // --- SIMILARITY COMPARISON ---
    if (data.type === 'similarity_compare') {
        return <SimilarityCompare data={data} />;
    }

    // --- SCALES (Single & Compare) ---
    if (data.type === 'scale_single' || data.type === 'scale_compare') { 
        return <ScaleVisual data={data} />;
    }

    // --- TRANSVERSAL ---
    if (data.type === 'transversal') {
        return <TransversalVisual data={data} />;
    }

    // --- AREA COMPARISON ---
    if (data.type === 'compare_shapes_area') {
        return <CompareShapesArea data={data} />;
    }

    // --- BASIC & COMPOSITE SHAPES (Dispatcher) ---
    // UPDATED: 'composite' is now handled by RenderShape which has logic for new and legacy subtypes
    if (['rectangle', 'square', 'parallelogram', 'triangle', 'circle', 'semicircle', 'quarter_circle', 'composite'].includes(data.type)) {
        return (
            <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
                <RenderShape type={data.type} dims={data} labels={data.labels} />
            </svg>
        );
    }
    
    // Fallback or Legacy Composite (if any types remain that RenderShape doesn't handle)
    // Since RenderShape handles all 'composite' subtypes now, this might be redundant
    // but kept just in case of other 'composite' variants from ComplexGeometry.
    if (data.type === 'composite_legacy') { // Renaming or removing to prevent conflict
        return <CompositeVisual data={data} />;
    }

    return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>;
};

// Re-export these for backward compatibility if other files import them from here
export { GraphCanvas, VolumeVisualization };

export const StaticGeometryVisual = ({ description }) => { 
    if (!description) return null; 
    const d = description.toLowerCase(); 
    if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; 
    return null; 
};

// FILE END: src\components\visuals\GeometryComponents.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryShapes.jsx
// =======================================================

import React from 'react';

// Helper for text generation
export const mkTxt = (x, y, txt, anchor = "middle", baseline = "middle", color = "#374151") =>
    <text key={`${x}-${y}-${txt}`} x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill={color} fontSize="20">{txt}</text>;

export const RenderShape = ({ type, dims, labels, areaText, offsetX = 0, offsetY = 0, scale = 1 }) => {
    const cx = 150 + offsetX;
    const cy = 125 + offsetY;
    const safeDims = dims || {};
    // Ensure width and height have fallbacks to prevent NaN
    const rawW = safeDims.width || safeDims.w || 10;
    const rawH = safeDims.height || safeDims.h || 10;
    const rawR = safeDims.radius || safeDims.r || 5;

    const maxDim = Math.max(rawW, rawH, rawR * 2) || 10;
    const baseScale = (120 / maxDim) * scale;
    
    const sw = rawW * baseScale;
    const sh = rawH * baseScale;
    const sr = rawR * baseScale;

    // Use passed labels or fallback to dimension values if no label object exists
    const safeLabels = labels || {};
    const l_b = safeLabels.b || safeLabels.base || safeLabels.width || safeLabels.w;
    const l_h = safeLabels.h || safeLabels.height;
    const l_hyp = safeLabels.hyp || safeLabels.hypotenuse || safeLabels.c || safeLabels.diagonal;
    const l_slant = safeLabels.slant || safeLabels.s; // For parallelogram slant side
    
    // Angle Labels
    const l_a1 = safeLabels.a1;
    const l_a2 = safeLabels.a2;

    // Side Labels for Similarity (s1, s2)
    const l_s1 = safeLabels.s1;
    const l_s2 = safeLabels.s2;

    if (type === 'rectangle' || type === 'square') {
        return (
            <g>
                <rect x={cx - sw / 2} y={cy - sh / 2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {l_b && mkTxt(cx, cy + sh / 2 + 25, l_b)}
                {l_h && mkTxt(cx + sw / 2 + 15, cy, l_h, "start")}
                {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
            </g>
        );
    }

    if (type === 'parallelogram') {
        const skew = sw * 0.25; // fixed skew amount for visual
        // Points: BottomLeft, BottomRight, TopRight, TopLeft
        const xBL = cx - sw / 2 - skew/2;
        const xBR = cx + sw / 2 - skew/2;
        const xTR = cx + sw / 2 + skew/2;
        const xTL = cx - sw / 2 + skew/2;
        
        const yTop = cy - sh / 2;
        const yBot = cy + sh / 2;

        const path = `${xBL},${yBot} ${xBR},${yBot} ${xTR},${yTop} ${xTL},${yTop}`;

        return (
            <g>
                {/* Dotted Height Line */}
                <line x1={xTL} y1={yTop} x2={xTL} y2={yBot} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                {/* Main Shape */}
                <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                
                {/* Base Label */}
                {l_b && mkTxt((xBL + xBR)/2, yBot + 25, l_b)}
                
                {/* Height Label (Internal) */}
                {l_h && mkTxt(xTL + 10, (yTop+yBot)/2, l_h, "start")}
                
                {/* Slant Side Label (Right Side) for Perimeter */}
                {l_slant && mkTxt((xBR+xTR)/2 + 10, (yBot+yTop)/2, l_slant, "start")}

                {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
            </g>
        );
    }

    if (type === 'triangle') {
        const L = cx - sw / 2; 
        const R = cx + sw / 2;
        const T = cy - sh / 2; 
        const B = cy + sh / 2;
        
        if (safeDims.subtype === 'right') {
            const p1 = { x: L, y: T }; const p2 = { x: L, y: B }; const p3 = { x: R, y: B };
            const path = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
            return (
                <g>
                    <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                    {l_h && mkTxt(L - 15, cy, l_h)}
                    {l_b && mkTxt(cx, B + 25, l_b)}
                    {l_hyp && mkTxt(cx + 10, cy - 10, l_hyp, "start")}
                </g>
            );
        } else {
            // Isosceles / Generic Triangle
            const points = `${L},${B} ${R},${B} ${cx},${T}`;
            return (
                <g>
                    <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                    <polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                    {l_b && mkTxt(cx, B + 25, l_b)}
                    {l_h && mkTxt(cx + 5, cy, l_h, "start")}
                    
                    {l_s1 && mkTxt(L - 10, cy, l_s1, "end")}
                    {l_s2 && mkTxt(R + 10, cy, l_s2, "start")}

                    {l_a1 && (
                        <>
                            <path d={`M ${L + 15} ${B} A 15 15 0 0 0 ${L + 8} ${B - 13}`} fill="none" stroke="#374151" strokeWidth="2" />
                            <text x={L - 10} y={B - 5} fontSize="16" fontWeight="bold" fill="#374151">{l_a1}</text>
                        </>
                    )}
                    
                    {l_a2 && (
                        <>
                            <path d={`M ${R - 15} ${B} A 15 15 0 0 1 ${R - 8} ${B - 13}`} fill="none" stroke="#374151" strokeWidth="2" />
                            <text x={R + 10} y={B - 5} fontSize="16" fontWeight="bold" fill="#374151">{l_a2}</text>
                        </>
                    )}
                </g>
            );
        }
    }
    if (type === 'circle') {
        const isDiameter = safeDims.show === 'diameter';
        const labelTxt = safeLabels.val || (safeLabels.r ? `r=${safeLabels.r}` : (safeLabels.diameter ? `d=${safeLabels.diameter}` : null));
        return (
            <g>
                <circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {isDiameter ? (
                    <>
                        <line x1={cx - sr} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" strokeDasharray="4" />
                        {labelTxt && <text x={cx} y={cy - 15} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>}
                    </>
                ) : (
                    <>
                        <circle cx={cx} cy={cy} r={3} fill="#374151" />
                        <line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" />
                        {labelTxt && <text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>}
                    </>
                )}
            </g>
        );
    }

    // --- NEW: Semicircle ---
    if (type === 'semicircle') {
        const isDiameter = safeDims.show === 'diameter';
        const rVal = safeLabels.r;
        const dVal = safeLabels.diameter;
        const dPath = `M ${cx - sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx + sr} ${cy} Z`; 
        
        return (
            <g>
                <path d={dPath} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {isDiameter ? (
                    <>
                        <line x1={cx - sr} y1={cy + 15} x2={cx + sr} y2={cy + 15} stroke="#374151" strokeWidth="2" markerEnd="url(#arrow)" markerStart="url(#arrow)" />
                        <text x={cx} y={cy + 35} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{dVal ? `d=${dVal}` : ''}</text>
                    </>
                ) : (
                    <>
                        <line x1={cx} y1={cy} x2={cx + sr*0.7} y2={cy - sr*0.7} stroke="#374151" strokeWidth="2" />
                        <text x={cx + 15} y={cy - 25} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
                        <circle cx={cx} cy={cy} r={3} fill="#374151" />
                    </>
                )}
            </g>
        );
    }

    // --- NEW: Quarter Circle ---
    if (type === 'quarter_circle') {
        const rVal = safeLabels.r;
        const originX = cx - sr/2;
        const originY = cy + sr/2;
        
        const dPath = `M ${originX} ${originY} L ${originX + sr} ${originY} A ${sr} ${sr} 0 0 0 ${originX} ${originY - sr} Z`;

        return (
            <g>
                <path d={dPath} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                <text x={originX + sr/2} y={originY + 20} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
                <text x={originX - 15} y={originY - sr/2} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
            </g>
        );
    }
    
    // --- COMBINED SHAPES (Level 4) ---
    if (type === 'composite') {
        const lab = labels || {};
        
        if (dims.subtype === 'rect_right_tri') {
            const wRect = (lab.w || 10) * baseScale;
            const hRect = (lab.h || 10) * baseScale;
            const wTri = (lab.tri_b || 5) * baseScale;
            const totalW = wRect + wTri;
            const startX = cx - totalW / 2;
            const startY = cy + hRect / 2;

            return (
                <g>
                    <rect x={startX} y={startY - hRect} width={wRect} height={hRect} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <polygon points={`${startX + wRect},${startY} ${startX + wRect + wTri},${startY} ${startX + wRect},${startY - hRect}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {mkTxt(startX + wRect/2, startY + 20, lab.w)} 
                    {mkTxt(startX - 15, startY - hRect/2, lab.h)} 
                    {mkTxt(startX + wRect + wTri/2, startY + 20, lab.tri_b)} 
                </g>
            );
        }

        if (dims.subtype === 'l_shape') {
            const vW = (lab.vW || 3) * baseScale;
            const vH = (lab.vH || 8) * baseScale;
            const hW = (lab.hW || 6) * baseScale; // This is the extension width
            const hH = (lab.hH || 3) * baseScale;
            
            const showTotal = !!lab.totalW;
            
            const totW = vW + hW; 
            const totH = Math.max(vH, hH);
            const startX = cx - totW / 2;
            const startY = cy + totH / 2; 
            const p = `${startX},${startY} ${startX + vW + hW},${startY} ${startX + vW + hW},${startY - hH} ${startX + vW},${startY - hH} ${startX + vW},${startY - vH} ${startX},${startY - vH}`;
            return (
                <g>
                    <polygon points={p} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {mkTxt(startX + vW/2, startY - vH - 15, lab.vW)}
                    {mkTxt(startX - 15, startY - vH/2, lab.vH)}
                    
                    {/* Right Side Label */}
                    {mkTxt(startX + vW + hW + 15, startY - hH/2, lab.hH)}

                    {/* Bottom Label logic */}
                    {showTotal ? (
                        <>
                            {/* Draw a dimension line for total width */}
                            <line x1={startX} y1={startY + 25} x2={startX + totW} y2={startY + 25} stroke="#374151" strokeWidth="1" />
                            <line x1={startX} y1={startY + 20} x2={startX} y2={startY + 30} stroke="#374151" strokeWidth="1" />
                            <line x1={startX + totW} y1={startY + 20} x2={startX + totW} y2={startY + 30} stroke="#374151" strokeWidth="1" />
                            {mkTxt(startX + totW/2, startY + 45, lab.totalW)}
                        </>
                    ) : (
                        mkTxt(startX + vW + hW/2, startY + 20, lab.hW) // Fallback to extension label
                    )}
                </g>
            );
        }

        if (dims.subtype === 'house_area') {
            const s = (lab.s || 10) * baseScale;
            const hTri = (lab.h_tri || 5) * baseScale;
            
            const startX = cx - s/2;
            const startY = cy + s/2; 

            return (
                <g>
                    <rect x={startX} y={startY - s} width={s} height={s} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <polygon points={`${startX},${startY - s} ${startX + s},${startY - s} ${cx},${startY - s - hTri}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <line x1={cx} y1={startY - s} x2={cx} y2={startY - s - hTri} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />

                    {mkTxt(cx, startY + 20, lab.s)} 
                    {mkTxt(startX - 15, startY - s/2, lab.s)} 
                    {mkTxt(cx + 15, startY - s - hTri/2, lab.h_tri, "start")} 
                </g>
            );
        }
        
        if (dims.subtype === 'house' || dims.subtype === 'portal') {
             return (
                <g>
                    {dims.subtype === 'house' ? (
                        <>
                            <rect x={cx - 50} y={cy - 20} width={100} height={80} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <polygon points={`${cx - 50},${cy - 20} ${cx + 50},${cy - 20} ${cx},${cy - 80}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            {mkTxt(cx + 60, cy + 20, lab.h)}
                            {mkTxt(cx, cy + 80, lab.w)}
                            {mkTxt(cx + 30, cy - 40, lab.h_roof)}
                        </>
                    ) : (
                        <>
                            <rect x={cx - 50} y={cy - 50} width={100} height={100} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <path d={`M ${cx - 50} ${cy - 50} A 50 50 0 0 1 ${cx + 50} ${cy - 50}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            {mkTxt(cx, cy + 70, lab.w)}
                            {mkTxt(cx + 60, cy, lab.h, "start")}
                        </>
                    )}
                </g>
            );
        }
    }

    return null;
};

// FILE END: src\components\visuals\GeometryShapes.jsx

// =======================================================
// FILE START: src\components\visuals\GraphCanvas.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

export const GraphCanvas = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const range = data.range || 10;
        ctx.clearRect(0, 0, width, height);
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const toX = (val) => (val + range) * (width / (range * 2));
        const toY = (val) => height - (val + range) * (height / (range * 2));
        
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        for (let i = -range; i <= range; i += data.gridStep || 1) {
            ctx.beginPath(); ctx.moveTo(toX(i), 0); ctx.lineTo(toX(i), height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, toY(i)); ctx.lineTo(width, toY(i)); ctx.stroke();
        }
        ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(width, toY(0)); ctx.stroke();
        ctx.fillStyle = '#6b7280';
        const step = data.labelStep || 2;
        for (let i = -range; i <= range; i += step) {
            if (i === 0) continue;
            const xPos = toX(i); const yOrigin = toY(0);
            ctx.beginPath(); ctx.moveTo(xPos, yOrigin - 3); ctx.lineTo(xPos, yOrigin + 3); ctx.stroke();
            ctx.fillText(i.toString(), xPos, yOrigin + 12);
            const yPos = toY(i); const xOrigin = toX(0);
            ctx.beginPath(); ctx.moveTo(xOrigin - 3, yPos); ctx.lineTo(xOrigin + 3, yPos); ctx.stroke();
            ctx.fillText(i.toString(), xOrigin - 12, yPos);
        }
        data.lines.forEach(line => {
            ctx.strokeStyle = line.color || '#dc2626'; ctx.lineWidth = 3;
            ctx.beginPath();
            const x1 = -range; const y1 = line.slope * x1 + line.intercept;
            const x2 = range; const y2 = line.slope * x2 + line.intercept;
            ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke();
        });
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};

// FILE END: src\components\visuals\GraphCanvas.jsx

// =======================================================
// FILE START: src\components\visuals\PatternComponents.jsx
// =======================================================

import React from 'react';

/**
 * PatternVisual hanterar rendering av algebraiska m√∂nster.
 * Den st√∂der t√§ndstickor (stick-figures), prickar och sifferf√∂ljder.
 */
const PatternVisual = ({ data }) => {
    if (!data) return null;

    const { subtype, sequence, figures = [] } = data;

    // --- Rendera en enkel sifferf√∂ljd (Niv√• 1-2) ---
    if (subtype === 'sequence') {
        return (
            <div className="flex flex-wrap justify-center gap-4 py-8">
                {sequence.map((num, i) => (
                    <div key={i} className="flex items-center">
                        <div className="w-12 h-12 flex items-center justify-center bg-white border-2 border-indigo-100 rounded-lg shadow-sm text-xl font-bold text-indigo-600 font-mono">
                            {num === '?' ? <span className="animate-pulse text-gray-400">?</span> : num}
                        </div>
                        {i < sequence.length - 1 && <span className="ml-4 text-gray-300">,</span>}
                    </div>
                ))}
            </div>
        );
    }

    // --- Rendera t√§ndsticksm√∂nster (Niv√• 3-5) ---
    if (subtype === 'matchsticks') {
        return (
            <div className="flex flex-col items-center gap-6 w-full overflow-x-auto py-4">
                <div className="flex justify-center items-end gap-12 min-w-max px-4">
                    {figures.map((fig, idx) => (
                        <div key={idx} className="flex flex-col items-center gap-4">
                            <svg 
                                width={fig.width || 100} 
                                height={fig.height || 100} 
                                viewBox={`0 0 ${fig.width || 100} ${fig.height || 100}`}
                            >
                                {fig.sticks.map((s, i) => (
                                    <line 
                                        key={i}
                                        x1={s.x1} y1={s.y1} x2={s.x2} y2={s.y2}
                                        stroke="#f59e0b"
                                        strokeWidth="4"
                                        strokeLinecap="round"
                                        className="drop-shadow-sm"
                                    />
                                ))}
                                {fig.sticks.map((s, i) => (
                                    <circle key={`head-${i}`} cx={s.x1} cy={s.y1} r="3" fill="#ef4444" />
                                ))}
                            </svg>
                            <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">
                                Figur {idx + 1}
                            </span>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    return null;
};

export default PatternVisual;

// FILE END: src\components\visuals\PatternComponents.jsx

// =======================================================
// FILE START: src\components\visuals\ProbabilityTree.jsx
// =======================================================

import React from 'react';

/**
 * ProbabilityTree handles the rendering of:
 * 1. Standard Probability Trees (Top-down)
 * 2. Combinatorial Pathways (A to B)
 * 3. Constrained Pathways (A to B with obstacles)
 */
const ProbabilityTree = ({ data }) => {
    if (!data) return null;

    const { subtype, layers, groups, initialCounts, targetBranch, obstacles = [] } = data;

    // --- MODE: PATHWAYS (Combinatorics A -> B) ---
    if (subtype === 'pathway') {
        const width = 400;
        const height = 220;
        const padding = 50;
        
        // Define layers for the network
        const layerCounts = layers || [1, 2, 3, 1];
        const stepX = (width - padding * 2) / (layerCounts.length - 1);

        const getPos = (lIdx, nIdx, count) => {
            const x = padding + lIdx * stepX;
            const layerHeight = 140;
            const startY = (height - layerHeight) / 2;
            const spacing = layerHeight / (count > 1 ? count - 1 : 1);
            const y = count === 1 ? height / 2 : startY + nIdx * spacing;
            return { x, y };
        };

        return (
            <div className="flex justify-center w-full py-6 bg-slate-50 rounded-xl border border-slate-200 shadow-inner overflow-x-auto">
                <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                    <defs>
                        <filter id="nodeShadow">
                            <feDropShadow dx="0" dy="1" stdDeviation="1" floodOpacity="0.1"/>
                        </filter>
                    </defs>

                    {/* 1. Draw Paths (Lines) */}
                    {layerCounts.map((count, lIdx) => {
                        if (lIdx === layerCounts.length - 1) return null;
                        const nextCount = layerCounts[lIdx + 1];
                        
                        return Array.from({ length: count }).map((_, nIdx) => {
                            const start = getPos(lIdx, nIdx, count);
                            return Array.from({ length: nextCount }).map((__, nextNIdx) => {
                                const end = getPos(lIdx + 1, nextNIdx, nextCount);
                                
                                // Obstacle Logic: Only check if obstacles exist in data
                                const isBlocked = obstacles.some(o => 
                                    o.layer === lIdx && o.from === nIdx && o.to === nextNIdx
                                );

                                return (
                                    <g key={`path-${lIdx}-${nIdx}-${nextNIdx}`}>
                                        <line 
                                            x1={start.x} y1={start.y} x2={end.x} y2={end.y}
                                            stroke={isBlocked ? "#fee2e2" : "#cbd5e1"} 
                                            strokeWidth={isBlocked ? "1.5" : "2.5"}
                                            strokeDasharray={isBlocked ? "4 2" : "0"}
                                            strokeLinecap="round"
                                        />
                                        {/* Visual Block Marker */}
                                        {isBlocked && (
                                            <g transform={`translate(${(start.x + end.x)/2}, ${(start.y + end.y)/2})`}>
                                                <circle r="9" fill="white" stroke="#ef4444" strokeWidth="1" />
                                                <circle r="7" fill="#ef4444" />
                                                <line x1="-3.5" y1="0" x2="3.5" y2="0" stroke="white" strokeWidth="2.5" strokeLinecap="round" />
                                            </g>
                                        )}
                                    </g>
                                );
                            });
                        });
                    })}

                    {/* 2. Draw Nodes */}
                    {layerCounts.map((count, lIdx) => (
                        Array.from({ length: count }).map((_, nIdx) => {
                            const { x, y } = getPos(lIdx, nIdx, count);
                            const isStart = lIdx === 0;
                            const isEnd = lIdx === layerCounts.length - 1;
                            
                            return (
                                <g key={`n-${lIdx}-${nIdx}`}>
                                    <circle 
                                        cx={x} cy={y} r={isStart || isEnd ? 9 : 5} 
                                        fill={isStart || isEnd ? "#6366f1" : "white"} 
                                        stroke={isStart || isEnd ? "none" : "#94a3b8"}
                                        strokeWidth="2"
                                        filter="url(#nodeShadow)"
                                    />
                                    {(isStart || isEnd) && (
                                        <text x={x} y={y - 18} textAnchor="middle" className="text-sm font-black fill-indigo-600 tracking-tighter">
                                            {isStart ? 'A' : 'B'}
                                        </text>
                                    )}
                                </g>
                            );
                        })
                    ))}
                </svg>
            </div>
        );
    }

    // --- MODE: STANDARD TREE (Probability L5) ---
    const width = 400;
    const height = 320;
    const nodeRadius = 6;
    const total = initialCounts[0] + initialCounts[1];
    const centerX = width / 2;

    const root = { x: centerX, y: 40 };
    const s1 = [
        { x: centerX - 100, y: 140, label: groups[0], count: initialCounts[0], total: total },
        { x: centerX + 100, y: 140, label: groups[1], count: initialCounts[1], total: total }
    ];
    const s2 = [
        { x: centerX - 145, y: 270, parent: 0, label: groups[0], c: initialCounts[0] - 1, t: total - 1 },
        { x: centerX - 55, y: 270, parent: 0, label: groups[1], c: initialCounts[1], t: total - 1 },
        { x: centerX + 55, y: 270, parent: 1, label: groups[0], c: initialCounts[0], t: total - 1 },
        { x: centerX + 145, y: 270, parent: 1, label: groups[1], c: initialCounts[1] - 1, t: total - 1 }
    ];

    const renderProbLabel = (x1, y1, x2, y2, num, den, bId) => {
        const mx = (x1 + x2) / 2;
        const my = (y1 + y2) / 2;
        const isT = targetBranch === bId;
        return (
            <g>
                <rect x={mx - 22} y={my - 16} width="44" height="32" fill="white" stroke={isT ? "#6366f1" : "#e2e8f0"} strokeWidth={isT ? "2" : "1"} rx="6" />
                <text x={mx} y={my + 5} textAnchor="middle" className={`text-sm font-bold ${isT ? 'fill-indigo-600 animate-pulse' : 'fill-slate-600'}`}>
                    {isT ? 'x' : `${num}/${den}`}
                </text>
            </g>
        );
    };

    return (
        <div className="flex justify-center w-full py-4 bg-white rounded-2xl border border-slate-200 shadow-sm overflow-x-auto">
            <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                {s1.map((n, i) => (
                    <g key={`l1-${i}`}>
                        <line x1={root.x} y1={root.y} x2={n.x} y2={n.y} stroke="#e2e8f0" strokeWidth="2.5" />
                        <text x={n.x} y={n.y - 18} textAnchor="middle" className="text-[10px] font-black fill-slate-400 uppercase tracking-widest">{n.label}</text>
                        {renderProbLabel(root.x, root.y, n.x, n.y, n.count, n.total, `s1_${i}`)}
                    </g>
                ))}
                {s2.map((n, i) => {
                    const p = s1[n.parent];
                    return (
                        <g key={`l2-${i}`}>
                            <line x1={p.x} y1={p.y} x2={n.x} y2={n.y} stroke="#e2e8f0" strokeWidth="2" />
                            <text x={n.x} y={n.y + 22} textAnchor="middle" className="text-[10px] font-bold fill-slate-400 uppercase tracking-wide">{n.label}</text>
                            {renderProbLabel(p.x, p.y, n.x, n.y, n.c, n.t, `s2_${i}`)}
                        </g>
                    );
                })}
                <circle cx={root.x} cy={root.y} r={nodeRadius} fill="#cbd5e1" />
                {s1.map((n, i) => <circle key={`cn1-${i}`} cx={n.x} cy={n.y} r={nodeRadius} fill="#94a3b8" />)}
                {s2.map((n, i) => <circle key={`cn2-${i}`} cx={n.x} cy={n.y} r={nodeRadius} fill="#94a3b8" />)}
            </svg>
        </div>
    );
};

export default ProbabilityTree;

// FILE END: src\components\visuals\ProbabilityTree.jsx

// =======================================================
// FILE START: src\components\visuals\ProbabilityVisuals.jsx
// =======================================================

import React from 'react';

export const ProbabilityMarbles = ({ data }) => {
    const { red, blue, green } = data.items;
    const colors = [];
    for(let i=0; i<red; i++) colors.push('#ef4444');
    for(let i=0; i<blue; i++) colors.push('#3b82f6');
    for(let i=0; i<green; i++) colors.push('#22c55e');
    
    const mixed = [];
    while(colors.length) {
        if (colors.length % 3 === 0) mixed.push(colors.pop()); 
        else mixed.unshift(colors.pop());
    }

    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200" className="bg-slate-100 rounded-full border-4 border-slate-300 shadow-inner">
                {mixed.map((c, i) => {
                    const angle = i * 2.4; 
                    const dist = 15 + i * 4; 
                    const x = 100 + dist * Math.cos(angle);
                    const y = 100 + dist * Math.sin(angle);
                    return <circle key={i} cx={x} cy={y} r={12} fill={c} stroke="rgba(0,0,0,0.2)" strokeWidth="1" />;
                })}
            </svg>
        </div>
    );
};

export const ProbabilitySpinner = ({ data }) => {
    const { sections } = data; 
    const radius = 80; const cx = 100; const cy = 100;
    const step = (2 * Math.PI) / sections;
    const colors = ['#3b82f6', '#ef4444', '#22c55e', '#eab308', '#a855f7', '#ec4899']; 
    const slices = [];
    for (let i = 0; i < sections; i++) {
        const startAngle = i * step - Math.PI/2; 
        const endAngle = (i + 1) * step - Math.PI/2;
        const x1 = cx + radius * Math.cos(startAngle); const y1 = cy + radius * Math.sin(startAngle);
        const x2 = cx + radius * Math.cos(endAngle); const y2 = cy + radius * Math.sin(endAngle);
        const largeArc = step > Math.PI ? 1 : 0;
        const pathData = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
        slices.push(<path key={i} d={pathData} fill={colors[i % colors.length]} stroke="white" strokeWidth="2" />);
    }
    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200">
                {slices}
                <polygon points="100,20 90,40 110,40" fill="#1e293b" />
                <circle cx="100" cy="100" r="5" fill="#1e293b" />
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\ProbabilityVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\ScaleVisuals.jsx
// =======================================================

import React from 'react';
import { RenderShape } from './GeometryShapes';

export const ScaleVisual = ({ data }) => {
    const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ', arrow: '‚û°', star: '‚≠ê', lightning: '‚ö°', key: 'üîë', heart: '‚ù§Ô∏è', cloud: '‚òÅÔ∏è', moon: 'üåô', sun: '‚òÄÔ∏è', magnifying_glass: 'üîç', map: 'üó∫Ô∏è', car: 'üöó', ladybug: 'üêû', house: 'üè†' }; 
    const emoji = shapeEmojis[data.shape] || 'üì¶'; 
    const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl select-none" style={{ fontSize: size }}>{emoji}</div>; 
    
    if (data.type === 'scale_single') {
        return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="80px" /><span className="bg-white px-4 py-2 rounded shadow text-3xl font-bold font-mono border border-gray-200">{data.label}</span></div>; 
    }
    return (
        <div className="flex items-center justify-center gap-4 sm:gap-8 my-6">
            <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="60px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.leftValue}</span></div>
            <div className="text-gray-300 text-3xl">‚Üí</div>
            <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="100px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.rightValue}</span></div>
        </div>
    ); 
};

export const SimilarityCompare = ({ data }) => {
    const shapeType = data.shapeType || 'triangle';
    const leftDims = { ...data.left, width: 40, height: 40, radius: 20, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
    const rightDims = { ...data.right, width: 60, height: 60, radius: 30, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
    return (
        <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
            <RenderShape type={shapeType} dims={leftDims} labels={data.left.labels} offsetX={-25} scale={0.8} />
            <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
            <RenderShape type={shapeType} dims={rightDims} labels={data.right.labels} offsetX={225} scale={1.2} />
        </svg>
    );
};

export const CompareShapesArea = ({ data }) => {
    return (
            <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
            <RenderShape type={data.shapeType} dims={data.left} areaText={data.left.area} offsetX={-25} scale={0.8} />
            <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
            <RenderShape type={data.shapeType} dims={data.right} areaText={data.right.area} offsetX={225} scale={1.2} />
        </svg>
    );
};

// FILE END: src\components\visuals\ScaleVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\SimpleTextLevel.jsx
// =======================================================

import React from 'react';

const SimpleTextLevel = ({ data }) => {
  return (
    <div className="text-content">
      <p>{data.question}</p>
    </div>
  );
};

// We simply don't add the property, or explicitly set it to false
// SimpleTextLevel.requiresCanvas = false; 

export default SimpleTextLevel;

// FILE END: src\components\visuals\SimpleTextLevel.jsx

// =======================================================
// FILE START: src\components\visuals\StatisticsVisuals.jsx
// =======================================================

import React from 'react';

export const FrequencyTable = ({ data }) => {
    const { headers, rows } = data;
    return (
        <div className="flex justify-center my-4 w-full">
            <div className="border border-slate-300 rounded-lg overflow-hidden shadow-sm bg-white min-w-[200px]">
                <table className="w-full text-sm text-left">
                    <thead className="bg-slate-100 text-slate-700 font-bold uppercase text-xs">
                        <tr>{headers.map((h, i) => <th key={i} className="px-4 py-2 border-b text-center">{h}</th>)}</tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                        {rows.map((row, rI) => (
                            <tr key={rI} className="hover:bg-slate-50">
                                {row.map((cell, cI) => <td key={cI} className="px-4 py-2 text-center font-mono text-slate-600">{cell}</td>)}
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export const PercentGrid = ({ data }) => {
    const { total = 100, colored = 0 } = data;
    const size = 300;
    const cellSize = size / 10;
    const cells = [];
    for (let i = 0; i < 100; i++) {
        const x = (i % 10) * cellSize;
        const y = Math.floor(i / 10) * cellSize;
        const isColored = i < colored;
        cells.push(<rect key={i} x={x} y={y} width={cellSize - 2} height={cellSize - 2} fill={isColored ? "#3b82f6" : "#f1f5f9"} stroke={isColored ? "#2563eb" : "#e2e8f0"} rx="4" />);
    }
    return <div className="flex justify-center my-4"><svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>{cells}</svg></div>;
};

// FILE END: src\components\visuals\StatisticsVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\VolumeVisualization.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

export const VolumeVisualization = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = '#374151'; 
        ctx.fillStyle = '#f3f4f6';
        ctx.lineWidth = 2; 
        ctx.lineJoin = 'round'; 
        ctx.font = "bold 14px Inter, sans-serif"; 
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";
        const drawLabel = (text, x, y, color='#dc2626') => { 
            if (!text) return;
            ctx.save(); 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
            const m = ctx.measureText(text);
            ctx.fillRect(x - m.width/2 - 2, y - 10, m.width + 4, 20);
            ctx.fillStyle = color; 
            ctx.fillText(text, x, y); 
            ctx.restore(); 
        };
        const drawDashed = (x1, y1, x2, y2) => { 
            ctx.save(); 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath(); 
            ctx.moveTo(x1, y1); 
            ctx.lineTo(x2, y2); 
            ctx.stroke(); 
            ctx.restore(); 
        };
        const TARGET_SIZE = 140; 
        let dims = [];
        if (data.labels) {
            dims = Object.values(data.labels).map(v => parseInt(String(v))).filter(v => !isNaN(v));
        }
        const maxVal = Math.max(...dims, 10);
        const scale = TARGET_SIZE / maxVal;
        if (data.type === 'cuboid') {
            const dw = (parseInt(data.labels.w) || 10) * scale;
            const dh = (parseInt(data.labels.h) || 10) * scale;
            const dd = (parseInt(data.labels.d) || 10) * scale * 0.5;
            const x0 = cx - dw/2 - dd/2;
            const y0 = cy + dh/2 + dd/2;
            ctx.strokeRect(x0, y0 - dh, dw, dh);
            ctx.beginPath(); ctx.moveTo(x0, y0 - dh); ctx.lineTo(x0 + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw, y0 - dh); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dd); ctx.lineTo(x0 + dw, y0); ctx.stroke();
            drawLabel(data.labels.w, x0 + dw/2, y0 + 15);
            drawLabel(data.labels.h, x0 - 20, y0 - dh/2);
            drawLabel(data.labels.d, x0 + dw + dd/2 + 5, y0 - dd/2);
        } 
        else if (data.type === 'triangular_prism') {
            const b = (parseInt(data.labels.b) || 10) * scale;
            const hTri = (parseInt(data.labels.h) || 10) * scale;
            const len = (parseInt(data.labels.l) || 20) * scale * 0.7;
            const startX = cx - b/2 - len/2;
            const startY = cy + hTri/2;
            ctx.beginPath();
            ctx.moveTo(startX, startY); ctx.lineTo(startX + b, startY); ctx.lineTo(startX + b/2, startY - hTri); ctx.closePath(); ctx.stroke();
            const offX = len; const offY = -len * 0.3;
            ctx.beginPath(); ctx.moveTo(startX + b/2, startY - hTri); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX + b, startY); ctx.lineTo(startX + b + offX, startY + offY); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            drawDashed(startX + b/2, startY, startX + b/2, startY - hTri);
            drawLabel(data.labels.h, startX + b/2 + 10, startY - hTri/2);
            drawLabel(data.labels.b, startX + b/2, startY + 15);
            drawLabel(data.labels.l, startX + b + offX/2 + 10, startY + offY/2);
        }
        else if (data.type === 'pyramid') {
            const w = (parseInt(data.labels.w || data.labels.s || 10) * scale);
            const d = (parseInt(data.labels.d || data.labels.s || 10) * scale * 0.6); 
            const hPyr = (parseInt(data.labels.h) || 10) * scale;
            const x0 = cx - w/2 - d/2;
            const y0 = cy + hPyr/3; 
            const FL = {x: x0, y: y0}; const FR = {x: x0+w, y: y0};
            const BR = {x: x0+w+d, y: y0-d}; const BL = {x: x0+d, y: y0-d};
            const Apex = {x: x0 + w/2 + d/2, y: y0 - d/2 - hPyr};
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(FR.x, FR.y); ctx.lineTo(BR.x, BR.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(BL.x, BL.y); ctx.lineTo(FL.x, FL.y); ctx.stroke(); ctx.restore();
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(FR.x, FR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BL.x, BL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke(); ctx.restore();
            const centerBase = {x: x0 + w/2 + d/2, y: y0 - d/2};
            drawDashed(centerBase.x, centerBase.y, Apex.x, Apex.y);
            drawLabel("h=" + data.labels.h, Apex.x + 20, centerBase.y - hPyr/2);
            drawLabel(data.labels.w || data.labels.s, x0 + w/2, y0 + 15);
        }
        else {
            let r = 50; 
            if(data.labels.r) r = parseInt(data.labels.r) * scale;
            if(data.labels.d) r = (parseInt(data.labels.d)/2) * scale;
            r = Math.max(30, Math.min(r, 70));
            const drawCircleData = (centerY, showLabel=true) => {
                 const val = data.labels.val || (data.labels.r ? `r=${data.labels.r}` : `d=${data.labels.d}`);
                 if (data.show === 'diameter') {
                     drawDashed(cx - r, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx, centerY - 10);
                 } else {
                     ctx.beginPath(); ctx.arc(cx, centerY, 2, 0, 2*Math.PI); ctx.fill();
                     drawDashed(cx, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx + r/2, centerY - 10);
                 }
            };
            if (data.type === 'sphere') {
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, cy, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(cy);
            }
            else if (data.type === 'hemisphere') {
                const yBase = cy + 10;
                ctx.beginPath(); ctx.arc(cx, yBase, r, Math.PI, 0); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, yBase, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(yBase);
            }
            else if (data.type === 'cylinder' || data.type === 'silo') {
                const hCyl = (parseInt(data.labels.h) || 10) * scale;
                const topY = cy - hCyl/2;
                const botY = cy + hCyl/2;
                if (data.type === 'cylinder' || data.type === 'silo') {
                     ctx.beginPath(); ctx.ellipse(cx, topY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, topY); ctx.lineTo(cx-r, botY); ctx.stroke();
                     ctx.beginPath(); ctx.moveTo(cx+r, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 15, cy);
                }
                if (data.type === 'silo') { ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); }
                drawCircleData(topY, true);
            }
            else if (data.type === 'cone' || data.type === 'ice_cream') {
                 const hCone = (parseInt(data.labels.h) || 10) * scale;
                 if (data.type === 'cone') {
                     const topY = cy - hCone/2; const botY = cy + hCone/2;
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, botY); ctx.lineTo(cx, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawDashed(cx, botY, cx, topY);
                     drawLabel("h=" + data.labels.h, cx + 5, cy);
                     drawCircleData(botY, true);
                     
                     // ADDED: Logic for Slant Height (s)
                     if (data.labels.s) {
                         // Draw label along the side
                         // Approx mid point of side
                         const sX = (cx + r + cx) / 2 + 15;
                         const sY = (botY + topY) / 2;
                         drawLabel("s=" + data.labels.s, sX, sY);
                     }
                 } else {
                     const seamY = cy - 20; const tipY = seamY + hCone;
                     ctx.beginPath(); ctx.moveTo(cx-r, seamY); ctx.lineTo(cx, tipY); ctx.lineTo(cx+r, seamY); ctx.stroke();
                     ctx.beginPath(); ctx.arc(cx, seamY, r, Math.PI, 0); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, seamY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 10, seamY + hCone/2);
                     drawCircleData(seamY, true);
                 }
            }
        }
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={320} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};

// FILE END: src\components\visuals\VolumeVisualization.jsx

// =======================================================
// FILE START: src\constants\content_map.js
// =======================================================

export const CONTENT_MAP = {
    arithmetic: {
        title: "Taluppfattning",
        topics: [
            {
                id: "arithmetic",
                title: "De Fyra R√§knes√§tten",
                levels: [
                    { lvl: 1, desc: "Addition (Uppst√§llning)", ex: "345 + 129" },
                    { lvl: 2, desc: "Subtraktion (Uppst√§llning)", ex: "502 - 148" },
                    { lvl: 3, desc: "Decimaltal (+/-)", ex: "4.5 + 2.15" },
                    { lvl: 4, desc: "Multiplikation (Enkel)", ex: "6 ¬∑ 12" },
                    { lvl: 5, desc: "Multiplikation (Medel)", ex: "23 ¬∑ 4" },
                    { lvl: 6, desc: "Multiplikation (Sv√•r)", ex: "45 ¬∑ 12" },
                    { lvl: 7, desc: "Kort Division", ex: "84 / 4" },
                    { lvl: 8, desc: "Blandade Heltal", ex: "Mix av alla r√§knes√§tt" },
                    { lvl: 9, desc: "Blandade Decimaltal", ex: "Mix med decimaler" }
                ]
            },
            {
                id: "fraction_basics",
                title: "Br√•k: Grunder",
                levels: [
                    { lvl: 1, desc: "Visuella Br√•k", ex: "Del av helhet" },
                    { lvl: 2, desc: "Ber√§kna delen", ex: "1/4 av 20" },
                    { lvl: 3, desc: "Blandad & Br√•kform", ex: "1 1/2 <-> 3/2" },
                    { lvl: 4, desc: "F√∂rl√§nga & F√∂rkorta", ex: "2/4 -> 1/2" },
                    { lvl: 5, desc: "Br√•k & Decimaltal", ex: "1/5 = 0.2" }
                ]
            },
            {
                id: "fraction_arith",
                title: "Br√•k: R√§kna",
                levels: [
                    { lvl: 1, desc: "Addition & Subtraktion (Lika)", ex: "1/5 + 2/5" },
                    { lvl: 2, desc: "Addition & Subtraktion (Olika)", ex: "1/2 + 1/4" },
                    { lvl: 3, desc: "Blandad form (+)", ex: "1 1/2 + 3/4" },
                    { lvl: 4, desc: "Multiplikation", ex: "2/3 ¬∑ 4/5" },
                    { lvl: 5, desc: "Division", ex: "1/2 / 1/4" }
                ]
            },
            {
                id: "negative",
                title: "Negativa Tal",
                levels: [
                    { lvl: 1, desc: "Enkel Addition/Subtraktion", ex: "5 - 8" },
                    { lvl: 2, desc: "Sv√•rare Addition/Subtraktion", ex: "-5 - (-8)" },
                    { lvl: 3, desc: "Multiplikation", ex: "-3 ¬∑ 4" },
                    { lvl: 4, desc: "Division", ex: "-12 / -3" },
                    { lvl: 5, desc: "Blandade Uppgifter", ex: "Mix av r√§knes√§tt" }
                ]
            },
            {
                id: "ten_powers",
                title: "10, 100, 1000",
                levels: [
                    { lvl: 1, desc: "Mult/Div med 10, 100, 1000", ex: "3.5 ¬∑ 100" },
                    { lvl: 2, desc: "Begreppsf√∂rst√•else", ex: "Vilket √§r st√∂rst?" },
                    { lvl: 3, desc: "Blandade Faktorer", ex: "0.1, 0.01, 1000" }
                ]
            },
            {
                id: "exponents",
                title: "Potenser & R√∂tter",
                levels: [
                    { lvl: 1, desc: "Grunder & x^0", ex: "3^2, 5^0" },
                    { lvl: 2, desc: "Tiopotenser", ex: "10^3, 10^-2" },
                    { lvl: 3, desc: "Grundpotensform", ex: "4.5 ¬∑ 10^3" },
                    { lvl: 4, desc: "Kvadratr√∂tter", ex: "sqrt(25)" },
                    { lvl: 5, desc: "Potenslagar (Enkel)", ex: "x^2 ¬∑ x^3" },
                    { lvl: 6, desc: "Potenslagar (Avancerad)", ex: "(x^2)^3" }
                ]
            },
            {
                id: "percent",
                title: "Procent",
                levels: [
                    { lvl: 1, desc: "Grundl√§ggande (Rutn√§t)", ex: "Bildst√∂d" },
                    { lvl: 2, desc: "Huvudr√§kning (10%, 50%)", ex: "10% av 500" },
                    { lvl: 3, desc: "Multiplar av 10%", ex: "30% av 200" },
                    { lvl: 4, desc: "Ber√§kna andelen (Decimal)", ex: "0.15 ¬∑ 400" },
                    { lvl: 5, desc: "Hitta helheten (100%)", ex: "Delen √§r 20, andel 50%" },
                    { lvl: 6, desc: "Verklig F√∂r√§ndring", ex: "Pris√∂kning" }
                ]
            }
        ]
    },
    algebra: {
        title: "Algebra",
        topics: [
            {
                id: "simplify",
                title: "Uttryck",
                levels: [
                    { lvl: 1, desc: "F√∂renkla Uttryck", ex: "2x + 3x" },
                    { lvl: 2, desc: "Parenteser (Addition)", ex: "2 + (x - 3)" },
                    { lvl: 3, desc: "Parenteser (Multiplikation)", ex: "3(x + 2)" },
                    { lvl: 4, desc: "Parenteser (Subtraktion)", ex: "5 - (x - 2)" },
                    { lvl: 5, desc: "Probleml√∂sning", ex: "Skriv uttryck f√∂r omkrets" },
                    { lvl: 6, desc: "Blandade Niv√•er", ex: "Mix av algebra" }
                ]
            },
            {
                id: "equation",
                title: "Ekvationer",
                levels: [
                    { lvl: 1, desc: "Enstegsekvationer", ex: "x + 5 = 12" },
                    { lvl: 2, desc: "Tv√•stegsekvationer", ex: "2x + 3 = 11" },
                    { lvl: 3, desc: "Med Parenteser", ex: "2(x + 1) = 10" },
                    { lvl: 4, desc: "Variabel p√• b√•da sidor", ex: "3x + 2 = x + 8" },
                    { lvl: 5, desc: "Skriv Ekvation", ex: "Fr√•n text till ekvation" },
                    { lvl: 6, desc: "L√∂s Problem", ex: "Textuppgifter" },
                    { lvl: 7, desc: "Blandade Ekvationer", ex: "Mix av problem" }
                ]
            },
            {
                id: "linear_graph",
                title: "R√§ta Linjen",
                levels: [
                    { lvl: 1, desc: "Hitta m-v√§rdet", ex: "Sk√§rning y-axel" },
                    { lvl: 2, desc: "Hitta k-v√§rdet (Pos)", ex: "Lutning upp√•t" },
                    { lvl: 3, desc: "Hitta k-v√§rdet (Neg)", ex: "Lutning ned√•t" },
                    { lvl: 4, desc: "Best√§m funktionen", ex: "y = kx + m" },
                    { lvl: 5, desc: "Blandat", ex: "Mix av grafer" }
                ]
            }
        ]
    },
    statistics: {
        title: "Sannolikhet & Statistik",
        topics: [
            {
                id: "probability",
                title: "Sannolikhet",
                levels: [
                    { lvl: 1, desc: "Visuell Sannolikhet", ex: "Kulor i p√•se, Snurrhjul" },
                    { lvl: 2, desc: "T√§rning & Slump", ex: "T√§rning, Kortlek" },
                    { lvl: 3, desc: "Sannolikhet som Procent", ex: "Andel i %" },
                    { lvl: 4, desc: "Komplementh√§ndelse", ex: "Sannolikhet f√∂r 'Inte'" },
                    { lvl: 5, desc: "Oberoende H√§ndelser", ex: "Tv√• mynt, T√§rning + Mynt" },
                    { lvl: 6, desc: "Kombinatorik", ex: "Antal kombinationer (Tr√§d)" }
                ]
            },
            {
                id: "statistics",
                title: "Statistik",
                levels: [
                    { lvl: 1, desc: "Typv√§rde & Variationsbredd", ex: "Mode, Range" },
                    { lvl: 2, desc: "Medelv√§rde", ex: "Summa / Antal" },
                    { lvl: 3, desc: "Median", ex: "Mittenv√§rdet (sorterat)" },
                    { lvl: 4, desc: "Bakl√§nges medelv√§rde", ex: "Hitta saknat tal" },
                    { lvl: 5, desc: "Frekvenstabell", ex: "Medel/Median ur tabell" },
                    { lvl: 6, desc: "Blandade begrepp", ex: "J√§mf√∂r m√•tt" }
                ]
            },
            {
                id: "change_factor",
                title: "F√∂r√§ndringsfaktor",
                levels: [
                    { lvl: 1, desc: "Begrepp & Definition", ex: "√ñkning 20% -> 1.20" },
                    { lvl: 2, desc: "Ber√§kna nya v√§rdet", ex: "500 * 1.20" },
                    { lvl: 3, desc: "Ber√§kna gamla v√§rdet", ex: "Nytt / Faktor" },
                    { lvl: 4, desc: "Total f√∂r√§ndring", ex: "1.10 * 0.90" },
                    { lvl: 5, desc: "Textuppgifter", ex: "Befolkning, R√§nta" }
                ]
            }
        ]
    },
    geometry: {
        title: "Geometri",
        topics: [
            {
                id: "geometry",
                title: "Area & Omkrets",
                levels: [
                    { lvl: 1, desc: "Omkrets (Rektangel)", ex: "2(b+h)" },
                    { lvl: 2, desc: "Area (Rektangel)", ex: "b*h" },
                    { lvl: 3, desc: "Area (Triangel)", ex: "b*h/2" },
                    { lvl: 4, desc: "Sammansatta (Rekt+Tri)", ex: "Rectanglar och trianglar" },
                    { lvl: 5, desc: "Cirklar", ex: "pi*r^2" },
                    { lvl: 6, desc: "Sammansatta (Alla)", ex: "Hus, Portal" }
                ]
            },
            {
                id: "scale",
                title: "Skala",
                levels: [
                    { lvl: 1, desc: "Begreppsf√∂rst√•else", ex: "1:100 vs 100:1" },
                    { lvl: 2, desc: "Ber√§kna l√§ngd (Enkel)", ex: "Bild -> Verklighet" },
                    { lvl: 3, desc: "Blandade Scenarier", ex: "Karta, Ritning" },
                    { lvl: 4, desc: "Best√§m Skalan", ex: "Bild / Verklighet" },
                    { lvl: 5, desc: "Probleml√∂sning", ex: "Textuppgifter" },
                    { lvl: 6, desc: "Areaskala", ex: "L√§ngdskala^2" },
                    { lvl: 7, desc: "Blandat", ex: "Mix av uppgifter" }
                ]
            },
            {
                id: "volume",
                title: "Volym",
                levels: [
                    { lvl: 1, desc: "R√§tblock & Kub", ex: "b*d*h" },
                    { lvl: 2, desc: "Prisma", ex: "B*h" },
                    { lvl: 3, desc: "Cylinder", ex: "pi*r^2*h" },
                    { lvl: 4, desc: "Pyramid & Kon", ex: "B*h/3" },
                    { lvl: 5, desc: "Klot", ex: "4*pi*r^3/3" },
                    { lvl: 6, desc: "Blandade Volymer", ex: "Mix av kroppar" },
                    { lvl: 7, desc: "Enhetsomvandling", ex: "dm3 <-> liter" },
                    { lvl: 8, desc: "Begr√§nsningsyta", ex: "Area till 3D former" }
                ]
            },
            {
                id: "similarity",
                title: "Likformighet",
                levels: [
                    { lvl: 1, desc: "Likformig eller inte?", ex: "J√§mf√∂r former" },
                    { lvl: 2, desc: "Ber√§kna sida", ex: "Skala * sida" },
                    { lvl: 3, desc: "Topptriangelsatsen", ex: "Liten/Stor triangel" },
                    { lvl: 4, desc: "Pythagoras", ex: "R√§tvinklig triangel" }
                ]
            },
            {
                id: "pythagoras",
                title: "Pythagoras Sats",
                levels: [
                    { lvl: 1, desc: "Kvadrater & R√∂tter", ex: "3^2, sqrt(9)" },
                    { lvl: 2, desc: "Hitta Hypotenusan", ex: "a^2 + b^2 = c^2" },
                    { lvl: 3, desc: "Hitta Kateten", ex: "c^2 - b^2 = a^2" },
                    { lvl: 4, desc: "Probleml√∂sning", ex: "Stege mot v√§gg" },
                    { lvl: 5, desc: "Avst√•nd", ex: "Koordinatsystem" },
                    { lvl: 6, desc: "R√§tvinklig?", ex: "Omv√§nd sats" }
                ]
            },
            {
                id: "angles",
                title: "Vinklar", // NEW
                levels: [
                    { lvl: 1, desc: "Vinkeltyper", ex: "Spetsig, R√§t, Trubbig" },
                    { lvl: 2, desc: "Komplement & Supplement", ex: "Summa 90/180" },
                    { lvl: 3, desc: "Vertikal- & Sidovinklar", ex: "Korsande linjer" },
                    { lvl: 4, desc: "Vinkelsumma (Triangel)", ex: "x + y + z = 180" },
                    { lvl: 5, desc: "Likbel√§gna & Alternatvinklar", ex: "Parallella linjer" },
                    { lvl: 6, desc: "Vinkelsumma (Polygoner)", ex: "(n-2)*180" }
                ]
            }
        ]
    }
};

// FILE END: src\constants\content_map.js

// =======================================================
// FILE START: src\constants\curriculum.js
// =======================================================

export const CATEGORIES = {
    ARITHMETIC: {
        id: 'ARITHMETIC',
        label: { en: 'Number Theory', sv: 'Taluppfattning' },
        color: 'pink',
        generators: [
            { id: 'BasicArithmeticGen', api: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'FractionBasicsGen', api: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, // Added
            { id: 'FractionArithGen', api: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, // Added
            { id: 'NegativeNumbersGen', api: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'TenPowersGen', api: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'PercentGen', api: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    ALGEBRA: {
        id: 'ALGEBRA',
        label: { en: 'Algebra', sv: 'Algebra' },
        color: 'indigo',
        generators: [
            { id: 'ExpressionSimplificationGen', api: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'PatternsGen', api: 'patterns', label: { sv: "Algebraiska m√∂nster", en: "Algebraic Patterns" } },
            { id: 'EquationGenerator', api: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'LinearGraphGenerator', api: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    },
    GEOMETRY: {
        id: 'GEOMETRY',
        label: { en: 'Geometry', sv: 'Geometri' },
        color: 'emerald',
        generators: [
            { id: 'GeometryGenerator', api: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'ScaleGenerator', api: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'VolumeGenerator', api: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'SimilarityGenerator', api: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'PythagorasGen', api: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } },
            { id: 'AnglesGen', api: 'angles', label: { sv: "Vinklar", en: "Angles" } }
        ]
    },
    STATISTICS: {
        id: 'STATISTICS',
        label: { en: 'Statistics', sv: 'Sannolikhet & Statistik' },
        color: 'yellow',
        generators: [
            { id: 'ProbabilityGen', api: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
            { id: 'StatisticsGen', api: 'statistics', label: { sv: "Statistik", en: "Statistics" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    BasicArithmeticGen: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    FractionBasicsGen: { // New
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Del av antal", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    FractionArithGen: { // New
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+ och -)", en: "Mixed Numbers (+ and -)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    NegativeNumbersGen: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    TenPowersGen: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    PatternsGen: { 
        1: { sv: "Hitta n√§sta tal & Skillnad", en: "Next Number & Difference" },
        2: { sv: "Ber√§kna h√∂ga figurer", en: "Calculate High Terms" },
        3: { sv: "Fr√•n bild till uttryck", en: "From Visual to Expression" },
        4: { sv: "Fr√•n tabell till formel", en: "Table to Formula" },
        5: { sv: "L√∂s ut n (bakl√§nges)", en: "Solve for n" }
    },
    PercentGen: {
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Ber√§kna det hela", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    EquationGenerator: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    ExpressionSimplificationGen: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    GeometryGenerator: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Sammansatta (Rekt+Tri)", en: "Combined (Rect+Tri)" },
        5: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        6: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    ScaleGenerator: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    VolumeGenerator: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" },
        7: { sv: "Begr√§nsningsyta", en: "Surface Area" } 
    },
    SimilarityGenerator: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    PythagorasGen: { 
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    },
    LinearGraphGenerator: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    },
    ProbabilityGen: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse", en: "Complementary Events" },
        5: { sv: "Tr√§ddiagram", en: "Probability tree" },
        6: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        7: { sv: "Kombinatorik", en: "Combinatorics" },
        8: { sv: "Kombinatorik (Sv√•r)", en: "Combinatorics (Hard)" }
    },
    StatisticsGen: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    AnglesGen: { 
        1: { sv: "Begrepp", en: "Concepts" },
        2: { sv: "Komplement/Supplementvinklar ", en: "Complementary/Supplementary angles" },
        3: { sv: "Vertikala vinklar", en: "Vertical Angles" },
        4: { sv: "Vinkelsumma (triangel)", en: "Angle sums (Triangle)" },
        5: { sv: "Vinkelsumma (m√•ngh√∂rning)", en: "Angle sums (Polygons)" },
        6: { sv: "Parallella linjer", en: "Parallel lines" }
    }
    
};

export const getColorClasses = (color, type) => {
    const c = color || 'emerald';
    switch (type) {
        case 'bg-light': return `bg-${c}-50`;
        case 'bg-dark': return `bg-${c}-500`;
        case 'border': return `border-${c}-100`;
        case 'text': return `text-${c}-700`;
        case 'ring': return `ring-${c}-500`;
        case 'border-solid': return `border-${c}-500`;
        default: return '';
    }
};

// FILE END: src\constants\curriculum.js

// =======================================================
// FILE START: src\constants\localization.js
// =======================================================

export const CATEGORIES = {
    arithmetic: {
        id: 'arithmetic', 
        label: { sv: "Taluppfattning", en: "Number Theory" },
        color: "pink",
        levels: 9,
        topics: [
            { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, 
            { id: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, 
            { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'exponents', label: { sv: "Potenser & R√∂tter", en: "Exponents & Roots" } },
            { id: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    
    algebra: {
        id: 'algebra',
        label: { sv: "Algebra", en: "Algebra" },
        color: "indigo",
        levels: 6,
        topics: [
            { id: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'patterns', label: { sv: "Algebraiska m√∂ster", en: "Algebraic patterns" } }
        ]
    },
    geometry: {
        id: 'geometry',
        label: { sv: "Geometri", en: "Geometry" },
        color: "emerald",
        levels: 7,
        topics: [
            { id: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } },
            { id: 'angles', label: { sv: "Vinklar", en: "Angles" } } // NEW
        ]
    },

    statistics: { 
        id: 'statistics',
        label: { sv: "Sannolikhet & Statistik", en: "Prob & Stats" },
        color: "yellow", 
        levels: 6,
        topics: [
             { id: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
             { id: 'statistics', label: { sv: "Statistik", en: "Statistics" } },
             { id: 'linear_graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } },
             { id: 'change_factor', label: { sv: "F√∂r√§ndringsfaktor", en: "Change Factor" } } // NEW
        ]
    }
};

export const CATEGORIES_ARRAY = Object.values(CATEGORIES);

export const UI_TEXT = {
    sv: {
        hero_title: "Mattest√∂d",
        hero_subtitle: "Anpassade uppgifter f√∂r h√∂gstadiet.",
        tagline: "R√§tt st√∂d. Direkt.",
        startBtn: "Starta √ñvning",
        aboutBtn: "Om Skaparen",
        contactTitle: "Kontakta mig",
        aboutTitle: "Om Skaparen",
        aboutText: "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att hitta nya s√§tt att undervisa i klassrummet.",
        contactLink: "F√∂lj mig p√• LinkedIn",
        tagCorrect: "R√§tt", tagWrong: "Fel", tagSkipped: "Hoppade √∂ver",
        streak_modal_title: "Grymt jobbat! üî•", streak_modal_msg: "Du har en streak p√• {streak}!",
        total_modal_title: "Bra jobbat! ‚úÖ", total_modal_msg: "Du har klarat {total} uppgifter! Forts√§tt s√•!",
        btn_close_streak: "K√∂r vidare!", btn_close_total: "Forts√§tt",
        timer_title: "Timer", timer_off: "Av", timer_min: "min", timer_reset: "Nollst√§ll", timer_paused: "Pausad",
        stats_title: "Statistik", stats_times_up: "Tiden √§r ute!", stats_longest_streak: "L√§ngsta streak", stats_attempted: "F√∂rs√∂k", stats_correct_no_help: "R√§tt (utan hj√§lp)", stats_correct_help: "R√§tt (med hj√§lp)", stats_incorrect: "Fel", stats_skipped: "Hoppade √∂ver", stats_close: "St√§ng",
        menu_btn: "Meny", level_breakdown: "Niv√•detaljer",
        stat_skip: "Hopp", stat_wrong: "Fel", stat_help: "Hj√§lp", stat_correct: "R√§tt", stat_total: "Totalt",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Aktivitet", donow_desc: "V√§lj upp till 3 niv√•er f√∂r att generera ett startkort.",
        donow_generate: "Generera", backBtn: "Tillbaka",
        donow_show_all: "Visa Alla Svar", donow_hide_all: "D√∂lj Alla Svar",
        donow_regenerate: "Nytt Set", 
        levels: "Niv√•er",
        clickToSelect: "Klicka f√∂r att v√§lja niv√•",
        selectLevel: "V√§lj Niv√•",
        btnCheck: "Svara", btnHint: "Ledtr√•d", btnSolution: "L√∂sning", btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        error: "N√•got gick fel. F√∂rs√∂k igen.",
        levelUpTitle: "Niv√• upp?", levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", levelUpYes: "Ja, k√∂r!", levelUpNo: "Nej, stanna h√§r"
    },
    en: {
        hero_title: "Math Support",
        hero_subtitle: "Adaptive exercises for middle school.",
        tagline: "Right support. Instantly.",
        startBtn: "Start Practice",
        aboutBtn: "About Creator",
        contactTitle: "Contact Me",
        aboutTitle: "About the Creator",
        aboutText: "Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
        contactLink: "Follow me on LinkedIn",
        tagCorrect: "Correct", tagWrong: "Wrong", tagSkipped: "Skipped",
        streak_modal_title: "Awesome! üî•", streak_modal_msg: "You hit a streak of {streak}!",
        total_modal_title: "Great work! ‚úÖ", total_modal_msg: "You answered {total} questions correctly! Great job!",
        btn_close_streak: "Great job!", btn_close_total: "Continue",
        timer_title: "Practice Timer", timer_off: "Off", timer_min: "min", timer_reset: "Reset", timer_paused: "Paused",
        stats_title: "Statistics", stats_times_up: "Time's up!", stats_longest_streak: "Longest streak", stats_attempted: "Problems attempted", stats_correct_no_help: "Correct (no help)", stats_correct_help: "Correct (with help)", stats_incorrect: "Incorrect", stats_skipped: "Skipped", stats_close: "Close",
        menu_btn: "Menu", level_breakdown: "Level Breakdown",
        stat_skip: "Skip", stat_wrong: "Wrong", stat_help: "Help", stat_correct: "Correct", stat_total: "Total",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Activity", donow_desc: "Select up to 3 levels to generate a startup card.",
        donow_generate: "Generate", backBtn: "Back",
        donow_show_all: "Show All Answers", donow_hide_all: "Hide All Answers",
        donow_regenerate: "New Set", 
        levels: "Levels",
        clickToSelect: "Click to select level",
        selectLevel: "Select Level",
        btnCheck: "Submit", btnHint: "Hint", btnSolution: "Solution", btnSkip: "Skip",
        btnNext: "Next ‚û°",
        error: "Something went wrong. Please retry.",
        levelUpTitle: "Level Up?", levelUpDesc: "You seem to know this! Do you want to skip to the next level?", levelUpYes: "Yes, let's go!", levelUpNo: "No, stay here"
    }
};

export const LEVEL_DESCRIPTIONS = {
    
    angles: {
        1: { sv: "Vinkeltyper", en: "Types of Angles" },
        2: { sv: "Komplement & Supplement", en: "Complementary & Supplementary" },
        3: { sv: "Vertikal- & Sidovinklar", en: "Vertical & Adjacent Angles" },
        4: { sv: "Vinkelsumma (Triangel)", en: "Triangle Angle Sum" },
        5: { sv: "Likbel√§gna & Alternatvinklar", en: "Parallel Lines" },
        6: { sv: "Vinkelsumma (Polygoner)", en: "Polygon Angle Sum" }
    },
    change_factor: {
        1: { sv: "Begrepp & Definition", en: "Concepts & Definitions" },
        2: { sv: "Ber√§kna nya v√§rdet", en: "Calculate New Value" },
        3: { sv: "Ber√§kna gamla v√§rdet", en: "Find Original Value" },
        4: { sv: "Total f√∂r√§ndring", en: "Total Change" },
        5: { sv: "Textuppgifter", en: "Word Problems" }
    },
    fraction_basics: {
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Ber√§kna delen", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    fraction_arith: {
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+ och -)", en: "Mixed Numbers (+ and -)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    exponents: { 
        1: { sv: "Grunder & x^0", en: "Foundations & x^0" },
        2: { sv: "Tiopotenser", en: "Powers of 10" },
        3: { sv: "Grundpotensform", en: "Scientific Notation" },
        4: { sv: "Kvadratr√∂tter", en: "Square Roots" },
        5: { sv: "Potenslagar (Enkel)", en: "Exponent Laws (Basic)" },
        6: { sv: "Potenslagar (Avancerad)", en: "Exponent Laws (Adv)" }
    },
    arithmetic: {
        1: { sv: "Addition (Uppst√§llning)", en: "Addition (Vertical)" },
        2: { sv: "Subtraktion (Uppst√§llning)", en: "Subtraction (Vertical)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (Enkel)", en: "Multiplication (Simple)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Kort Division", en: "Short Division" },
        8: { sv: "Blandade Heltal", en: "Mixed Integers" },
        9: { sv: "Blandade Decimaltal", en: "Mixed Decimals" }
    },
    negative: {
        1: { sv: "Enkel Addition/Subtraktion", en: "Simple Add/Sub" },
        2: { sv: "Sv√•rare Addition/Subtraktion", en: "Harder Add/Sub" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandade Uppgifter", en: "Mixed Problems" }
    },
    ten_powers: {
        1: { sv: "Mult/Div med 10, 100, 1000", en: "Mult/Div by 10, 100, 1000" },
        2: { sv: "Begreppsf√∂rst√•else", en: "Conceptual Understanding" },
        3: { sv: "Blandade Faktorer (0.1, 100...)", en: "Mixed Factors" }
    },
    percent: { 
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Hitta helheten (100%)", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    probability: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse (Inte)", en: "Complementary Events" },
        5: { sv: "Tr√§ddiagram", en: "Probability Trees" },
        6: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        7: { sv: "Kombinatorik", en: "Combinatorics" },
        8: { sv: "Kombinatorik (Sv√•r)", en: "Combinatorics (Hard)" }
    },
    statistics: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    simplify: {
        1: { sv: "F√∂renkla Uttryck (Enkel)", en: "Simplify Expressions (Easy)" },
        2: { sv: "Parenteser (Addition)", en: "Parentheses (Addition)" },
        3: { sv: "Parenteser (Multiplikation)", en: "Parentheses (Multiplication)" },
        4: { sv: "Parenteser (Subtraktion)", en: "Parentheses (Subtraction)" },
        5: { sv: "Probleml√∂sning", en: "Problem Solving" },
        6: { sv: "Blandade Niv√•er", en: "Mixed Levels" }
    },
    equation: {
        1: { sv: "Enkels steg (x+a=b)", en: "One Step" },
        2: { sv: "Tv√• steg (ax+b=c)", en: "Two Steps" },
        3: { sv: "Med Parenteser", en: "With Parentheses" },
        4: { sv: "Variabel p√• b√•da sidor", en: "Variables on both sides" },
        5: { sv: "Skriv Ekvation (Problem)", en: "Write Equation (Word Problems)" },
        6: { sv: "L√∂s Problem (Ekvation)", en: "Solve Word Problems" },
        7: { sv: "Blandade Ekvationer", en: "Mixed Equations" }
    },
    linear_graph: {
        1: { sv: "Hitta m-v√§rdet", en: "Find m-value" },
        2: { sv: "Hitta k-v√§rdet (Positiv)", en: "Find k-value (Positive)" },
        3: { sv: "Hitta k-v√§rdet (Negativ)", en: "Find k-value (Negative)" },
        4: { sv: "Best√§m funktionen (y=kx+m)", en: "Determine Function" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    geometry: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Sammansatta (Rekt+Tri)", en: "Composite Shapes (Rect+Tri)" },
        5: { sv: "Cirkelns Area & Omkrets", en: "Circle Area & Perimeter" },
        6: { sv: "Sammansatta (Alla)", en: "Composite Shapes (All)" }
    },
    scale: {
        1: { sv: "F√∂rst√• Skala", en: "Understand Scale" },
        2: { sv: "Ber√§kna L√§ngd (Enkel)", en: "Calculate Length (Simple)" },
        3: { sv: "Blandade Scenarier", en: "Mixed Scenarios" }, 
        4: { sv: "Best√§m Skalan", en: "Determine Scale" },
        5: { sv: "Probleml√∂sning", en: "Word Problems" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    volume: {
        1: { sv: "R√§tblock & Kub", en: "Cuboid & Cube" },
        2: { sv: "Prisma", en: "Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot & Sammansatta", en: "Sphere & Composite" },
        6: { sv: "Blandade Volymer", en: "Mixed Volumes" },
        7: { sv: "Enhetsomvandling", en: "Unit Conversion" },
        8: { sv: "Begr√§ngsningsyta", en: "Surface Area" } 
    },
    similarity: {
        1: { sv: "√Ñr de likformiga?", en: "Are they similar?" },
        2: { sv: "Ber√§kna sida (Enkel)", en: "Calc Side (Simple)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras & Likformighet", en: "Pythagoras & Similarity" }
    },
    pythagoras: {
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    },
    patterns: { 
        1: { sv: "Hitta n√§sta tal & Skillnad", en: "Next Number & Difference" },
        2: { sv: "Ber√§kna h√∂ga figurer", en: "Calculate High Terms" },
        3: { sv: "Fr√•n bild till uttryck", en: "From Visual to Expression" },
        4: { sv: "Fr√•n tabell till formel", en: "Table to Formula" },
        5: { sv: "L√∂s ut n (bakl√§nges)", en: "Solve for n" }
    }
};

// FILE END: src\constants\localization.js

// =======================================================
// FILE START: src\core\generators\AnglesGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class AnglesGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Terminology(lang);
            case 2: return this.level2_CompSupp(lang);
            case 3: return this.level3_Vertical(lang);
            case 4: return this.level4_TriangleSum(lang);
            case 5: return this.level5_Polygons(lang);
            case 6: return this.level6_Parallel(lang);
            default: return this.level1_Terminology(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific variation key.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'classification_visual': return this.level1_Terminology(lang, key);
            case 'classification_inverse_numeric': return this.level1_Terminology(lang, key);
            case 'classification_lie': return this.level1_Terminology(lang, key);
            case 'comp_supp_visual': return this.level2_CompSupp(lang, key);
            case 'comp_supp_inverse': return this.level2_CompSupp(lang, key);
            case 'vertical_side_visual': return this.level3_Vertical(lang, key);
            case 'vertical_side_lie': return this.level3_Vertical(lang, key);
            case 'triangle_sum_visual': return this.level4_TriangleSum(lang, key);
            case 'triangle_isosceles': return this.level4_TriangleSum(lang, key);
            case 'polygon_sum': return this.level5_Polygons(lang, key);
            case 'polygon_inverse': return this.level5_Polygons(lang, key);
            case 'quad_missing': return this.level5_Polygons(lang, key);
            case 'parallel_visual': return this.level6_Parallel(lang, key);
            case 'parallel_lie': return this.level6_Parallel(lang, key);
            default: return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: TERMINOLOGY & CLASSIFICATION ---
    private level1_Terminology(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['classification_visual', 'classification_inverse_numeric', 'classification_lie']);

        // Variation A: Standard Visual Identification
        if (v === 'classification_visual') {
            const type = MathUtils.randomChoice(['acute', 'right', 'obtuse', 'straight']);
            let angle = 0;
            let labelSv = "";
            let labelEn = "";

            if (type === 'acute') { angle = MathUtils.randomInt(20, 80); labelSv = "Spetsig"; labelEn = "Acute"; }
            else if (type === 'right') { angle = 90; labelSv = "R√§t"; labelEn = "Right"; }
            else if (type === 'obtuse') { angle = MathUtils.randomInt(100, 170); labelSv = "Trubbig"; labelEn = "Obtuse"; }
            else { angle = 180; labelSv = "Rak"; labelEn = "Straight"; }

            const cx = 150, cy = 200;
            const len = 100;
            const x2 = cx + len * Math.cos(-angle * Math.PI / 180);
            const y2 = cy + len * Math.sin(-angle * Math.PI / 180);

            return {
                renderData: {
                    description: lang === 'sv' ? "Vad kallas denna typ av vinkel?" : "What is this type of angle called?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(lang === 'sv' ? ["Spetsig", "R√§t", "Trubbig", "Rak"] : ["Acute", "Right", "Obtuse", "Straight"]),
                    geometry: {
                        type: 'angle',
                        lines: [{x1: cx, y1: cy, x2: cx + len, y2: cy}, {x1: cx, y1: cy, x2: x2, y2: y2}],
                        arcs: [{ center: {x: cx, y: cy}, startAngle: 0, endAngle: angle, radius: 40, label: `${angle}¬∞` }]
                    }
                },
                token: this.toBase64(lang === 'sv' ? labelSv : labelEn),
                clues: [{ text: lang === 'sv' ? "En r√§t vinkel √§r exakt $90^\\circ$. Vinklar mindre √§n det √§r spetsiga, och vinklar st√∂rre √§r trubbiga." : "A right angle is exactly $90^\\circ$. Smaller angles are acute, and larger angles are obtuse." }],
                metadata: { variation_key: "classification_visual", difficulty: 1 }
            };
        }

        // Variation B: Numeric Categorization (Inverse)
        if (v === 'classification_inverse_numeric') {
            const angle = MathUtils.randomChoice([45, 90, 135, 180]);
            let correct = "";
            if (angle < 90) correct = lang === 'sv' ? "Spetsig" : "Acute";
            else if (angle === 90) correct = lang === 'sv' ? "R√§t" : "Right";
            else if (angle < 180) correct = lang === 'sv' ? "Trubbig" : "Obtuse";
            else correct = lang === 'sv' ? "Rak" : "Straight";

            return {
                renderData: {
                    description: lang === 'sv' ? `En vinkel √§r ${angle}¬∞. Vilken kategori tillh√∂r den?` : `An angle is ${angle}¬∞. Which category does it belong to?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(lang === 'sv' ? ["Spetsig", "R√§t", "Trubbig", "Rak"] : ["Acute", "Right", "Obtuse", "Straight"])
                },
                token: this.toBase64(correct),
                clues: [{ text: lang === 'sv' ? "Titta p√• gradtalet. En spetsig vinkel √§r $< 90^\\circ$, en r√§t √§r $90^\\circ$, en trubbig √§r $> 90^\\circ$ och en rak √§r $180^\\circ$." : "Look at the degrees. Acute is $< 90^\\circ$, Right is $90^\\circ$, Obtuse is $> 90^\\circ$, and Straight is $180^\\circ$." }],
                metadata: { variation_key: "classification_inverse_numeric", difficulty: 1 }
            };
        }

        // Variation C: Spot the Lie
        const getAngleTypePair = (isCorrect: boolean) => {
            const type = MathUtils.randomChoice(['acute', 'right', 'obtuse', 'straight']);
            let angle = 0;
            if (isCorrect) {
                if (type === 'acute') angle = MathUtils.randomInt(10, 89);
                else if (type === 'right') angle = 90;
                else if (type === 'obtuse') angle = MathUtils.randomInt(91, 179);
                else angle = 180;
            } else {
                if (type === 'acute') angle = MathUtils.randomInt(91, 180);
                else if (type === 'right') angle = MathUtils.randomChoice([45, 135]);
                else if (type === 'obtuse') angle = MathUtils.randomInt(10, 89);
                else angle = 90;
            }
            const names: any = { 
                acute: { sv: "spetsig", en: "acute" }, 
                right: { sv: "r√§t", en: "right" }, 
                obtuse: { sv: "trubbig", en: "obtuse" }, 
                straight: { sv: "rak", en: "straight" } 
            };
            return lang === 'sv' 
                ? `${angle}¬∞ √§r en ${names[type].sv} vinkel` 
                : `${angle}¬∞ is an ${names[type].en} angle`;
        };

        const sTrue1 = getAngleTypePair(true);
        const sTrue2 = getAngleTypePair(true);
        const sFalse = getAngleTypePair(false);

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende √§r FALSKT?" : "Which statement is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [{ text: lang === 'sv' ? "G√• igenom varje p√•st√•ende. Kom ih√•g: Spetsig ($<90^\\circ$), R√§t ($90^\\circ$), Trubbig ($>90^\\circ$), Rak ($180^\\circ$)." : "Check each statement. Remember: Acute ($<90^\\circ$), Right ($90^\\circ$), Obtuse ($>90^\\circ$), Straight ($180^\\circ$)." }],
            metadata: { variation_key: "classification_lie", difficulty: 1 }
        };
    }

    // --- LEVEL 2: COMPLEMENTARY & SUPPLEMENTARY ---
    private level2_CompSupp(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['comp_supp_visual', 'comp_supp_inverse']);

        if (v === 'comp_supp_visual') {
            const isSupp = Math.random() > 0.5;
            const total = isSupp ? 180 : 90;
            const known = MathUtils.randomInt(20, total - 20);
            const unknown = total - known;
            const cx = 150, cy = 200, len = 120;

            const lines = isSupp ? [{x1: cx - len, y1: cy, x2: cx + len, y2: cy}] : [{x1: cx, y1: cy, x2: cx + len, y2: cy}, {x1: cx, y1: cy, x2: cx, y2: cy - len}];
            const xCut = cx + len * Math.cos(-known * Math.PI / 180);
            const yCut = cy + len * Math.sin(-known * Math.PI / 180);
            lines.push({x1: cx, y1: cy, x2: xCut, y2: yCut});

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna vinkeln x." : "Calculate angle x.",
                    answerType: 'numeric',
                    geometry: {
                        type: 'angle', lines,
                        arcs: [
                            { center: {x: cx, y: cy}, startAngle: 0, endAngle: known, radius: 40, label: `${known}¬∞` },
                            { center: {x: cx, y: cy}, startAngle: known, endAngle: total, radius: 50, label: 'x' }
                        ]
                    }
                },
                token: this.toBase64(unknown.toString()),
                clues: [
                    { text: lang === 'sv' ? (isSupp ? "Vinklarna delar en rak linje ($180^\\circ$)." : "Vinklarna bildar en r√§t vinkel ($90^\\circ$).") : (isSupp ? "The angles share a straight line ($180^\\circ$)." : "The angles form a right angle ($90^\\circ$).") },
                    { text: lang === 'sv' ? `Eftersom de bildar ${total}^\\circ$ kan vi r√§kna ut x genom: ${total} - ${known}.` : `Since they form ${total}^\\circ$, we can find x by: ${total} - ${known}.` }
                ],
                metadata: { variation_key: "comp_supp_visual", difficulty: 2 }
            };
        }

        // Variation B: Terminology Inverse
        const isSupp = Math.random() > 0.5;
        const known = MathUtils.randomInt(10, isSupp ? 170 : 80);
        const ans = isSupp ? 180 - known : 90 - known;
        const termSv = isSupp ? "supplementvinkel" : "komplementvinkel";
        const termEn = isSupp ? "supplementary angle" : "complementary angle";

        return {
            renderData: {
                description: lang === 'sv' ? `En vinkel √§r ${known}¬∞. Vad √§r dess ${termSv}?` : `An angle is ${known}¬∞. What is its ${termEn}?`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [{ text: lang === 'sv' ? (isSupp ? "Supplementvinklar bildar tillsammans en rak linje ($180^\\circ$)." : "Komplementvinklar bildar tillsammans en r√§t vinkel ($90^\\circ$).") : (isSupp ? "Supplementary angles sum to $180^\\circ$." : "Complementary angles sum to $90^\\circ$.") }],
            metadata: { variation_key: "comp_supp_inverse", difficulty: 2 }
        };
    }

    // --- LEVEL 3: VERTICAL & SIDE ---
    private level3_Vertical(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vertical_side_visual', 'vertical_side_lie']);
        const angle = MathUtils.randomInt(40, 140);

        if (v === 'vertical_side_visual') {
            const isVertical = Math.random() > 0.5;
            const target = isVertical ? angle : 180 - angle;
            const cx = 150, cy = 125, len = 100, rot = 15;

            const lines = [
                {x1: cx - len * Math.cos(rot * Math.PI / 180), y1: cy + len * Math.sin(rot * Math.PI / 180), x2: cx + len * Math.cos(rot * Math.PI / 180), y2: cy - len * Math.sin(rot * Math.PI / 180)},
                {x1: cx - len * Math.cos((rot + angle) * Math.PI / 180), y1: cy + len * Math.sin((rot + angle) * Math.PI / 180), x2: cx + len * Math.cos((rot + angle) * Math.PI / 180), y2: cy - len * Math.sin((rot + angle) * Math.PI / 180)}
            ];

            const arcs = [{ center: {x: cx, y: cy}, startAngle: rot, endAngle: rot + angle, radius: 40, label: `${angle}¬∞` }];
            if (isVertical) arcs.push({ center: {x: cx, y: cy}, startAngle: rot + 180, endAngle: rot + angle + 180, radius: 40, label: 'x' });
            else arcs.push({ center: {x: cx, y: cy}, startAngle: rot + angle, endAngle: rot + 180, radius: 35, label: 'x' });

            return {
                renderData: {
                    description: lang === 'sv' ? "Best√§m vinkeln x." : "Determine angle x.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', lines, arcs }
                },
                token: this.toBase64(target.toString()),
                clues: [{ text: isVertical ? (lang === 'sv' ? "Vertikalvinklar sitter mitt emot varandra vid ett linjekryss och √§r alltid lika stora." : "Vertical angles are opposite each other in a line crossing and are always equal.") : (lang === 'sv' ? "Sidovinklar ligger l√§ngs en rak linje, vilket betyder att x + k√§nd vinkel = $180^\\circ$." : "Side angles lie along a straight line, which means x + known angle = $180^\\circ$.") }],
                metadata: { variation_key: "vertical_side_visual", difficulty: 3 }
            };
        }

        const a = MathUtils.randomInt(40, 140);
        const b = 180 - a;
        const sTrue1 = lang === 'sv' ? `Vertikalvinkeln till ${a}¬∞ √§r ${a}¬∞` : `The vertical angle to ${a}¬∞ is ${a}¬∞`;
        const sTrue2 = lang === 'sv' ? `Sidovinkeln till ${a}¬∞ √§r ${b}¬∞` : `The side angle to ${a}¬∞ is ${b}¬∞`;
        const sFalse = lang === 'sv' ? `Sidovinklar till ${a}¬∞ blir totalt 90¬∞` : `Side angles to ${a}¬∞ sum to 90¬∞`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende √§r FALSKT?" : "Which statement is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [{ text: lang === 'sv' ? "Sidovinklar bildar en rak linje, vilket betyder att de tillsammans √§r $180^\\circ$. Komplementvinklar √§r de som blir $90^\\circ$." : "Side angles form a straight line, which means they sum to $180^\\circ$. Complementary angles are those that sum to $90^\\circ$." }],
            metadata: { variation_key: "vertical_side_lie", difficulty: 2 }
        };
    }

    // --- LEVEL 4: TRIANGLE SUM ---
    private level4_TriangleSum(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['triangle_sum_visual', 'triangle_isosceles']);

        if (v === 'triangle_sum_visual') {
            const a = MathUtils.randomInt(30, 80);
            const b = MathUtils.randomInt(30, 80);
            const ans = 180 - a - b;

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna x i triangeln." : "Calculate x in the triangle.",
                    answerType: 'numeric',
                    geometry: {
                        type: 'angle',
                        polygons: [{ points: "50,220 250,220 150,50" }],
                        labels: [{x: 65, y: 210, text: `${a}¬∞`}, {x: 235, y: 210, text: `${b}¬∞`}, {x: 150, y: 85, text: 'x'}]
                    }
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? "Vinkelsumman i en triangel √§r alltid $180^\\circ$. R√§kna ut $180 - vinkel_1 - vinkel_2$." : "The sum of angles in a triangle is always $180^\\circ$. Calculate $180 - angle_1 - angle_2$." }],
                metadata: { variation_key: "triangle_sum_visual", difficulty: 3 }
            };
        }

        const vertex = MathUtils.randomInt(30, 100);
        const base = (180 - vertex) / 2;
        const findVertex = Math.random() > 0.5;

        return {
            renderData: {
                description: lang === 'sv' ? "Triangeln √§r likbent. Ber√§kna x." : "The triangle is isosceles. Calculate x.",
                answerType: 'numeric',
                geometry: {
                    type: 'angle',
                    polygons: [{ points: "50,200 250,200 150,50" }],
                    labels: findVertex ? 
                        [{x: 100, y: 190, text: `${base}¬∞`}, {x: 200, y: 190, text: `${base}¬∞`}, {x: 150, y: 80, text: 'x'}] :
                        [{x: 100, y: 190, text: 'x'}, {x: 200, y: 190, text: `${base}¬∞`}, {x: 150, y: 80, text: `${vertex}¬∞`}]
                }
            },
            token: this.toBase64(findVertex ? vertex.toString() : base.toString()),
            clues: [{ text: lang === 'sv' ? "I en likbent triangel √§r de tv√• basvinklarna lika stora. Vinkelsumman √§r fortfarande $180^\\circ$." : "In an isosceles triangle, the two base angles are equal. The sum is still $180^\\circ$." }],
            metadata: { variation_key: "triangle_isosceles", difficulty: 4 }
        };
    }

    // --- LEVEL 5: POLYGONS ---
    private level5_Polygons(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['polygon_sum', 'polygon_inverse', 'quad_missing']);

        if (v === 'polygon_sum') {
            const n = MathUtils.randomChoice([4, 5, 6]);
            const sum = (n - 2) * 180;
            const names = { 4: {sv:"fyrh√∂rning", en:"quadrilateral"}, 5: {sv:"femh√∂rning", en:"pentagon"}, 6: {sv:"sexh√∂rning", en:"hexagon"} };

            return {
                renderData: {
                    description: lang === 'sv' ? `Vad √§r vinkelsumman i en ${names[n as 4|5|6].sv}?` : `What is the sum of angles in a ${names[n as 4|5|6].en}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(sum.toString()),
                clues: [{ text: lang === 'sv' ? "Anv√§nd formeln $(n - 2) \\cdot 180^\\circ$, d√§r n √§r antalet h√∂rn eller sidor." : "Use the formula $(n - 2) \\cdot 180^\\circ$, where n is the number of corners or sides." }],
                metadata: { variation_key: "polygon_sum", difficulty: 4 }
            };
        }

        if (v === 'polygon_inverse') {
            const n = MathUtils.randomChoice([3, 4, 5, 8]);
            const sum = (n - 2) * 180;
            return {
                renderData: {
                    description: lang === 'sv' ? `En polygon har en vinkelsumma p√• ${sum}¬∞. Hur m√•nga sidor har den?` : `A polygon has an angle sum of ${sum}¬∞. How many sides does it have?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(n.toString()),
                clues: [{ text: lang === 'sv' ? "Bakl√§nges r√§knat: $(\\text{summa} / 180) + 2$." : "Calculated backwards: $(\\text{sum} / 180) + 2$." }],
                metadata: { variation_key: "polygon_inverse", difficulty: 4 }
            };
        }

        const a = MathUtils.randomInt(70, 110);
        const b = MathUtils.randomInt(70, 110);
        const c = MathUtils.randomInt(70, 110);
        const ans = 360 - a - b - c;
        return {
            renderData: {
                description: lang === 'sv' ? "Best√§m vinkeln x i fyrh√∂rningen." : "Determine angle x in the quadrilateral.",
                answerType: 'numeric',
                geometry: { 
                    type: 'angle', 
                    polygons: [{ points: "50,50 250,50 230,200 70,200" }], 
                    labels: [{x: 70, y: 70, text: `${a}¬∞`}, {x: 230, y: 70, text: `${b}¬∞`}, {x: 210, y: 185, text: `${c}¬∞`}, {x: 90, y: 185, text: 'x'}] 
                }
            },
            token: this.toBase64(ans.toString()),
            clues: [{ text: lang === 'sv' ? "Vinkelsumman i en fyrh√∂rning (4 h√∂rn) √§r alltid $360^\\circ$." : "The sum of angles in a quadrilateral (4 corners) is always $360^\\circ$." }],
            metadata: { variation_key: "quad_missing", difficulty: 4 }
        };
    }

    // --- LEVEL 6: PARALLEL LINES ---
    private level6_Parallel(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['parallel_visual', 'parallel_lie']);
        const angle = MathUtils.randomInt(50, 130);

        if (v === 'parallel_visual') {
            const type = MathUtils.randomChoice(['corr', 'alt_int', 'alt_ext', 'interior']);
            let target = (type === 'interior') ? 180 - angle : angle;
            const cy = 125;

            const lines = [
                {x1: 30, y1: cy - 50, x2: 270, y2: cy - 50}, 
                {x1: 30, y1: cy + 50, x2: 270, y2: cy + 50}, 
                {x1: 100, y1: 50, x2: 200, y2: 200}
            ];

            const labels = [];
            if (type === 'alt_int') { labels.push({ x: 145, y: 90, text: `${angle}¬∞` }, { x: 155, y: 160, text: 'x' }); }
            else if (type === 'interior') { labels.push({ x: 145, y: 90, text: `${angle}¬∞` }, { x: 195, y: 160, text: 'x' }); }
            else if (type === 'alt_ext') { labels.push({ x: 90, y: 60, text: `${angle}¬∞` }, { x: 230, y: 190, text: 'x' }); }
            else { labels.push({ x: 145, y: 60, text: `${angle}¬∞` }, { x: 215, y: 160, text: 'x' }); }

            return {
                renderData: {
                    description: lang === 'sv' ? "Linjerna √§r parallella. Best√§m x." : "The lines are parallel. Determine x.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', lines, labels }
                },
                token: this.toBase64(target.toString()),
                clues: [{ text: lang === 'sv' ? "N√§r linjer √§r parallella bildas parvis lika vinklar. Z-vinklar (alternat) och F-vinklar (likbel√§gna) √§r lika stora. U-vinklar √§r supplement√§ra ($180^\\circ$)." : "Parallel lines create pairs of equal angles. Z-shapes (alternate) and F-shapes (corresponding) are equal. U-shapes sum to $180^\\circ$." }],
                metadata: { variation_key: "parallel_visual", difficulty: 5 }
            };
        }

        const a = MathUtils.randomInt(50, 130);
        const sTrue1 = lang === 'sv' ? `Alternatvinklar √§r lika stora (${a}¬∞ = ${a}¬∞)` : `Alternate angles are equal (${a}¬∞ = ${a}¬∞)`;
        const sTrue2 = lang === 'sv' ? `Likbel√§gna vinklar √§r lika stora (${a}¬∞ = ${a}¬∞)` : `Corresponding angles are equal (${a}¬∞ = ${a}¬∞)`;
        const sFalse = lang === 'sv' ? `Likbel√§gna vinklar blir totalt 180¬∞ (${a}¬∞ + ${a}¬∞ = 180¬∞)` : `Corresponding angles sum to 180¬∞ (${a}¬∞ + ${a}¬∞ = 180¬∞)`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende om parallella linjer √§r FALSKT?" : "Which statement about parallel lines is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [{ text: lang === 'sv' ? "Likbel√§gna vinklar (F-form) och Alternatvinklar (Z-form) √§r alltid lika stora. Bara vinklar p√• samma sida (U-form) blir supplement√§ra ($180^\\circ$)." : "Corresponding (F-shape) and Alternate (Z-shape) angles are always equal. Only angles on the same side (U-shape) sum to $180^\\circ$." }],
            metadata: { variation_key: "parallel_lie", difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\AnglesGen.ts

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class BasicArithmeticGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSimple(lang);
            case 2: return this.level2_SubSimple(lang);
            case 3: return this.level3_Decimals(lang);
            case 4: return this.level4_MultEasy(lang);
            case 5: return this.level5_MultMedium(lang);
            case 6: return this.level6_MultHard(lang);
            case 7: return this.level7_DivEasy(lang);
            case 8: return this.level8_MixedIntegers(lang);
            case 9: return this.level9_MixedDecimals(lang);
            default: return this.level1_AddSimple(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'add_std_vertical':
            case 'add_std_horizontal':
            case 'add_missing_variable':
            case 'add_spot_the_lie':
                return this.level1_AddSimple(lang, key);
            
            case 'sub_std_vertical':
            case 'sub_std_horizontal':
            case 'sub_missing_variable':
                return this.level2_SubSimple(lang, key);
            
            case 'dec_add_vertical':
            case 'dec_sub_vertical':
                return this.level3_Decimals(lang, key);
            
            case 'mult_table_std':
            case 'mult_commutative':
                return this.level4_MultEasy(lang, key);
            
            case 'mult_2x1_vertical':
            case 'mult_distributive':
                return this.level5_MultMedium(lang, key);
            
            case 'mult_decimal_std':
            case 'mult_decimal_placement':
                return this.level6_MultHard(lang, key);
            
            case 'div_basic_std':
            case 'div_inverse_logic':
                return this.level7_DivEasy(lang, key);
            
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private makeVertical(top: number | string, bottom: number | string, op: string): string {
        return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
    }

    // --- LEVEL 1: ADDITION ---
    private level1_AddSimple(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['add_std_vertical', 'add_std_horizontal', 'add_missing_variable', 'add_spot_the_lie']);

        if (v === 'add_std_vertical' || v === 'add_std_horizontal') {
            const a = MathUtils.randomInt(10, 999);
            const b = MathUtils.randomInt(10, 999);
            const isVertical = v === 'add_std_vertical';
            const res = this.createProblem(a, b, '+', lang, isVertical);
            res.metadata = { variation_key: v, difficulty: 1 };
            return res;
        }

        if (v === 'add_missing_variable') {
            const a = MathUtils.randomInt(5, 100);
            const x = MathUtils.randomInt(5, 100);
            const c = a + x;
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket tal saknas f√∂r att summan ska st√§mma?" : "What number is missing to make the sum correct?",
                    latex: `${a} + ? = ${c}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(x.toString()),
                clues: [
                    { text: lang === 'sv' ? "T√§nk p√• addition som en balansv√•g. F√∂r att hitta den saknade delen tar vi hela summan minus den k√§nda delen." : "Think of addition as a balance scale. To find the missing part, take the whole sum minus the known part.", latex: `${c} - ${a} = x` }
                ],
                metadata: { variation_key: 'add_missing_variable', difficulty: 2 }
            };
        }

        const generateEquation = (isCorrect: boolean) => {
            const n1 = MathUtils.randomInt(10, 50);
            const n2 = MathUtils.randomInt(10, 50);
            const result = isCorrect ? (n1 + n2) : (n1 + n2 + MathUtils.randomChoice([-2, -1, 1, 2]));
            return `${n1} + ${n2} = ${result}`;
        };

        const sTrue1 = generateEquation(true);
        const sTrue2 = generateEquation(true);
        const sFalse = generateEquation(false);

        return {
            renderData: {
                description: lang === 'sv' ? "Vilken av f√∂ljande utr√§kningar √§r FELAKTIG?" : "Which of the following calculations is INCORRECT?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [{ text: lang === 'sv' ? "Kontrollera entalen f√∂rst, sedan tiotalen. En av dessa summor st√§mmer inte." : "Check the ones first, then the tens. One of these sums is incorrect." }],
            metadata: { variation_key: 'add_spot_the_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 2: SUBTRACTION ---
    private level2_SubSimple(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sub_std_vertical', 'sub_std_horizontal', 'sub_missing_variable']);

        if (v === 'sub_std_vertical' || v === 'sub_std_horizontal') {
            const a = MathUtils.randomInt(50, 999);
            const b = MathUtils.randomInt(10, a - 1);
            const isVertical = v === 'sub_std_vertical';
            const res = this.createProblem(a, b, '-', lang, isVertical);
            res.metadata = { variation_key: v, difficulty: 2 };
            return res;
        }

        const a = MathUtils.randomInt(100, 250);
        const x = MathUtils.randomInt(20, 80);
        const c = a - x;
        return {
            renderData: {
                description: lang === 'sv' ? "Hitta det saknade talet i subtraktionen." : "Find the missing number in the subtraction.",
                latex: `${a} - ? = ${c}`,
                answerType: 'numeric'
            },
            token: this.toBase64(x.toString()),
            clues: [{ text: lang === 'sv' ? `Vi b√∂rjar med ${a} och tar bort n√•got (x) f√∂r att f√• ${c}. Skillnaden mellan dem √§r x.` : `We start with ${a} and remove something (x) to get ${c}. The difference between them is x.`, latex: `${a} - ${c} = x` }],
            metadata: { variation_key: 'sub_missing_variable', difficulty: 2 }
        };
    }

    // --- LEVEL 3: DECIMALS ---
    private level3_Decimals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['dec_add_vertical', 'dec_sub_vertical']);
        const op = v === 'dec_add_vertical' ? '+' : '-';
        const a = MathUtils.randomInt(100, 4500) / 100;
        const b = MathUtils.randomInt(100, 4500) / 100;
        
        const res = this.createProblem(
            op === '+' ? a : Math.max(a, b), 
            op === '+' ? b : Math.min(a, b), 
            op, lang, true
        );

        res.clues.push({ 
            text: lang === 'sv' ? "Viktigaste regeln: Decimaltecknen m√•ste st√• rakt under varandra. Fyll i med nollor om talen har olika m√•nga decimaler." : "Most important rule: The decimal points must be aligned vertically. Fill with zeros if the numbers have different numbers of decimal places." 
        });
        res.metadata = { variation_key: v, difficulty: 3 };
        return res;
    }

    // --- LEVEL 4: MULT EASY ---
    private level4_MultEasy(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_table_std', 'mult_commutative']);
        const a = MathUtils.randomInt(2, 10);
        const b = MathUtils.randomInt(2, 10);

        if (v === 'mult_table_std') {
            const res = this.createProblem(a, b, '*', lang, false);
            res.metadata = { variation_key: 'mult_table_std', difficulty: 2 };
            return res;
        }

        const correct = `${b} √ó ${a}`;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket uttryck ger samma produkt som ${a} √ó ${b}?` : `Which expression gives the same product as ${a} √ó ${b}?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([correct, `${a} + ${b}`, `${a} - ${b}`])
            },
            token: this.toBase64(correct),
            clues: [{ text: lang === 'sv' ? "Den kommutativa lagen s√§ger att ordningen p√• talen inte spelar n√•gon roll vid multiplikation." : "The commutative law states that the order of numbers does not matter in multiplication.", latex: "a \\cdot b = b \\cdot a" }],
            metadata: { variation_key: 'mult_commutative', difficulty: 2 }
        };
    }

    // --- LEVEL 5: MULT MEDIUM ---
    private level5_MultMedium(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_2x1_vertical', 'mult_distributive']);
        const a = MathUtils.randomInt(11, 35);
        const b = MathUtils.randomInt(3, 9);

        if (v === 'mult_2x1_vertical') {
            const res = this.createProblem(a, b, '*', lang, true);
            res.metadata = { variation_key: 'mult_2x1_vertical', difficulty: 3 };
            return res;
        }

        const part1 = Math.floor(a / 10) * 10;
        const part2 = a % 10;
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna genom att dela upp talet i talsorter: (${part1} √ó ${b}) + (${part2} √ó ${b})` : `Calculate by splitting the number into place values: (${part1} √ó ${b}) + (${part2} √ó ${b})`,
                answerType: 'numeric'
            },
            token: this.toBase64((a * b).toString()),
            clues: [{ text: lang === 'sv' ? "Detta kallas den distributiva lagen. Det √§r oftast enklare att r√§kna tiotalen f√∂r sig och entalen f√∂r sig." : "This is called the distributive law. It is often easier to calculate the tens and ones separately.", latex: `${part1*b} + ${part2*b}` }],
            metadata: { variation_key: 'mult_distributive', difficulty: 3 }
        };
    }

    // --- LEVEL 6: MULT HARD ---
    private level6_MultHard(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_decimal_std', 'mult_decimal_placement']);
        const a = MathUtils.randomInt(1, 9) / 10;
        const b = MathUtils.randomInt(2, 15);
        const ans = Math.round(a * b * 100) / 100;

        if (v === 'mult_decimal_std') {
            const res = this.createProblem(a, b, '*', lang, false);
            res.clues.push({ text: lang === 'sv' ? "Tips: Multiplicera som om det vore heltal f√∂rst (9 x 12). R√§kna sedan hur m√•nga decimaler som fanns totalt och flytta kommat lika m√•nga steg." : "Hint: Multiply as if they were integers first (9 x 12). Then count the total number of decimals in the original numbers and move the decimal point the same number of steps." });
            res.metadata = { variation_key: 'mult_decimal_std', difficulty: 4 };
            return res;
        }

        const options = [
            `${a} √ó ${b} = ${ans}`,
            `${a} √ó ${b} = ${Math.round(ans * 10 * 10) / 10}`,
            `${a} √ó ${b} = ${Math.round(ans * 100 * 10) / 1000}`
        ];
        return {
            renderData: {
                description: lang === 'sv' ? "Vilken av utr√§kningarna har placerat decimalkommat r√§tt?" : "Which calculation has placed the decimal point correctly?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle(options)
            },
            token: this.toBase64(`${a} √ó ${b} = ${ans}`),
            clues: [{ text: lang === 'sv' ? `R√§kna antalet decimaler i faktorerna. H√§r har ${a} en decimal och ${b} har noll. Produkten m√•ste d√§rf√∂r ha exakt en decimal.` : `Count the decimals in the factors. Here ${a} has one decimal and ${b} has zero. The product must therefore have exactly one decimal.` }],
            metadata: { variation_key: 'mult_decimal_placement', difficulty: 4 }
        };
    }

    // --- LEVEL 7: DIVISION ---
    private level7_DivEasy(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['div_basic_std', 'div_inverse_logic']);
        const f1 = MathUtils.randomInt(2, 12);
        const f2 = MathUtils.randomInt(2, 12);
        const prod = f1 * f2;

        if (v === 'div_basic_std') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna kvoten." : "Calculate the quotient.",
                    latex: `\\frac{${prod}}{${f1}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(f2.toString()),
                clues: [{ text: lang === 'sv' ? `Division √§r motsatsen till multiplikation. Fr√•ga dig sj√§lv: Vad multiplicerat med ${f1} blir ${prod}?` : `Division is the opposite of multiplication. Ask yourself: What multiplied by ${f1} equals ${prod}?`, latex: `${f1} \\cdot ? = ${prod}` }],
                metadata: { variation_key: 'div_basic_std', difficulty: 2 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Om vi vet att ${f1} √ó ${f2} = ${prod}, vad blir d√• resultatet av ${prod} / ${f1}?` : `If we know that ${f1} √ó ${f2} = ${prod}, what is the result of ${prod} / ${f1}?`,
                answerType: 'numeric'
            },
            token: this.toBase64(f2.toString()),
            clues: [{ text: lang === 'sv' ? "Eftersom division och multiplikation h√∂r ihop i samma sifferfamilj kan du se svaret direkt i multiplikationen." : "Since division and multiplication belong to the same fact family, you can see the answer directly in the multiplication." }],
            metadata: { variation_key: 'div_inverse_logic', difficulty: 2 }
        };
    }

    // --- LEVEL 8 & 9: MIXED ---
    private level8_MixedIntegers(lang: string): any {
        const key = MathUtils.randomChoice(['add_std_horizontal', 'sub_std_horizontal', 'mult_table_std', 'div_basic_std']);
        const res = this.generateByVariation(key, lang);
        res.metadata.mixed = true;
        return res;
    }

    private level9_MixedDecimals(lang: string): any {
        const key = MathUtils.randomChoice(['dec_add_vertical', 'dec_sub_vertical', 'mult_decimal_std']);
        const res = this.generateByVariation(key, lang);
        res.metadata.mixed = true;
        return res;
    }

    private createProblem(a: number, b: number, op: string, lang: string, vertical: boolean = false, extraClues: any[] = []) {
        let ans = 0;
        let latex = "";
        if (op === '+') ans = a + b;
        if (op === '-') ans = a - b;
        if (op === '*') ans = a * b;
        ans = Math.round(ans * 1000) / 1000;

        if (vertical) {
            const opSymbol = op === '*' ? '\\times' : op;
            latex = (op === '-') ? this.makeVertical(a, b, opSymbol) : this.makeVertical(Math.max(a, b), Math.min(a, b), opSymbol);
        } else {
            const opSymbol = op === '*' ? '\\cdot' : op;
            latex = `${a} ${opSymbol} ${b}`;
        }

        const description = vertical 
            ? (lang === 'sv' ? "St√§ll upp och ber√§kna. T√§nk p√• talsorterna." : "Set up and calculate. Pay attention to place values.")
            : (lang === 'sv' ? "Ber√§kna." : "Calculate.");

        const defaultClues = vertical 
            ? [{ text: lang === 'sv' ? "B√∂rja alltid fr√•n h√∂ger (entalen). Om summan blir 10 eller mer, flytta tiotalet som en minnessiffra till n√§sta kolumn." : "Always start from the right (ones). If the sum is 10 or more, carry the ten over as a small digit to the next column." }]
            : [];

        return {
            renderData: { latex, description, answerType: 'numeric' },
            token: this.toBase64(ans.toString()),
            clues: extraClues.length > 0 ? [...defaultClues, ...extraClues] : defaultClues,
            metadata: { variation_key: 'generic_arithmetic', difficulty: 1 }
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ChangeFactorGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ChangeFactorGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_ApplyFactor(lang);
            case 3: return this.level3_FindOriginal(lang);
            case 4: return this.level4_TotalChange(lang);
            case 5: return this.level5_WordProblems(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'pct_to_factor_inc':
            case 'pct_to_factor_dec':
            case 'factor_to_pct_inc':
            case 'factor_to_pct_dec':
                return this.level1_Concepts(lang, key);
            
            case 'apply_factor_inc':
            case 'apply_factor_dec':
                return this.level2_ApplyFactor(lang, key);
            
            case 'find_original_inc':
            case 'find_original_dec':
                return this.level3_FindOriginal(lang, key);
            
            case 'sequential_factors':
                return this.level4_TotalChange(lang, key);
            
            case 'word_population':
            case 'word_interest':
            case 'word_depreciation':
            case 'word_sale':
            case 'word_decay':
            case 'word_salary':
            case 'word_inflation':
            case 'word_stock':
                return this.level5_WordProblems(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPTS & DEFINITION ---
    private level1_Concepts(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['pct_to_factor_inc', 'pct_to_factor_dec', 'factor_to_pct_inc', 'factor_to_pct_dec']);
        
        const isIncrease = v.endsWith('_inc');
        const isToFactor = v.startsWith('pct_to_factor');
        
        let pct = 0;
        if (Math.random() < 0.3) pct = MathUtils.randomInt(1, 9) * 10;
        else pct = MathUtils.randomInt(1, 150);
        
        let factor = 0;
        if (isIncrease) {
            factor = 1 + (pct / 100);
        } else {
            pct = Math.min(pct, 99);
            factor = 1 - (pct / 100);
        }
        factor = Math.round(factor * 100) / 100;

        if (isToFactor) {
            const desc = lang === 'sv'
                ? (isIncrease ? `Ett v√§rde √∂kar med ${pct}%. Vilken f√∂r√§ndringsfaktor motsvarar denna √∂kning?` : `Ett v√§rde minskar med ${pct}%. Vilken f√∂r√§ndringsfaktor motsvarar denna minskning?`)
                : (isIncrease ? `A value increases by ${pct}%. What is the change factor corresponding to this increase?` : `A value decreases by ${pct}%. What is the change factor corresponding to this decrease?`);
            
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    { text: lang === 'sv' ? "T√§nk p√• 100% som det ursprungliga hela v√§rdet, vilket skrivs som 1,00 i decimalform." : "Think of 100% as the original whole value, which is written as 1.00 in decimal form.", latex: "100\\% = 1.00" },
                    { 
                        text: lang === 'sv' 
                            ? (isIncrease ? `Addera √∂kningen (${pct}%) till det ursprungliga v√§rdet (100%).` : `Dra bort minskningen (${pct}%) fr√•n det ursprungliga v√§rdet (100%).`)
                            : (isIncrease ? `Add the increase (${pct}%) to the original value (100%).` : `Subtract the decrease (${pct}%) from the original value (100%).`),
                        latex: isIncrease ? `1.00 + ${pct/100} = ${factor}` : `1.00 - ${pct/100} = ${factor}` 
                    }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        } else {
            const diff = Math.abs(1 - factor);
            const diffPct = Math.round(diff * 100);
            const desc = lang === 'sv'
                ? `F√∂r√§ndringsfaktorn f√∂r en h√§ndelse √§r ${factor}. Hur m√•nga procents ${isIncrease ? '√∂kning' : 'minskning'} inneb√§r detta?`
                : `The change factor for an event is ${factor}. What percentage ${isIncrease ? 'increase' : 'decrease'} does this represent?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(diffPct.toString()),
                clues: [
                    { text: lang === 'sv' ? "J√§mf√∂r f√∂r√§ndringsfaktorn med 1,00 f√∂r att se hur mycket v√§rdet har √§ndrats." : "Compare the change factor with 1.00 to see how much the value has changed.", latex: factor > 1 ? `${factor} - 1.00 = ${diff.toFixed(2)}` : `1.00 - ${factor} = ${diff.toFixed(2)}` },
                    { text: lang === 'sv' ? "G√∂r om skillnaden i decimalform till procent genom att multiplicera med 100." : "Convert the decimal difference to a percentage by multiplying by 100.", latex: `${diff.toFixed(2)} \\cdot 100 = ${diffPct}\\%` }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }
    }

    // --- LEVEL 2: APPLYING FACTOR ---
    private level2_ApplyFactor(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['apply_factor_inc', 'apply_factor_dec']);
        const isIncrease = v === 'apply_factor_inc';
        
        const pct = MathUtils.randomInt(1, 95);
        let factor = isIncrease ? 1 + pct/100 : 1 - pct/100;
        factor = Math.round(factor * 100) / 100;

        let base = MathUtils.randomInt(2, 50) * 100;

        const ans = Math.round(base * factor);

        const desc = lang === 'sv'
            ? `Ett pris p√• ${base} kr ska ${isIncrease ? 'h√∂jas' : 's√§nkas'} med ${pct}%. Ber√§kna det nya priset genom att anv√§nda en f√∂r√§ndringsfaktor.`
            : `A price of ${base} kr is to be ${isIncrease ? 'increased' : 'decreased'} by ${pct}%. Calculate the new price by applying a change factor.`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "B√∂rja med att best√§mma f√∂r√§ndringsfaktorn f√∂r justeringen." : "Begin by determining the change factor for the adjustment.", latex: isIncrease ? `1.00 + ${pct/100} = ${factor}` : `1.00 - ${pct/100} = ${factor}` },
                { text: lang === 'sv' ? "Multiplicera det gamla v√§rdet med faktorn f√∂r att f√• fram det nya priset." : "Multiply the old value by the factor to find the new price.", latex: `${base} \\cdot ${factor} = ${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: FINDING ORIGINAL ---
    private level3_FindOriginal(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['find_original_inc', 'find_original_dec']);
        const isIncrease = v === 'find_original_inc';
        
        const pct = MathUtils.randomInt(5, 80);
        let factor = isIncrease ? 1 + pct/100 : 1 - pct/100;
        factor = Math.round(factor * 100) / 100;

        const original = MathUtils.randomInt(2, 25) * 100;
        const newPrice = Math.round(original * factor);

        const desc = lang === 'sv'
            ? `Efter en ${isIncrease ? 'pris√∂kning' : 'priss√§nkning'} med ${pct}% kostar en vara nu ${newPrice} kr. Hur mycket kostade varan fr√•n b√∂rjan?`
            : `After a price ${isIncrease ? 'increase' : 'decrease'} of ${pct}%, an item now costs ${newPrice} kr. What was the original price of the item?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(original.toString()),
            clues: [
                { text: lang === 'sv' ? "Eftersom vi vet det nya v√§rdet men s√∂ker det gamla, m√•ste vi dividera med f√∂r√§ndringsfaktorn." : "Since we know the new value but seek the old one, we must divide by the change factor.", latex: `\\text{Gammalt v√§rde} = \\frac{\\text{Nytt v√§rde}}{\\text{Faktor}}` },
                { text: lang === 'sv' ? `F√∂r√§ndringsfaktorn √§r ${factor}. Dela det nya priset med detta tal.` : `The change factor is ${factor}. Divide the new price by this number.`, latex: `\\frac{${newPrice}}{${factor}} = ${original}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: TOTAL CHANGE (SEQUENTIAL) ---
    private level4_TotalChange(lang: string, variationKey?: string): any {
        const pct1 = MathUtils.randomChoice([10, 20, 25, 50]);
        const pct2 = MathUtils.randomChoice([10, 20, 25, 50]);
        const inc1 = Math.random() > 0.5;
        const inc2 = Math.random() > 0.5;

        const f1 = inc1 ? 1 + pct1/100 : 1 - pct1/100;
        const f2 = inc2 ? 1 + pct2/100 : 1 - pct2/100;
        const totalFactor = Math.round(f1 * f2 * 10000) / 10000;

        const desc = lang === 'sv'
            ? `V√§rdet p√• ett f√∂rem√•l √§ndras f√∂rst med ${inc1 ? '+' : '-'}${pct1}% och d√§refter med ytterligare ${inc2 ? '+' : '-'}${pct2}%. Ber√§kna den totala f√∂r√§ndringsfaktorn f√∂r b√•da h√§ndelserna.`
            : `The value of an item changes first by ${inc1 ? '+' : '-'}${pct1}% and then by an additional ${inc2 ? '+' : '-'}${pct2}%. Calculate the total change factor for both events combined.`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(totalFactor.toString()),
            clues: [
                { text: lang === 'sv' ? "N√§r flera f√∂r√§ndringar sker efter varandra i en kedja ska man multiplicera deras individuella faktorer." : "When multiple changes occur sequentially in a chain, you multiply their individual factors.", latex: `F_{total} = F_1 \\cdot F_2` },
                { text: lang === 'sv' ? `Ber√§kna produkten av ${f1} och ${f2}.` : `Calculate the product of ${f1} and ${f2}.`, latex: `${f1} \\cdot ${f2} = ${totalFactor}` }
            ],
            metadata: { variation_key: 'sequential_factors', difficulty: 4 }
        };
    }

    // --- LEVEL 5: WORD PROBLEMS ---
    private level5_WordProblems(lang: string, variationKey?: string): any {
        const scenarios = ['word_population', 'word_interest', 'word_depreciation', 'word_sale', 'word_decay', 'word_salary', 'word_inflation', 'word_stock'];
        const v = variationKey || MathUtils.randomChoice(scenarios);

        if (v === 'word_population' || v === 'word_salary' || v === 'word_stock') {
            const start = MathUtils.randomInt(10, 50) * 1000;
            const pct = MathUtils.randomInt(5, 40);
            const isInc = v !== 'word_stock';
            const factor = isInc ? 1 + pct/100 : 1 - pct/100;
            const end = Math.round(start * factor);

            let desc = "";
            if (v === 'word_population') {
                desc = lang === 'sv' 
                    ? `Folkm√§ngden i en kommun har √§ndrats fr√•n ${start} till ${end} inv√•nare under en fem√•rsperiod. Ber√§kna f√∂r√§ndringsfaktorn f√∂r denna befolknings√§ndring.` 
                    : `The population of a municipality changed from ${start} to ${end} inhabitants over a five-year period. Calculate the change factor for this population shift.`;
            } else if (v === 'word_salary') {
                desc = lang === 'sv'
                    ? `Efter en lyckad l√∂nef√∂rhandling h√∂jdes en anst√§llds l√∂n fr√•n ${start} kr till ${end} kr per m√•nad. Vilken f√∂r√§ndringsfaktor beskriver l√∂ne√∂kningen?`
                    : `After a successful salary negotiation, an employee's salary was increased from ${start} kr to ${end} kr per month. Which change factor describes the increase?`;
            } else {
                desc = lang === 'sv'
                    ? `V√§rdet p√• en aktie sj√∂nk fr√•n ${start} kr till ${end} kr under en turbulent handelsdag. Ange den f√∂r√§ndringsfaktor som motsvarar v√§rdeminskningen.`
                    : `The value of a stock fell from ${start} kr to ${end} kr during a turbulent trading day. State the change factor corresponding to the decrease in value.`;
            }

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [{ text: lang === 'sv' ? "F√∂r√§ndringsfaktorn ber√§knas alltid genom att dela det nya v√§rdet med det ursprungliga (gamla) v√§rdet." : "The change factor is always calculated by dividing the new value by the original (old) value.", latex: `\\text{Faktor} = \\frac{\\text{Nytt}}{\\text{Gammalt}} = \\frac{${end}}{${start}}` }],
                metadata: { variation_key: v, difficulty: 3 }
            };
        }

        if (v === 'word_interest' || v === 'word_depreciation' || v === 'word_decay') {
            const money = MathUtils.randomInt(10, 50) * 1000;
            const rate = MathUtils.randomInt(2, 15);
            const isInc = v === 'word_interest';
            const factor = isInc ? 1 + rate/100 : 1 - rate/100;
            const years = 2;
            const ans = Math.round(money * Math.pow(factor, years));

            let desc = "";
            if (v === 'word_interest') {
                desc = lang === 'sv' 
                    ? `Du s√§tter in ${money} kr p√• ett sparkonto med en √•rlig r√§nta p√• ${rate}%. Hur mycket pengar finns p√• kontot efter ${years} √•r om r√§ntan √§r of√∂r√§ndrad? Avrunda till n√§rmaste heltal.`
                    : `You deposit ${money} kr into a savings account with an annual interest rate of ${rate}%. How much money will be in the account after ${years} years if the rate remains unchanged? Round to the nearest integer.`;
            } else if (v === 'word_depreciation') {
                desc = lang === 'sv'
                    ? `En maskin som kostade ${money} kr vid ink√∂p minskar i v√§rde med ${rate}% varje √•r. Ber√§kna maskinens ber√§knade v√§rde efter ${years} √•r. Avrunda till n√§rmaste heltal.`
                    : `A machine that cost ${money} kr at purchase decreases in value by ${rate}% each year. Calculate the estimated value of the machine after ${years} years. Round to the nearest integer.`;
            } else {
                desc = lang === 'sv'
                    ? `Ett prov av ett radioaktivt √§mne med massan ${money} gram minskar med ${rate}% i vikt per dygn. Hur stor massa √•terst√•r efter ${years} dygn? Avrunda till n√§rmaste heltal.`
                    : `A sample of a radioactive substance with a mass of ${money} grams decreases by ${rate}% in weight per day. How much mass remains after ${years} days? Round to the nearest integer.`;
            }

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `F√∂r√§ndringsfaktorn f√∂r ett √•r √§r ${factor}. F√∂r att f√• v√§rdet efter ${years} √•r multiplicerar vi startv√§rdet med faktorn tv√• g√•nger.` : `The change factor for one year is ${factor}. To find the value after ${years} years, we multiply the starting value by the factor twice.`, latex: `${money} \\cdot ${factor}^2 = ${ans}` }
                ],
                metadata: { variation_key: v, difficulty: 4 }
            };
        }

        if (v === 'word_sale' || v === 'word_inflation') {
            const pct = MathUtils.randomChoice([10, 20, 25, 50]);
            const isInc = v === 'word_inflation';
            const factor = isInc ? 1 + pct/100 : 1 - pct/100;
            const original = MathUtils.randomInt(5, 20) * 100;
            const current = Math.round(original * factor);

            let desc = "";
            if (v === 'word_sale') {
                desc = lang === 'sv'
                    ? `Under en slutf√∂rs√§ljning s√§nks priset p√• en vara med ${pct}%. Det nya nedsatta priset √§r ${current} kr. Ber√§kna varans ordinarie pris f√∂re rean.`
                    : `During a clearance sale, the price of an item is reduced by ${pct}%. The new discounted price is ${current} kr. Calculate the item's regular price before the sale.`;
            } else {
                desc = lang === 'sv'
                    ? `P√• grund av h√∂g inflation har priset p√• en tj√§nst stigit med ${pct}% och kostar nu ${current} kr. Hur mycket kostade tj√§nsten f√∂re pris√∂kningen?`
                    : `Due to high inflation, the price of a service has risen by ${pct}% and now costs ${current} kr. How much did the service cost before the price increase?`;
            }

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(original.toString()),
                clues: [
                    { text: lang === 'sv' ? `En f√∂r√§ndring p√• ${isInc ? '+' : '-'}${pct}% ger f√∂r√§ndringsfaktorn ${factor}. F√∂r att hitta det ursprungliga priset dividerar vi det nuvarande priset med denna faktor.` : `A change of ${isInc ? '+' : '-'}${pct}% gives the change factor ${factor}. To find the original price, we divide the current price by this factor.`, latex: `\\frac{${current}}{${factor}} = ${original}` }
                ],
                metadata: { variation_key: v, difficulty: 4 }
            };
        }

        // Standard Fallback for unexpected keys
        return this.level2_ApplyFactor(lang);
    }
}

// FILE END: src\core\generators\ChangeFactorGen.ts

// =======================================================
// FILE START: src\core\generators\ExponentsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExponentsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Foundations(lang);
            case 2: return this.level2_PowersOfTen(lang);
            case 3: return this.level3_ScientificNotation(lang);
            case 4: return this.level4_SquareRoots(lang);
            case 5: return this.level5_LawsBasic(lang);
            case 6: return this.level6_LawsAdvanced(lang);
            default: return this.level1_Foundations(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'zero_rule':
            case 'power_of_one':
            case 'foundations_calc':
            case 'foundations_spot_the_lie':
                return this.level1_Foundations(lang, key);
            
            case 'ten_positive_exponent':
            case 'ten_negative_exponent':
            case 'ten_inverse_counting':
                return this.level2_PowersOfTen(lang, key);
            
            case 'scientific_to_form':
            case 'scientific_missing_mantissa':
            case 'scientific_missing_exponent':
                return this.level3_ScientificNotation(lang, key);
            
            case 'root_calc':
            case 'root_inverse_algebra':
                return this.level4_SquareRoots(lang, key);
            
            case 'law_multiplication':
            case 'law_division':
            case 'law_addition_trap':
            case 'law_mult_div_combined':
                return this.level5_LawsBasic(lang, key);
            
            case 'law_power_of_power':
            case 'law_inverse_algebra':
            case 'law_all_combined':
                return this.level6_LawsAdvanced(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: FOUNDATIONS ---
    private level1_Foundations(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['zero_rule', 'power_of_one', 'foundations_calc', 'foundations_spot_the_lie']);

        if (v === 'zero_rule' || v === 'power_of_one') {
            const isZero = v === 'zero_rule';
            const base = MathUtils.randomInt(5, 500);
            const desc = lang === 'sv'
                ? `Ber√§kna v√§rdet av uttrycket nedan.`
                : `Calculate the value of the expression below.`;

            return {
                renderData: {
                    description: desc,
                    latex: isZero ? `${base}^{0}` : `${base}^{1}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(isZero ? "1" : base.toString()),
                clues: isZero ? [
                    { text: lang === 'sv' ? "Kom ih√•g noll-regeln: Alla tal (utom noll) som √§r upph√∂jda till 0 blir alltid exakt 1." : "Remember the zero rule: Any number (except zero) raised to the power of 0 is always exactly 1.", latex: "x^{0} = 1" },
                    { text: lang === 'sv' ? "Detta beror p√• att en division av ett tal med sig sj√§lvt skapar en noll-exponent." : "This is because dividing a number by itself creates a zero exponent.", latex: "\\frac{x^n}{x^n} = x^{n-n} = x^0 = 1" }
                ] : [
                    { text: lang === 'sv' ? "En exponent p√• 1 betyder att basen bara f√∂rekommer en enda g√•ng." : "An exponent of 1 means the base appears only one single time.", latex: "x^{1} = x" },
                    { text: lang === 'sv' ? `Eftersom talet bara st√•r d√§r en g√•ng f√∂rblir v√§rdet ${base}.` : `Since the number is only there once, the value remains ${base}.`, latex: `${base}^{1} = ${base}` }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }

        if (v === 'foundations_spot_the_lie') {
            const base = MathUtils.randomInt(2, 5);
            const exp = MathUtils.randomInt(2, 3);
            const val = Math.pow(base, exp);
            
            const true1 = `${base}^{${exp}} = ${val}`;
            const true2 = `${MathUtils.randomInt(10, 99)}^{0} = 1`;
            const lie = `${base}^{${exp}} = ${base * exp}`; 

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden om potenser √§r FALSKT?" : "Which of the following statements about powers is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([true1, true2, lie])
                },
                token: this.toBase64(lie),
                clues: [
                    { text: lang === 'sv' ? "En vanlig f√§lla √§r att multiplicera basen med exponenten. Men en potens betyder upprepad multiplikation!" : "A common trap is multiplying the base by the exponent. But a power means repeated multiplication!", latex: `${base}^{${exp}} = ` + Array(exp).fill(base).join(" \\cdot ") }
                ],
                metadata: { variation_key: "foundations_spot_the_lie", difficulty: 2 }
            };
        }

        const base = MathUtils.randomInt(2, 10);
        const exp = MathUtils.randomInt(2, 4);
        if (Math.pow(base, exp) > 1000) return this.level1_Foundations(lang, v);
        const ans = Math.pow(base, exp);

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna potensen genom att multiplicera basen med sig sj√§lv ${exp} g√•nger.` : `Calculate the power by multiplying the base by itself ${exp} times.`,
                latex: `${base}^{${exp}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? `Exponenten (${exp}) talar om att vi ska ha ${exp} stycken faktorer av basen (${base}).` : `The exponent (${exp}) tells us to have ${exp} factors of the base (${base}).`, latex: Array(exp).fill(base).join(' \\cdot ') },
                { text: lang === 'sv' ? "R√§kna ut produkten av dessa faktorer." : "Calculate the product of these factors.", latex: `${ans}` }
            ],
            metadata: { variation_key: "foundations_calc", difficulty: 1 }
        };
    }

    // --- LEVEL 2: POWERS OF 10 ---
    private level2_PowersOfTen(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['ten_positive_exponent', 'ten_negative_exponent', 'ten_inverse_counting']);
        const power = MathUtils.randomInt(1, 6);

        if (v === 'ten_negative_exponent') {
            const ansStr = (1 / Math.pow(10, power)).toString();
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv tiopotensen som ett decimaltal." : "Write the power of ten as a decimal number.",
                    latex: `10^{-${power}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ansStr),
                clues: [
                    { text: lang === 'sv' ? "En negativ exponent betyder att vi dividerar 1 med basen." : "A negative exponent means we divide 1 by the base.", latex: `10^{-${power}} = \\frac{1}{10^{${power}}}` },
                    { text: lang === 'sv' ? `Detta resulterar i ett decimaltal d√§r 1:an hamnar p√• den ${power}:e decimalplatsen.` : `This results in a decimal where the 1 is placed at the ${power}:th decimal position.`, latex: ansStr }
                ],
                metadata: { variation_key: "ten_negative_exponent", difficulty: 2 }
            };
        }

        if (v === 'ten_inverse_counting') {
            const zeros = MathUtils.randomInt(2, 7);
            const num = "1" + "0".repeat(zeros);
            return {
                renderData: {
                    description: lang === 'sv' ? `Skriv talet ${num.replace(/\B(?=(\d{3})+(?!\d))/g, " ")} som en potens med basen 10.` : `Write the number ${num.replace(/\B(?=(\d{3})+(?!\d))/g, " ")} as a power with base 10.`,
                    latex: `10^{?} = ${num}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`10^${zeros}`),
                clues: [
                    { text: lang === 'sv' ? "R√§kna hur m√•nga nollor som st√•r efter ettan. Antalet nollor motsvarar exponenten." : "Count how many zeros follow the one. The number of zeros corresponds to the exponent.", latex: `\\text{Antal nollor} = ${zeros}` }
                ],
                metadata: { variation_key: "ten_inverse_counting", difficulty: 2 }
            };
        }

        const ans = Math.pow(10, power);
        return {
            renderData: {
                description: lang === 'sv' ? "Skriv tiopotensen som ett vanligt heltal." : "Write the power of ten as a standard integer.",
                latex: `10^{${power}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? `En snabb regel f√∂r basen 10 √§r att skriva en 1:a och sedan l√§gga till lika m√•nga nollor som exponenten visar.` : `A quick rule for base 10 is writing a 1 and then adding as many zeros as the exponent shows.`, latex: `1 \\rightarrow ${ans}` }
            ],
            metadata: { variation_key: "ten_positive_exponent", difficulty: 1 }
        };
    }

    // --- LEVEL 3: SCIENTIFIC NOTATION ---
    private level3_ScientificNotation(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['scientific_to_form', 'scientific_missing_mantissa', 'scientific_missing_exponent']);
        
        const mantissa = (MathUtils.randomInt(11, 99) / 10); 
        const exponent = MathUtils.randomInt(3, 8);
        const number = mantissa * Math.pow(10, exponent);

        if (v === 'scientific_to_form') {
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Skriv talet ${number.toLocaleString(lang)} i grundpotensform.` 
                        : `Write the number ${number.toLocaleString(lang)} in scientific notation.`,
                    answerType: 'structured_scientific'
                },
                token: this.toBase64(`${mantissa}*10^${exponent}`),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Flytta decimalkommat s√• att du f√•r ett tal mellan 1 och 10." : "Step 1: Move the decimal point so you get a number between 1 and 10.", latex: `a = ${mantissa}` },
                    { text: lang === 'sv' ? `Steg 2: R√§kna hur m√•nga steg kommat flyttades. Det blir din tiopotens.` : `Step 2: Count how many steps the decimal was moved. That will be your power of ten.`, latex: `10^{${exponent}}` }
                ],
                metadata: { variation_key: "scientific_to_form", difficulty: 3 }
            };
        }

        const isMantissaMissing = v === 'scientific_missing_mantissa';
        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Vilket v√§rde saknas f√∂r att talet ska vara korrekt skrivet i grundpotensform?` 
                    : `Which value is missing for the number to be correctly written in scientific notation?`,
                latex: `${number.toLocaleString(lang)} = ${isMantissaMissing ? 'a' : mantissa} \\cdot 10^{${isMantissaMissing ? exponent : 'n'}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(isMantissaMissing ? mantissa.toString() : exponent.toString()),
            clues: [
                { text: lang === 'sv' ? "Grundpotensform best√•r always av en mantissa (mellan 1-10) och en tiopotens." : "Scientific notation always consists of a mantissa (between 1-10) and a power of ten.", latex: "a \\cdot 10^{n}" }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: SQUARE ROOTS ---
    private level4_SquareRoots(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['root_calc', 'root_inverse_algebra']);
        const base = MathUtils.randomInt(2, 12);
        const square = base * base;

        if (v === 'root_inverse_algebra') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Hitta det positiva v√§rdet p√• x som g√∂r att ekvationen st√§mmer.` : `Find the positive value of x that makes the equation true.`,
                    latex: `x^{2} = ${square}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(base.toString()),
                clues: [
                    { text: lang === 'sv' ? "F√∂r att f√• bort upph√∂jt till 2, drar vi kvadratroten ur b√•da sidor." : "To remove the power of 2, we take the square root of both sides.", latex: "x = \\sqrt{" + square + "}" },
                    { text: lang === 'sv' ? `Vilket tal g√•nger sig sj√§lvt blir ${square}?` : `What number times itself equals ${square}?`, latex: `${base} \\cdot ${base} = ${square}` }
                ],
                metadata: { variation_key: "root_inverse_algebra", difficulty: 2 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna kvadratroten ur talet." : "Calculate the square root of the number.",
                latex: `\\sqrt{${square}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(base.toString()),
            clues: [
                { text: lang === 'sv' ? `Kvadratroten ur ${square} √§r det tal som multiplicerat med sig sj√§lvt blir ${square}.` : `The square root of ${square} is the number that, when multiplied by itself, equals ${square}.`, latex: `? \\cdot ? = ${square}` }
            ],
            metadata: { variation_key: "root_calc", difficulty: 2 }
        };
    }

    // --- LEVEL 5: LAWS BASIC ---
    private level5_LawsBasic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['law_multiplication', 'law_division', 'law_addition_trap', 'law_mult_div_combined']);
        const a = MathUtils.randomInt(2, 12);
        const b = MathUtils.randomInt(2, 8);

        if (v === 'law_multiplication') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Anv√§nd potenslagarna f√∂r att skriva om uttrycket till en enda potens." : "Use the power laws to rewrite the expression as a single power.",
                    latex: `x^{${a}} \\cdot x^{${b}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${a + b}`),
                clues: [
                    { text: lang === 'sv' ? "N√§r vi multiplicerar potenser med samma bas, adderar vi deras exponenter." : "When multiplying powers with the same base, we add their exponents.", latex: "x^{a} \\cdot x^{b} = x^{a+b}" },
                    { text: lang === 'sv' ? `R√§kna ut den nya exponenten: ${a} + ${b}.` : `Calculate the new exponent: ${a} + ${b}.`, latex: `${a+b}` }
                ],
                metadata: { variation_key: "law_multiplication", difficulty: 3 }
            };
        }

        if (v === 'law_division') {
            const big = MathUtils.randomInt(b + 1, b + 12);
            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla divisionen till en enda potens." : "Simplify the division to a single power.",
                    latex: `\\frac{x^{${big}}}{x^{${b}}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${big - b}`),
                clues: [
                    { text: lang === 'sv' ? "N√§r vi dividerar potenser med samma bas, subtraherar vi n√§mnarens exponent fr√•n t√§ljarens." : "When dividing powers with the same base, we subtract the denominator's exponent from the numerator's.", latex: "\\frac{x^{a}}{x^{b}} = x^{a-b}" },
                    { text: lang === 'sv' ? `R√§kna ut den nya exponenten: ${big} - ${b}.` : `Calculate the new exponent: ${big} - ${b}.`, latex: `${big - b}` }
                ],
                metadata: { variation_key: "law_division", difficulty: 3 }
            };
        }

        if (v === 'law_mult_div_combined') {
            const nTerms = MathUtils.randomInt(2, 3);
            const dTerms = MathUtils.randomInt(1, 2);
            const nExps = Array.from({length: nTerms}, () => MathUtils.randomInt(2, 8));
            const dExps = Array.from({length: dTerms}, () => MathUtils.randomInt(2, 5));
            
            const nSum = nExps.reduce((acc, cur) => acc + cur, 0);
            const dSum = dExps.reduce((acc, cur) => acc + cur, 0);
            const finalExp = nSum - dSum;

            // Prevent negative results for basic level
            if (finalExp < 0) return this.level5_LawsBasic(lang, v);

            const nLatex = nExps.map(e => `x^{${e}}`).join(' \\cdot ');
            const dLatex = dExps.map(e => `x^{${e}}`).join(' \\cdot ');
            const fullLatex = `\\frac{${nLatex}}{${dLatex}}`;

            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla uttrycket genom att kombinera b√•de multiplikations- och divisionsreglerna." : "Simplify the expression by combining both the multiplication and division rules.",
                    latex: fullLatex,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${finalExp}`),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: F√∂renkla t√§ljaren och n√§mnaren var f√∂r sig genom att addera exponenterna." : "Step 1: Simplify the numerator and denominator separately by adding the exponents.", latex: `\\frac{x^{${nSum}}}{x^{${dSum}}}` },
                    { text: lang === 'sv' ? "Steg 2: Subtrahera n√§mnarens exponent fr√•n t√§ljarens." : "Step 2: Subtract the denominator's exponent from the numerator's.", latex: `x^{${nSum} - ${dSum}} = x^{${finalExp}}` }
                ],
                metadata: { variation_key: "law_mult_div_combined", difficulty: 4 }
            };
        }

        const q = lang === 'sv' ? `G√•r det att f√∂renkla $x^{${a}} + x^{${b}}$ med hj√§lp av potenslagarna?` : `Is it possible to simplify $x^{${a}} + x^{${b}}$ using the power laws?`;
        const options = lang === 'sv' ? ["Nej, lagarna g√§ller bara mult/div", "Ja, det blir x upph√∂jt till summan"] : ["No, laws only apply to mult/div", "Yes, it becomes x to the power of the sum"];
        
        return {
            renderData: { description: q, answerType: 'multiple_choice', options },
            token: this.toBase64(options[0]),
            clues: [
                { text: lang === 'sv' ? "Potenslagarna √§r begr√§nsade. De fungerar bara n√§r vi multiplicerar eller dividerar baserna." : "Power laws are limited. They only work when we multiply or divide the bases.", latex: "x^a + x^b \\neq x^{a+b}" }
            ],
            metadata: { variation_key: "law_addition_trap", difficulty: 2 }
        };
    }

    // --- LEVEL 6: LAWS ADVANCED ---
    private level6_LawsAdvanced(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['law_power_of_power', 'law_inverse_algebra', 'law_all_combined']);
        const a = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(2, 6);

        if (v === 'law_power_of_power') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Anv√§nd regeln f√∂r 'potens av en potens' f√∂r att f√∂renkla uttrycket." : "Use the 'power of a power' rule to simplify the expression.",
                    latex: `(x^{${a}})^{${b}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${a * b}`),
                clues: [
                    { text: lang === 'sv' ? "N√§r en potens √§r upph√∂jd till en annan exponent, ska exponenterna multipliceras." : "When a power is raised to another exponent, the exponents should be multiplied.", latex: "(x^{a})^{b} = x^{a \\cdot b}" },
                    { text: lang === 'sv' ? `Multiplicera ${a} med ${b}.` : `Multiply ${a} by ${b}.`, latex: `${a * b}` }
                ],
                metadata: { variation_key: "law_power_of_power", difficulty: 4 }
            };
        }

        if (v === 'law_all_combined') {
            // ((x^a)^b * (x^c)^d) / (x^e)^f
            const e1 = MathUtils.randomInt(2, 4);
            const p1 = MathUtils.randomInt(2, 4);
            const e2 = MathUtils.randomInt(2, 4);
            const p2 = MathUtils.randomInt(2, 3);
            const e3 = MathUtils.randomInt(2, 5);
            const p3 = MathUtils.randomInt(2, 4);

            const n1 = e1 * p1;
            const n2 = e2 * p2;
            const d1 = e3 * p3;
            
            const nSum = n1 + n2;
            const finalExp = nSum - d1;

            // Ensure difficulty fits advanced level but remains solvable
            if (finalExp < 0 || finalExp > 25) return this.level6_LawsAdvanced(lang, v);

            const fullLatex = `\\frac{(x^{${e1}})^{${p1}} \\cdot (x^{${e2}})^{${p2}}}{(x^{${e3}})^{${p3}}}`;

            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla hela uttrycket till en enda potens. Anv√§nd alla potenslagar du l√§rt dig." : "Simplify the entire expression to a single power. Use all the power laws you have learned.",
                    latex: fullLatex,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${finalExp}`),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Anv√§nd 'potens av en potens' f√∂r att f√∂renkla varje parentes f√∂rst." : "Step 1: Use the 'power of a power' rule to simplify each set of parentheses first.", latex: `\\frac{x^{${n1}} \\cdot x^{${n2}}}{x^{${d1}}}` },
                    { text: lang === 'sv' ? "Steg 2: Addera exponenterna i t√§ljaren." : "Step 2: Add the exponents in the numerator.", latex: `\\frac{x^{${nSum}}}{x^{${d1}}}` },
                    { text: lang === 'sv' ? "Steg 3: Subtrahera n√§mnarens exponent fr√•n t√§ljarens." : "Step 3: Subtract the denominator's exponent from the numerator's.", latex: `x^{${nSum} - ${d1}} = x^{${finalExp}}` }
                ],
                metadata: { variation_key: "law_all_combined", difficulty: 5 }
            };
        }

        const target = a * b;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket v√§rde p√• y g√∂r att f√∂renklingen st√§mmer?` : `What value of y makes the simplification correct?`,
                latex: `(x^{${a}})^{y} = x^{${target}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(b.toString()),
            clues: [
                { text: lang === 'sv' ? "Eftersom regeln √§r multiplikation s√∂ker vi ett tal y som g√•nger a blir resultatet." : "Since the rule is multiplication, we seek a number y that times a equals the result.", latex: `${a} \\cdot y = ${target}` }
            ],
            metadata: { variation_key: "law_inverse_algebra", difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\ExponentsGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExpressionSimplificationGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_CombineTerms(lang);
            case 2: return this.level2_Parentheses(lang);
            case 3: return this.level3_DistributeAndSimplify(lang);
            case 4: return this.level4_SubtractParentheses(lang);
            case 5: return this.level5_WordProblems(lang);
            case 6: return this.level6_Mixed(lang);
            default: return this.level1_CombineTerms(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'combine_lie_exponent':
            case 'combine_concept_id':
            case 'combine_standard_mixed':
                return this.level1_CombineTerms(lang, key);
            
            case 'distribute_lie_partial':
            case 'distribute_inverse_factor':
            case 'distribute_plus':
            case 'distribute_minus':
                return this.level2_Parentheses(lang, key);
            
            case 'distribute_double':
            case 'distribute_combine_std':
                return this.level3_DistributeAndSimplify(lang, key);
            
            case 'sub_concept_plus_logic':
            case 'sub_block_plus':
            case 'sub_block_minus':
                return this.level4_SubtractParentheses(lang, key);
            
            case 'word_candy':
            case 'word_discount':
            case 'word_combined_age':
            case 'word_combined_age_tri':
            case 'word_rect_perimeter':
            case 'word_savings':
            case 'word_passengers':
            case 'word_garden':
            case 'word_sports':
            case 'word_phone_battery':
                return this.level5_WordProblems(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Combine Like Terms ---
    private level1_CombineTerms(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['combine_lie_exponent', 'combine_concept_id', 'combine_standard_mixed']);

        if (v === 'combine_lie_exponent') {
            const a = MathUtils.randomInt(2, 6);
            const b = MathUtils.randomInt(2, 6);
            const sum = a + b;
            const sTrue = `${a}x + ${b}x = ${sum}x`;
            const sLie = `${a}x + ${b}x = ${sum}x^2`; 
            const sTrue2 = `${a}x + x = ${a+1}x`;
            const options = [sTrue, sLie, sTrue2];

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden om f√∂renkling √§r FALSKT?" : "Which of the following statements about simplification is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(options)
                },
                token: this.toBase64(sLie),
                clues: [
                    { text: lang === 'sv' ? "N√§r vi adderar termer av samma slag (som x) √§ndras inte variabelns exponent. Det √§r som att l√§gga ihop frukter." : "When we add terms of the same kind (like x), the variable's exponent does not change. It is like adding fruit.", latex: "3x + 2x = 5x" },
                    { text: lang === 'sv' ? "Variabeln f√•r bara en tv√•a (x¬≤) om vi multiplicerar x med x." : "The variable only gets a two (x¬≤) if we multiply x by x.", latex: "x \\cdot x = x^2" }
                ],
                metadata: { variation_key: 'combine_lie_exponent', difficulty: 2 }
            };
        }

        if (v === 'combine_concept_id') {
            const a = MathUtils.randomInt(2, 9);
            const correct = `${MathUtils.randomInt(2, 9)}x`;
            const wrong1 = `${MathUtils.randomInt(2, 9)}y`;
            const wrong2 = `${MathUtils.randomInt(2, 9)}`;

            return {
                renderData: {
                    description: lang === 'sv' ? `Vilken av dessa termer kan du l√§gga ihop med ${a}x genom f√∂renkling?` : `Which of these terms can you add to ${a}x through simplification?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, wrong1, wrong2])
                },
                token: this.toBase64(correct),
                clues: [{ text: lang === 'sv' ? "Du kan bara kombinera termer som har exakt samma bokstav (variabel)." : "You can only combine terms that have the exact same letter (variable)." }],
                metadata: { variation_key: 'combine_concept_id', difficulty: 1 }
            };
        }

        const a = MathUtils.randomInt(2, 8);
        const b = MathUtils.randomInt(2, 12);
        const c = MathUtils.randomInt(2, 8);
        const d = MathUtils.randomInt(2, 12);
        const ans = `${a + c}x + ${b + d}`;

        return {
            renderData: {
                latex: `${a}x + ${b} + ${c}x + ${d}`,
                description: lang === 'sv' ? "F√∂renkla uttrycket genom att samla ihop termer av samma slag." : "Simplify the expression by gathering like terms.",
                answerType: 'text'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Samla ihop alla x-termer." : "Step 1: Gather all x-terms.", latex: `${a}x + ${c}x = ${a+c}x` },
                { text: lang === 'sv' ? "Steg 2: Samla ihop alla siffror." : "Step 2: Gather all numbers.", latex: `${b} + ${d} = ${b+d}` }
            ],
            metadata: { variation_key: 'combine_standard_mixed', difficulty: 2 }
        };
    }

    // --- LEVEL 2: Parentheses (Distribution) ---
    private level2_Parentheses(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['distribute_lie_partial', 'distribute_inverse_factor', 'distribute_plus', 'distribute_minus']);
        const a = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(2, 5);
        const c = MathUtils.randomInt(1, 6);
        const inOp = (v === 'distribute_minus') ? '-' : (v === 'distribute_plus' ? '+' : Math.random() > 0.5 ? '+' : '-');

        if (v === 'distribute_lie_partial') {
            const correct = `${a}(x ${inOp} ${c}) = ${a}x ${inOp} ${a*c}`;
            const lie = `${a}(x ${inOp} ${c}) = ${a}x ${inOp} ${c}`; 

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilken av f√∂renklingarna nedan √§r FELAKTIG?" : "Which of the simplifications below is INCORRECT?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, lie, `${a}(x ${inOp} ${c}) = ${a} \cdot x ${inOp} ${a} \cdot ${c}`])
                },
                token: this.toBase64(lie),
                clues: [
                    { text: lang === 'sv' ? "Siffran utanf√∂r parentesen m√•ste multipliceras med VARJE del inuti parentesen." : "The number outside the parentheses must be multiplied by EVERY part inside the parentheses." },
                    { text: lang === 'sv' ? `Man m√•ste allts√• √§ven r√§kna ut ${a} g√•nger ${c}.` : `So you must also calculate ${a} times ${c}.`, latex: `${a} \\cdot ${c} = ${a*c}` }
                ],
                metadata: { variation_key: 'distribute_lie_partial', difficulty: 2 }
            };
        }

        const latex = `${a}(${b}x ${inOp} ${c})`;
        const ans = `${a*b}x ${inOp} ${a*c}`;

        return {
            renderData: {
                latex,
                description: lang === 'sv' ? "F√∂renkla uttrycket genom att multiplicera in siffran i parentesen." : "Simplify the expression by distributing the number into the parentheses.",
                answerType: 'text'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? `Multiplicera ${a} med b√•da termerna inuti parentesen.` : `Multiply ${a} with both terms inside the parentheses.`, latex: `${a} \\cdot ${b}x ${inOp} ${a} \\cdot ${c}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: Distribute & Combine ---
    private level3_DistributeAndSimplify(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['distribute_double', 'distribute_combine_std']);
        const a = MathUtils.randomInt(2, 4);
        const b = MathUtils.randomInt(2, 4);
        const c = MathUtils.randomInt(1, 5);
        const d = MathUtils.randomInt(2, 6);

        if (v === 'distribute_double') {
            const k1 = MathUtils.randomInt(2, 3);
            const k2 = MathUtils.randomInt(2, 3);
            const ans = `${k1+k2}x + ${k1*c + k2*d}`;

            return {
                renderData: {
                    latex: `${k1}(x + ${c}) + ${k2}(x + ${d})`,
                    description: lang === 'sv' ? "F√∂renkla uttrycket genom att f√∂rst expandera b√•da parenteserna." : "Simplify the expression by first expanding both parentheses.",
                    answerType: 'text'
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Multiplicera in i b√•da parenteserna." : "Step 1: Distribute into both parentheses.", latex: `${k1}x + ${k1*c} + ${k2}x + ${k2*d}` },
                    { text: lang === 'sv' ? "Steg 2: Samla ihop x-termer och siffror var f√∂r sig." : "Step 2: Collect x-terms and numbers separately." }
                ],
                metadata: { variation_key: 'distribute_double', difficulty: 4 }
            };
        }

        const ans = `${a*b + d}x + ${a*c}`;
        return {
            renderData: {
                latex: `${a}(${b}x + ${c}) + ${d}x`,
                description: lang === 'sv' ? "Expandera parentesen och f√∂renkla sedan uttrycket." : "Expand the parentheses and then simplify the expression.",
                answerType: 'text'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Ta bort parentesen genom att multiplicera med " + a + "." : "Step 1: Remove parentheses by multiplying with " + a + ".", latex: `${a*b}x + ${a*c} + ${d}x` },
                { text: lang === 'sv' ? "Steg 2: L√§gg ihop alla termer som har x i sig." : "Step 2: Add all terms that contain x together.", latex: `${a*b}x + ${d}x = ${a*b+d}x` }
            ],
            metadata: { variation_key: 'distribute_combine_std', difficulty: 3 }
        };
    }

    // --- LEVEL 4: Subtracting Parentheses ---
    private level4_SubtractParentheses(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sub_concept_plus_logic', 'sub_block_plus', 'sub_block_minus']);
        const startX = MathUtils.randomInt(7, 15);
        const subX = MathUtils.randomInt(2, 5);
        const subK = MathUtils.randomInt(2, 8);
        const inOp = (v === 'sub_block_minus') ? '-' : (v === 'sub_block_plus' ? '+' : Math.random() > 0.5 ? '+' : '-');

        if (v === 'sub_concept_plus_logic') {
            const q = lang === 'sv' ? "Om det st√•r ett PLUSTECKEN (+) framf√∂r en parentes, √§ndras tecknen inuti n√§r du tar bort parentesen?" : "If there is a PLUS SIGN (+) in front of a pair of parentheses, do the signs inside change when you remove them?";
            const ans = lang === 'sv' ? "Nej, de f√∂rblir desamma" : "No, they stay the same";
            const wrong = lang === 'sv' ? "Ja, alla tecken √§ndras" : "Yes, all signs change";

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, wrong])
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Bara ett minustecken (-) framf√∂r parentesen tvingar oss att byta tecken p√• termerna inuti." : "Only a minus sign (-) in front of the parentheses forces us to change the signs of the terms inside." }],
                metadata: { variation_key: 'sub_concept_plus_logic', difficulty: 2 }
            };
        }

        const resX = startX - subX;
        const resOp = inOp === '+' ? '-' : '+';
        const ans = `${resX}x ${resOp} ${subK}`;

        return {
            renderData: {
                latex: `${startX}x - (${subX}x ${inOp} ${subK})`,
                description: lang === 'sv' ? "F√∂renkla uttrycket. Var extra noga med minustecknet framf√∂r parentesen!" : "Simplify the expression. Be extra careful with the minus sign in front of the parentheses!",
                answerType: 'text'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? `Eftersom det √§r minus framf√∂r parentesen √§ndras ${inOp} till ${resOp} n√§r parentesen tas bort.` : `Since there is a minus in front of the parentheses, ${inOp} changes to ${resOp} when the parentheses are removed.`, latex: `${startX}x - ${subX}x ${resOp} ${subK}` },
                { text: lang === 'sv' ? "F√∂renkla nu x-termerna." : "Now simplify the x-terms.", latex: `${startX}x - ${subX}x = ${resX}x` }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }

    // --- LEVEL 5: Word Problems ---
    private level5_WordProblems(lang: string, variationKey?: string): any {
        const scenarios = [
            'word_candy', 'word_discount', 'word_combined_age', 'word_combined_age_tri',
            'word_rect_perimeter', 'word_savings', 'word_passengers', 'word_garden',
            'word_sports', 'word_phone_battery'
        ];
        const v = variationKey || MathUtils.randomChoice(scenarios);

        const A = MathUtils.randomInt(2, 5);  
        const B = MathUtils.randomInt(10, 50); 
        const C = MathUtils.randomInt(2, 5);  

        let description = "";
        let answer = "";
        let steps = [];

        if (v === 'word_candy') {
            description = lang === 'sv' 
                ? `Du har ${A} p√•sar med godis d√§r varje p√•se inneh√•ller x bitar. Du k√∂per sedan ${C} likadana p√•sar till, men √§ter upp ${B} stycken l√∂sa godisar. Skriv ett f√∂renklat uttryck f√∂r totalt antal godisar.` 
                : `You have ${A} bags of candy where each bag contains x pieces. You then buy ${C} more identical bags, but you eat ${B} loose candies. Write a simplified expression for the total number of candies.`;
            answer = `${A+C}x - ${B}`;
            steps = [
                { text: lang === 'sv' ? `Steg 1: R√§kna ihop alla p√•sar med x bitar.` : `Step 1: Add up all the bags with x pieces.`, latex: `${A}x + ${C}x = ${A+C}x` },
                { text: lang === 'sv' ? `Steg 2: Dra ifr√•n de ${B} godisarna du √•t upp.` : `Step 2: Subtract the ${B} candies you ate.`, latex: `${A+C}x - ${B}` }
            ];
        } 
        else if (v === 'word_discount') {
            description = lang === 'sv'
                ? `Du k√∂per ${A} tr√∂jor som kostar x kr styck. Du hittar √§ven en jacka som kostar ${B} kr mer √§n en tr√∂ja. Skriv ett f√∂renklat uttryck f√∂r din totala kostnad.`
                : `You buy ${A} shirts that cost x kr each. You also find a jacket that costs ${B} kr more than a shirt. Write a simplified expression for your total cost.`;
            answer = `${A+1}x + ${B}`;
            steps = [
                { text: lang === 'sv' ? `Tr√∂jorna kostar ${A}x. Jackan kostar (x + ${B}).` : `The shirts cost ${A}x. The jacket costs (x + ${B}).`, latex: `${A}x + (x + ${B})` },
                { text: lang === 'sv' ? "F√∂renkla genom att l√§gga ihop alla x." : "Simplify by adding all x's together.", latex: `${A+1}x + ${B}` }
            ];
        }
        else if (v === 'word_combined_age_tri') {
            const diff = MathUtils.randomInt(2, 6);
            description = lang === 'sv'
                ? `Elias √§r x √•r. Hans syster √§r ${diff} √•r √§ldre √§n Elias, och deras pappa √§r tre g√•nger s√• gammal som Elias. Skriv ett f√∂renklat uttryck f√∂r deras sammanlagda √•lder.`
                : `Elias is x years old. His sister is ${diff} years older than Elias, and their father is three times as old as Elias. Write a simplified expression for their combined age.`;
            answer = `5x + ${diff}`;
            steps = [
                { text: lang === 'sv' ? `Elias: x. Syster: (x + ${diff}). Pappa: 3x.` : `Elias: x. Sister: (x + ${diff}). Father: 3x.`, latex: `x + (x + ${diff}) + 3x` },
                { text: lang === 'sv' ? "Addera alla x-termer: 1 + 1 + 3 = 5." : "Add all the x-terms: 1 + 1 + 3 = 5.", latex: `5x + ${diff}` }
            ];
        }
        else if (v === 'word_rect_perimeter') {
            const isShorter = Math.random() > 0.5;
            const diff = MathUtils.randomInt(2, 10);
            description = lang === 'sv'
                ? `En rektangel har bredden x cm. L√§ngden √§r ${diff} cm ${isShorter ? 'kortare' : 'l√§ngre'} √§n bredden. Skriv ett f√∂renklat uttryck f√∂r rektangelns omkrets.`
                : `A rectangle has a width of x cm. The length is ${diff} cm ${isShorter ? 'shorter' : 'longer'} than the width. Write a simplified expression for the rectangle's perimeter.`;
            answer = isShorter ? `4x - ${diff * 2}` : `4x + ${diff * 2}`;
            steps = [
                { text: lang === 'sv' ? "Omkretsen √§r summan av fyra sidor: tv√• bredder (x) och tv√• l√§ngder (x " + (isShorter ? '-' : '+') + " " + diff + ")." : "The perimeter is the sum of four sides: two widths (x) and two lengths (x " + (isShorter ? '-' : '+') + " " + diff + ").", latex: `2(x) + 2(x ${isShorter ? '-' : '+'} ${diff})` },
                { text: lang === 'sv' ? "Expandera och f√∂renkla resultatet." : "Expand and simplify the result.", latex: `${answer}` }
            ];
        }
        else if (v === 'word_passengers') {
            const off = MathUtils.randomInt(5, 15);
            description = lang === 'sv'
                ? `En buss har x passagerare. Vid f√∂rsta h√•llplatsen g√•r ${off} personer av. Vid n√§sta h√•llplats g√•r ${A} g√•nger s√• m√•nga som ursprungligen var p√• bussen (x) p√•. Skriv ett uttryck f√∂r antalet passagerare nu.`
                : `A bus has x passengers. At the first stop, ${off} people get off. At the next stop, ${A} times as many people as were originally on the bus (x) get on. Write an expression for the number of passengers now.`;
            answer = `${A+1}x - ${off}`;
            steps = [
                { text: lang === 'sv' ? `B√∂rja med x. Ta bort ${off} och l√§gg till ${A}x.` : `Start with x. Remove ${off} and add ${A}x.`, latex: `x - ${off} + ${A}x` },
                { text: lang === 'sv' ? "Kombinera x-termerna." : "Combine the x-terms.", latex: `${A+1}x - ${off}` }
            ];
        }
        else if (v === 'word_savings') {
            description = lang === 'sv'
                ? `Du har x kr p√• ett konto. Du tar ut ${B} kr f√∂r att fika. Senare s√§tter du in dubbelt s√• mycket som du hade fr√•n b√∂rjan (x). Skriv ett f√∂renklat uttryck f√∂r ditt nya saldo.`
                : `You have x kr in an account. You withdraw ${B} kr for coffee. Later, you deposit twice as much as you originally had (x). Write a simplified expression for your new balance.`;
            answer = `3x - ${B}`;
            steps = [
                { text: lang === 'sv' ? `Saldo-f√∂r√§ndring: x - ${B} + 2x.` : `Balance change: x - ${B} + 2x.`, latex: `3x - ${B}` }
            ];
        }
        else if (v === 'word_phone_battery') {
            const usage = MathUtils.randomInt(10, 30);
            description = lang === 'sv'
                ? `Din telefon har x% batteri. Du anv√§nder telefonen s√• att niv√•n sjunker med ${usage} procentenheter. Sedan laddar du den s√• att den √∂kar med ${A}x procentenheter. Skriv ett f√∂renklat uttryck f√∂r batteriniv√•n.`
                : `Your phone has x% battery. You use the phone so the level drops by ${usage} percentage points. Then you charge it so it increases by ${A}x percentage points. Write a simplified expression for the battery level.`;
            answer = `${A+1}x - ${usage}`;
            steps = [
                { text: lang === 'sv' ? `Starta med x, dra bort ${usage} och l√§gg till ${A}x.` : `Start with x, subtract ${usage}, and add ${A}x.`, latex: `x - ${usage} + ${A}x` }
            ];
        }
        else {
            // Default: word_garden
            const died = MathUtils.randomInt(3, 8);
            description = lang === 'sv'
                ? `I en tr√§dg√•rd finns x blommor. Tyv√§rr vissnar ${died} stycken bort. Sedan planterar du ${C} rader med x blommor i varje rad. Skriv ett f√∂renklat uttryck f√∂r totalt antal blommor.`
                : `In a garden there are x flowers. Unfortunately, ${died} of them wither away. Then you plant ${C} rows with x flowers in each row. Write a simplified expression for the total number of flowers.`;
            answer = `${C+1}x - ${died}`;
            steps = [
                { text: lang === 'sv' ? `B√∂rja med x. Dra bort ${died} och l√§gg till ${C}x blommor.` : `Start with x. Subtract ${died} and add ${C}x flowers.`, latex: `x - ${died} + ${C}x` }
            ];
        }

        return {
            renderData: {
                latex: "",
                description: description,
                answerType: 'text'
            },
            token: this.toBase64(answer),
            clues: steps,
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    private level6_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 5);
        const data = this.generate(lvl, lang);
        data.metadata.mixed = true;
        return data;
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\FractionArithGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionArithGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SameDenom(lang);
            case 2: return this.level2_DiffDenom(lang);
            case 3: return this.level3_MixedNumbers(lang);
            case 4: return this.level4_Multiplication(lang);
            case 5: return this.level5_Division(lang);
            default: return this.level1_SameDenom(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'add_concept':
            case 'add_missing':
            case 'add_calc':
                return this.level1_SameDenom(lang, key);
            
            case 'lcd_find':
            case 'add_error_spot':
            case 'add_diff_denom':
                return this.level2_DiffDenom(lang, key);
            
            case 'mixed_est':
            case 'mixed_add_same':
            case 'mixed_add_diff':
            case 'mixed_sub_same':
            case 'mixed_sub_diff':
                return this.level3_MixedNumbers(lang, key);
            
            case 'mult_scaling':
            case 'mult_area':
            case 'mult_calc':
                return this.level4_Multiplication(lang, key);
            
            case 'div_operator':
            case 'div_reciprocal':
            case 'div_calc':
                return this.level5_Division(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return MathUtils.gcd(a, b);
    }

    private lcm(a: number, b: number): number {
        return (a * b) / this.gcd(a, b);
    }

    private simplify(n: number, d: number): { n: number, d: number } {
        const div = this.gcd(n, d);
        return { n: n / div, d: d / div };
    }

    // --- LEVEL 1: SAME DENOMINATORS ---
    private level1_SameDenom(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['add_concept', 'add_missing', 'add_calc']);

        if (v === 'add_concept') {
            const d = MathUtils.randomInt(4, 9);
            const n1 = MathUtils.randomInt(1, 3);
            const n2 = MathUtils.randomInt(1, 3);
            const sum = n1 + n2;
            
            const correctEq = `\\frac{${n1}}{${d}} + \\frac{${n2}}{${d}} = \\frac{${sum}}{${d}}`;
            const lieType = Math.random() > 0.5 ? 'add_denoms' : 'wrong_numerators';
            const wrongEq = lieType === 'add_denoms' 
                ? `\\frac{${n1}}{${d}} + \\frac{${n2}}{${d}} = \\frac{${sum}}{${d + d}}`
                : `\\frac{${n1}}{${d}} + \\frac{${n2}}{${d}} = \\frac{${n1}}{${d}}`; 
            
            const isCorrectA = Math.random() > 0.5;
            const optCorrect = isCorrectA 
                ? (lang === 'sv' ? "Alternativ A" : "Option A")
                : (lang === 'sv' ? "Alternativ B" : "Option B");

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilken av de tv√• utr√§kningarna nedan f√∂ljer reglerna f√∂r br√•kr√§kning?" : "Which calculation below follows the proper rules of fractions?",
                    latex: `\\text{A: } ${isCorrectA ? correctEq : wrongEq} \\quad \\text{B: } ${isCorrectA ? wrongEq : correctEq}`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([optCorrect, isCorrectA ? (lang === 'sv' ? "Alternativ B" : "Option B") : (lang === 'sv' ? "Alternativ A" : "Option A")])
                },
                token: this.toBase64(optCorrect),
                clues: [{ text: lang === 'sv' ? "Kom ih√•g: N√§r vi adderar br√•k med samma n√§mnare l√§gger vi bara ihop t√§ljarna. N√§mnaren f√∂rblir densamma." : "Remember: When adding fractions with the same denominator, we only add the numerators. The denominator remains the same." }],
                metadata: { variation_key: 'add_concept', difficulty: 1 }
            };
        }

        const den = MathUtils.randomInt(4, 15);
        const n1 = MathUtils.randomInt(1, den - 2);
        const n2 = MathUtils.randomInt(1, den - n1 - 1) || 1;
        const simp = this.simplify(n1 + n2, den);

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna summan av br√•ken och svara i enklaste form." : "Calculate the sum of the fractions and answer in simplest form.",
                latex: `\\frac{${n1}}{${den}} + \\frac{${n2}}{${den}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [{ text: lang === 'sv' ? `Addera t√§ljarna: $${n1} + ${n2} = ${n1+n2}$. Beh√•ll n√§mnaren $${den}$.` : `Add the numerators: $${n1} + ${n2} = ${n1+n2}$. Keep the denominator $${den}$.`, latex: `\\frac{${n1+n2}}{${den}}` }],
            metadata: { variation_key: 'add_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: DIFFERENT DENOMINATORS ---
    private level2_DiffDenom(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['lcd_find', 'add_error_spot', 'add_diff_denom']);

        if (v === 'add_error_spot') {
            const isActuallyCorrect = Math.random() > 0.5;
            const d1 = MathUtils.randomInt(2, 4);
            const d2 = MathUtils.randomInt(d1 + 1, 5);
            const lcd = this.lcm(d1, d2);
            const resN = (lcd / d1) + (lcd / d2);
            const equation = isActuallyCorrect 
                ? `\\frac{1}{${d1}} + \\frac{1}{${d2}} = \\frac{${resN}}{${lcd}}`
                : `\\frac{1}{${d1}} + \\frac{1}{${d2}} = \\frac{2}{${d1 + d2}}`;

            const ans = isActuallyCorrect ? (lang === 'sv' ? "R√§tt" : "Correct") : (lang === 'sv' ? "Fel" : "Wrong");

            return {
                renderData: {
                    description: lang === 'sv' ? "Granska utr√§kningen nedan. √Ñr den korrekt utf√∂rd?" : "Review the calculation below. Is it correctly performed?",
                    latex: equation,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["R√§tt", "Fel"] : ["Correct", "Wrong"]
                },
                token: this.toBase64(ans),
                clues: [{ text: isActuallyCorrect ? (lang === 'sv' ? "Korrekt! Br√•ken har f√•tt en gemensam n√§mnare innan additionen." : "Correct! The fractions were given a common denominator before addition.") : (lang === 'sv' ? "Felaktigt. Man kan aldrig addera n√§mnarna direkt." : "Incorrect. You can never add the denominators directly.") }],
                metadata: { variation_key: 'add_error_spot', difficulty: 2 }
            };
        }

        const d1 = MathUtils.randomInt(2, 5);
        const d2 = MathUtils.randomInt(2, 5);
        if (d1 === d2) return this.level2_DiffDenom(lang, v);
        const lcd = this.lcm(d1, d2);
        const simp = this.simplify(lcd/d1 + lcd/d2, lcd);

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna summan genom att f√∂rst hitta en gemensam n√§mnare." : "Calculate the sum by first finding a common denominator.",
                latex: `\\frac{1}{${d1}} + \\frac{1}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [
                { text: lang === 'sv' ? `F√∂rl√§ng br√•ken s√• de b√•da f√•r n√§mnaren $${lcd}$.` : `Extend the fractions so they both have the denominator $${lcd}$.`, latex: `\\frac{${lcd/d1}}{${lcd}} + \\frac{${lcd/d2}}{${lcd}}` }
            ],
            metadata: { variation_key: 'add_diff_denom', difficulty: 3 }
        };
    }

    // --- LEVEL 3: MIXED NUMBERS ---
    private level3_MixedNumbers(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mixed_add_same', 'mixed_add_diff', 'mixed_sub_same', 'mixed_sub_diff']);
        const isSub = v.includes('_sub');
        const isDiff = v.includes('_diff');

        // Randomized values with subtraction safety
        let w1 = MathUtils.randomInt(3, 7);
        let w2 = MathUtils.randomInt(1, 2);
        let d1 = MathUtils.randomChoice([2, 3, 4, 5]);
        let d2 = isDiff ? MathUtils.randomChoice([2, 3, 4, 5].filter(x => x !== d1)) : d1;
        let n1 = MathUtils.randomInt(1, d1 - 1);
        let n2 = MathUtils.randomInt(1, d2 - 1);

        // Logic check: Ensure answer > 0 and Whole number > 0
        const val1 = w1 + n1 / d1;
        const val2 = w2 + n2 / d2;
        if (isSub && (val1 - val2 < 1)) return this.level3_MixedNumbers(lang, v);

        // Step 1: Improper conversions
        const imp1N = w1 * d1 + n1;
        const imp2N = w2 * d2 + n2;

        // Step 2: Common Denominator
        const commonD = this.lcm(d1, d2);
        const k1 = commonD / d1;
        const k2 = commonD / d2;
        const adjN1 = imp1N * k1;
        const adjN2 = imp2N * k2;

        // Step 3: Operation
        const resN = isSub ? adjN1 - adjN2 : adjN1 + adjN2;
        const finalW = Math.floor(resN / commonD);
        const finalN = resN % commonD;
        const finalAns = finalN === 0 ? `${finalW}` : `${finalW} ${finalN}/${commonD}`;

        const opSym = isSub ? "-" : "+";
        const opWord = isSub ? (lang === 'sv' ? "subtraktionen" : "subtraction") : (lang === 'sv' ? "additionen" : "addition");

        const steps = [
            {
                text: lang === 'sv' 
                    ? `Steg 1: G√∂r om det f√∂rsta talet till br√•kform genom att ber√§kna $(${w1} \\cdot ${d1}) + ${n1}$.` 
                    : `Step 1: Convert the first number to an improper fraction by calculating $(${w1} \\cdot ${d1}) + ${n1}$.`,
                latex: `${w1}\\frac{${n1}}{${d1}} = \\frac{${w1} \\cdot ${d1} + ${n1}}{${d1}} = \\frac{${imp1N}}{${d1}}`
            },
            {
                text: lang === 'sv' 
                    ? `Steg 2: G√∂r samma sak med det andra talet genom att ber√§kna $(${w2} \\cdot ${d2}) + ${n2}$.` 
                    : `Step 2: Convert the second number to an improper fraction by calculating $(${w2} \\cdot ${d2}) + ${n2}$.`,
                latex: `${w2}\\frac{${n2}}{${d2}} = \\frac{${w2} \\cdot ${d2} + ${n2}}{${d2}} = \\frac{${imp2N}}{${d2}}`
            }
        ];

        if (isDiff) {
            steps.push({
                text: lang === 'sv' 
                    ? `Steg 3: Hitta gemensam n√§mnare ($${commonD}$). Multiplicera t√§ljare och n√§mnare i b√•da br√•ken s√• de f√•r samma botten.` 
                    : `Step 3: Find a common denominator ($${commonD}$). Multiply the numerator and denominator of both fractions to get the same base.`,
                latex: `\\frac{${imp1N} \\cdot ${k1}}{${d1} \\cdot ${k1}} = \\frac{${adjN1}}{${commonD}}, \\quad \\frac{${imp2N} \\cdot ${k2}}{${d2} \\cdot ${k2}} = \\frac{${adjN2}}{${commonD}}`
            });
        }

        steps.push({
            text: lang === 'sv' 
                ? `Steg ${isDiff ? '4' : '3'}: Ber√§kna ${isSub ? 'skillnaden' : 'summan'} och omvandla sedan tillbaka till blandad form.` 
                : `Step ${isDiff ? '4' : '3'}: Calculate the ${isSub ? 'difference' : 'sum'} and then convert back to mixed form.`,
            latex: `\\frac{${adjN1} ${opSym} ${adjN2}}{${commonD}} = \\frac{${resN}}{${commonD}} = ${finalAns}`
        });

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna ${opWord} och svara i blandad form.` : `Calculate the ${opWord} and answer in mixed form.`,
                latex: `${w1}\\frac{${n1}}{${d1}} ${opSym} ${w2}\\frac{${n2}}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(finalAns),
            clues: steps,
            metadata: { variation_key: v, difficulty: isDiff ? 4 : 3 }
        };
    }

    // --- LEVEL 4: MULTIPLICATION ---
    private level4_Multiplication(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_scaling', 'mult_calc']);

        if (v === 'mult_scaling') {
            const int = MathUtils.randomChoice([10, 20, 50]);
            const fracD = MathUtils.randomChoice([2, 4, 5]);
            const ans = lang === 'sv' ? "Mindre" : "Smaller";

            return {
                renderData: {
                    description: lang === 'sv' ? `Om du multiplicerar ${int} med $\\frac{1}{${fracD}}$, blir resultatet st√∂rre eller mindre √§n ${int}?` : `If you multiply ${int} by $\\frac{1}{${fracD}}$, will the result be larger or smaller than ${int}?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["St√∂rre", "Mindre"] : ["Larger", "Smaller"]
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? `Att multiplicera med ett br√•k mindre √§n 1 (som $\\frac{1}{${fracD}}$) √§r som att dela upp talet i bitar. D√§rf√∂r minskar v√§rdet.` : `Multiplying by a fraction less than 1 (like $\\frac{1}{${fracD}}$) is like splitting the number into pieces. Therefore, the value decreases.` }],
                metadata: { variation_key: 'mult_scaling', difficulty: 2 }
            };
        }

        const n1 = MathUtils.randomInt(1, 3), d1 = MathUtils.randomInt(4, 6);
        const n2 = MathUtils.randomInt(1, 3), d2 = MathUtils.randomInt(4, 6);
        const simp = this.simplify(n1 * n2, d1 * d2);

        return {
            renderData: {
                description: lang === 'sv' ? "Multiplicera br√•ken med varandra." : "Multiply the fractions together.",
                latex: `\\frac{${n1}}{${d1}} \\cdot \\frac{${n2}}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [{ text: lang === 'sv' ? "Multiplicera t√§ljarna f√∂r sig och n√§mnarna f√∂r sig." : "Multiply the numerators together and the denominators together.", latex: `\\frac{${n1} \\cdot ${n2}}{${d1} \\cdot ${d2}}` }],
            metadata: { variation_key: 'mult_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 5: DIVISION ---
    private level5_Division(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['div_reciprocal', 'div_calc']);

        if (v === 'div_reciprocal') {
            const n = MathUtils.randomInt(2, 5), d = MathUtils.randomInt(6, 9);
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket br√•k √§r det inverterade talet (reciproka v√§rdet) till br√•ket nedan?` : `Which fraction is the reciprocal of the fraction below?`,
                    latex: `\\frac{${n}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${d}/${n}`),
                clues: [{ text: lang === 'sv' ? "F√∂r att invertera ett br√•k byter du helt enkelt plats p√• siffran d√§r uppe och siffran d√§r nere." : "To invert a fraction, you simply swap the top number and the bottom number." }],
                metadata: { variation_key: 'div_reciprocal', difficulty: 2 }
            };
        }

        const d1 = MathUtils.randomInt(3, 8), d2 = MathUtils.randomInt(2, 4);
        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna kvoten genom att multiplicera med det inverterade br√•ket." : "Calculate the quotient by multiplying with the reciprocal.",
                latex: `\\frac{1}{${d1}} \\div \\frac{1}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${d2}/${d1}`),
            clues: [{ text: lang === 'sv' ? "V√§nd p√• det andra br√•ket och √§ndra divisionen till multiplikation." : "Flip the second fraction and change the division to multiplication.", latex: `\\frac{1}{${d1}} \\cdot \\frac{${d2}}{1}` }],
            metadata: { variation_key: 'div_calc', difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\FractionArithGen.ts

// =======================================================
// FILE START: src\core\generators\FractionBasicsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionBasicsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_PartsOfQuantity(lang);
            case 3: return this.level3_MixedImproper(lang);
            case 4: return this.level4_SimplifyExtend(lang);
            case 5: return this.level5_Decimals(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Maps specific mastery buckets to internal randomized generators.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'visual_lie':
            case 'visual_inverse':
            case 'visual_calc':
                return this.level1_Visuals(lang, key);
            
            case 'part_inverse':
            case 'part_compare':
            case 'part_calc':
                return this.level2_PartsOfQuantity(lang, key);
            
            case 'mixed_bounds':
            case 'mixed_missing':
            case 'mixed_convert_imp':
            case 'mixed_convert_mix':
                return this.level3_MixedImproper(lang, key);
            
            case 'simplify_missing':
            case 'simplify_concept':
            case 'simplify_calc':
                return this.level4_SimplifyExtend(lang, key);
            
            case 'decimal_inequality':
            case 'decimal_to_dec':
            case 'decimal_to_frac':
                return this.level5_Decimals(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return MathUtils.gcd(a, b);
    }

    // --- LEVEL 1: VISUAL CONCEPTS ---
    private level1_Visuals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['visual_lie', 'visual_inverse', 'visual_calc']);

        // VARIATION A: Spot the Lie (Percent Grid)
        if (v === 'visual_lie') {
            const p = MathUtils.randomChoice([10, 20, 25, 40, 50, 60, 75, 80, 90]);
            const div = this.gcd(p, 100);
            const simpleN = p / div;
            const simpleD = 100 / div;

            const statementPercent = `${p}%`;
            const statementFraction = `${simpleN}/${simpleD}`;
            
            let statementFalse = "";
            if (p < 50) {
                statementFalse = lang === 'sv' ? "Mer √§n h√§lften" : "More than half";
            } else if (p === 50) {
                statementFalse = lang === 'sv' ? "Mindre √§n 1/4" : "Less than 1/4";
            } else {
                statementFalse = lang === 'sv' ? "Mindre √§n h√§lften" : "Less than half";
            }

            const options = MathUtils.shuffle([statementPercent, statementFraction, statementFalse]);

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? "Studera figuren nedan noga. Vilket av p√•st√•endena om den f√§rgade andelen √§r FALSKT?" 
                        : "Study the figure below carefully. Which statement about the colored part is FALSE?",
                    answerType: 'multiple_choice',
                    options: options,
                    geometry: { type: 'percent_grid', total: 100, colored: p }
                },
                token: this.toBase64(statementFalse),
                clues: [
                    { text: lang === 'sv' ? "Hela rutn√§tet best√•r av 100 rutor. H√§lften av 100 √§r 50 rutor." : "The whole grid consists of 100 squares. Half of 100 is 50 squares.", latex: "\\frac{50}{100} = 50\\%" },
                    { text: lang === 'sv' ? `R√§kna antalet f√§rgade rutor. Det √§r ${p} stycken. J√§mf√∂r detta antal med de olika p√•st√•endena.` : `Count the number of colored squares. There are ${p}. Compare this count with the different statements.`, latex: "" }
                ],
                metadata: { variation_key: 'visual_lie', difficulty: 1 }
            };
        }

        // VARIATION B: Inverse Logic (Word Problem)
        if (v === 'visual_inverse') {
            const fractionD = MathUtils.randomInt(3, 8);
            const countPerPart = MathUtils.randomInt(2, 6);
            const total = countPerPart * fractionD;
            
            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Du har en samling med ${total} kulor. Om exakt 1/${fractionD} av dem √§r r√∂da, hur m√•nga r√∂da kulor har du d√•?`
                        : `You have a collection of ${total} marbles. If exactly 1/${fractionD} of them are red, how many red marbles do you have?`,
                    answerType: 'numeric',
                    geometry: null 
                },
                token: this.toBase64(countPerPart.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `Att s√∂ka 1/${fractionD} inneb√§r att du delar upp hela antalet i ${fractionD} lika stora grupper.` : `Finding 1/${fractionD} means you divide the whole number into ${fractionD} equal groups.`, 
                        latex: `\\frac{${total}}{${fractionD}} = ${countPerPart}` 
                    }
                ],
                metadata: { variation_key: 'visual_inverse', difficulty: 2 }
            };
        }

        // VARIATION C: Standard Visuals (Marbles)
        const red = MathUtils.randomInt(1, 5);
        const blue = MathUtils.randomInt(1, 5);
        const green = MathUtils.randomInt(1, 5);
        const totalItems = red + blue + green;
        const target = MathUtils.randomChoice(['red', 'blue', 'green']);
        
        let count = 0;
        let colorName = "";
        if (target === 'red') { count = red; colorName = lang === 'sv' ? 'r√∂da' : 'red'; }
        else if (target === 'blue') { count = blue; colorName = lang === 'sv' ? 'bl√•a' : 'blue'; }
        else { count = green; colorName = lang === 'sv' ? 'gr√∂na' : 'green'; }

        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Hur stor andel av kulorna i beh√•llaren √§r ${colorName}? Svara i br√•kform.` 
                    : `What fraction of the marbles in the container are ${colorName}? Answer as a fraction.`,
                answerType: 'fraction',
                geometry: { type: 'probability_marbles', items: { red, blue, green } }
            },
            token: this.toBase64(`${count}/${totalItems}`),
            clues: [
                { text: lang === 'sv' ? `R√§kna antalet ${colorName} kulor (${count}) och dela det med det totala antalet kulor i beh√•llaren (${totalItems}).` : `Count the number of ${colorName} marbles (${count}) and divide it by the total number of marbles in the container (${totalItems}).`, latex: `\\frac{\\text{Andel ${colorName}}}{\\text{Totalt antal}}` }
            ],
            metadata: { variation_key: 'visual_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: PARTS OF QUANTITY ---
    private level2_PartsOfQuantity(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['part_inverse', 'part_compare', 'part_calc']);

        if (v === 'part_inverse') {
            const denom = MathUtils.randomChoice([3, 4, 5, 8, 10]);
            const partValue = MathUtils.randomChoice([5, 10, 20, 25, 50, 100]);
            const total = partValue * denom;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Om 1/${denom} av ett totalt belopp motsvarar ${partValue} kr, hur mycket √§r d√• hela beloppet v√§rt?`
                        : `If 1/${denom} of a total amount corresponds to ${partValue} kr, how much is the entire amount worth?`,
                    answerType: 'numeric',
                    suffix: 'kr'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `Eftersom en av ${denom} delar √§r ${partValue} kr, m√•ste vi multiplicera delens v√§rde med antalet delar f√∂r att f√• helheten.` : `Since one of ${denom} parts is ${partValue} kr, we must multiply the part's value by the number of parts to get the whole.`,
                        latex: `${partValue} \\cdot ${denom} = ${total}` 
                    }
                ],
                metadata: { variation_key: 'part_inverse', difficulty: 2 }
            };
        }

        if (v === 'part_compare') {
            const d1 = MathUtils.randomInt(2, 5);
            const mult1 = MathUtils.randomInt(2, 6);
            const t1 = d1 * mult1;
            
            const d2 = MathUtils.randomInt(2, 5);
            const mult2 = MathUtils.randomInt(2, 6);
            const t2 = d2 * mult2;

            if (mult1 === mult2) return this.level2_PartsOfQuantity(lang, v);

            const isFirstLarger = mult1 > mult2;
            const winningOpt = isFirstLarger 
                ? `1/${d1} ${lang==='sv'?'av':'of'} ${t1}`
                : `1/${d2} ${lang==='sv'?'av':'of'} ${t2}`;
            const losingOpt = isFirstLarger
                ? `1/${d2} ${lang==='sv'?'av':'of'} ${t2}`
                : `1/${d1} ${lang==='sv'?'av':'of'} ${t1}`;

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av alternativen nedan representerar det st√∂rsta v√§rdet?" : "Which of the options below represents the largest value?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([winningOpt, losingOpt])
                },
                token: this.toBase64(winningOpt),
                clues: [
                    { text: lang === 'sv' ? "Ber√§kna v√§rdet f√∂r varje alternativ genom att dela talet med n√§mnaren." : "Calculate the value for each option by dividing the number by the denominator.", latex: `${t1} / ${d1} = ${mult1} \\quad \\text{vs} \\quad ${t2} / ${d2} = ${mult2}` }
                ],
                metadata: { variation_key: 'part_compare', difficulty: 2 }
            };
        }

        const denom = MathUtils.randomChoice([3, 4, 5, 6, 8, 10]);
        const mult = MathUtils.randomInt(2, 12);
        const total = denom * mult;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna hur stor del av talet som andelen motsvarar." : "Calculate how large a part of the number the fraction represents.",
                latex: `\\frac{1}{${denom}} \\text{ ${lang==='sv'?'av':'of'} } ${total}`,
                answerType: 'numeric'
            },
            token: this.toBase64(mult.toString()),
            clues: [
                { text: lang === 'sv' ? "Dela helheten med n√§mnaren f√∂r att ta reda p√• vad en del √§r v√§rd." : "Divide the whole by the denominator to find out what one part is worth.", latex: `\\frac{${total}}{${denom}} = ${mult}` }
            ],
            metadata: { variation_key: 'part_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 3: MIXED & IMPROPER ---
    private level3_MixedImproper(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mixed_bounds', 'mixed_missing', 'mixed_convert_imp', 'mixed_convert_mix']);

        if (v === 'mixed_bounds') {
            const w = MathUtils.randomInt(2, 6);
            const den = MathUtils.randomInt(3, 8);
            const num = MathUtils.randomInt(1, den - 1);
            const improper = w * den + num; 
            const isGreater = Math.random() > 0.5;
            const compareVal = isGreater ? w : w + 1; 
            
            const correctAnswer = (improper/den > compareVal) ? (lang==='sv'?'Ja':'Yes') : (lang==='sv'?'Nej':'No');
            const wrongAnswer = (improper/den > compareVal) ? (lang==='sv'?'Nej':'No') : (lang==='sv'?'Ja':'Yes');

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `√Ñr br√•ket nedan st√∂rre √§n heltalet ${compareVal}?` 
                        : `Is the improper fraction below greater than the integer ${compareVal}?`,
                    latex: `\\frac{${improper}}{${den}}`,
                    answerType: 'multiple_choice',
                    options: [correctAnswer, wrongAnswer]
                },
                token: this.toBase64(correctAnswer),
                clues: [
                    { 
                        text: lang === 'sv' ? `T√§nk p√• heltalet ${compareVal} som ett br√•k med n√§mnaren ${den}.` : `Think of the integer ${compareVal} as a fraction with the denominator ${den}.`,
                        latex: `${compareVal} = \\frac{${compareVal} \\cdot ${den}}{${den}} = \\frac{${compareVal*den}}{${den}}`
                    },
                    { text: lang === 'sv' ? `J√§mf√∂r t√§ljarna f√∂r att se vilket br√•k som √§r st√∂rst.` : `Compare the numerators to see which fraction is largest.`, latex: `${improper} \\text{ vs } ${compareVal*den}` }
                ],
                metadata: { variation_key: 'mixed_bounds', difficulty: 2 }
            };
        }

        if (v === 'mixed_missing') {
            const w = MathUtils.randomInt(1, 5);
            const d = MathUtils.randomInt(3, 9);
            const n = MathUtils.randomInt(1, d - 1);
            const imp = w * d + n;

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket tal saknas i t√§ljaren f√∂r att likheten ska st√§mma?" : "What number is missing in the numerator for the equality to be correct?",
                    latex: `${w}\\frac{?}{${d}} = \\frac{${imp}}{${d}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(n.toString()),
                clues: [
                    { text: lang === 'sv' ? `Ett heltal (${w}) motsvarar ${w} g√•nger n√§mnaren (${d}) i delar.` : `A whole number (${w}) corresponds to ${w} times the denominator (${d}) in parts.`, latex: `${w} \\cdot ${d} = ${w*d}` },
                    { text: lang === 'sv' ? `R√§kna ut skillnaden mellan totala antalet delar (${imp}) och heltalets delar.` : `Calculate the difference between the total number of parts (${imp}) and the whole number's parts.`, latex: `${imp} - ${w*d} = ${n}` }
                ],
                metadata: { variation_key: 'mixed_missing', difficulty: 2 }
            };
        }

        const isToImp = v === 'mixed_convert_imp' || (v === undefined && Math.random() > 0.5);
        const w = MathUtils.randomInt(1, 6);
        const d = MathUtils.randomInt(3, 9);
        const n = MathUtils.randomInt(1, d - 1);
        const imp = w * d + n;

        if (isToImp) {
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv om det blandade talet till br√•kform (osammansatt form)." : "Rewrite the mixed number as an improper fraction.",
                    latex: `${w}\\frac{${n}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${imp}/${d}`),
                clues: [
                    { text: lang === 'sv' ? `Multiplicera heltalet (${w}) med n√§mnaren (${d}) och l√§gg sedan till t√§ljaren (${n}).` : `Multiply the whole number (${w}) by the denominator (${d}) and then add the numerator (${n}).`, latex: `(${w} \\cdot ${d}) + ${n} = ${imp}` }
                ],
                metadata: { variation_key: 'mixed_convert_imp', difficulty: 2 }
            };
        } else {
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv om fr√•n br√•kform till blandad form." : "Rewrite the improper fraction as a mixed number.",
                    latex: `\\frac{${imp}}{${d}}`,
                    answerType: 'mixed_fraction'
                },
                token: this.toBase64(`${w} ${n}/${d}`),
                clues: [
                    { text: lang === 'sv' ? `Se hur m√•nga hela g√•nger n√§mnaren g√•r i t√§ljaren f√∂r att f√• heltalet, och beh√•ll resten som t√§ljare.` : `See how many whole times the denominator fits into the numerator to get the whole number, and keep the remainder as the numerator.`, latex: `${imp} / ${d} = ${w} \\text{ rest } ${n}` }
                ],
                metadata: { variation_key: 'mixed_convert_mix', difficulty: 2 }
            };
        }
    }

    // --- LEVEL 4: SIMPLIFY & EXTEND ---
    private level4_SimplifyExtend(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['simplify_missing', 'simplify_concept', 'simplify_calc']);

        if (v === 'simplify_missing') {
            const baseN = MathUtils.randomInt(1, 5);
            const baseD = MathUtils.randomInt(baseN + 1, 9);
            const f = MathUtils.randomInt(2, 6);
            const targetD = baseD * f;
            const targetN = baseN * f; 

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket tal saknas i t√§ljaren f√∂r att de tv√• br√•ken ska ha samma v√§rde (vara likv√§rdiga)?" : "What number is missing in the numerator for the two fractions to have the same value (be equivalent)?",
                    latex: `\\frac{${baseN}}{${baseD}} = \\frac{?}{${targetD}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(targetN.toString()),
                clues: [
                    { text: lang === 'sv' ? `B√∂rja med att se vad n√§mnaren har multiplicerats med f√∂r att bli ${targetD}.` : `Start by seeing what the denominator has been multiplied by to become ${targetD}.`, latex: `${baseD} \\cdot ${f} = ${targetD}` },
                    { text: lang === 'sv' ? "G√∂r nu exakt samma sak med t√§ljaren." : "Now do exactly the same to the numerator.", latex: `${baseN} \\cdot ${f} = ${targetN}` }
                ],
                metadata: { variation_key: 'simplify_missing', difficulty: 3 }
            };
        }

        if (v === 'simplify_concept') {
            const k = MathUtils.randomInt(2, 5);
            const q = lang === 'sv' 
                ? `Vad h√§nder med ett br√•ks totala v√§rde om du multiplicerar b√•de t√§ljaren och n√§mnaren med ${k}?`
                : `What happens to a fraction's total value if you multiply both the numerator and the denominator by ${k}?`;
            const ans = lang === 'sv' ? "V√§rdet f√∂rblir detsamma" : "The value stays the same";
            const wrong = lang === 'sv' ? `V√§rdet blir ${k} g√•nger st√∂rre` : `The value becomes ${k} times larger`;

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, wrong, lang==='sv'?"V√§rdet minskar":"The value decreases"])
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Att f√∂rl√§nga eller f√∂rkorta ett br√•k √§ndrar bara hur m√•nga bitar vi ser, men inte den totala andelen." : "Extending or simplifying a fraction only changes how many pieces we see, but not the total share.", latex: "1/2 = 2/4 = 3/6" }
                ],
                metadata: { variation_key: 'simplify_concept', difficulty: 3 }
            };
        }

        const factor = MathUtils.randomInt(2, 5);
        const sn = MathUtils.randomInt(1, 5);
        const sd = MathUtils.randomInt(sn + 1, 10);
        if (this.gcd(sn, sd) !== 1) return this.level4_SimplifyExtend(lang, v);

        return {
            renderData: {
                description: lang === 'sv' ? "F√∂rkorta br√•ket s√• l√•ngt det g√•r genom att hitta den st√∂rsta gemensamma delaren." : "Simplify the fraction as much as possible by finding the greatest common divisor.",
                latex: `\\frac{${sn * factor}}{${sd * factor}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${sn}/${sd}`),
            clues: [
                { text: lang === 'sv' ? `Hitta ett tal som b√•de ${sn*factor} och ${sd*factor} kan delas med. H√§r kan b√•da delas med ${factor}.` : `Find a number that both ${sn*factor} and ${sd*factor} can be divided by. Here, both can be divided by ${factor}.`, latex: `\\frac{${sn*factor} / ${factor}}{${sd*factor} / ${factor}} = \\frac{${sn}}{${sd}}` }
            ],
            metadata: { variation_key: 'simplify_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 5: DECIMALS ---
    private level5_Decimals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['decimal_inequality', 'decimal_to_dec', 'decimal_to_frac']);

        if (v === 'decimal_inequality') {
            const d = MathUtils.randomChoice([2, 4, 5, 10]);
            const n = MathUtils.randomInt(1, d - 1);
            const fracVal = n / d;
            let compareDec = MathUtils.randomFloat(0.1, 0.9, 1);
            if (compareDec === fracVal) compareDec += 0.1;

            const correct = fracVal > compareDec ? ">" : "<";
            
            return {
                renderData: {
                    description: lang === 'sv' ? "V√§lj det tecken som g√∂r att p√•st√•endet nedan st√§mmer." : "Choose the sign that makes the statement below correct.",
                    latex: `\\frac{${n}}{${d}} \\text{ [ ? ] } ${compareDec.toString().replace('.', ',')}`,
                    answerType: 'multiple_choice',
                    options: [">", "<", "="]
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? `G√∂r om br√•ket till ett decimaltal f√∂r att kunna j√§mf√∂ra: ${n} delat med ${d}.` : `Convert the fraction to a decimal to be able to compare: ${n} divided by ${d}.`, latex: `\\frac{${n}}{${d}} = ${fracVal}` }
                ],
                metadata: { variation_key: 'decimal_inequality', difficulty: 3 }
            };
        }

        const pairs = [
            { f: "1/2", d: 0.5 }, { f: "1/4", d: 0.25 }, { f: "3/4", d: 0.75 },
            { f: "1/5", d: 0.2 }, { f: "2/5", d: 0.4 }, { f: "4/5", d: 0.8 },
            { f: "1/10", d: 0.1 }, { f: "7/10", d: 0.7 }
        ];
        const pair = MathUtils.randomChoice(pairs);
        const isToDec = v === 'decimal_to_dec';

        return {
            renderData: {
                description: lang === 'sv' 
                    ? (isToDec ? "Skriv br√•ket som ett decimaltal." : "Skriv decimaltalet som ett br√•k i dess enklaste form.") 
                    : (isToDec ? "Write the fraction as a decimal number." : "Write the decimal number as a fraction in its simplest form."),
                latex: isToDec ? pair.f : pair.d.toString().replace('.', ','),
                answerType: isToDec ? 'numeric' : 'fraction'
            },
            token: this.toBase64(isToDec ? pair.d.toString() : pair.f),
            clues: [
                { text: lang === 'sv' ? "Kom ih√•g positionssystemet. F√∂rsta decimalen √§r tiondelar, andra √§r hundradelar." : "Remember the place value system. The first decimal is tenths, the second is hundredths.", latex: "" }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\FractionBasicsGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class GeometryGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_PerimeterBasic(lang);
            case 2: return this.level2_AreaBasic(lang);
            case 3: return this.level3_Triangles(lang);
            case 4: return this.level4_CombinedFigures(lang);
            case 5: return this.level5_Circles(lang);
            case 6: return this.level6_CompositeAdvanced(lang);
            default: return this.level1_PerimeterBasic(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'perimeter_square':
            case 'perimeter_rect':
            case 'perimeter_parallel':
            case 'perimeter_inverse':
            case 'perimeter_lie':
                return this.level1_PerimeterBasic(lang, key);
            
            case 'area_square':
            case 'area_rect':
            case 'area_parallel':
            case 'area_inverse':
            case 'area_trap':
                return this.level2_AreaBasic(lang, key);
            
            case 'area_triangle':
            case 'inverse_triangle':
            case 'perimeter_triangle_right':
            case 'perimeter_triangle_iso':
            case 'perimeter_triangle_scalene':
                return this.level3_Triangles(lang, key);
            
            case 'combined_rect_tri':
            case 'combined_l_shape':
            case 'combined_house':
                return this.level4_CombinedFigures(lang, key);
            
            case 'circle_area':
            case 'circle_perimeter':
            case 'semicircle_area':
            case 'semicircle_perimeter':
            case 'area_quarter':
            case 'perimeter_quarter':
                return this.level5_Circles(lang, key);
            
            case 'perimeter_house':
            case 'perimeter_portal':
                return this.level6_CompositeAdvanced(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: PERIMETER BASIC ---
    private level1_PerimeterBasic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['perimeter_square', 'perimeter_rect', 'perimeter_parallel', 'perimeter_inverse', 'perimeter_lie']);
        
        if (v === 'perimeter_square') {
            const s = MathUtils.randomInt(3, 15);
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' ? `En kvadrat har en sida som √§r ${s} cm l√•ng. Ber√§kna kvadratens omkrets.` : `A square has a side that is ${s} cm long. Calculate the perimeter of the square.`,
                    answerType: 'numeric'
                },
                token: this.toBase64((4 * s).toString()),
                clues: [{ text: lang === 'sv' ? "En kvadrat har fyra sidor som alla √§r precis lika l√•nga. Omkretsen √§r summan av dessa sidor." : "A square has four sides that are all exactly the same length. The perimeter is the sum of these sides.", latex: `O = 4 \\cdot ${s}` }],
                metadata: { variation_key: 'perimeter_square', difficulty: 1 }
            };
        }

        if (v === 'perimeter_rect') {
            const b = MathUtils.randomInt(5, 15), h = MathUtils.randomInt(3, 10);
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: b, height: h, labels: { b: b, h: h } },
                    description: lang === 'sv' ? `En rektangel har basen ${b} cm och h√∂jden ${h} cm. Vad √§r rektangelns omkrets?` : `A rectangle has a base of ${b} cm and a height of ${h} cm. What is the perimeter of the rectangle?`,
                    answerType: 'numeric'
                },
                token: this.toBase64((2 * (b + h)).toString()),
                clues: [{ text: lang === 'sv' ? "Omkretsen √§r v√§gen runt hela figuren. En rektangel har tv√• baser och tv√• h√∂jder." : "Perimeter is the path around the entire figure. A rectangle has two bases and two heights.", latex: `O = ${b} + ${h} + ${b} + ${h}` }],
                metadata: { variation_key: 'perimeter_rect', difficulty: 1 }
            };
        }

        if (v === 'perimeter_inverse') {
            const w = MathUtils.randomInt(4, 10), h = MathUtils.randomInt(3, 8);
            const perim = 2 * (w + h);
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: w, height: h, labels: { b: w, h: '?' } },
                    description: lang === 'sv' ? `En rektangel har omkretsen ${perim} cm. Vi vet att basen √§r ${w} cm. Hur l√•ng √§r h√∂jden?` : `A rectangle has a perimeter of ${perim} cm. We know the base is ${w} cm. What is the height?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Dra bort de tv√• k√§nda baserna fr√•n den totala omkretsen." : "Step 1: Subtract the two known bases from the total perimeter.", latex: `${perim} - (2 \\cdot ${w}) = ${perim - 2*w}` },
                    { text: lang === 'sv' ? "Steg 2: Dela det som √§r kvar med 2 f√∂r att f√• fram h√∂jden." : "Step 2: Divide what remains by 2 to find the height.", latex: `\\frac{${perim - 2*w}}{2} = ${h}` }
                ],
                metadata: { variation_key: 'perimeter_inverse', difficulty: 2 }
            };
        }

        if (v === 'perimeter_lie') {
            const s = 5, p = 20;
            const sTrue1 = lang === 'sv' ? "Omkretsen √§r 20 cm" : "The perimeter is 20 cm";
            const sTrue2 = lang === 'sv' ? "Sidan √§r 5 cm" : "The side is 5 cm";
            const sFalse = lang === 'sv' ? "Omkretsen √§r 25 cm" : "The perimeter is 25 cm";
            return {
                renderData: {
                    geometry: { type: 'square', width: 5, height: 5, labels: { b: 5, h: 5 } },
                    description: lang === 'sv' ? "Titta p√• kvadraten nedan. Vilket av p√•st√•endena √§r FALSKT?" : "Look at the square below. Which of the statements is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
                },
                token: this.toBase64(sFalse),
                clues: [{ text: lang === 'sv' ? "R√§kna ut omkretsen genom att multiplicera sidan med 4. J√§mf√∂r sedan med alternativen." : "Calculate the perimeter by multiplying the side by 4. Then compare with the options.", latex: `4 \\cdot 5 = 20` }],
                metadata: { variation_key: 'perimeter_lie', difficulty: 1 }
            };
        }

        // Default: perimeter_parallel
        const b = MathUtils.randomInt(6, 12), s = MathUtils.randomInt(4, 9);
        return {
            renderData: {
                geometry: { type: 'parallelogram', width: b, height: s-1, labels: { b: b, s: s } },
                description: lang === 'sv' ? `En parallellogram har sidorna ${b} cm och ${s} cm. Ber√§kna omkretsen.` : `A parallelogram has sides of ${b} cm and ${s} cm. Calculate its perimeter.`,
                answerType: 'numeric'
            },
            token: this.toBase64((2 * (b + s)).toString()),
            clues: [{ text: lang === 'sv' ? "Precis som en rektangel har en parallellogram tv√• par av lika l√•nga sidor." : "Just like a rectangle, a parallelogram has two pairs of equal sides.", latex: `O = 2 \\cdot (${b} + ${s})` }],
            metadata: { variation_key: 'perimeter_parallel', difficulty: 1 }
        };
    }

    // --- LEVEL 2: AREA BASIC ---
    private level2_AreaBasic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['area_square', 'area_rect', 'area_parallel', 'area_inverse', 'area_trap']);

        if (v === 'area_square') {
            const s = MathUtils.randomInt(3, 12);
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' ? `En kvadrat har sidan ${s} cm. Ber√§kna kvadratens area.` : `A square has a side of ${s} cm. Calculate the area of the square.`,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64((s * s).toString()),
                clues: [{ text: lang === 'sv' ? "Arean f√∂r en kvadrat ber√§knas genom att multiplicera sidan med sig sj√§lv." : "The area of a square is calculated by multiplying the side by itself.", latex: `A = ${s} \\cdot ${s}` }],
                metadata: { variation_key: 'area_square', difficulty: 1 }
            };
        }

        if (v === 'area_inverse') {
            const b = MathUtils.randomInt(4, 10), h = MathUtils.randomInt(3, 8);
            const area = b * h;
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: b, height: h, labels: { b: b, h: '?' } },
                    description: lang === 'sv' ? `Rektangelns area √§r ${area} cm¬≤. Vi vet att basen √§r ${b} cm. Vad √§r rektangelns h√∂jd?` : `The area of the rectangle is ${area} cm¬≤. We know the base is ${b} cm. What is the height?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(h.toString()),
                clues: [{ text: lang === 'sv' ? "Eftersom Area = Bas ‚Ä¢ H√∂jd, kan vi hitta h√∂jden genom att dividera arean med basen." : "Since Area = Base ‚Ä¢ Height, we can find the height by dividing the area by the base.", latex: `h = \\frac{${area}}{${b}}` }],
                metadata: { variation_key: 'area_inverse', difficulty: 2 }
            };
        }

        if (v === 'area_trap') {
            const b = MathUtils.randomInt(5, 12), h = MathUtils.randomInt(4, 9), s = h + 2;
            return {
                renderData: {
                    geometry: { type: 'parallelogram', width: b, height: h, labels: { b: b, h: h, s: s } },
                    description: lang === 'sv' ? "Ber√§kna parallellogrammens area." : "Calculate the area of the parallelogram. Be sure to choose the correct dimensions!",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64((b * h).toString()),
                clues: [{ text: lang === 'sv' ? "Viktigt: Vid ber√§kning av area ska du alltid anv√§nda den vinkelr√§ta h√∂jden, aldrig den sneda sidan." : "Important: When calculating area, you should always use the perpendicular height, never the slanted side.", latex: `A = ${b} \\cdot ${h}` }],
                metadata: { variation_key: 'area_trap', difficulty: 2 }
            };
        }

        const b = MathUtils.randomInt(5, 12), h = MathUtils.randomInt(3, 9);
        const type = v === 'area_rect' ? 'rectangle' : 'parallelogram';
        return {
            renderData: {
                geometry: { type: type, width: b, height: h, labels: { b: b, h: h } },
                description: lang === 'sv' ? `Ber√§kna arean av figuren nedan.` : `Calculate the area of the figure below.`,
                answerType: 'numeric', suffix: 'cm¬≤'
            },
            token: this.toBase64((b * h).toString()),
            clues: [{ text: lang === 'sv' ? "Arean ber√§knas genom att multiplicera basen med den vinkelr√§ta h√∂jden." : "The area is calculated by multiplying the base by the perpendicular height.", latex: `A = ${b} \\cdot ${h}` }],
            metadata: { variation_key: v, difficulty: 1 }
        };
    }

    // --- LEVEL 3: TRIANGLES ---
    private level3_Triangles(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['area_triangle', 'inverse_triangle', 'perimeter_triangle_right', 'perimeter_triangle_iso', 'perimeter_triangle_scalene']);

        if (v === 'area_triangle') {
            const b = MathUtils.randomInt(4, 12), h = MathUtils.randomInt(3, 10);
            return {
                renderData: {
                    geometry: { type: 'triangle', width: b, height: h, labels: { b: b, h: h } },
                    description: lang === 'sv' ? `En triangel har basen ${b} cm och h√∂jden ${h} cm. Ber√§kna triangelns area.` : `A triangle has a base of ${b} cm and a height of ${h} cm. Calculate the area of the triangle.`,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(((b * h) / 2).toString()),
                clues: [
                    { text: lang === 'sv' ? "T√§nk p√• en triangel som halva ytan av en rektangel med samma bas och h√∂jd." : "Think of a triangle as half the area of a rectangle with the same base and height.", latex: "" },
                    { text: lang === 'sv' ? "Formeln √§r d√§rf√∂r: (Bas ‚Ä¢ H√∂jd) / 2." : "The formula is therefore: (Base ‚Ä¢ Height) / 2.", latex: `A = \\frac{${b} \\cdot ${h}}{2}` }
                ],
                metadata: { variation_key: 'area_triangle', difficulty: 2 }
            };
        }

        if (v === 'inverse_triangle') {
            const h = MathUtils.randomInt(4, 10), b = MathUtils.randomInt(4, 10);
            const area = (b * h) / 2;
            return {
                renderData: {
                    geometry: { type: 'triangle', width: b, height: h, labels: { b: b, h: '?' } },
                    description: lang === 'sv' ? `Triangelns area √§r ${area} cm¬≤. Vi vet att basen √§r ${b} cm. Vad √§r h√∂jden?` : `The triangle's area is ${area} cm¬≤. We know the base is ${b} cm. What is the height?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "Eftersom arean √§r h√§lften av basen g√•nger h√∂jden, b√∂rjar vi med att dubbla arean." : "Since the area is half of the base times the height, we start by doubling the area.", latex: `2 \\cdot ${area} = ${b} \\cdot h` },
                    { text: lang === 'sv' ? "Dela sedan det resultatet med basen f√∂r att f√• h√∂jden." : "Then divide that result by the base to find the height.", latex: `h = \\frac{${area * 2}}{${b}}` }
                ],
                metadata: { variation_key: 'inverse_triangle', difficulty: 3 }
            };
        }

        // Perimeter Variations
        const type = v.replace('perimeter_triangle_', '');
        let b = 6, h = 8, s1 = 10, s2 = 10;
        if (type === 'right') { b = 3; h = 4; s1 = 5; }
        else if (type === 'iso') { b = 6; h = 5; s1 = 5; s2 = 5; }
        else { b = 7; h = 5; s1 = 6; s2 = 8; }

        return {
            renderData: {
                geometry: { type: 'triangle', subtype: type === 'right' ? 'right' : undefined, width: b, height: h, labels: { b: b, s1: s1, s2: s2, h: type === 'right' ? undefined : h } },
                description: lang === 'sv' ? "Ber√§kna triangelns omkrets genom att addera alla sidor." : "Calculate the triangle's perimeter by adding all sides.",
                answerType: 'numeric'
            },
            token: this.toBase64((b + s1 + (type === 'right' || type === 'scalene' ? s2 : s1)).toString()),
            clues: [{ text: lang === 'sv' ? "Omkretsen √§r den totala l√§ngden runt figurens ytterkant. Addera de tre sidorna." : "The perimeter is the total length around the outer edge of the figure. Add the three sides.", latex: "" }],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 4: COMBINED FIGURES ---
    private level4_CombinedFigures(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['combined_rect_tri', 'combined_l_shape', 'combined_house']);

        if (v === 'combined_rect_tri') {
            const rw = 6, rh = 4, tb = 3;
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'rect_right_tri', labels: { w: rw, h: rh, tri_b: tb } },
                    description: lang === 'sv' ? "Figuren best√•r av en rektangel och en triangel. Ber√§kna den totala arean." : "The figure consists of a rectangle and a triangle. Calculate the total area.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64((rw * rh + (tb * rh) / 2).toString()),
                clues: [
                    { text: lang === 'sv' ? "Dela upp figuren i tv√• k√§nda former: en rektangel och en triangel." : "Split the figure into two known shapes: a rectangle and a triangle.", latex: "" },
                    { text: lang === 'sv' ? `Rektangelns area: ${rw} ‚Ä¢ ${rh}. Triangelns area: (${tb} ‚Ä¢ ${rh}) / 2.` : `Rectangle area: ${rw} ‚Ä¢ ${rh}. Triangle area: (${tb} ‚Ä¢ ${rh}) / 2.`, latex: "" }
                ],
                metadata: { variation_key: 'combined_rect_tri', difficulty: 3 }
            };
        }

        if (v === 'combined_l_shape') {
            const vW = 3, vH = 8, hW = 5, hH = 3;
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'l_shape', labels: { vW, vH, hW, hH, totalW: vW + hW } },
                    description: lang === 'sv' ? "Ber√§kna arean av den L-formade figuren genom att dela upp den i tv√• rektanglar." : "Calculate the area of the L-shaped figure by splitting it into two rectangles.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64((vW * vH + hW * hH).toString()),
                clues: [{ text: lang === 'sv' ? "Du kan dela figuren antingen vertikalt eller horisontellt f√∂r att f√• tv√• rektanglar." : "You can split the figure either vertically or horizontally to get two rectangles.", latex: `(${vW} \\cdot ${vH}) + (${hW} \\cdot ${hH})` }],
                metadata: { variation_key: 'combined_l_shape', difficulty: 3 }
            };
        }

        const s = 6, ht = 4;
        return {
            renderData: {
                geometry: { type: 'composite', subtype: 'house_area', labels: { s: s, h_tri: ht } },
                description: lang === 'sv' ? "Figuren ser ut som ett hus och best√•r av en kvadrat och en triangel. Vad √§r den totala arean?" : "The figure looks like a house and consists of a square and a triangle. What is the total area?",
                answerType: 'numeric', suffix: 'cm¬≤'
            },
            token: this.toBase64((s * s + (s * ht) / 2).toString()),
            clues: [{ text: lang === 'sv' ? "Ber√§kna kvadratens yta f√∂rst och l√§gg sedan till triangelns yta." : "Calculate the square's surface first and then add the triangle's surface.", latex: `(${s} \\cdot ${s}) + \\frac{${s} \\cdot ${ht}}{2}` }],
            metadata: { variation_key: 'combined_house', difficulty: 3 }
        };
    }

    // --- LEVEL 5: CIRCLES ---
    private level5_Circles(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['circle_area', 'circle_perimeter', 'semicircle_area', 'semicircle_perimeter', 'area_quarter', 'perimeter_quarter']);
        const r = MathUtils.randomInt(4, 10);
        const pi = 3.14;

        if (v === 'circle_area' || v === 'circle_perimeter') {
            const isArea = v === 'circle_area';
            const ans = isArea ? pi * r * r : 2 * pi * r;
            return {
                renderData: {
                    geometry: { type: 'circle', radius: r, labels: isArea ? { r: r } : { diameter: 2 * r }, show: isArea ? 'radius' : 'diameter' },
                    description: lang === 'sv' ? (isArea ? `Ber√§kna arean av cirkeln ($\pi \approx 3,14$).` : `Ber√§kna cirkelns omkrets ($\pi \approx 3,14$).`) : (isArea ? `Calculate the area of the circle ($\pi \approx 3.14$).` : `Calculate the perimeter of the circle ($\pi \approx 3.14$).`),
                    answerType: 'numeric'
                },
                token: this.toBase64((Math.round(ans * 100) / 100).toString()),
                clues: [{ text: isArea ? (lang === 'sv' ? "Formeln f√∂r area √§r pi g√•nger radien i kvadrat." : "The formula for area is pi times the radius squared.") : (lang === 'sv' ? "Formeln f√∂r omkrets √§r pi g√•nger diametern." : "The formula for perimeter is pi times the diameter."), latex: isArea ? `A = 3,14 \\cdot ${r}^2` : `O = 3,14 \\cdot ${2 * r}` }],
                metadata: { variation_key: v, difficulty: 2 }
            };
        }

        if (v === 'semicircle_area' || v === 'semicircle_perimeter') {
            const isArea = v === 'semicircle_area';
            const ans = isArea ? (pi * r * r) / 2 : (pi * 2 * r) / 2 + (2 * r);
            return {
                renderData: {
                    geometry: { type: 'semicircle', radius: r, labels: { r: r, diameter: 2*r }, show: isArea ? 'radius' : 'diameter' },
                    description: lang === 'sv' ? (isArea ? "Ber√§kna arean av halvcirkeln." : "Ber√§kna omkretsen runt hela halvcirkeln (b√•gen + basen).") : (isArea ? "Calculate the area of the semicircle." : "Calculate the perimeter around the whole semicircle (arc + base)."),
                    answerType: 'numeric'
                },
                token: this.toBase64((Math.round(ans * 100) / 100).toString()),
                clues: [{ text: isArea ? (lang === 'sv' ? "R√§kna ut en hel cirkels area och dela den sedan med 2." : "Calculate a full circle's area and then divide it by 2.") : (lang === 'sv' ? "Ber√§kna halva omkretsen f√∂r b√•gen och gl√∂m inte att l√§gga till den raka diametern." : "Calculate half the circumference for the arc and don't forget to add the straight diameter."), latex: isArea ? `\\frac{3,14 \\cdot ${r}^2}{2}` : `\\frac{3,14 \\cdot ${2 * r}}{2} + ${2 * r}` }],
                metadata: { variation_key: v, difficulty: 3 }
            };
        }

        const isArea = v === 'area_quarter';
        const ans = isArea ? (pi * r * r) / 4 : (pi * 2 * r) / 4 + (2 * r);
        return {
            renderData: {
                geometry: { type: 'quarter_circle', radius: r, labels: { r: r } },
                description: lang === 'sv' ? (isArea ? "Ber√§kna arean av kvartscirkeln." : "Ber√§kna kvartscirkelns omkrets (b√•gen + de tv√• radierna).") : (isArea ? "Calculate the area of the quarter circle." : "Calculate the quarter circle's perimeter (arc + the two radii)."),
                answerType: 'numeric'
            },
            token: this.toBase64((Math.round(ans * 100) / 100).toString()),
            clues: [{ text: isArea ? (lang === 'sv' ? "R√§kna ut arean f√∂r en hel cirkel och dela med 4." : "Calculate the area for a full circle and divide by 4.") : (lang === 'sv' ? "Ber√§kna en fj√§rdedel av omkretsen f√∂r b√•gen och l√§gg till de tv√• raka radierna." : "Calculate one-fourth of the circumference for the arc and add the two straight radii."), latex: isArea ? `\\frac{3,14 \\cdot ${r}^2}{4}` : `\\frac{2 \\cdot 3,14 \\cdot ${r}}{4} + ${r} + ${r}` }],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 6: COMPOSITE ADVANCED ---
    private level6_CompositeAdvanced(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['perimeter_house', 'perimeter_portal']);
        const w = 60, h = 40;

        if (v === 'perimeter_house') {
            const hr = 30;
            const slope = Math.sqrt((w/2)**2 + hr**2);
            const ans = Math.round((w + 2*h + 2*slope) * 10) / 10;
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'house', labels: { w, h, h_roof: hr } },
                    description: lang === 'sv' ? "Ber√§kna den totala omkretsen runt husets ytterkant (inklusive taket)." : "Calculate the total perimeter around the outer edge of the house (including the roof).",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Steg 1: Identifiera alla ytterv√§ggar. Botten (${w}) och tv√• sidov√§ggar (${h} var).` : `Step 1: Identify all outer walls. The bottom (${w}) and two side walls (${h} each).`, latex: "" },
                    { text: lang === 'sv' ? `Steg 2: R√§kna ut takets tv√• sneda sidor (ca ${Math.round(slope*10)/10} var). Addera sedan allt.` : `Step 2: Calculate the two slanted sides of the roof (approx ${Math.round(slope*10)/10} each). Then add everything together.`, latex: "" }
                ],
                metadata: { variation_key: 'perimeter_house', difficulty: 4 }
            };
        }

        const r = w / 2;
        const arc = 3.14 * r;
        const ans = Math.round((w + 2*h + arc) * 10) / 10;
        return {
            renderData: {
                geometry: { type: 'composite', subtype: 'portal', labels: { w, h } },
                description: lang === 'sv' ? "Ber√§kna omkretsen runt hela portalen (v√§ggar, golv och den runda b√•gen)." : "Calculate the perimeter around the whole portal (walls, floor, and the round arch).",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "B√•gen √§r en halvcirkel. R√§kna ut dess l√§ngd med formeln f√∂r omkrets delat p√• tv√•." : "The arch is a semicircle. Calculate its length using the formula for circumference divided by two.", latex: `\\frac{3,14 \\cdot ${w}}{2} = ${arc}` },
                { text: lang === 'sv' ? "L√§gg sedan till de raka sidorna: botten och de tv√• vertikala v√§ggarna." : "Then add the straight sides: the bottom and the two vertical walls.", latex: `${arc} + ${w} + ${h} + ${h} = ${ans}` }
            ],
            metadata: { variation_key: 'perimeter_portal', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';
import { LinearEquationProblemGen } from './LinearEquationProblemGen.js';

export class LinearEquationGen {
    private problemGen: LinearEquationProblemGen;

    constructor() {
        this.problemGen = new LinearEquationProblemGen();
    }

    public generate(level: number, lang: string = 'sv'): any {
        // Delegate Word Problems to the Specialist (Levels 5 & 6)
        if (level === 5 || level === 6) {
            return this.problemGen.generate(level, lang);
        }
        
        // Mixed Level Drill (Level 7)
        if (level === 7) {
            return this.level7_Mixed(lang);
        }

        switch (level) {
            case 1: return this.level1_OneStep(lang);
            case 2: return this.level2_TwoStep(lang);
            case 3: return this.level3_Parentheses(lang);
            case 4: return this.level4_BothSides(lang);
            default: return this.level1_OneStep(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        // Handle Word Problem delegation
        const wordProblemKeys = [
            'rate_fixed_add_write', 'rate_fixed_add_solve',
            'rate_fixed_sub_write', 'rate_fixed_sub_solve',
            'compare_word_sum_write', 'compare_word_sum_solve',
            'compare_word_diff_write', 'compare_word_diff_solve'
        ];

        if (wordProblemKeys.includes(key)) {
            const level = key.endsWith('_write') ? 5 : 6;
            return this.problemGen.generate(level, lang);
        }

        switch (key) {
            case 'onestep_concept_inverse':
            case 'onestep_spot_lie':
            case 'onestep_calc':
                return this.level1_OneStep(lang, key);
            
            case 'twostep_concept_order':
            case 'twostep_calc':
                return this.level2_TwoStep(lang, key);
            
            case 'paren_lie_distribution':
            case 'paren_calc':
                return this.level3_Parentheses(lang, key);
            
            case 'bothsides_concept_strategy':
            case 'bothsides_calc':
                return this.level4_BothSides(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: One-Step Equations ---
    private level1_OneStep(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['onestep_concept_inverse', 'onestep_spot_lie', 'onestep_calc']);

        if (v === 'onestep_concept_inverse') {
            const type = MathUtils.randomInt(1, 4);
            const val1 = MathUtils.randomInt(2, 12);
            const val2 = MathUtils.randomInt(2, 12);
            
            let q = "";
            let correctOp = "";
            let clue = "";

            const ops = lang === 'sv' 
                ? ["Addition (+)", "Subtraktion (-)", "Multiplikation (¬∑)", "Division (/)"] 
                : ["Addition (+)", "Subtraction (-)", "Multiplication (¬∑)", "Division (/)"];

            if (type === 1) { // x + a = b
                q = `x + ${val1} = ${val1 + val2}`;
                correctOp = lang === 'sv' ? "Subtraktion (-)" : "Subtraction (-)";
                clue = lang === 'sv' ? "F√∂r att f√• x ensamt m√•ste vi g√∂ra motsatsen till addition, vilket √§r subtraktion." : "To get x alone, we must perform the opposite of addition, which is subtraction.";
            } else if (type === 2) { // x - a = b
                q = `x - ${val1} = ${val2}`;
                correctOp = lang === 'sv' ? "Addition (+)" : "Addition (+)";
                clue = lang === 'sv' ? "Eftersom vi har en subtraktion (-), anv√§nder vi motsatsen (addition) f√∂r att nollst√§lla termen." : "Since we have a subtraction (-), we use the opposite (addition) to cancel the term.";
            } else if (type === 3) { // ax = b
                q = `${val1}x = ${val1 * val2}`;
                correctOp = lang === 'sv' ? "Division (/)" : "Division (/)";
                clue = lang === 'sv' ? "Talet st√•r precis bredvid x, vilket betyder multiplikation. Motsatsen √§r division." : "The number is right next to x, which means multiplication. The opposite is division.";
            } else { // x / a = b
                q = `\\frac{x}{${val1}} = ${val2}`;
                correctOp = lang === 'sv' ? "Multiplikation (¬∑)" : "Multiplication (¬∑)";
                clue = lang === 'sv' ? "H√§r √§r x dividerat med ett tal. F√∂r att f√• x fritt anv√§nder vi multiplikation." : "Here x is divided by a number. To free x, we use multiplication.";
            }

            return {
                renderData: {
                    description: lang === 'sv' ? `Betrakta ekvationen $${q}$. Vilken r√§kneoperation ska du utf√∂ra p√• b√•da sidor f√∂r att isolera variabeln x?` : `Consider the equation $${q}$. Which operation should you perform on both sides to isolate the variable x?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(ops)
                },
                token: this.toBase64(correctOp),
                clues: [{ text: clue }],
                metadata: { variation_key: 'onestep_concept_inverse', difficulty: 1 }
            };
        }

        if (v === 'onestep_spot_lie') {
            const targetX = MathUtils.randomInt(2, 10);
            const a = MathUtils.randomInt(2, 6);
            const b = MathUtils.randomInt(2, 15);
            
            // Equation strings for buttons: Use middle dot instead of \cdot
            const sTrue1 = `${a}x = ${a * targetX}`;
            const sTrue2 = `x + ${b} = ${targetX + b}`;
            const lie = `x - ${b} = ${targetX + b}`; 

            return {
                renderData: {
                    description: lang === 'sv' ? `Om vi utg√•r fr√•n att $x = ${targetX}$, vilket av f√∂ljande p√•st√•enden st√§mmer d√• INTE?` : `Assuming that $x = ${targetX}$, which of the following statements is NOT true?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, lie])
                },
                token: this.toBase64(lie),
                clues: [{ text: lang === 'sv' ? "Testa varje alternativ genom att ers√§tta x med talet. Den ekvation d√§r v√§nster och h√∂ger sida inte blir lika √§r 'l√∂gnen'." : "Test each option by replacing x with the number. The equation where the left and right sides are not equal is the 'lie'." }],
                metadata: { variation_key: 'onestep_spot_lie', difficulty: 1 }
            };
        }

        const type = MathUtils.randomInt(1, 3);
        const x = MathUtils.randomInt(2, 12);
        let latex = '', answer = x.toString(), clue = '';
        
        if (type === 1) { // kx = res
            const k = MathUtils.randomInt(2, 9);
            latex = `${k}x = ${k * x}`;
            clue = lang === 'sv' ? `Dela b√•da sidor med ${k} eftersom division √§r motsatsen till multiplikation.` : `Divide both sides by ${k} as division is the opposite of multiplication.`;
        } else { // x + k = res
            const k = MathUtils.randomInt(1, 20);
            const isPlus = Math.random() > 0.5;
            latex = isPlus ? `x + ${k} = ${x + k}` : `x - ${k} = ${x - k}`;
            clue = isPlus 
                ? (lang === 'sv' ? `Subtrahera ${k} fr√•n b√•da sidor f√∂r att f√• variabeln x ensam.` : `Subtract ${k} from both sides to get the variable x alone.`)
                : (lang === 'sv' ? `Eftersom du har en subtraktion av ${k}, addera ${k} p√• b√•da sidor f√∂r att nollst√§lla termen.` : `Since you have a subtraction of ${k}, add ${k} to both sides to cancel out the term.`);
        }

        return {
            renderData: { 
                latex, 
                description: lang === 'sv' ? "Ber√§kna v√§rdet p√• variabeln x i ekvationen nedan." : "Calculate the value of the variable x in the equation below.", 
                answerType: 'text' 
            },
            token: this.toBase64(answer),
            clues: [{ text: clue }],
            metadata: { variation_key: 'onestep_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: Two-Step Equations ---
    private level2_TwoStep(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['twostep_concept_order', 'twostep_calc']);
        
        if (v === 'twostep_concept_order') {
            const a = MathUtils.randomInt(2, 5), b = MathUtils.randomInt(2, 10), c = 20;
            const correct = lang === 'sv' ? `Subtrahera ${b} f√∂rst` : `Subtract ${b} first`;
            const wrong = lang === 'sv' ? `Dividera med ${a} f√∂rst` : `Divide by ${a} first`;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `N√§r du ska l√∂sa ekvationen $${a}x + ${b} = ${c}$, vilket av f√∂ljande steg √§r mest logiskt att b√∂rja med?` : `When solving the equation $${a}x + ${b} = ${c}$, which of the following steps is most logical to perform first?`,
                    answerType: 'multiple_choice',
                    options: [correct, wrong]
                },
                token: this.toBase64(correct),
                clues: [{ text: lang === 'sv' ? "I algebra anv√§nder vi oftast prioriteringsreglerna bakl√§nges. Vi b√∂rjar med att ta bort addition eller subtraktion innan vi r√∂r multiplikationen vid x." : "In algebra, we usually use the order of operations in reverse. We start by removing addition or subtraction before touching the multiplication at x." }],
                metadata: { variation_key: 'twostep_concept_order', difficulty: 2 }
            };
        }

        const x = MathUtils.randomInt(2, 10);
        const a = MathUtils.randomInt(2, 6);
        const b = MathUtils.randomInt(1, 15);
        const isPlus = Math.random() > 0.5;
        const c = isPlus ? a * x + b : a * x - b;

        return {
            renderData: { 
                latex: `${a}x ${isPlus ? '+' : '-'} ${b} = ${c}`, 
                description: lang === 'sv' ? "L√∂s ekvationen steg f√∂r steg. Kom ih√•g att alltid utf√∂ra samma √§ndring p√• b√•da sidor." : "Solve the equation step by step. Remember to always perform the same change on both sides.", 
                answerType: 'text' 
            },
            token: this.toBase64(x.toString()),
            clues: [
                { text: lang === 'sv' ? `Steg 1: Flytta konstanten ${b} genom att utf√∂ra den motsatta r√§kneoperationen.` : `Step 1: Move the constant ${b} by performing the opposite mathematical operation.`, latex: `${a}x = ${c} ${isPlus ? '-' : '+'} ${b}` },
                { text: lang === 'sv' ? `Steg 2: Dela nu b√•da sidor med ${a} f√∂r att f√• fram v√§rdet p√• x.` : `Step 2: Now divide both sides by ${a} to find the value of x.`, latex: `x = \\frac{${isPlus ? c-b : c+b}}{${a}}` }
            ],
            metadata: { variation_key: 'twostep_calc', difficulty: 2 }
        };
    }

    // --- LEVEL 3: Parentheses ---
    private level3_Parentheses(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['paren_lie_distribution', 'paren_calc']);
        const a = MathUtils.randomInt(2, 5), b = MathUtils.randomInt(2, 6), x = MathUtils.randomInt(1, 8);

        if (v === 'paren_lie_distribution') {
            const correct = `${a}(x + ${b}) = ${a}x + ${a*b}`;
            const lie = `${a}(x + ${b}) = ${a}x + ${b}`; 
            // Use middle dot (¬∑) for button text instead of \cdot
            const altCorrect = `${a}(x + ${b}) = ${a} ¬∑ x + ${a} ¬∑ ${b}`;

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av alternativen nedan visar en FELAKTIG metod f√∂r att multiplicera in i parentesen?" : "Which of the options below shows an INCORRECT method for distributing into the parentheses?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, lie, altCorrect]),
                },
                token: this.toBase64(lie),
                clues: [{ text: lang === 'sv' ? "Talet som st√•r precis utanf√∂r parentesen √§r en faktor som ska multipliceras med VARJE term som finns inuti parentesen." : "The number just outside the parentheses is a factor that must be multiplied by EVERY term inside the parentheses." }],
                metadata: { variation_key: 'paren_lie_distribution', difficulty: 3 }
            };
        }

        const c = a * (x + b);
        return {
            renderData: {
                latex: `${a}(x + ${b}) = ${c}`,
                description: lang === 'sv' ? "F√∂renkla uttrycket genom att multiplicera in i parentesen f√∂rst, och l√∂s d√§refter ekvationen." : "Simplify the expression by distributing into the parentheses first, and then solve the equation.",
                answerType: 'text'
            },
            token: this.toBase64(x.toString()),
            clues: [
                { text: lang === 'sv' ? `Steg 1: Multiplicera in ${a} i parentesen s√• att den f√∂rsvinner.` : `Step 1: Distribute ${a} into the parentheses to remove them.`, latex: `${a}x + ${a*b} = ${c}` },
                { text: lang === 'sv' ? "Steg 2: L√∂s nu ut variabeln x precis som i en vanlig tv√•stegsekvation." : "Step 2: Now solve for the variable x just like in a standard two-step equation." }
            ],
            metadata: { variation_key: 'paren_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 4: Both Sides ---
    private level4_BothSides(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['bothsides_concept_strategy', 'bothsides_calc']);
        const x = MathUtils.randomInt(2, 10), a = MathUtils.randomInt(6, 10), c = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(2, 12);
        const d = (a - c) * x + b;

        if (v === 'bothsides_concept_strategy') {
            const eq = `${a}x + ${b} = ${c}x + ${d}`;
            const correct = lang === 'sv' ? `Subtrahera ${c}x fr√•n b√•da sidor` : `Subtract ${c}x from both sides`;
            const wrong = lang === 'sv' ? `Subtrahera ${a}x fr√•n b√•da sidor` : `Subtract ${a}x from both sides`;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `I ekvationen $${eq}$, vilket av dessa steg √§r mest strategiskt f√∂r att h√•lla antalet x positivt?` : `In the equation $${eq}$, which of these steps is most strategic for keeping the amount of x positive?`,
                    answerType: 'multiple_choice',
                    options: [correct, wrong]
                },
                token: this.toBase64(correct),
                clues: [{ text: lang === 'sv' ? "Genom att 'flytta' den minsta x-termen till den sida d√§r det finns flest x, slipper vi arbeta med negativa antal x vilket underl√§ttar utr√§kningen." : "By 'moving' the smallest x-term to the side with the most x's, we avoid working with negative amounts of x, which makes the calculation easier." }],
                metadata: { variation_key: 'bothsides_concept_strategy', difficulty: 3 }
            };
        }

        return {
            renderData: {
                latex: `${a}x + ${b} = ${c}x + ${d}`,
                description: lang === 'sv' ? "Samla alla termer med x p√• en sida och alla vanliga tal p√• den andra sidan f√∂r att l√∂sa ut x." : "Gather all terms with x on one side and all constants on the other side to solve for x.",
                answerType: 'text'
            },
            token: this.toBase64(x.toString()),
            clues: [
                { text: lang === 'sv' ? `Steg 1: Subtrahera ${c}x fr√•n b√•da sidor f√∂r att samla x p√• v√§nster sida.` : `Step 1: Subtract ${c}x from both sides to gather x on the left side.`, latex: `${a-c}x + ${b} = ${d}` },
                { text: lang === 'sv' ? `Steg 2: Flytta konstanten ${b} genom att subtrahera den fr√•n b√•da sidor.` : `Step 2: Move the constant ${b} by subtracting it from both sides.`, latex: `${a-c}x = ${d-b}` },
                { text: lang === 'sv' ? "Steg 3: Slutf√∂r utr√§kningen genom att dividera med koefficienten framf√∂r x." : "Step 3: Complete the calculation by dividing by the coefficient in front of x.", latex: `x = ${x}` }
            ],
            metadata: { variation_key: 'bothsides_calc', difficulty: 4 }
        };
    }

    private level7_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(1, 4);
        const data = this.generate(subLevel, lang);
        data.metadata.mixed = true;
        return data;
    }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearEquationProblemGen {
    public generate(level: number, lang: string = 'sv'): any {
        const mode = level === 5 ? 'write' : 'solve';
        const type = MathUtils.randomChoice(['A', 'B', 'C', 'D']);
        
        switch (type) {
            case 'A': return this.scenarioA_RatePlusFixed(lang, mode);
            case 'B': return this.scenarioB_RateMinusFixed(lang, mode);
            case 'C': return this.scenarioC_CompareSum(lang, mode);
            case 'D': return this.scenarioD_CompareDiff(lang, mode);
            default: return this.scenarioA_RatePlusFixed(lang, mode);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        const mode = key.endsWith('_write') ? 'write' : 'solve';
        const baseKey = key.replace('_write', '').replace('_solve', '');

        switch (baseKey) {
            case 'rate_fixed_add': return this.scenarioA_RatePlusFixed(lang, mode);
            case 'rate_fixed_sub': return this.scenarioB_RateMinusFixed(lang, mode);
            case 'compare_word_sum': return this.scenarioC_CompareSum(lang, mode);
            case 'compare_word_diff': return this.scenarioD_CompareDiff(lang, mode);
            default: return this.generate(mode === 'write' ? 5 : 6, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private getTaskText(lang: string, mode: 'write' | 'solve'): string {
        if (mode === 'write') {
            return lang === 'sv' 
                ? "Skriv en ekvation som beskriver detta problem (du beh√∂ver inte l√∂sa ut x)." 
                : "Write an equation that describes this problem (you do not need to solve for x).";
        }
        return lang === 'sv' 
            ? "L√∂s problemet och ta reda p√• vilket v√§rde variabeln x har." 
            : "Solve the problem and find the value of the variable x.";
    }

    // --- Type A: ax + b = c (Rate + Fixed Cost) ---
    private scenarioA_RatePlusFixed(lang: string, mode: 'write' | 'solve') {
        const scenarios = [
            {   
                fixedName: lang === 'sv' ? "kasse" : "bag",
                textSv: (a:number, b:number, c:number) => `Du k√∂per x stycken √§pplen f√∂r ${a} kr/st och en papperskasse f√∂r ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x apples for ${a} kr each and a paper bag for ${b} kr. In total you pay ${c} kr.`
            },
            {   
                fixedName: lang === 'sv' ? "startavgift" : "start fee",
                textSv: (a:number, b:number, c:number) => `En taxiresa kostar ${a} kr per kilometer plus en startavgift p√• ${b} kr. Hela resan kostade totalt ${c} kr. Du √•kte x km.`,
                textEn: (a:number, b:number, c:number) => `A taxi trip costs ${a} kr per kilometer plus a start fee of ${b} kr. The entire trip cost ${c} kr in total. You traveled x km.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(5, 20);
        const a = MathUtils.randomInt(5, 40);
        const b = MathUtils.randomChoice([15, 25, 45, 50]);
        const c = a * x + b;

        const equation = `${a}x+${b}=${c}`;
        const desc = (lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c)) + " " + this.getTaskText(lang, mode);

        const clues = mode === 'write' ? [
            { text: lang === 'sv' ? `Steg 1: Identifiera den r√∂rliga kostnaden (${a} kr f√∂r varje x).` : `Step 1: Identify the variable cost (${a} kr for each x).`, latex: `${a} \\cdot x = ${a}x` },
            { text: lang === 'sv' ? `Steg 2: L√§gg till den fasta kostnaden f√∂r ${s.fixedName} (${b} kr).` : `Step 2: Add the fixed cost for the ${s.fixedName} (${b} kr).`, latex: `${a}x + ${b}` },
            { text: lang === 'sv' ? `Steg 3: S√§tt hela uttrycket lika med det totala beloppet ${c} kr.` : `Step 3: Set the entire expression equal to the total amount of ${c} kr.`, latex: `${equation}` }
        ] : [
            { text: lang === 'sv' ? `B√∂rja med att ta bort den fasta avgiften (${b}) fr√•n totalsumman.` : `Start by removing the fixed fee (${b}) from the total amount.`, latex: `${a}x = ${c} - ${b} = ${c-b}` },
            { text: lang === 'sv' ? `Dela nu resultatet med priset per enhet (${a}) f√∂r att f√• fram x.` : `Now divide the result by the price per unit (${a}) to find x.`, latex: `x = \\frac{${c-b}}{${a}} = ${x}` }
        ];

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `rate_fixed_add_${mode}`, difficulty: mode === 'write' ? 3 : 4 }
        };
    }

    // --- Type B: ax - b = c (Rate - Discount) ---
    private scenarioB_RateMinusFixed(lang: string, mode: 'write' | 'solve') {
        const x = MathUtils.randomInt(2, 6);
        const a = MathUtils.randomInt(150, 450);
        const b = MathUtils.randomChoice([100, 200, 300]);
        const c = a * x - b;

        const desc = lang === 'sv'
            ? `Du k√∂per x stycken datorspel som kostar ${a} kr styck. Eftersom du har ett presentkort f√•r du ${b} kr rabatt p√• hela k√∂pet. Du betalar till slut ${c} kr. ${this.getTaskText(lang, mode)}`
            : `You buy x computer games that cost ${a} kr each. Since you have a gift card, you get a ${b} kr discount on the total. You end up paying ${c} kr. ${this.getTaskText(lang, mode)}`;

        const equation = `${a}x-${b}=${c}`;
        const clues = mode === 'write' ? [
            { text: lang === 'sv' ? `Steg 1: Ber√§kna vad spelen kostar tillsammans utan rabatt.` : `Step 1: Calculate what the games cost together without the discount.`, latex: `${a}x` },
            { text: lang === 'sv' ? `Steg 2: Subtrahera rabatten p√• ${b} kr fr√•n uttrycket.` : `Step 2: Subtract the discount of ${b} kr from the expression.`, latex: `${a}x - ${b}` },
            { text: lang === 'sv' ? `Steg 3: S√§tt detta lika med vad du faktiskt betalade (${c} kr).` : `Step 3: Set this equal to what you actually paid (${c} kr).`, latex: `${equation}` }
        ] : [
            { text: lang === 'sv' ? `Addera rabatten (${b}) till summan f√∂r att se vad det kostade f√∂re rabatten.` : `Add the discount (${b}) to the total to see the cost before the discount.`, latex: `${a}x = ${c} + ${b} = ${c+b}` },
            { text: lang === 'sv' ? `Dela det beloppet med styckpriset (${a}) f√∂r att hitta antalet spel.` : `Divide that amount by the unit price (${a}) to find the number of games.`, latex: `x = ${x}` }
        ];

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `rate_fixed_sub_${mode}`, difficulty: mode === 'write' ? 3 : 4 }
        };
    }

    // --- Type C: Compare Sum (x + (x+a) = c) ---
    private scenarioC_CompareSum(lang: string, mode: 'write' | 'solve') {
        const names = lang === 'sv' ? ["Lukas", "Maja"] : ["Lucas", "Maya"];
        const diff = MathUtils.randomInt(5, 15);
        const x = MathUtils.randomInt(10, 40);
        const total = 2 * x + diff;

        const desc = lang === 'sv'
            ? `${names[0]} har x kr. ${names[1]} har ${diff} kr mer √§n ${names[0]}. Tillsammans har de ${total} kr. ${this.getTaskText(lang, mode)}`
            : `${names[0]} has x kr. ${names[1]} has ${diff} kr more than ${names[0]}. Together they have ${total} kr. ${this.getTaskText(lang, mode)}`;

        const equation = `2x+${diff}=${total}`;
        const clues = mode === 'write' ? [
            { text: lang === 'sv' ? `${names[0]}s pengar: x. ${names[1]}s pengar: (x + ${diff}).` : `${names[0]}'s money: x. ${names[1]}'s money: (x + ${diff}).`, latex: "" },
            { text: lang === 'sv' ? `Summera dem: x + (x + ${diff}) = 2x + ${diff}.` : `Sum them up: x + (x + ${diff}) = 2x + ${diff}.`, latex: `${equation}` }
        ] : [
            { text: lang === 'sv' ? `Ta bort skillnaden (${diff}) fr√•n totalen f√∂r att f√• reda p√• vad de har om de hade haft lika mycket.` : `Subtract the difference (${diff}) from the total to find out what they have if they were equal.`, latex: `2x = ${total} - ${diff} = ${total-diff}` },
            { text: lang === 'sv' ? "Dela nu resultatet med 2 f√∂r att hitta v√§rdet p√• x." : "Now divide the result by 2 to find the value of x.", latex: `x = ${x}` }
        ];

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `compare_word_sum_${mode}`, difficulty: 4 }
        };
    }

    // --- Type D: Compare Diff (x + (x-b) = c) ---
    private scenarioD_CompareDiff(lang: string, mode: 'write' | 'solve') {
        const length = MathUtils.randomInt(60, 150);
        const diff = MathUtils.randomInt(10, 30);
        const x = (length + diff) / 2;
        if (!Number.isInteger(x)) return this.scenarioD_CompareDiff(lang, mode);

        const desc = lang === 'sv'
            ? `En planka som √§r ${length} cm l√•ng kapas i tv√• bitar. Den l√•nga biten √§r x cm. Den korta biten √§r ${diff} cm kortare √§n den l√•nga. ${this.getTaskText(lang, mode)}`
            : `A plank that is ${length} cm long is cut into two pieces. The long piece is x cm. The short piece is ${diff} cm shorter than the long one. ${this.getTaskText(lang, mode)}`;

        const equation = `2x-${diff}=${length}`;
        const clues = mode === 'write' ? [
            { text: lang === 'sv' ? `L√•ng bit: x. Kort bit: (x - ${diff}).` : `Long piece: x. Short piece: (x - ${diff}).`, latex: "" },
            { text: lang === 'sv' ? `L√§gg ihop bitarna: x + (x - ${diff}) = 2x - ${diff}.` : `Add the pieces: x + (x - ${diff}) = 2x - ${diff}.`, latex: `${equation}` }
        ] : [
            { text: lang === 'sv' ? `L√§gg till skillnaden (${diff}) till plankans l√§ngd f√∂r att g√∂ra bitarna lika l√•nga i din ber√§kning.` : `Add the difference (${diff}) to the plank's length to make the pieces equal in your calculation.`, latex: `2x = ${length} + ${diff} = ${length+diff}` },
            { text: lang === 'sv' ? "Dela totalen med 2 f√∂r att hitta den l√§ngsta biten x." : "Divide the total by 2 to find the longest piece x.", latex: `x = ${x}` }
        ];

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `compare_word_diff_${mode}`, difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearGraphGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_FindM(lang);
            case 2: return this.level2_FindK_Pos(lang);
            case 3: return this.level3_FindK_Neg(lang);
            case 4: return this.level4_FindFunction(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_FindM(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request specific "Skill Buckets".
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'intercept_id': 
                return this.level1_FindM(lang, key);
            case 'slope_pos_int':
            case 'slope_pos_frac':
                return this.level2_FindK_Pos(lang, key);
            case 'slope_neg_int':
            case 'slope_neg_frac':
                return this.level3_FindK_Neg(lang, key);
            case 'eq_standard':
            case 'eq_no_m':
            case 'eq_horizontal':
                return this.level4_FindFunction(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Intercept (m) ---
    private level1_FindM(lang: string, variationKey?: string): any {
        const m = MathUtils.randomInt(-5, 5);
        const k = MathUtils.randomChoice([1, -1, 2]); // Simple slopes for intercept focus

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#2563eb' }] },
                description: lang === 'sv' 
                    ? "Studera linjen i koordinatsystemet. Vilket √§r linjens m-v√§rde?" 
                    : "Study the line in the coordinate system. What is the m-value (y-intercept)?",
                answerType: 'numeric'
            },
            token: this.toBase64(m.toString()),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "m-v√§rdet √§r den punkt d√§r linjen korsar (sk√§r) y-axeln." 
                        : "The m-value is the point where the line crosses (intersects) the y-axis.", 
                    latex: `(0, m)` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Leta upp siffran p√• den vertikala axeln d√§r linjen g√•r igenom.` 
                        : `Look for the number on the vertical axis where the line passes through.`, 
                    latex: `y = ${m}` 
                }
            ],
            metadata: { variation_key: 'intercept_id', difficulty: 1 }
        };
    }

    // --- LEVEL 2: Positive Slope (k) ---
    private level2_FindK_Pos(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['slope_pos_int', 'slope_pos_frac']);
        let k = 1;
        let kDisplay = "1";
        
        if (v === 'slope_pos_int') {
            k = MathUtils.randomInt(1, 4);
            kDisplay = k.toString();
        } else {
            // Fractional slope: 1/2 or 1/4
            const den = MathUtils.randomChoice([2, 4]);
            k = 1 / den;
            kDisplay = `1/${den}`;
        }

        const m = MathUtils.randomInt(-2, 2);

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#16a34a' }] },
                description: lang === 'sv' 
                    ? "Ber√§kna linjens lutning (k-v√§rde). Hur mycket stiger linjen f√∂r varje steg √•t h√∂ger?" 
                    : "Calculate the slope (k-value) of the line. How much does the line rise for every step to the right?",
                answerType: 'text'
            },
            token: this.toBase64(kDisplay),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "k-v√§rdet beskriver lutningen. Vi m√§ter 'skillnad i y' delat med 'skillnad i x'." 
                        : "The k-value describes the slope. We measure 'change in y' divided by 'change in x'.", 
                    latex: "k = \\frac{\\Delta y}{\\Delta x}" 
                },
                { 
                    text: v === 'slope_pos_int' 
                        ? (lang === 'sv' ? `Om du g√•r 1 steg √•t h√∂ger, g√•r linjen upp ${k} steg.` : `If you go 1 step to the right, the line goes up ${k} steps.`)
                        : (lang === 'sv' ? `H√§r beh√∂ver du g√• flera steg √•t h√∂ger f√∂r att hamna p√• en j√§mn punkt.` : `Here you need to go several steps to the right to hit an even point.`),
                    latex: v === 'slope_pos_frac' ? `k = \\frac{1}{\\text{steg √•t h√∂ger}}` : `k = ${k}`
                }
            ],
            metadata: { variation_key: v, difficulty: v === 'slope_pos_frac' ? 3 : 2 }
        };
    }

    // --- LEVEL 3: Negative Slope (k) ---
    private level3_FindK_Neg(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['slope_neg_int', 'slope_neg_frac']);
        let k = -1;
        let kDisplay = "-1";

        if (v === 'slope_neg_int') {
            k = MathUtils.randomInt(-4, -1);
            kDisplay = k.toString();
        } else {
            const den = MathUtils.randomChoice([2, 3]);
            k = -1 / den;
            kDisplay = `-1/${den}`;
        }

        const m = MathUtils.randomInt(-2, 4);

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#dc2626' }] },
                description: lang === 'sv' 
                    ? "Best√§m linjens lutning (k-v√§rdet). T√§nk p√• om linjen stiger eller sjunker!" 
                    : "Determine the slope (k-value) of the line. Consider if the line rises or falls!",
                answerType: 'text'
            },
            token: this.toBase64(kDisplay),
            clues: [
                { text: lang === 'sv' ? "Eftersom linjen lutar ned√•t n√§r vi g√•r √•t h√∂ger, m√•ste k-v√§rdet vara negativt." : "Since the line slopes downward as we move to the right, the k-value must be negative." },
                { text: lang === 'sv' ? "Anv√§nd trappstegsmetoden: Hur m√•nga steg g√•r linjen ner f√∂r varje steg √•t h√∂ger?" : "Use the step method: How many steps does the line go down for every step to the right?", latex: `k = ${kDisplay}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: Full Function (y = kx + m) ---
    private level4_FindFunction(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['eq_standard', 'eq_no_m', 'eq_horizontal']);
        
        let k = MathUtils.randomInt(-2, 2);
        let m = MathUtils.randomInt(-3, 3);

        if (v === 'eq_no_m') m = 0;
        if (v === 'eq_horizontal') { k = 0; if (m === 0) m = 2; }
        if (v === 'eq_standard' && k === 0) k = 1;

        // Equation Builder
        let eq = "y=";
        if (k !== 0) {
            if (k === 1) eq += "x";
            else if (k === -1) eq += "-x";
            else eq += `${k}x`;
        }
        
        if (m !== 0) {
            if (m > 0 && k !== 0) eq += `+${m}`;
            else eq += `${m}`;
        } else if (k === 0) {
            eq += "0";
        }

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#7c3aed' }] },
                description: lang === 'sv' 
                    ? "Skriv den fullst√§ndiga r√§ta linjens ekvation p√• formen y = kx + m." 
                    : "Write the complete equation of the line in the form y = kx + m.",
                answerType: 'text'
            },
            token: this.toBase64(eq),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Hitta m (d√§r linjen sk√§r y-axeln)." : "Step 1: Find m (where the line crosses the y-axis).", latex: `m = ${m}` },
                { text: lang === 'sv' ? "Steg 2: Hitta k (lutningen per steg)." : "Step 2: Find k (the slope per step).", latex: `k = ${k}` },
                { text: lang === 'sv' ? "Steg 3: S√§tt ihop dem i formeln y = kx + m." : "Step 3: Combine them into the formula y = kx + m.", latex: eq }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }

    private level5_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(1, 4);
        const res = this.generate(subLevel, lang);
        res.metadata.mixed = true;
        return res;
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class NegativeNumbersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Foundations(lang);
            case 2: return this.level2_AddSubFluency(lang);
            case 3: return this.level3_Multiplication(lang);
            case 4: return this.level4_Division(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_Foundations(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'theory_number_line':
            case 'theory_sign_dominance':
            case 'theory_spot_lie':
                return this.level1_Foundations(lang, key);
            
            case 'fluency_chain_4':
            case 'fluency_chain_5':
            case 'fluency_double_neg':
            case 'fluency_plus_neg':
            case 'fluency_transform_match':
                return this.level2_AddSubFluency(lang, key);
            
            case 'mult_same_sign':
            case 'mult_diff_sign':
            case 'mult_inverse_missing':
            case 'mult_chain':
                return this.level3_Multiplication(lang, key);
            
            case 'div_same_sign':
            case 'div_diff_sign':
            case 'div_check_logic':
                return this.level4_Division(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    /**
     * Formats negative numbers with parentheses for LaTeX if needed
     */
    private p(n: number): string {
        return n < 0 ? `(${n})` : `${n}`;
    }

    // --- LEVEL 1: FOUNDATIONS ---
    private level1_Foundations(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['theory_number_line', 'theory_sign_dominance', 'theory_spot_lie']);

        if (v === 'theory_number_line') {
            const start = MathUtils.randomInt(-8, 5);
            const steps = MathUtils.randomInt(2, 6);
            const isRight = Math.random() > 0.5;
            const ans = isRight ? start + steps : start - steps;
            const dir = isRight 
                ? (lang === 'sv' ? "H√ñGER" : "RIGHT") 
                : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `F√∂rest√§ll dig att du st√•r p√• talet ${start} p√• tallinjen. Om du g√•r exakt ${steps} steg √•t ${dir}, p√• vilket tal hamnar du d√•?` 
                        : `Imagine you are standing at the number ${start} on the number line. If you move exactly ${steps} steps to the ${dir}, what number do you land on?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `N√§r du g√•r √•t ${dir} p√• tallinjen blir talet ${isRight ? 'st√∂rre' : 'mindre'}.` : `When you move to the ${dir} on the number line, the number gets ${isRight ? 'larger' : 'smaller'}.`, latex: `${start} ${isRight ? '+' : '-'} ${steps} = ${ans}` }
                ],
                metadata: { variation_key: 'theory_number_line', difficulty: 1 }
            };
        }

        if (v === 'theory_sign_dominance') {
            const pos = MathUtils.randomInt(5, 15);
            const neg = MathUtils.randomInt(-15, -5);
            const isPosLarger = pos > Math.abs(neg);
            const ansLabel = isPosLarger ? (lang === 'sv' ? "Positivt" : "Positive") : (lang === 'sv' ? "Negativt" : "Negative");
            const wrongLabel = isPosLarger ? (lang === 'sv' ? "Negativt" : "Negative") : (lang === 'sv' ? "Positivt" : "Positive");

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Utan att r√§kna ut det exakta svaret, avg√∂r om resultatet av $${pos} + (${neg})$ blir positivt eller negativt.` 
                        : `Without calculating the exact answer, determine if the result of $${pos} + (${neg})$ will be positive or negative.`,
                    answerType: 'multiple_choice',
                    options: [ansLabel, wrongLabel]
                },
                token: this.toBase64(ansLabel),
                clues: [
                    { text: lang === 'sv' ? "Titta p√• vilket tal som har st√∂rst avst√•nd till noll (st√∂rst absolutbelopp). Det tecknet vinner." : "Look at which number has the greatest distance to zero (greatest absolute value). That sign wins.", latex: `|${pos}| \\text{ vs } |${neg}|` }
                ],
                metadata: { variation_key: 'theory_sign_dominance', difficulty: 1 }
            };
        }

        const generateComparison = (isCorrect: boolean) => {
            const n1 = MathUtils.randomInt(-12, -1);
            const n2 = MathUtils.randomInt(-12, -1);
            if (n1 === n2) return "0 > -1"; // Fallback
            const realCorrect = n1 > n2;
            const text = realCorrect === isCorrect ? `${n1} > ${n2}` : `${n1} < ${n2}`;
            return text;
        };

        const lie = generateComparison(false);
        return {
            renderData: {
                description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden om negativa tals storleksordning √§r FALSKT?" : "Which of the following statements about the magnitude of negative numbers is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([generateComparison(true), generateComparison(true), lie])
            },
            token: this.toBase64(lie),
            clues: [{ text: lang === 'sv' ? "T√§nk p√• att ett negativt tal som √§r 'l√•ngt till v√§nster' p√• tallinjen alltid √§r mindre √§n ett tal n√§rmare noll." : "Keep in mind that a negative number that is 'far to the left' on the number line is always smaller than a number closer to zero." }],
            metadata: { variation_key: 'theory_spot_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 2: ADD/SUB FLUENCY ---
    private level2_AddSubFluency(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['fluency_chain_4', 'fluency_double_neg', 'fluency_plus_neg', 'fluency_transform_match']);

        if (v.startsWith('fluency_chain')) {
            const numTerms = v.endsWith('5') ? 5 : 4;
            const terms = Array.from({length: numTerms}, () => MathUtils.randomInt(-10, 10));
            const ops = Array.from({length: numTerms - 1}, () => MathUtils.randomChoice(['+', '-']));

            let latex = this.p(terms[0]);
            let runningTotal = terms[0];
            let simplifiedParts = [terms[0].toString()];

            for(let i=0; i < numTerms - 1; i++) {
                const next = terms[i+1];
                const op = ops[i];
                latex += ` ${op} ${this.p(next)}`;
                if (op === '+') runningTotal += next; else runningTotal -= next;

                const effectiveSign = (op === '+' && next >= 0) || (op === '-' && next < 0) ? '+' : '-';
                simplifiedParts.push(`${effectiveSign} ${Math.abs(next)}`);
            }

            return {
                renderData: {
                    latex: latex,
                    description: lang === 'sv' ? "Ber√§kna v√§rdet av uttrycket genom att steg f√∂r steg f√∂renkla tecknen." : "Calculate the value of the expression by simplifying the signs step by step.",
                    answerType: 'numeric'
                },
                token: this.toBase64(runningTotal.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Skriv om uttrycket genom att f√∂renkla alla dubbeltecken f√∂rst." : "Step 1: Rewrite the expression by simplifying all double signs first.", latex: simplifiedParts.join(" ") },
                    { text: lang === 'sv' ? "Steg 2: R√§kna ut summan fr√•n v√§nster till h√∂ger." : "Step 2: Calculate the sum from left to right.", latex: `\\text{Resultat} = ${runningTotal}` }
                ],
                metadata: { variation_key: v, difficulty: 4 }
            };
        }

        if (v === 'fluency_transform_match') {
            const a = MathUtils.randomInt(-5, 5);
            const b = MathUtils.randomInt(2, 9);
            const op = MathUtils.randomChoice(['+', '-']);
            const correct = op === '-' ? `${a} + ${b}` : `${a} - ${b}`;
            const wrong = op === '-' ? `${a} - ${b}` : `${a} + ${b}`;

            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket f√∂renklat uttryck betyder exakt samma sak som: $${a} ${op} (-${b})$?` : `Which simplified expression means exactly the same as: $${a} ${op} (-${b})$?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, wrong, `${a} ${op} ${b}`])
                },
                token: this.toBase64(correct),
                clues: [{ text: lang === 'sv' ? "Kom ih√•g teckenreglerna: plus och minus blir minus, medan tv√• minus blir plus." : "Remember the sign rules: plus and minus become minus, while two minuses become plus.", latex: op === '-' ? "-(-) \\rightarrow +" : "+(-) \\rightarrow -" }],
                metadata: { variation_key: 'fluency_transform_match', difficulty: 2 }
            };
        }

        const a = MathUtils.randomInt(-10, 10);
        const b = MathUtils.randomInt(1, 10);
        const op = v === 'fluency_double_neg' ? '-' : '+';
        const ans = op === '-' ? a + b : a - b;

        return {
            renderData: {
                latex: `${a} ${op} (-${b})`,
                description: lang === 'sv' ? "F√∂renkla de dubbla tecknen och ber√§kna det slutgiltiga v√§rdet." : "Simplify the double signs and calculate the final value.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? (op === '-' ? "Tv√• minustecken intill varandra blir ett plus." : "Ett plustecken och ett minustecken intill varandra blir ett minus.") : (op === '-' ? "Two minus signs next to each other become a plus." : "A plus sign and a minus sign next to each other become a minus."), latex: op === '-' ? "-(-) \\rightarrow +" : "+(-) \\rightarrow -" }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: MULTIPLICATION ---
    private level3_Multiplication(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_same_sign', 'mult_diff_sign', 'mult_inverse_missing', 'mult_chain']);

        if (v === 'mult_chain') {
            const numTerms = MathUtils.randomInt(3, 5);
            const factors = Array.from({length: numTerms}, () => {
                let n = MathUtils.randomInt(-5, 5);
                return n === 0 ? 1 : n; // Avoid zero for sign tracking focus
            });
            
            const ans = factors.reduce((acc, cur) => acc * cur, 1);
            const negCount = factors.filter(f => f < 0).length;
            const isEven = negCount % 2 === 0;

            const latex = factors.map(f => this.p(f)).join(' \\cdot ');

            return {
                renderData: {
                    latex,
                    description: lang === 'sv' 
                        ? "Ber√§kna produkten av alla talen i kedjan. Var extra noga med om svaret ska bli positivt eller negativt!" 
                        : "Calculate the product of all the numbers in the chain. Pay extra attention to whether the answer should be positive or negative!",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? `Steg 1: R√§kna hur m√•nga negativa tal det finns. Det √§r ${negCount} stycken.` 
                            : `Step 1: Count how many negative numbers there are. There are ${negCount}.`, 
                        latex: "" 
                    },
                    { 
                        text: lang === 'sv' 
                            ? (isEven ? `Ett j√§mnt antal minustecken (${negCount}) g√∂r att resultatet blir POSITIVT.` : `Ett udda antal minustecken (${negCount}) g√∂r att resultatet blir NEGATIVT.`)
                            : (isEven ? `An even number of minus signs (${negCount}) results in a POSITIVE answer.` : `An odd number of minus signs (${negCount}) results in a NEGATIVE answer.`), 
                        latex: isEven ? "(-) \\cdot (-) = +" : "(-) \\cdot (-) \\cdot (-) = -"
                    },
                    {
                        text: lang === 'sv' ? "Steg 2: Multiplicera sifferv√§rdena som vanligt." : "Step 2: Multiply the numerical values as usual.",
                        latex: factors.map(f => Math.abs(f)).join(' \\cdot ') + ` = ${Math.abs(ans)}`
                    }
                ],
                metadata: { variation_key: 'mult_chain', difficulty: 4 }
            };
        }

        const aVal = MathUtils.randomInt(2, 9), bVal = MathUtils.randomInt(2, 9);
        const signA = Math.random() > 0.5 ? 1 : -1;
        const signB = (v === 'mult_same_sign') ? signA : (v === 'mult_diff_sign' ? -signA : (Math.random() > 0.5 ? 1 : -1));
        
        const a = aVal * signA, b = bVal * signB;
        const ans = a * b;

        if (v === 'mult_inverse_missing') {
            return {
                renderData: {
                    latex: `${this.p(a)} \\cdot ? = ${ans}`,
                    description: lang === 'sv' ? "Vilken faktor saknas f√∂r att multiplikationen ska st√§mma?" : "What factor is missing for the multiplication to be correct?",
                    answerType: 'numeric'
                },
                token: this.toBase64(b.toString()),
                clues: [{ text: lang === 'sv' ? `Om produkten √§r ${ans > 0 ? 'positiv' : 'negativ'} och den f√∂rsta faktorn √§r ${a > 0 ? 'positiv' : 'negativ'}, vad m√•ste d√• den andra faktorn ha f√∂r tecken?` : `If the product is ${ans > 0 ? 'positive' : 'negative'} and the first factor is ${a > 0 ? 'positive' : 'negative'}, what sign must the second factor have?` }],
                metadata: { variation_key: 'mult_inverse_missing', difficulty: 3 }
            };
        }

        return {
            renderData: {
                latex: `${this.p(a)} \\cdot ${this.p(b)}`,
                description: lang === 'sv' ? "Ber√§kna produkten av de tv√• talen." : "Calculate the product of the two numbers.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Best√§m tecknet. Lika tecken ger ett positivt svar, olika tecken ger ett negativt svar." : "Step 1: Determine the sign. Like signs give a positive answer, different signs give a negative answer.", latex: signA === signB ? "(-) \\cdot (-) = +" : "(+) \\cdot (-) = -" },
                { text: lang === 'sv' ? `Steg 2: Multiplicera sifferv√§rdena: $${aVal} \\cdot ${bVal} = ${Math.abs(ans)}$.` : `Step 2: Multiply the numerical values: $${aVal} \\cdot ${bVal} = ${Math.abs(ans)}$.`, latex: "" }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 4: DIVISION ---
    private level4_Division(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['div_same_sign', 'div_diff_sign', 'div_check_logic']);
        const bVal = MathUtils.randomInt(2, 10), resVal = MathUtils.randomInt(2, 10);
        const signB = Math.random() > 0.5 ? 1 : -1;
        const signRes = (v === 'div_same_sign') ? (signB === 1 ? 1 : -1) : (v === 'div_diff_sign' ? -signB : (Math.random() > 0.5 ? 1 : -1));
        
        const b = bVal * signB, res = resVal * signRes;
        const a = b * res;

        if (v === 'div_check_logic') {
            const options = [
                `${this.p(res)} ¬∑ ${this.p(b)} = ${a}`,
                `${this.p(res)} + ${this.p(b)} = ${a}`,
                `${this.p(a)} ¬∑ ${this.p(b)} = ${res}`
            ];
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilken multiplikation bevisar att divisionen $${a} / ${this.p(b)} = ${res}$ √§r korrekt?` : `Which multiplication proves that the division $${a} / ${this.p(b)} = ${res}$ is correct?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(options)
                },
                token: this.toBase64(options[0]),
                clues: [{ text: lang === 'sv' ? "Division √§r multiplikation bakl√§nges. Kvoten g√•nger n√§mnaren ska alltid bli lika med t√§ljaren." : "Division is multiplication in reverse. The quotient times the denominator must always equal the numerator." }],
                metadata: { variation_key: 'div_check_logic', difficulty: 2 }
            };
        }

        return {
            renderData: {
                latex: `\\frac{${a}}{${this.p(b)}}`,
                description: lang === 'sv' ? "Ber√§kna kvoten av divisionen." : "Calculate the quotient of the division.",
                answerType: 'numeric'
            },
            token: this.toBase64(res.toString()),
            clues: [
                { text: lang === 'sv' ? "Teckenreglerna f√∂r division √§r exakt desamma som f√∂r multiplikation." : "The sign rules for division are exactly the same as for multiplication.", latex: (a > 0 && b > 0) || (a < 0 && b < 0) ? "(-) / (-) = +" : "(-) / (+) = -" }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    private level5_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        const data = this.generate(lvl, lang);
        data.metadata.mixed = true;
        return data;
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\PatternsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PatternsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Sequences(lang);
            case 2: return this.level2_HighTerm(lang);
            case 3: return this.level3_VisualFormula(lang);
            case 4: return this.level4_TableToFormula(lang);
            case 5: return this.level5_ReverseEngineering(lang);
            default: return this.level1_Sequences(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'seq_lie':
            case 'seq_type':
            case 'seq_diff':
            case 'seq_next':
                return this.level1_Sequences(lang, key);
            
            case 'high_term':
                return this.level2_HighTerm(lang, key);
            
            case 'formula_missing':
            case 'visual_calc':
            case 'find_formula':
                return this.level3_VisualFormula(lang, key);
            
            case 'table_formula':
            case 'table_fill':
                return this.level4_TableToFormula(lang, key);
            
            case 'reverse_calc':
                return this.level5_ReverseEngineering(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    /**
     * Internal helper to generate matchstick figure data for PatternVisual.jsx
     */
    private generateMatchstickData(type: 'squares' | 'triangles' | 'houses', count: number) {
        const sticks: { x1: number, y1: number, x2: number, y2: number }[] = [];
        const unitW = 40;
        const padding = 10;

        for (let i = 0; i < count; i++) {
            const xOffset = padding + (i * unitW);
            
            if (type === 'squares') {
                // Top
                sticks.push({ x1: xOffset, y1: 40, x2: xOffset + unitW, y2: 40 });
                // Bottom
                sticks.push({ x1: xOffset, y1: 80, x2: xOffset + unitW, y2: 80 });
                // Right
                sticks.push({ x1: xOffset + unitW, y1: 40, x2: xOffset + unitW, y2: 80 });
                // Left (only for the first one)
                if (i === 0) sticks.push({ x1: xOffset, y1: 40, x2: xOffset, y2: 80 });
            } 
            else if (type === 'triangles') {
                // Bottom
                sticks.push({ x1: xOffset, y1: 80, x2: xOffset + unitW, y2: 80 });
                // Right Slant Down
                sticks.push({ x1: xOffset + unitW / 2, y1: 40, x2: xOffset + unitW, y2: 80 });
                // Left Slant Up (only for the first one)
                if (i === 0) sticks.push({ x1: xOffset, y1: 80, x2: xOffset + unitW / 2, y2: 40 });
            }
            else if (type === 'houses') {
                // Square Base: Left, Bottom, Right
                if (i === 0) sticks.push({ x1: xOffset, y1: 50, x2: xOffset, y2: 90 }); // Left
                sticks.push({ x1: xOffset, y1: 90, x2: xOffset + unitW, y2: 90 }); // Bottom
                sticks.push({ x1: xOffset + unitW, y1: 50, x2: xOffset + unitW, y2: 90 }); // Right
                
                // Roof Slants
                sticks.push({ x1: xOffset, y1: 50, x2: xOffset + unitW / 2, y2: 20 });
                sticks.push({ x1: xOffset + unitW / 2, y1: 20, x2: xOffset + unitW, y2: 50 });
                
                // Horizontal separator (ceiling)
                sticks.push({ x1: xOffset, y1: 50, x2: xOffset + unitW, y2: 50 });
            }
        }

        return {
            width: (count * unitW) + (padding * 2),
            height: 100,
            sticks
        };
    }

    // --- LEVEL 1: SEQUENCES ---
    private level1_Sequences(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['seq_lie', 'seq_type', 'seq_diff', 'seq_next']);

        if (v === 'seq_lie') {
            const start = MathUtils.randomInt(2, 10);
            const diff = MathUtils.randomInt(2, 5);
            const seq = [start, start + diff, start + diff * 2, start + diff * 3];
            
            const sTrue1 = lang === 'sv' ? `√ñkningen √§r ${diff}` : `The increase is ${diff}`;
            const sTrue2 = lang === 'sv' ? `Starttalet √§r ${start}` : `The starting number is ${start}`;
            const sFalse = lang === 'sv' ? `N√§sta tal √§r ${seq[3] + diff + 1}` : `The next number is ${seq[3] + diff + 1}`;

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Studera noga hur talf√∂ljden f√∂r√§ndras: ${seq.join(', ')}... Vilket av p√•st√•endena nedan √§r FALSKT?` 
                        : `Examine how the sequence changes: ${seq.join(', ')}... Which of the statements below is FALSE?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse]),
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(sFalse),
                clues: [{ text: lang === 'sv' ? "Kontrollera skillnaden mellan talen och ber√§kna vad n√§sta steg logiskt borde bli." : "Check the difference between the numbers and calculate what the next step logically should be." }],
                metadata: { variation_key: 'seq_lie', difficulty: 1 }
            };
        }

        if (v === 'seq_type') {
            const isGeo = Math.random() > 0.5;
            const start = MathUtils.randomInt(2, 5);
            const factor = MathUtils.randomInt(2, 3);
            const seq = isGeo 
                ? [start, start * factor, start * Math.pow(factor, 2), start * Math.pow(factor, 3)]
                : [start, start + factor, start + factor * 2, start + factor * 3];

            const ans = isGeo ? (lang === 'sv' ? "Geometriskt" : "Geometric") : (lang === 'sv' ? "Aritmetiskt" : "Arithmetic");
            const wrong = isGeo ? (lang === 'sv' ? "Aritmetiskt" : "Arithmetic") : (lang === 'sv' ? "Geometriskt" : "Geometric");

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Titta p√• talf√∂ljden: ${seq.join(', ')}... √Ñr detta ett aritmetiskt m√∂nster (plus/minus) eller ett geometriskt m√∂nster (g√•nger/delat)?` 
                        : `Look at the sequence: ${seq.join(', ')}... Is this an arithmetic pattern (plus/minus) or a geometric pattern (times/divide)?`,
                    answerType: 'multiple_choice',
                    options: [ans, wrong],
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Aritmetiska m√∂nster √∂kar eller minskar med samma summa varje g√•ng. Geometriska m√∂nster f√∂r√§ndras genom multiplikation eller division." : "Arithmetic patterns increase or decrease by the same sum each time. Geometric patterns change through multiplication or division." }],
                metadata: { variation_key: 'seq_type', difficulty: 2 }
            };
        }

        const diff = MathUtils.randomInt(2, 9);
        const start = MathUtils.randomInt(1, 15);
        const seq = [start, start + diff, start + diff * 2, start + diff * 3];

        if (v === 'seq_diff') {
            return {
                renderData: {
                    description: lang === 'sv' ? `H√§r √§r en talf√∂ljd: ${seq.join(', ')}... Hur stor √§r den konstanta √∂kningen (differensen) i m√∂nstret?` : `Here is a sequence: ${seq.join(', ')}... What is the constant increase (difference) in the pattern?`,
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(diff.toString()),
                clues: [{ text: lang === 'sv' ? "Ta ett tal i f√∂ljden och dra ifr√•n talet som st√•r precis f√∂re." : "Take a number in the sequence and subtract the number that stands just before it.", latex: `${seq[1]} - ${seq[0]} = ${diff}` }],
                metadata: { variation_key: 'seq_diff', difficulty: 1 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Vilket tal kommer h√§rn√§st i m√∂nstret: ${seq.join(', ')}?` : `What is the next number in the pattern: ${seq.join(', ')}?`,
                answerType: 'numeric',
                geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '?'] }
            },
            token: this.toBase64((seq[3] + diff).toString()),
            clues: [{ text: lang === 'sv' ? `M√∂nstret √∂kar med ${diff} i varje steg. Addera ${diff} till det sista k√§nda talet i f√∂ljden.` : `The pattern increases by ${diff} for each step. Add ${diff} to the last known number in the sequence.`, latex: `${seq[3]} + ${diff} = ${seq[3] + diff}` }],
            metadata: { variation_key: 'seq_next', difficulty: 1 }
        };
    }

    // --- LEVEL 2: HIGH TERM ---
    private level2_HighTerm(lang: string, variationKey?: string): any {
        const diff = MathUtils.randomInt(3, 9);
        const start = MathUtils.randomInt(2, 15); 
        const targetN = MathUtils.randomChoice([10, 20, 50, 100]);
        const ans = start + (targetN - 1) * diff;

        return {
            renderData: { 
                description: lang === 'sv' ? `I ett m√∂nster som startar med ${start}, ${start + diff}, ${start + diff * 2}... vilket tal √§r nummer ${targetN} i ordningen?` : `In a pattern starting with ${start}, ${start + diff}, ${start + diff * 2}... what is the ${targetN}th number in the sequence?`, 
                answerType: 'numeric', 
                geometry: { type: 'pattern', subtype: 'sequence', sequence: [start, start + diff, start + diff * 2, '...'] } 
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? `Anv√§nd en genv√§g: F√∂r att n√• nummer ${targetN} fr√•n det f√∂rsta talet beh√∂ver du g√∂ra ${targetN - 1} hopp.` : `Use a shortcut: To reach number ${targetN} from the first number, you need to make ${targetN - 1} jumps.`, latex: "" },
                { text: lang === 'sv' ? "Multiplicera antalet hopp med √∂kningen och l√§gg till starttalet." : "Multiply the number of jumps by the increase and add the starting number.", latex: `${start} + (${targetN} - 1) \\cdot ${diff} = ${ans}` }
            ],
            metadata: { variation_key: 'high_term', difficulty: 2 }
        };
    }

    // --- LEVEL 3: VISUAL FORMULAS (With Matchstick Logic) ---
    private level3_VisualFormula(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['formula_missing', 'visual_calc', 'find_formula']);
        
        // Scenario definitions for matchstick growth
        const scenarios = [
            { type: 'squares', diff: 3, unitConst: 1, nameSv: "kvadrater", nameEn: "squares" },
            { type: 'triangles', diff: 2, unitConst: 1, nameSv: "trianglar", nameEn: "triangles" },
            { type: 'houses', diff: 5, unitConst: 1, nameSv: "hus", nameEn: "houses" }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const offset = MathUtils.randomInt(0, 2); // Random offset for starting count (e.g. Fig 1 has 2 houses)
        
        // n is figure index. x is actual object count.
        // x = n + offset
        // Sticks = diff * (n + offset) + unitConst
        // Sticks = (diff)n + (diff * offset + unitConst)
        const a = s.diff;
        const b = s.diff * offset + s.unitConst;
        const objName = lang === 'sv' ? s.nameSv : s.nameEn;

        // Generate visuals for Fig 1, Fig 2, Fig 3
        const figures = [
            this.generateMatchstickData(s.type as any, 1 + offset),
            this.generateMatchstickData(s.type as any, 2 + offset),
            this.generateMatchstickData(s.type as any, 3 + offset)
        ];

        const val1 = a * 1 + b;

        if (v === 'formula_missing') {
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `M√∂nstret av ${objName} f√∂ljer formeln $V = ?n + ${b}$. Om figur 1 best√•r av ${val1} stickor, vilket tal saknas d√• i formeln?` 
                        : `The pattern of ${objName} follows the formula $V = ?n + ${b}$. If figure 1 consists of ${val1} sticks, what number is missing in the formula?`,
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'matchsticks', figures: [figures[0], figures[1]] }
                },
                token: this.toBase64(a.toString()),
                clues: [{ text: lang === 'sv' ? "Talet som st√•r framf√∂r n motsvarar m√∂nstrets √∂kning. Hur m√•nga nya stickor tillkommer f√∂r varje ny figur?" : "The number in front of n corresponds to the pattern's increase. How many new sticks are added for each new figure?", latex: `${a * 2 + b} - ${a * 1 + b} = ${a}` }],
                metadata: { variation_key: 'formula_missing', difficulty: 3 }
            };
        }

        if (v === 'visual_calc') {
            const target = MathUtils.randomChoice([10, 20]);
            const ans = a * target + b;
            return {
                renderData: {
                    description: lang === 'sv' ? `M√∂nstret f√∂r ${objName} beskrivs av formeln $V = ${a}n + ${b}$. Hur m√•nga stickor beh√∂vs f√∂r att bygga figur nummer ${target}?` : `The pattern for ${objName} is described by the formula $V = ${a}n + ${b}$. How many sticks are needed to build figure number ${target}?`,
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'matchsticks', figures }
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? `S√§tt in figurnumret ${target} ist√§llet f√∂r n i formeln.` : `Insert the figure number ${target} instead of n in the formula.`, latex: `${a} \\cdot ${target} + ${b} = ${ans}` }],
                metadata: { variation_key: 'visual_calc', difficulty: 2 }
            };
        }

        // find_formula
        return {
            renderData: {
                description: lang === 'sv' ? `Vilken formel p√• formen $an + b$ beskriver antalet stickor i m√∂nstret av ${objName}?` : `Which formula of the form $an + b$ describes the number of sticks in the pattern of ${objName}?`,
                answerType: 'text',
                geometry: { type: 'pattern', subtype: 'matchsticks', figures } 
            },
            token: this.toBase64(`${a}n+${b}`),
            clues: [
                { text: lang === 'sv' ? `Steg 1: Hitta √∂kningen 'a' genom att se hur m√•nga nya stickor som l√§ggs till per figur.` : `Step 1: Find the increase 'a' by seeing how many new sticks are added per figure.`, latex: `a = ${a}` },
                { text: lang === 'sv' ? "Steg 2: Hitta startv√§rdet 'b' genom att ta v√§rdet i figur 1 minus √∂kningen." : "Step 2: Find the starting value 'b' by taking the value in figure 1 minus the increase.", latex: `${val1} - ${a} = ${b}` }
            ],
            metadata: { variation_key: 'find_formula', difficulty: 3 }
        };
    }

    // --- LEVEL 4: TABLE TO FORMULA ---
    private level4_TableToFormula(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['table_formula', 'table_fill']);
        const a = MathUtils.randomInt(2, 6);
        const b = MathUtils.randomInt(1, 5);
        const rows = [[1, a + b], [2, a * 2 + b], [3, a * 3 + b], [4, a * 4 + b]];

        if (v === 'table_formula') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Studera v√§rdena i tabellen noggrant. Vilken formel p√• formen $an + b$ beskriver sambandet mellan n och v√§rdet?" : "Study the values in the table carefully. Which formula of the form $an + b$ describes the relationship between n and the value?",
                    answerType: 'text',
                    geometry: { type: 'frequency_table', headers: ['n', 'V√§rde'], rows }
                },
                token: this.toBase64(`${a}n+${b}`),
                clues: [{ text: lang === 'sv' ? `Titta p√• hur mycket v√§rdet √∂kar f√∂r varje steg n. Det √§r din 'a'-koefficient.` : `Look at how much the value increases for each step n. That is your 'a' coefficient.`, latex: `a = ${a}` }],
                metadata: { variation_key: 'table_formula', difficulty: 3 }
            };
        }

        const targetN = 5;
        const targetVal = a * targetN + b;
        return {
            renderData: {
                description: lang === 'sv' ? `Anv√§nd det m√∂nster som tabellen visar f√∂r att r√§kna ut vilket v√§rde som h√∂r till figurnummer n = ${targetN}.` : `Use the pattern shown in the table to calculate which value corresponds to figure number n = ${targetN}.`,
                answerType: 'numeric',
                geometry: { type: 'frequency_table', headers: ['n', 'V√§rde'], rows }
            },
            token: this.toBase64(targetVal.toString()),
            clues: [{ text: lang === 'sv' ? `M√∂nstret i tabellen har en konstant √∂kning p√• ${a}. Addera detta till det sista k√§nda v√§rdet.` : `The pattern in the table has a constant increase of ${a}. Add this to the last known value.`, latex: `${rows[3][1]} + ${a} = ${targetVal}` }],
            metadata: { variation_key: 'table_fill', difficulty: 2 }
        };
    }

    // --- LEVEL 5: REVERSE ENGINEERING ---
    private level5_ReverseEngineering(lang: string, variationKey?: string): any {
        const a = MathUtils.randomInt(3, 8);
        const b = MathUtils.randomInt(2, 10);
        const n = MathUtils.randomInt(10, 50);
        const total = a * n + b;
        const formula = `${a}n + ${b}`;

        return {
            renderData: {
                description: lang === 'sv'
                    ? `Ett v√§xande m√∂nster beskrivs av formeln $V = ${formula}$. Vilket figurnummer (n) har m√∂nstret n√§r det totala v√§rdet √§r uppe i ${total}?`
                    : `A growing pattern is described by the formula $V = ${formula}$. Which figure number (n) does the pattern have when the total value reaches ${total}?`,
                answerType: 'numeric'
            },
            token: this.toBase64(n.toString()),
            clues: [
                { text: lang === 'sv' ? `Arbeta bakl√§nges: B√∂rja med att dra bort det fasta v√§rdet (${b}) fr√•n det totala v√§rdet.` : `Work backwards: Start by subtracting the fixed value (${b}) from the total value.`, latex: `${total} - ${b} = ${total - b}` },
                { text: lang === 'sv' ? `Dela sedan det kvarvarande v√§rdet med den konstanta √∂kningen (${a}) f√∂r att hitta n.` : `Then divide the remaining value by the constant increase (${a}) to find n.`, latex: `\\frac{${total - b}}{${a}} = ${n}` }
            ],
            metadata: { variation_key: 'reverse_calc', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\PatternsGen.ts

// =======================================================
// FILE START: src\core\generators\PercentGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PercentGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ConceptsAndVisuals(lang);
            case 2: return this.level2_MentalMath(lang);
            case 3: return this.level3_BuildingBlocks(lang);
            case 4: return this.level4_PercentEquation(lang);
            case 5: return this.level5_ReversePercentage(lang);
            case 6: return this.level6_PercentageChange(lang);
            default: return this.level1_ConceptsAndVisuals(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'visual_translation':
            case 'visual_lie':
            case 'equivalence':
                return this.level1_ConceptsAndVisuals(lang, key);
            
            case 'benchmark_calc':
            case 'benchmark_inverse':
            case 'benchmark_commutative':
                return this.level2_MentalMath(lang, key);
            
            case 'composition':
            case 'decomposition':
            case 'estimation':
                return this.level3_BuildingBlocks(lang, key);
            
            case 'find_percent_basic':
            case 'find_percent_test':
            case 'find_percent_discount':
            case 'find_percent_group':
                return this.level4_PercentEquation(lang, key);
            
            case 'reverse_find_whole':
            case 'reverse_scaling':
            case 'reverse_concept':
                return this.level5_ReversePercentage(lang, key);
            
            case 'change_calc':
            case 'change_multiplier':
            case 'change_trap':
                return this.level6_PercentageChange(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPTS & VISUALS ---
    private level1_ConceptsAndVisuals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['visual_translation', 'visual_lie', 'equivalence']);

        if (v === 'visual_translation') {
            const colored = MathUtils.randomInt(1, 99);
            const targetType = MathUtils.randomChoice(['fraction', 'decimal', 'percent']);
            
            let answer = "";
            let desc = "";

            if (targetType === 'fraction') {
                desc = lang === 'sv' 
                    ? "Titta p√• rutn√§tet nedan. Hur stor andel av rutorna √§r f√§rgade? Svara i br√•kform." 
                    : "Look at the grid below. What fraction of the squares are colored? Answer as a fraction.";
                answer = `${colored}/100`;
            } else if (targetType === 'decimal') {
                desc = lang === 'sv' 
                    ? "Studera figuren och ange hur stor andel som √§r f√§rgad i decimalform." 
                    : "Study the figure and state how large a part is colored in decimal form.";
                answer = (colored / 100).toString().replace('.', ',');
            } else {
                desc = lang === 'sv' 
                    ? "Hur m√•nga procent av hela rutn√§tet √§r f√§rgat med bl√• f√§rg?" 
                    : "What percentage of the entire grid is colored in blue?";
                answer = colored.toString();
            }

            return {
                renderData: {
                    description: desc,
                    answerType: targetType === 'fraction' ? 'fraction' : 'numeric',
                    suffix: targetType === 'percent' ? '%' : '',
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(answer),
                clues: [
                    { text: lang === 'sv' ? "Hela rutn√§tet best√•r av exakt 100 rutor. Varje f√§rgad ruta motsvarar d√§rf√∂r en hundradel eller en procent." : "The whole grid consists of exactly 100 squares. Therefore, each colored square corresponds to one hundredth or one percent.", latex: "" },
                    { text: lang === 'sv' ? `Vi har ${colored} f√§rgade rutor av totalt 100.` : `We have ${colored} colored squares out of a total of 100.`, latex: `\\frac{${colored}}{100} = ${colored}\\%` }
                ],
                metadata: { variation_key: 'visual_translation', difficulty: 1 }
            };
        }

        if (v === 'visual_lie') {
            const colored = MathUtils.randomInt(15, 85);
            const sTrue1 = `${colored}%`;
            const sTrue2 = (colored > 50) 
                ? (lang === 'sv' ? "Mer √§n h√§lften" : "More than half") 
                : (lang === 'sv' ? "Mindre √§n h√§lften" : "Less than half");
            const sFalse = (colored / 10).toString().replace('.', ',');

            return {
                renderData: {
                    description: lang === 'sv' ? "Granska figuren och p√•st√•endena nedan. Vilket av alternativen √§r FALSKT?" : "Examine the figure and the statements below. Which of the options is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse]),
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(sFalse),
                clues: [{ text: lang === 'sv' ? `Det finns exakt ${colored} bl√• rutor. Eftersom det √§r 100 rutor totalt motsvarar det ${colored}%, inte ${sFalse}.` : `There are exactly ${colored} blue squares. Since there are 100 squares total, that corresponds to ${colored}%, not ${sFalse}.` }],
                metadata: { variation_key: 'visual_lie', difficulty: 1 }
            };
        }

        const p = MathUtils.randomChoice([10, 20, 25, 40, 50, 75, 80]);
        const dec = (p / 100).toString().replace('.', ',');
        const wrong = (p / 10).toString().replace('.', ','); 

        return {
            renderData: {
                description: lang === 'sv' ? `Vilket av f√∂ljande alternativ representerar INTE samma v√§rde som ${p}%?` : `Which of the following options does NOT represent the same value as ${p}%?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([dec, `${p}/100`, `${p/MathUtils.gcd(p,100)}/${100/MathUtils.gcd(p,100)}`, wrong]) 
            },
            token: this.toBase64(wrong),
            clues: [{ text: lang === 'sv' ? "Kom ih√•g att procent betyder hundradelar. F√∂r att f√• decimalform flyttar vi kommat tv√• steg." : "Remember that percent means hundredths. To get decimal form, we move the decimal point two places.", latex: `${p}\\% = \\frac{${p}}{100} = ${p/100}` }],
            metadata: { variation_key: 'equivalence', difficulty: 1 }
        };
    }

    // --- LEVEL 2: MENTAL MATH BENCHMARKS ---
    private level2_MentalMath(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['benchmark_calc', 'benchmark_inverse', 'benchmark_commutative']);
        const benchmark = MathUtils.randomChoice([10, 20, 25, 50]);

        if (v === 'benchmark_calc') {
            const step = benchmark === 50 ? 2 : (benchmark === 25 ? 4 : (benchmark === 20 ? 5 : 10));
            const base = MathUtils.randomInt(3, 15) * step;
            const ans = (base * benchmark) / 100;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna hur mycket ${benchmark}% av ${base} √§r utan att anv√§nda minir√§knare.` : `Calculate how much ${benchmark}% of ${base} is without using a calculator.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? `T√§nk p√• ${benchmark}% som br√•ket $1/${step}$. Du kan allts√• helt enkelt dela talet med ${step}.` : `Think of ${benchmark}% as the fraction $1/${step}$. You can simply divide the number by ${step}.`, latex: `\\frac{${base}}{${step}} = ${ans}` }],
                metadata: { variation_key: 'benchmark_calc', difficulty: 2 }
            };
        }

        if (v === 'benchmark_inverse') {
            const part = MathUtils.randomInt(4, 20);
            const step = benchmark === 50 ? 2 : (benchmark === 25 ? 4 : (benchmark === 20 ? 5 : 10));
            const total = part * step;

            return {
                renderData: {
                    description: lang === 'sv' ? `Vi vet att ${benchmark}% av ett ok√§nt tal √§r ${part}. Vilket √§r d√• det hela talet (100%)?` : `We know that ${benchmark}% of an unknown number is ${part}. What is the whole number (100%)?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(total.toString()),
                clues: [{ text: lang === 'sv' ? `Eftersom det g√•r ${step} stycken delar av ${benchmark}% p√• en helhet, multiplicerar vi delens v√§rde med ${step}.` : `Since there are ${step} parts of ${benchmark}% in a whole, we multiply the part's value by ${step}.`, latex: `${part} \\cdot ${step} = ${total}` }],
                metadata: { variation_key: 'benchmark_inverse', difficulty: 2 }
            };
        }

        const n1 = MathUtils.randomChoice([25, 50]);
        const n2 = MathUtils.randomInt(4, 15) * (n1 === 25 ? 4 : 2);
        const ans = (n1 * n2) / 100;

        return {
            renderData: {
                description: lang === 'sv' ? `Anv√§nd ett smart knep f√∂r att ber√§kna detta i huvudet: ${n2}% av ${n1}.` : `Use a smart trick to calculate this in your head: ${n2}% of ${n1}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [{ text: lang === 'sv' ? "Knepet √§r att $x \\%$ av $y$ √§r exakt samma sak som $y \\%$ av $x$. Det √§r enklare att r√§kna ut den k√§nda procenten av det andra talet." : "The trick is that $x \\%$ of $y$ is exactly the same as $y \\%$ of $x$. It is easier to calculate the known percentage of the other number.", latex: `${n1}\\% \\text{ av } ${n2} = ${ans}` }],
            metadata: { variation_key: 'benchmark_commutative', difficulty: 2 }
        };
    }

    // --- LEVEL 3: BUILDING BLOCKS ---
    private level3_BuildingBlocks(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['composition', 'decomposition', 'estimation']);

        if (v === 'composition') {
            const base = MathUtils.randomInt(4, 15) * 10;
            const pct = MathUtils.randomChoice([30, 40, 60, 70, 80, 90]);
            const ans = (base * pct) / 100;

            return {
                renderData: {
                    description: lang === 'sv' ? `R√§kna ut vad ${pct}% av ${base} √§r genom att f√∂rst ta reda p√• vad 10% √§r.` : `Calculate what ${pct}% of ${base} is by first finding out what 10% is.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Hitta 10% genom att dela talet med 10." : "Step 1: Find 10% by dividing the number by 10.", latex: `10 \\% = \\frac{${base}}{10} = ${base/10}` },
                    { text: lang === 'sv' ? `Steg 2: Eftersom du vill ha ${pct}%, multiplicerar du 10-procentsv√§rdet med ${pct/10}.` : `Step 2: Since you want ${pct}%, multiply the 10-percent value by ${pct/10}.`, latex: `${base/10} \\cdot ${pct/10} = ${ans}` }
                ],
                metadata: { variation_key: 'composition', difficulty: 2 }
            };
        }

        if (v === 'decomposition') {
            const base = MathUtils.randomInt(5, 20) * 20;
            const ans = (base * 5) / 100;

            return {
                renderData: {
                    description: lang === 'sv' ? `Om du vet att 10% av ${base} √§r ${base/10}, vad √§r d√• h√§lften av det, allts√• 5% av talet?` : `If you know that 10% of ${base} is ${base/10}, what is half of that, i.e., 5% of the number?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? "Dela helt enkelt v√§rdet f√∂r 10% med 2 f√∂r att f√• fram vad 5% motsvarar." : "Simply divide the value for 10% by 2 to find what 5% corresponds to.", latex: `\\frac{${base/10}}{2} = ${ans}` }],
                metadata: { variation_key: 'decomposition', difficulty: 2 }
            };
        }

        const base = MathUtils.randomInt(10, 60) * 2;
        const testPct = MathUtils.randomInt(11, 19);
        const target = base * 0.15; 
        const isGreater = (base * testPct / 100) > target;
        const ans = isGreater ? (lang === 'sv' ? "St√∂rre" : "Greater") : (lang === 'sv' ? "Mindre" : "Smaller");

        return {
            renderData: {
                description: lang === 'sv' ? `G√∂r en snabb uppskattning: √§r ${testPct}% av ${base} st√∂rre eller mindre √§n ${target.toString().replace('.', ',')}?` : `Make a quick estimate: is ${testPct}% of ${base} greater or smaller than ${target}?`,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["St√∂rre", "Mindre"] : ["Greater", "Smaller"]
            },
            token: this.toBase64(ans),
            clues: [{ text: lang === 'sv' ? `Anv√§nd 10% och 20% som mentala st√∂djepunkter f√∂r att se om ${testPct}% hamnar √∂ver eller under m√•let.` : `Use 10% and 20% as mental benchmarks to see if ${testPct}% falls above or below the target.` }],
            metadata: { variation_key: 'estimation', difficulty: 3 }
        };
    }

    // --- LEVEL 4: PERCENT EQUATION (Word Problems) ---
    private level4_PercentEquation(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['find_percent_basic', 'find_percent_test', 'find_percent_discount', 'find_percent_group']);
        
        const scenarios = {
            find_percent_test: [
                { sv: (p:any, w:any) => `Du svarade r√§tt p√• ${p} fr√•gor av totalt ${w} stycken p√• ett prov. Hur m√•nga procent r√§tt hade du?`, en: (p:any, w:any) => `You answered ${p} questions correctly out of a total of ${w} on a test. What percentage did you get right?` }
            ],
            find_percent_discount: [
                { sv: (p:any, w:any) => `En vara s√§nktes med ${p} kr fr√•n sitt ordinarie pris p√• ${w} kr. Hur m√•nga procent motsvarade s√§nkningen?`, en: (p:any, w:any) => `An item was reduced by ${p} kr from its original price of ${w} kr. What percentage was the reduction?` }
            ],
            find_percent_group: [
                { sv: (p:any, w:any) => `I en grupp p√• ${w} personer b√§r ${p} stycken glas√∂gon. Hur stor andel av gruppen b√§r glas√∂gon i procent?`, en: (p:any, w:any) => `In a group of ${w} people, ${p} wear glasses. What percentage of the group wears glasses?` }
            ],
            find_percent_basic: [
                { sv: (p:any, w:any) => `Talet ${p} √§r hur m√•nga procent av talet ${w}?`, en: (p:any, w:any) => `The number ${p} is what percentage of the number ${w}?` }
            ]
        };

        const wholes = [20, 25, 40, 50, 200];
        const w = MathUtils.randomChoice(wholes);
        const p = MathUtils.randomChoice([5, 10, 15, 20, 25, 40, 60, 80]);
        const part = (p * w) / 100;

        const s: any = MathUtils.randomChoice(scenarios[v as keyof typeof scenarios]);
        const desc = lang === 'sv' ? s.sv(part, w) : s.en(part, w);

        return {
            renderData: { description: desc, answerType: 'numeric', suffix: '%' },
            token: this.toBase64(p.toString()),
            clues: [
                { text: lang === 'sv' ? "F√∂r att hitta andelen i procent tar vi delen och dividerar den med det hela." : "To find the share in percent, we take the part and divide it by the whole.", latex: `\\text{Andel} = \\frac{${part}}{${w}}` },
                { text: lang === 'sv' ? "Omvandla br√•ket till procent genom att skriva om det till hundradelar." : "Convert the fraction to a percentage by rewriting it as hundredths.", latex: `\\frac{${part}}{${w}} = \\frac{${p}}{100} = ${p}\\%` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 5: REVERSE PERCENTAGE ---
    private level5_ReversePercentage(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['reverse_find_whole', 'reverse_scaling', 'reverse_concept']);

        if (v === 'reverse_find_whole') {
            const p = MathUtils.randomChoice([5, 10, 20, 25, 50]);
            const w = MathUtils.randomInt(4, 15) * 20;
            const part = (p * w) / 100;

            const scenarios = [
                { sv: `${p}% av deltagarna i ett lopp √§r ${part} personer. Hur m√•nga deltog totalt?`, en: `${p}% of the participants in a race is ${part} people. How many participated in total?` },
                { sv: `${p}% av pengarna i en kassa √§r ${part} kr. Hur mycket finns det totalt?`, en: `${p}% of the money in a cash register is ${part} kr. How much is there in total?` }
            ];
            const s = MathUtils.randomChoice(scenarios);

            return {
                renderData: {
                    description: lang === 'sv' ? s.sv : s.en,
                    answerType: 'numeric'
                },
                token: this.toBase64(w.toString()),
                clues: [
                    { text: lang === 'sv' ? `Ta reda p√• vad 1% √§r genom att dela ${part} med ${p}.` : `Find out what 1% is by dividing ${part} by ${p}.`, latex: `1\\% = \\frac{${part}}{${p}} = ${part/p}` },
                    { text: lang === 'sv' ? "Multiplicera sedan detta v√§rde med 100 f√∂r att f√• fram 100%." : "Then multiply this value by 100 to get 100%.", latex: `${part/p} \\cdot 100 = ${w}` }
                ],
                metadata: { variation_key: 'reverse_find_whole', difficulty: 3 }
            };
        }

        if (v === 'reverse_scaling') {
            const val10 = MathUtils.randomInt(8, 60);
            const targetP = MathUtils.randomChoice([30, 40, 70, 80]);
            const factor = targetP / 10;
            const ans = val10 * factor;

            return {
                renderData: {
                    description: lang === 'sv' ? `Du vet att 10% av ett pris √§r ${val10} kr. Hur mycket √§r d√• ${targetP}% av samma pris?` : `You know that 10% of a price is ${val10} kr. How much is ${targetP}% of the same price?`,
                    answerType: 'numeric', suffix: 'kr'
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? `Eftersom ${targetP}% √§r ${factor} g√•nger s√• mycket som 10%, multiplicerar vi v√§rdet med ${factor}.` : `Since ${targetP}% is ${factor} times as much as 10%, we multiply the value by ${factor}.`, latex: `${val10} \\cdot ${factor} = ${ans}` }],
                metadata: { variation_key: 'reverse_scaling', difficulty: 3 }
            };
        }

        const q = lang === 'sv' ? "Om vi vet v√§rdet av 25% av ett tal, hur f√•r vi d√• fram hela talet (100%) p√• enklaste s√§tt?" : "If we know the value of 25% of a number, how do we find the whole number (100%) in the simplest way?";
        const ansLabel = lang === 'sv' ? "Multiplicera med 4" : "Multiply by 4";

        return {
            renderData: {
                description: q,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([ansLabel, lang === 'sv' ? "Dividera med 4" : "Divide by 4", lang === 'sv' ? "Multiplicera med 25" : "Multiply by 25"])
            },
            token: this.toBase64(ansLabel),
            clues: [{ text: lang === 'sv' ? "Eftersom $25 \\%$ √§r en fj√§rdedel ($1/4$), beh√∂vs det fyra s√•dana delar f√∂r att n√• 100%." : "Since $25 \\%$ is a quarter ($1/4$), four such parts are needed to reach 100%." }],
            metadata: { variation_key: 'reverse_concept', difficulty: 2 }
        };
    }

    // --- LEVEL 6: PERCENTAGE CHANGE ---
    private level6_PercentageChange(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['change_calc', 'change_multiplier', 'change_trap']);

        if (v === 'change_calc') {
            const oldVal = MathUtils.randomInt(3, 12) * 100;
            const p = MathUtils.randomChoice([10, 20, 25, 40, 50]);
            const isInc = Math.random() > 0.5;
            const newVal = isInc ? oldVal * (1 + p/100) : oldVal * (1 - p/100);

            const scenarios = [
                { sv: `Priset p√• en aktie √§ndrades fr√•n ${oldVal} kr till ${newVal} kr. Hur stor var f√∂r√§ndringen i procent?`, en: `The price of a stock changed from ${oldVal} kr to ${newVal} kr. How large was the change in percent?` },
                { sv: `Folkm√§ngden i en by √§ndrades fr√•n ${oldVal} till ${newVal} inv√•nare. Ange f√∂r√§ndringen i procent.`, en: `The population of a village changed from ${oldVal} to ${newVal} inhabitants. State the change in percent?` }
            ];
            const s = MathUtils.randomChoice(scenarios);

            return {
                renderData: {
                    description: lang === 'sv' ? s.sv : s.en,
                    answerType: 'numeric', suffix: '%'
                },
                token: this.toBase64(p.toString()),
                clues: [
                    { text: lang === 'sv' ? "Anv√§nd formeln f√∂r procentuell f√∂r√§ndring: Skillnaden dividerat med det ursprungliga v√§rdet." : "Use the formula for percentage change: The difference divided by the original value.", latex: `\\text{F√∂r√§ndring} = \\frac{\\text{Skillnad}}{\\text{Ursprung}}` },
                    { text: lang === 'sv' ? `Skillnaden √§r ${Math.abs(newVal - oldVal)} enheter.` : `The difference is ${Math.abs(newVal - oldVal)} units.`, latex: `\\frac{${Math.abs(newVal - oldVal)}}{${oldVal}} = ${p/100} = ${p}\\%` }
                ],
                metadata: { variation_key: 'change_calc', difficulty: 4 }
            };
        }

        if (v === 'change_multiplier') {
            const p = MathUtils.randomInt(5, 50);
            const isInc = Math.random() > 0.5;
            const ans = isInc ? (1 + p/100) : (1 - p/100);

            return {
                renderData: {
                    description: lang === 'sv' ? `Vilken f√∂r√§ndringsfaktor motsvarar en ${isInc ? 'pris√∂kning' : 'priss√§nkning'} med ${p}%?` : `Which change factor corresponds to a ${isInc ? 'price increase' : 'price decrease'} of ${p}%?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString().replace('.', ',')),
                clues: [{ text: lang === 'sv' ? (isInc ? "Vid en √∂kning l√§gger vi till procenten till 1,00." : "Vid en s√§nkning drar vi bort procenten fr√•n 1,00.") : (isInc ? "For an increase, we add the percentage to 1.00." : "For a decrease, we subtract the percentage from 1.00."), latex: isInc ? `1 + ${p/100} = ${ans}` : `1 - ${p/100} = ${ans}` }],
                metadata: { variation_key: 'change_multiplier', difficulty: 3 }
            };
        }

        const pVal = 10;
        const ansLabel = lang === 'sv' ? "Det √§r l√§gre √§n startpriset" : "It is lower than the starting price";
        return {
            renderData: {
                description: lang === 'sv' ? `Ett pris h√∂js f√∂rst med ${pVal}% och s√§nks d√§refter omedelbart med ${pVal}%. Vilket p√•st√•ende st√§mmer om det slutgiltiga priset?` : `A price first increases by ${pVal}% and then immediately after decreases by ${pVal}%. Which statement is true about the final price?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([ansLabel, lang === 'sv' ? "Det √§r samma som startpriset" : "It is the same as the starting price", lang === 'sv' ? "Det √§r h√∂gre √§n startpriset" : "It is higher than the starting price"])
            },
            token: this.toBase64(ansLabel),
            clues: [
                { text: lang === 'sv' ? "Detta √§r en klassisk f√§lla! Den andra s√§nkningen ber√§knas p√• det nya, h√∂gre priset, vilket g√∂r s√§nkningen st√∂rre i kronor r√§knat." : "This is a classic trap! The second decrease is calculated on the new, higher price, which makes the decrease larger in absolute terms.", latex: "" },
                { text: lang === 'sv' ? "Testa med 100 kr: $100 \\cdot 1,10 = 110$. Sedan $110 \\cdot 0,90 = 99$." : "Test with 100 kr: $100 \\cdot 1.10 = 110$. Then $110 \\cdot 0.90 = 99$.", latex: "" }
            ],
            metadata: { variation_key: 'change_trap', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\PercentGen.ts

// =======================================================
// FILE START: src\core\generators\ProbabilityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ProbabilityGen {
    // --- CONTEXT LIBRARY ---
    private static readonly SCENARIOS = {
        containers: [
            { sv: "en p√•se", en: "a bag" },
            { sv: "en urna", en: "an urn" },
            { sv: "en glasburk", en: "a glass jar" },
            { sv: "en l√•da", en: "a box" },
            { sv: "en sk√•l", en: "a bowl" }
        ],
        items: [
            { sv: ["r√∂da", "bl√•a", "gr√∂na"], en: ["red", "blue", "green"], type: "marbles" },
            { sv: ["sura", "s√∂ta", "starka"], en: ["sour", "sweet", "spicy"], type: "candies" },
            { sv: ["vuxna", "barn", "pension√§rer"], en: ["adults", "children", "seniors"], type: "people" },
            { sv: ["elbilar", "bensinbilar", "hybridbilar"], en: ["electric", "petrol", "hybrid"], type: "cars" },
            { sv: ["√§pplen", "bananer", "p√§ron"], en: ["apples", "bananas", "pears"], type: "fruits" },
            { sv: ["spader", "hj√§rter", "kl√∂ver"], en: ["spades", "hearts", "clubs"], type: "cards" }
        ],
        lotteries: [
            { sv: "Lotteri Alfa", en: "Lottery Alpha" },
            { sv: "Lotteri Beta", en: "Lottery Beta" },
            { sv: "Spelhjul X", en: "Spinner X" },
            { sv: "Spelhjul Y", en: "Spinner Y" }
        ],
        likelihood: [
            { category: 'impossible', sv: ["att sl√• en 7:a med en vanlig t√§rning", "att en triangel har 4 h√∂rn", "att det sn√∂ar vid +40 grader"], en: ["rolling a 7 on a standard die", "a triangle having 4 corners", "it snowing at +40¬∞C"], val: 0 },
            { category: 'certain', sv: ["att solen g√•r upp imorgon", "att f√• krona eller klave vid ett myntkast", "att sl√• under 7 med en t√§rning"], en: ["the sun rising tomorrow", "getting heads or tails on a coin flip", "rolling under 7 on a die"], val: 1 },
            { category: 'even', sv: ["att f√• krona vid slantsingling", "att sl√• ett j√§mnt tal med en t√§rning", "att dra ett r√∂tt kort ur en kortlek"], en: ["getting heads on a coin toss", "rolling an even number on a die", "picking a red card from a deck"], val: 0.5 }
        ],
        atLeastOne: [
            { sv: "ett fr√∂ gror", en: "a seed sprouts", denoms: [2, 3, 4, 5] },
            { sv: "en skytt tr√§ffar m√•let", en: "a shooter hits the target", denoms: [2, 3, 5, 10] },
            { sv: "en lott ger vinst", en: "a ticket is a winner", denoms: [4, 5, 10, 20] }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_StandardGroups(lang);
            case 3: return this.level3_ConceptsAndLogic(lang);
            case 4: return this.level4_Complementary(lang);
            case 5: return this.level5_ProbabilityTree(lang);
            case 6: return this.level6_EventChains(lang);
            case 7: return this.level7_Combinatorics(lang);
            case 8: return this.level8_CombinatoricsComplex(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'visual_not':
            case 'visual_or':
            case 'visual_calc':
            case 'visual_spinner':
                return this.level1_Visuals(lang, key);
            case 'group_ratio':
            case 'group_ternary':
                return this.level2_StandardGroups(lang, key);
            case 'concept_compare':
            case 'concept_validity':
            case 'concept_likelihood':
                return this.level3_ConceptsAndLogic(lang, key);
            case 'comp_at_least':
            case 'comp_multi':
            case 'comp_lie':
                return this.level4_Complementary(lang, key);
            case 'tree_missing':
            case 'tree_calc':
                return this.level5_ProbabilityTree(lang, key);
            case 'chain_any_order':
            case 'chain_fixed_order':
                return this.level6_EventChains(lang, key);
            case 'comb_constraint':
            case 'comb_handshake':
                return this.level7_Combinatorics(lang, key);
            case 'pathways_basic':
            case 'pathways_blocked':
            case 'pathways_prob':
                return this.level8_CombinatoricsComplex(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private rawFraction(n: number, d: number): string {
        return `${n}/${d}`;
    }

    // --- LEVEL 1: VISUALS ---
    private level1_Visuals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['visual_not', 'visual_or', 'visual_calc', 'visual_spinner']);
        const counts = [MathUtils.randomInt(2, 5), MathUtils.randomInt(2, 5), MathUtils.randomInt(1, 4)];
        const total = counts.reduce((a, b) => a + b, 0);
        const labels = lang === 'sv' ? ["R√∂d", "Bl√•", "Gr√∂n"] : ["Red", "Blue", "Green"];
        const container = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.containers);

        if (v === 'visual_spinner') {
            const sections = MathUtils.randomChoice([4, 6, 8, 10]);
            const winSections = MathUtils.randomInt(1, sections / 2);
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Ett lyckohjul √§r uppdelat i ${sections} lika stora f√§lt. ${winSections} av f√§lten ger vinst. Vad √§r sannolikheten att du vinner p√• ett snurr?` 
                        : `A spinner is divided into ${sections} equal sections. ${winSections} of the sections result in a win. What is the probability that you win on one spin?`,
                    answerType: 'fraction',
                    geometry: { type: 'probability_spinner', sections }
                },
                token: this.toBase64(this.rawFraction(winSections, sections)),
                clues: [{ text: lang === 'sv' ? "Sannolikheten ber√§knas genom att dela antalet vinstf√§lt med det totala antalet f√§lt p√• hjulet." : "Probability is calculated by dividing the number of winning sections by the total number of sections on the wheel.", latex: `P = \\frac{${winSections}}{${sections}}` }],
                metadata: { variation_key: 'visual_spinner', difficulty: 1 }
            };
        }

        if (v === 'visual_not') {
            const targetIdx = MathUtils.randomInt(0, 2);
            const ansCount = total - counts[targetIdx];
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `I ${container.sv} finns totalt ${total} kulor. Om du drar en kula utan att titta, vad √§r sannolikheten att du INTE f√•r en ${labels[targetIdx].toLowerCase()} kula?` 
                        : `In ${container.en}, there are ${total} marbles. If you pick one without looking, what is the probability that you do NOT pick a ${labels[targetIdx].toLowerCase()} marble?`,
                    answerType: 'fraction',
                    geometry: { type: 'probability_marbles', items: { red: counts[0], blue: counts[1], green: counts[2] } }
                },
                token: this.toBase64(this.rawFraction(ansCount, total)),
                clues: [
                    { text: lang === 'sv' ? "Sannolikheten f√∂r 'inte' inneb√§r att vi r√§knar alla kulor som har en annan f√§rg √§n den som n√§mns." : "The probability of 'not' means we count all marbles that have a color other than the one mentioned.", latex: `${total} - ${counts[targetIdx]} = ${ansCount}` },
                    { text: lang === 'sv' ? "Dela sedan antalet 'giltiga' kulor med det totala antalet." : "Then divide the number of 'valid' marbles by the total number.", latex: `\\frac{${ansCount}}{${total}}` }
                ],
                metadata: { variation_key: 'visual_not', difficulty: 2 }
            };
        }

        if (v === 'visual_or') {
            const idx1 = 0, idx2 = 1;
            const ansCount = counts[idx1] + counts[idx2];
            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Du ska dra en kula ur en samling. Hur stor √§r sannolikheten att du f√•r antingen en ${labels[idx1].toLowerCase()} eller en ${labels[idx2].toLowerCase()} kula?`
                        : `You are picking a marble from a collection. What is the probability that you get either a ${labels[idx1].toLowerCase()} or a ${labels[idx2].toLowerCase()} marble?`,
                    answerType: 'fraction',
                    geometry: { type: 'probability_marbles', items: { red: counts[0], blue: counts[1], green: counts[2] } }
                },
                token: this.toBase64(this.rawFraction(ansCount, total)),
                clues: [{ text: lang === 'sv' ? "N√§r vi s√∂ker sannolikheten f√∂r 'antingen eller' adderar vi antalet √∂nskade kulor fr√•n b√•da grupperna." : "When seeking the probability for 'either or', we add the number of desired marbles from both groups.", latex: `${counts[idx1]} + ${counts[idx2]} = ${ansCount}` }],
                metadata: { variation_key: 'visual_or', difficulty: 2 }
            };
        }

        const target = MathUtils.randomInt(0, 2);
        return {
            renderData: {
                description: lang === 'sv' ? `Studera kulorna i beh√•llaren. Om du drar en slumpm√§ssig kula, vad √§r sannolikheten att den √§r ${labels[target].toLowerCase()}?` : `Study the marbles in the container. If you pick a random marble, what is the probability that it is ${labels[target].toLowerCase()}?`,
                answerType: 'fraction',
                geometry: { type: 'probability_marbles', items: { red: counts[0], blue: counts[1], green: counts[2] } }
            },
            token: this.toBase64(this.rawFraction(counts[target], total)),
            clues: [{ text: lang === 'sv' ? "Sannolikhet ber√§knas alltid som antalet √∂nskade utfall (vinst) delat med det totala antalet m√∂jliga utfall." : "Probability is always calculated as the number of desired outcomes (wins) divided by the total number of possible outcomes.", latex: `\\frac{${counts[target]}}{${total}}` }],
            metadata: { variation_key: 'visual_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: GROUPS & RATIOS ---
    private level2_StandardGroups(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['group_ratio', 'group_ternary']);
        const ctx = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.items);
        const labels = lang === 'sv' ? ctx.sv : ctx.en;

        if (v === 'group_ratio') {
            const r1 = MathUtils.randomInt(1, 5), r2 = MathUtils.randomInt(1, 5);
            const total = r1 + r2;
            return {
                renderData: { 
                    description: lang === 'sv' 
                        ? `I en samling √§r f√∂rh√•llandet mellan ${labels[0]} och ${labels[1]} exakt ${r1}:${r2}. Vad √§r sannolikheten att slumpm√§ssigt v√§lja en ${labels[0]}?` 
                        : `In a collection, the ratio of ${labels[0]} to ${labels[1]} is ${r1}:${r2}. What is the probability of randomly picking a ${labels[0]}?`, 
                    answerType: 'fraction' 
                },
                token: this.toBase64(this.rawFraction(r1, total)),
                clues: [
                    { text: lang === 'sv' ? "F√∂rh√•llandet visar hur m√•nga 'delar' det finns av varje sort. R√§kna f√∂rst ut det totala antalet delar." : "The ratio shows how many 'parts' there are of each type. First, calculate the total number of parts.", latex: `${r1} + ${r2} = ${total}` },
                    { text: lang === 'sv' ? "Sannolikheten √§r antalet delar av den sort du s√∂ker genom det totala antalet delar." : "The probability is the number of parts of the type you seek divided by the total number of parts.", latex: `\\frac{${r1}}{${total}}` }
                ],
                metadata: { variation_key: 'group_ratio', difficulty: 3 }
            };
        }

        const a = MathUtils.randomInt(4, 10), b = MathUtils.randomInt(4, 10), extra = MathUtils.randomInt(4, 10);
        const total = a + b + extra;
        return {
            renderData: { 
                description: lang === 'sv' 
                    ? `I en l√•da finns totalt ${total} f√∂rem√•l. ${a} stycken √§r ${labels[0]} och ${b} stycken √§r ${labels[1]}. Resten √§r ${labels[2]}. Vad √§r sannolikheten att f√• en ${labels[2]}?` 
                    : `In a box, there are ${total} items in total. ${a} are ${labels[0]} and ${b} are ${labels[1]}. The rest are ${labels[2]}. What is the probability of picking a ${labels[2]}?`, 
                answerType: 'fraction' 
            },
            token: this.toBase64(this.rawFraction(extra, total)),
            clues: [{ text: lang === 'sv' ? `B√∂rja med att ta reda p√• hur m√•nga ${labels[2]} det finns genom att dra bort de andra fr√•n totalen.` : `Start by finding out how many ${labels[2]} there are by subtracting the others from the total.`, latex: `${total} - (${a} + ${b}) = ${extra}` }],
            metadata: { variation_key: 'group_ternary', difficulty: 2 }
        };
    }

    // --- LEVEL 3: CONCEPTS & LOGIC ---
    private level3_ConceptsAndLogic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['concept_compare', 'concept_validity', 'concept_likelihood']);

        if (v === 'concept_likelihood') {
            const cat = MathUtils.randomChoice(['impossible', 'certain', 'even']);
            const scenario = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.likelihood.find(x => x.category === cat)!.sv);
            const scenarioEn = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.likelihood.find(x => x.category === cat)!.en);
            const labelSv = cat === 'impossible' ? "Om√∂jligt" : (cat === 'certain' ? "S√§kert" : "H√§lften/H√§lften");
            const labelEn = cat === 'impossible' ? "Impossible" : (cat === 'certain' ? "Certain" : "Even chance");

            return {
                renderData: {
                    description: lang === 'sv' ? `Hur skulle du beskriva sannolikheten f√∂r f√∂ljande h√§ndelse: ${scenario}?` : `How would you describe the probability of the following event: ${scenarioEn}?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Om√∂jligt", "S√§kert", "H√§lften/H√§lften"] : ["Impossible", "Certain", "Even chance"]
                },
                token: this.toBase64(lang === 'sv' ? labelSv : labelEn),
                clues: [{ text: lang === 'sv' ? "Sannolikhet 0 betyder att n√•got aldrig kan h√§nda, medan 1 betyder att det garanterat h√§nder." : "Probability 0 means something can never happen, while 1 means it is guaranteed to happen." }],
                metadata: { variation_key: 'concept_likelihood', difficulty: 1 }
            };
        }

        if (v === 'concept_compare') {
            const aN = 1, aD = 4, bN = 2, bD = 5;
            const l1 = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.lotteries);
            const l2 = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.lotteries.filter(x => x !== l1));
            const options = lang === 'sv' ? [l1.sv, l2.sv, "Lika stor"] : [l1.en, l2.en, "Equal"];
            const ans = (bN / bD) > (aN / aD) ? options[1] : options[0];

            return {
                renderData: {
                    description: lang === 'sv' ? `Var √§r chansen st√∂rst att vinna: I ${l1.sv} (vinstchans ${aN}/${aD}) eller i ${l2.sv} (vinstchans ${bN}/${bD})?` : `Where is the best chance to win: In ${l1.en} (chance ${aN}/${aD}) or in ${l2.en} (chance ${bN}/${bD})?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(options)
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "G√∂r om br√•ken till decimaltal eller procent f√∂r att l√§ttare se vilket som √§r st√∂rst." : "Convert the fractions to decimals or percentages to more easily see which is largest.", latex: `\\frac{1}{4} = 0,25 \\quad \\text{vs} \\quad \\frac{2}{5} = 0,40` }],
                metadata: { variation_key: 'concept_compare', difficulty: 3 }
            };
        }

        const valid = "0.75";
        return {
            renderData: {
                description: lang === 'sv' ? "Vilket av f√∂ljande v√§rden √§r en korrekt angiven sannolikhet?" : "Which of the following values is a correctly stated probability?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([valid, "1.5", "-0.1", "110%"])
            },
            token: this.toBase64(valid),
            clues: [{ text: lang === 'sv' ? "En sannolikhet kan aldrig vara mindre √§n 0 eller st√∂rre √§n 1 (100%)." : "A probability can never be less than 0 or greater than 1 (100%)." }],
            metadata: { variation_key: 'concept_validity', difficulty: 1 }
        };
    }

    // --- LEVEL 4: COMPLEMENTARY ---
    private level4_Complementary(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['comp_at_least', 'comp_multi', 'comp_lie']);
        const scenario = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.atLeastOne);
        const d = MathUtils.randomChoice(scenario.denoms);

        if (v === 'comp_at_least') {
            const trials = 2;
            const pNoneN = Math.pow(d - 1, trials);
            const pNoneD = Math.pow(d, trials);
            const ansN = pNoneD - pNoneN;

            return {
                renderData: {
                    description: lang === 'sv' ? `Chansen att ${scenario.sv} √§r 1/${d}. Om f√∂rs√∂ket g√∂rs ${trials} g√•nger, vad √§r sannolikheten att det lyckas MINST en g√•ng?` : `The chance that ${scenario.en} is 1/${d}. If the attempt is made ${trials} times, what is the probability it succeeds AT LEAST once?`,
                    answerType: 'fraction'
                },
                token: this.toBase64(this.rawFraction(ansN, pNoneD)),
                clues: [
                    { text: lang === 'sv' ? "Tricket f√∂r 'minst en g√•ng' √§r att f√∂rst r√§kna ut risken att h√§ndelsen ALDRIG sker." : "The trick for 'at least once' is to first calculate the risk of the event NEVER happening.", latex: `P(\\text{Aldrig}) = (\\frac{${d-1}}{${d}})^2 = \\frac{${pNoneN}}{${pNoneD}}` },
                    { text: lang === 'sv' ? "Sannolikheten f√∂r minst en vinst √§r sedan 1 minus risken f√∂r ingen vinst." : "The probability for at least one win is then 1 minus the risk of no wins.", latex: `1 - \\frac{${pNoneN}}{${pNoneD}} = \\frac{${ansN}}{${pNoneD}}` }
                ],
                metadata: { variation_key: 'comp_at_least', difficulty: 4 }
            };
        }

        if (v === 'comp_lie') {
            const p1 = 0.3, p2 = 0.4, p3 = 0.3;
            const lie = lang === 'sv' ? "Summan av alla utfall kan bli 1.5" : "The sum of all outcomes can be 1.5";
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket p√•st√•ende om komplementh√§ndelser √§r FALSKT?" : "Which statement about complementary events is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([lie, lang === 'sv' ? "Summan av alla utfall √§r alltid 1" : "The sum of all outcomes is always 1", lang === 'sv' ? "P(A) + P(inte A) = 1" : "P(A) + P(not A) = 1"])
                },
                token: this.toBase64(lie),
                clues: [{ text: lang === 'sv' ? "I ett slumpf√∂rs√∂k m√•ste summan av sannolikheterna f√∂r alla m√∂jliga utfall alltid bli exakt 1 (100%)." : "In a random experiment, the sum of probabilities for all possible outcomes must always be exactly 1 (100%)." }],
                metadata: { variation_key: 'comp_lie', difficulty: 2 }
            };
        }

        const pA = MathUtils.randomInt(2, 6) * 10, pB = MathUtils.randomInt(1, 3) * 10;
        const pRest = 100 - pA - pB;
        return {
            renderData: {
                description: lang === 'sv' ? `I ett lotteri √§r chansen f√∂r storvinst ${pA}% och sm√•vinst ${pB}%. Vad √§r sannolikheten att man INTE vinner n√•gonting?` : `In a lottery, the chance for a big prize is ${pA}% and a small prize is ${pB}%. What is the probability of NOT winning anything?`,
                answerType: 'numeric', suffix: '%'
            },
            token: this.toBase64(pRest.toString()),
            clues: [{ text: lang === 'sv' ? "Addera alla vinstchanser och dra bort summan fr√•n 100%." : "Add all winning chances and subtract the sum from 100%.", latex: `100\\% - (${pA}\\% + ${pB}\\%) = ${pRest}\\%` }],
            metadata: { variation_key: 'comp_multi', difficulty: 2 }
        };
    }

    // --- LEVEL 5: PROBABILITY TREES ---
    private level5_ProbabilityTree(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['tree_missing', 'tree_calc']);
        const d1 = MathUtils.randomInt(2, 3), d2 = MathUtils.randomInt(3, 5);
        const dTot = d1 * d2;

        if (v === 'tree_missing') {
            return {
                renderData: {
                    description: lang === 'sv' ? `En gren i ett sannolikhetstr√§d slutar p√• sannolikheten 1/${dTot}. Om det f√∂rsta steget i grenen var 1/${d1}, vad var d√• sannolikheten i det andra steget?` : `A branch in a probability tree ends with the probability 1/${dTot}. If the first step in the branch was 1/${d1}, what was the probability in the second step?`,
                    answerType: 'fraction'
                },
                token: this.toBase64(this.rawFraction(1, d2)),
                clues: [{ text: lang === 'sv' ? "Sannolikheter l√§ngs en gren multipliceras. F√∂r att hitta en saknad del i en multiplikation anv√§nder vi division." : "Probabilities along a branch are multiplied. To find a missing part in a multiplication, we use division.", latex: `\\frac{1}{${dTot}} \\div \\frac{1}{${d1}} = \\frac{1}{${d2}}` }],
                metadata: { variation_key: 'tree_missing', difficulty: 3 }
            };
        }

        const c1 = 3, c2 = 4, tot = 7;
        return {
            renderData: {
                description: lang === 'sv' ? `Du drar tv√• f√∂rem√•l ur en beh√•llare utan att l√§gga tillbaka det f√∂rsta. Det finns ${c1} stycken A och ${c2} stycken B. Vad √§r sannolikheten att dra f√∂rst en A och sedan en B?` : `You pick two items from a container without replacing the first one. There are ${c1} of type A and ${c2} of type B. What is the probability of picking first an A and then a B?`,
                answerType: 'fraction',
                geometry: { type: 'probability_tree', groups: ["A", "B"], initialCounts: [c1, c2], targetBranch: 's2_1' }
            },
            token: this.toBase64(this.rawFraction(c1 * c2, tot * (tot - 1))),
            clues: [{ text: lang === 'sv' ? "Multiplicera chansen f√∂r f√∂rsta draget med chansen f√∂r det andra. Kom ih√•g att totala antalet f√∂rem√•l minskar med 1." : "Multiply the chance of the first draw by the chance of the second. Remember that the total number of items decreases by 1.", latex: `\\frac{${c1}}{${tot}} \\cdot \\frac{${c2}}{${tot-1}}` }],
            metadata: { variation_key: 'tree_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 6: EVENT CHAINS ---
    private level6_EventChains(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['chain_any_order', 'chain_fixed_order']);
        const a = 4, b = 5, total = 9;

        if (v === 'chain_any_order') {
            const n = (a * b) * 2, d = total * (total - 1);
            return {
                renderData: {
                    description: lang === 'sv' ? `I en sk√•l finns ${a} r√∂da och ${b} bl√•a frukter. Om du drar tv√• frukter utan √•terl√§ggning, vad √§r sannolikheten att du f√•r en av varje f√§rg?` : `In a bowl there are ${a} red and ${b} blue fruits. If you pick two fruits without replacement, what is the probability that you get one of each color?`,
                    answerType: 'fraction'
                },
                token: this.toBase64(this.rawFraction(n, d)),
                clues: [
                    { text: lang === 'sv' ? "Det finns tv√• m√∂jliga s√§tt att vinna: (R√∂d sen Bl√•) eller (Bl√• sen R√∂d)." : "There are two possible ways to win: (Red then Blue) or (Blue then Red)." },
                    { text: lang === 'sv' ? "Ber√§kna sannolikheten f√∂r b√•da v√§garna och addera dem." : "Calculate the probability for both paths and add them together.", latex: `2 \\cdot (\\frac{${a}}{${total}} \\cdot \\frac{${b}}{${total-1}})` }
                ],
                metadata: { variation_key: 'chain_any_order', difficulty: 4 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Sannolikheten att dra tv√• bl√•a f√∂rem√•l i rad utan √•terl√§ggning? (Totalt finns ${a} r√∂da och ${b} bl√•a).` : `Probability of picking two blue items in a row without replacement? (There are ${a} red and ${b} blue total).`,
                answerType: 'fraction'
            },
            token: this.toBase64(this.rawFraction(b * (b - 1), total * (total - 1))),
            clues: [{ text: lang === 'sv' ? "Vid dragning av samma f√§rg minskar b√•de antalet bl√•a f√∂rem√•l och det totala antalet inf√∂r det andra draget." : "When drawing the same color, both the number of blue items and the total number decrease before the second draw.", latex: `\\frac{${b}}{${total}} \\cdot \\frac{${b-1}}{${total-1}}` }],
            metadata: { variation_key: 'chain_fixed_order', difficulty: 3 }
        };
    }

    // --- LEVEL 7: COMBINATORICS ---
    private level7_Combinatorics(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['comb_constraint', 'comb_handshake']);

        if (v === 'comb_constraint') {
            const c1 = MathUtils.randomInt(3, 5), c2 = MathUtils.randomInt(2, 4);
            return {
                renderData: {
                    description: lang === 'sv' ? `Du ska v√§lja en outfit. Du har ${c1} olika tr√∂jor och ${c2} olika byxor att v√§lja mellan. P√• hur m√•nga unika s√§tt kan du kombinera dina kl√§der?` : `You are choosing an outfit. You have ${c1} different shirts and ${c2} different pants to choose from. In how many unique ways can you combine your clothes?`,
                    answerType: 'numeric'
                },
                token: this.toBase64((c1 * c2).toString()),
                clues: [{ text: lang === 'sv' ? "F√∂r att hitta totala antalet kombinationer multiplicerar vi antalet val i varje kategori med varandra." : "To find the total number of combinations, we multiply the number of choices in each category with each other.", latex: `${c1} \\cdot ${c2} = ${c1*c2}` }],
                metadata: { variation_key: 'comb_constraint', difficulty: 3 }
            };
        }

        const n = MathUtils.randomInt(5, 10);
        return {
            renderData: {
                description: lang === 'sv' ? `${n} personer tr√§ffas p√• en fest och alla skakar hand med alla precis en g√•ng. Hur m√•nga handskakningar sker totalt?` : `${n} people meet at a party and everyone shakes hands with everyone exactly once. How many handshakes occur in total?`,
                answerType: 'numeric'
            },
            token: this.toBase64(((n * (n - 1)) / 2).toString()),
            clues: [{ text: lang === 'sv' ? "Vi anv√§nder formeln f√∂r att r√§kna unika par: n(n-1)/2. Vi delar med 2 eftersom en handskakning sker mellan tv√• personer samtidigt." : "We use the formula for counting unique pairs: n(n-1)/2. We divide by 2 because a handshake happens between two people simultaneously.", latex: `\\frac{${n} \\cdot (${n}-1)}{2}` }],
            metadata: { variation_key: 'comb_handshake', difficulty: 3 }
        };
    }

    // --- LEVEL 8: COMPLEX PATHWAYS ---
    private level8_CombinatoricsComplex(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['pathways_basic', 'pathways_blocked', 'pathways_prob']);
        const layers = [1, MathUtils.randomInt(2, 3), MathUtils.randomInt(2, 3), 1];
        let totalPaths = 1;
        for (let i = 1; i < layers.length - 1; i++) totalPaths *= layers[i];

        const obstacles: any[] = [];
        if (v !== 'pathways_basic') {
            const possibleEdges = [];
            for (let l = 0; l < layers.length - 1; l++) {
                for (let f = 0; f < layers[l]; f++) {
                    for (let t = 0; t < layers[l+1]; t++) possibleEdges.push({ layer: l, from: f, to: t });
                }
            }
            obstacles.push(MathUtils.randomChoice(possibleEdges));
        }

        const validCount = this.countValidPaths(layers, obstacles);
        const ans = v === 'pathways_prob' ? this.rawFraction(validCount, totalPaths) : validCount.toString();

        let desc = lang === 'sv' ? "Diagrammet visar v√§gar mellan A och B. P√• hur m√•nga s√§tt kan man g√• hela v√§gen?" : "The diagram shows paths between A and B. In how many ways can you travel the whole distance?";
        if (v === 'pathways_blocked') desc = lang === 'sv' ? "R√∂da kryss markerar blockerade stigar. Hur m√•nga fungerande v√§gar finns kvar fr√•n A till B?" : "Red marks indicate blocked paths. How many working paths remain from A to B?";
        if (v === 'pathways_prob') desc = lang === 'sv' ? "Om du v√§ljer en v√§g helt slumpm√§ssigt, vad √§r sannolikheten att just den v√§gen √§r √∂ppen hela v√§gen?" : "If you choose a path completely at random, what is the probability that the specific path is open all the way?";

        return {
            renderData: {
                description: desc,
                answerType: v === 'pathways_prob' ? 'fraction' : 'numeric',
                geometry: { type: 'probability_tree', subtype: 'pathway', layers, obstacles }
            },
            token: this.toBase64(ans),
            clues: [{ text: lang === 'sv' ? "Multiplicera antalet val i varje steg f√∂r att f√• totalen. Vid blockeringar r√§knar du endast de v√§gar som inte passerar ett kryss." : "Multiply the number of choices at each step to get the total. For blockages, count only the paths that do not pass through a cross." }],
            metadata: { variation_key: v, difficulty: 5 }
        };
    }

    private countValidPaths(layers: number[], obstacles: any[]): number {
        const memo = new Map<string, number>();
        const find = (lIdx: number, nIdx: number): number => {
            if (lIdx === layers.length - 1) return 1;
            const key = `${lIdx}-${nIdx}`;
            if (memo.has(key)) return memo.get(key)!;
            let count = 0;
            for (let next = 0; next < layers[lIdx + 1]; next++) {
                if (!obstacles.some(o => o.layer === lIdx && o.from === nIdx && o.to === next)) {
                    count += find(lIdx + 1, next);
                }
            }
            memo.set(key, count);
            return count;
        };
        return find(0, 0);
    }
}

// FILE END: src\core\generators\ProbabilityGen.ts

// =======================================================
// FILE START: src\core\generators\PythagorasGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PythagorasGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SquaresRoots(lang);
            case 2: return this.level2_Hypotenuse(lang);
            case 3: return this.level3_Leg(lang);
            case 4: return this.level4_Applications(lang);
            case 5: return this.level5_Converse(lang);
            case 6: return this.level6_AdvancedMixed(lang);
            default: return this.level1_SquaresRoots(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'sqrt_calc':
            case 'square_calc':
            case 'missing_square':
            case 'sqrt_estimation':
                return this.level1_SquaresRoots(lang, key);
            
            case 'hyp_visual':
            case 'hyp_equation':
            case 'hyp_error':
                return this.level2_Hypotenuse(lang, key);
            
            case 'leg_visual':
            case 'leg_concept':
            case 'leg_text':
                return this.level3_Leg(lang, key);
            
            case 'app_ladder':
            case 'app_diagonal':
            case 'app_displacement':
            case 'app_guy_wire':
            case 'app_coords':
                return this.level4_Applications(lang, key);
            
            case 'conv_check':
            case 'conv_missing':
            case 'conv_trap':
                return this.level5_Converse(lang, key);

            case 'advanced_mixed':
                return this.level6_AdvancedMixed(lang);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Helper: Get a scaled triple to ensure integer solutions
    private getTriple(): { a: number, b: number, c: number, k: number } {
        const primitives = [
            [3, 4, 5], [5, 12, 13], [8, 15, 17], [7, 24, 25], [20, 21, 29],
            [12, 35, 37], [9, 40, 41], [28, 45, 53], [11, 60, 61], [16, 63, 65]
        ];
        const base = MathUtils.randomChoice(primitives);
        const k = MathUtils.randomChoice([1, 1, 2, 2, 3, 5]); 
        return { a: base[0] * k, b: base[1] * k, c: base[2] * k, k: k };
    }

    // --- LEVEL 1: SQUARES & ROOTS ---
    private level1_SquaresRoots(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sqrt_calc', 'square_calc', 'missing_square', 'sqrt_estimation']);

        if (v === 'sqrt_calc' || v === 'square_calc') {
            const isRoot = v === 'sqrt_calc';
            const base = MathUtils.randomInt(2, 15);
            const square = base * base;
            const desc = lang === 'sv' 
                ? (isRoot ? "Ber√§kna kvadratroten ur talet nedan." : "Ber√§kna kvadraten av talet nedan.")
                : (isRoot ? "Calculate the square root of the number below." : "Calculate the square of the number below.");

            return {
                renderData: {
                    description: desc,
                    latex: isRoot ? `\\sqrt{${square}}` : `${base}^2`,
                    answerType: 'numeric'
                },
                token: this.toBase64(isRoot ? base.toString() : square.toString()),
                clues: [{ 
                    text: lang === 'sv' 
                        ? (isRoot ? `Vilket tal multiplicerat med sig sj√§lvt blir ${square}?` : `Att kvadrera ett tal inneb√§r att man multiplicerar det med sig sj√§lvt en g√•ng.`) 
                        : (isRoot ? `Which number multiplied by itself results in ${square}?` : `Squaring a number means multiplying it by itself once.`), 
                    latex: isRoot ? `? \\cdot ? = ${square}` : `${base} \\cdot ${base} = ${square}` 
                }],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }

        if (v === 'missing_square') {
            const base = MathUtils.randomInt(2, 12);
            const square = base * base;
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket v√§rde p√• x g√∂r att ekvationen st√§mmer?" : "What value of x makes the equation true?",
                    latex: `x^2 = ${square}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(base.toString()),
                clues: [{ text: lang === 'sv' ? "F√∂r att f√• x ensamt n√§r det √§r upph√∂jt till tv√• anv√§nder vi den motsatta r√§kneoperationen: kvadratroten." : "To get x alone when it is raised to the power of two, we use the opposite operation: the square root.", latex: `x = \\sqrt{${square}}` }],
                metadata: { variation_key: 'missing_square', difficulty: 2 }
            };
        }

        const base = MathUtils.randomInt(4, 10);
        const square = base * base; 
        const offset = MathUtils.randomChoice([-5, -3, 3, 5]);
        const testVal = square + offset; 
        const isGreater = offset > 0;
        const q = lang === 'sv' 
            ? `√Ñr v√§rdet av $\\sqrt{${testVal}}$ st√∂rre √§n ${base}?` 
            : `Is the value of $\\sqrt{${testVal}}$ greater than ${base}?`;
        const ans = isGreater ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");

        return {
            renderData: {
                description: q,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"]
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? `Vi vet att $${base}^2$ √§r ${square}.` : `We know that $${base}^2$ is ${square}.`, latex: `${base}^2 = ${square}` },
                { text: lang === 'sv' ? `Eftersom ${testVal} √§r ${isGreater ? 'st√∂rre' : 'mindre'} √§n ${square}, s√• m√•ste dess kvadratrot vara ${isGreater ? 'st√∂rre' : 'mindre'} √§n ${base}.` : `Since ${testVal} is ${isGreater ? 'greater' : 'less'} than ${square}, its square root must be ${isGreater ? 'greater' : 'less'} than ${base}.` }
            ],
            metadata: { variation_key: 'sqrt_estimation', difficulty: 2 }
        };
    }

    // --- LEVEL 2: HYPOTENUSE ---
    private level2_Hypotenuse(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['hyp_visual', 'hyp_equation', 'hyp_error']);
        const t = this.getTriple();

        if (v === 'hyp_equation') {
            const options = MathUtils.shuffle([`${t.a}^2 + ${t.b}^2 = x^2`, `${t.a}^2 + x^2 = ${t.c}^2`, `x^2 - ${t.a}^2 = ${t.b}^2`]);
            return {
                renderData: {
                    description: lang === 'sv' ? `En r√§tvinklig triangel har kateterna ${t.a} och ${t.b}. Vilken ekvation ska man anv√§nda f√∂r att ber√§kna hypotenusan x?` : `A right-angled triangle has legs ${t.a} and ${t.b}. Which equation should be used to calculate the hypotenuse x?`,
                    answerType: 'multiple_choice',
                    options
                },
                token: this.toBase64(`${t.a}^2 + ${t.b}^2 = x^2`),
                clues: [{ text: lang === 'sv' ? "Pythagoras sats s√§ger att summan av kvadraterna p√• kateterna √§r lika med kvadraten p√• hypotenusan." : "Pythagoras' theorem states that the sum of the squares of the legs is equal to the square of the hypotenuse.", latex: "a^2 + b^2 = c^2" }],
                metadata: { variation_key: 'hyp_equation', difficulty: 2 }
            };
        }

        if (v === 'hyp_error') {
            const wrongSum = t.a + t.b;
            const ans = lang === 'sv' ? "Man m√•ste kvadrera sidorna f√∂rst" : "One must square the sides first";
            return {
                renderData: {
                    description: lang === 'sv' ? `En person r√§knade ut hypotenusan som ${t.a} + ${t.b} = ${wrongSum}. Varf√∂r √§r detta utr√§kningss√§tt FEL?` : `A person calculated the hypotenuse as ${t.a} + ${t.b} = ${wrongSum}. Why is this method INCORRECT?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, lang === 'sv' ? "Man ska anv√§nda subtraktion" : "One should use subtraction", lang === 'sv' ? "Det √§r faktiskt r√§tt" : "It is actually correct"])
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Man kan aldrig addera l√§ngderna direkt. Man m√•ste f√∂rst r√§kna ut arean av kvadraterna p√• sidorna." : "You can never add the lengths directly. You must first calculate the area of the squares on the sides." }],
                metadata: { variation_key: 'hyp_error', difficulty: 1 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna hypotenusans l√§ngd (x) i triangeln nedan." : "Calculate the length of the hypotenuse (x) in the triangle below.",
                answerType: 'numeric',
                geometry: { type: 'triangle', subtype: 'right', width: t.a, height: t.b, labels: { b: t.a, h: t.b, hyp: 'x' } }
            },
            token: this.toBase64(t.c.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: St√§ll upp Pythagoras sats med de k√§nda v√§rdena." : "Step 1: Set up Pythagoras' theorem with the known values.", latex: `${t.a}^2 + ${t.b}^2 = x^2` },
                { text: lang === 'sv' ? "Steg 2: R√§kna ut summan av kvadraterna och dra sedan kvadratroten ur resultatet." : "Step 2: Calculate the sum of the squares and then take the square root of the result.", latex: `x = \\sqrt{${t.a*t.a} + ${t.b*t.b}}` }
            ],
            metadata: { variation_key: 'hyp_visual', difficulty: 2 }
        };
    }

    // --- LEVEL 3: LEG ---
    private level3_Leg(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['leg_visual', 'leg_concept', 'leg_text']);
        const t = this.getTriple();

        if (v === 'leg_concept') {
            const ans = lang === 'sv' ? "Subtrahera" : "Subtract";
            return {
                renderData: {
                    description: lang === 'sv' ? "Om du redan vet l√§ngden p√• hypotenusan och en katet, ska du d√• addera eller subtrahera kvadraterna f√∂r att hitta den saknade sidan?" : "If you already know the length of the hypotenuse and one leg, should you add or subtract the squares to find the missing side?",
                    answerType: 'multiple_choice',
                    options: [ans, lang === 'sv' ? "Addera" : "Add"]
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Eftersom hypotenusan √§r den l√§ngsta sidan ($c^2$), m√•ste den andra kateten ($a^2$) vara skillnaden mellan hypotenusans kvadrat och den k√§nda katetens kvadrat." : "Since the hypotenuse is the longest side ($c^2$), the other leg ($a^2$) must be the difference between the square of the hypotenuse and the square of the known leg.", latex: "b^2 = c^2 - a^2" }],
                metadata: { variation_key: 'leg_concept', difficulty: 2 }
            };
        }

        const isText = v === 'leg_text';
        return {
            renderData: {
                description: lang === 'sv' ? `I en r√§tvinklig triangel √§r hypotenusan ${t.c} cm och en av kateterna √§r ${t.a} cm. Ber√§kna l√§ngden p√• den ok√§nda kateten x.` : `In a right-angled triangle, the hypotenuse is ${t.c} cm and one of the legs is ${t.a} cm. Calculate the length of the unknown leg x.`,
                answerType: 'numeric',
                geometry: isText ? null : { type: 'triangle', subtype: 'right', width: t.b, height: t.a, labels: { b: 'x', h: t.a, hyp: t.c } }
            },
            token: this.toBase64(t.b.toString()),
            clues: [
                { text: lang === 'sv' ? "N√§r man s√∂ker en katet st√§ller man upp sambandet som en subtraktion." : "When seeking a leg, the relationship is set up as a subtraction.", latex: `x^2 = ${t.c}^2 - ${t.a}^2` },
                { text: lang === 'sv' ? `Ber√§kna skillnaden: $${t.c*t.c} - ${t.a*t.a} = ${t.b*t.b}$, och dra sedan roten ur svaret.` : `Calculate the difference: $${t.c*t.c} - ${t.a*t.a} = ${t.b*t.b}$, and then take the square root of the answer.` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: APPLICATIONS ---
    private level4_Applications(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['app_ladder', 'app_diagonal', 'app_coords', 'app_displacement', 'app_guy_wire']);
        const t = this.getTriple();

        if (v === 'app_diagonal') {
            const scenario = MathUtils.randomChoice([
                { sv: `En rektangul√§r park √§r ${t.a} m l√•ng och ${t.b} m bred. Om du g√•r diagonalt fr√•n ett h√∂rn till det motsatta, hur l√•ngt g√•r du d√•?`, en: `A rectangular park is ${t.a} m long and ${t.b} m wide. If you walk diagonally from one corner to the opposite, how far do you walk?` },
                { sv: `En TV-sk√§rm har bredden ${t.a} cm och h√∂jden ${t.b} cm. Hur l√•ng √§r sk√§rmens diagonal?`, en: `A TV screen has a width of ${t.a} cm and a height of ${t.b} cm. How long is the screen's diagonal?` }
            ]);
            return {
                renderData: {
                    description: lang === 'sv' ? scenario.sv : scenario.en,
                    answerType: 'numeric',
                    geometry: { type: 'rectangle', width: t.a, height: t.b, labels: { b: t.a, h: t.b } }
                },
                token: this.toBase64(t.c.toString()),
                clues: [{ text: lang === 'sv' ? "Diagonalen i en rektangel fungerar som hypotenusa i en r√§tvinklig triangel." : "The diagonal of a rectangle acts as the hypotenuse in a right-angled triangle.", latex: `d = \\sqrt{${t.a}^2 + ${t.b}^2}` }],
                metadata: { variation_key: 'app_diagonal', difficulty: 3 }
            };
        }

        if (v === 'app_displacement') {
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `En cyklist cyklar ${t.a} km rakt norrut och sedan ${t.b} km rakt √∂sterut. Hur f√•gelv√§gen (n√§rmaste avst√•nd) √§r cyklisten fr√•n startpunkten?` 
                        : `A cyclist rides ${t.a} km straight north and then ${t.b} km straight east. What is the displacement (shortest distance) from the starting point?`,
                    answerType: 'numeric', suffix: 'km'
                },
                token: this.toBase64(t.c.toString()),
                clues: [
                    { text: lang === 'sv' ? "V√§gen norrut och v√§gen √∂sterut bildar en r√§t vinkel. Avst√•ndet fr√•n startpunkten √§r hypotenusan." : "The path north and the path east form a right angle. The distance from the start is the hypotenuse.", latex: `d = \\sqrt{${t.a}^2 + ${t.b}^2}` }
                ],
                metadata: { variation_key: 'app_displacement', difficulty: 3 }
            };
        }

        if (v === 'app_guy_wire') {
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Ett t√§lt h√•lls uppe av en lina f√§st i marken ${t.a} m fr√•n t√§ltst√•ngen. T√§ltst√•ngen √§r ${t.b} m h√∂g. Hur l√•ng √§r linan fr√•n markf√§stet till toppen?` 
                        : `A tent is held up by a guy wire attached to the ground ${t.a} m from the pole. The pole is ${t.b} m high. How long is the wire from the ground to the top?`,
                    answerType: 'numeric', suffix: 'm'
                },
                token: this.toBase64(t.c.toString()),
                clues: [
                    { text: lang === 'sv' ? "Marken och st√•ngen √§r kateter, och linan √§r hypotenusan." : "The ground and the pole are legs, and the wire is the hypotenuse.", latex: `l = \\sqrt{${t.a}^2 + ${t.b}^2}` }
                ],
                metadata: { variation_key: 'app_guy_wire', difficulty: 3 }
            };
        }

        if (v === 'app_coords') {
            const x1 = MathUtils.randomInt(1, 5), y1 = MathUtils.randomInt(1, 5);
            const x2 = x1 + t.a, y2 = y1 + t.b;
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna det kortaste avst√•ndet mellan punkterna (${x1}, ${y1}) och (${x2}, ${y2}) i ett koordinatsystem.` : `Calculate the shortest distance between the points (${x1}, ${y1}) and (${x2}, ${y2}) in a coordinate system.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(t.c.toString()),
                clues: [
                    { text: lang === 'sv' ? "Skillnaden i x-led och y-led mellan punkterna bildar de tv√• kateterna i en r√§tvinklig triangel." : "The difference in x and y between the points forms the two legs of a right-angled triangle.", latex: `\\Delta x = ${t.a}, \\Delta y = ${t.b}` },
                    { text: lang === 'sv' ? "Anv√§nd Pythagoras sats f√∂r att hitta avst√•ndet (hypotenusan)." : "Use Pythagoras' theorem to find the distance (the hypotenuse).", latex: `d = \\sqrt{${t.a}^2 + ${t.b}^2}` }
                ],
                metadata: { variation_key: 'app_coords', difficulty: 4 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `En stege som √§r ${t.c} meter l√•ng lutar mot en husv√§gg. Stegen n√•r ${t.b} meter upp p√• v√§ggen. Hur l√•ngt fr√•n v√§ggen st√•r stegens fot?` : `A ladder that is ${t.c} meters long leans against a house wall. The ladder reaches ${t.b} meters up the wall. How far from the wall is the base of the ladder?`,
                answerType: 'numeric', suffix: 'm'
            },
            token: this.toBase64(t.a.toString()),
            clues: [{ text: lang === 'sv' ? "Stegen fungerar som hypotenusan i en triangel. Husv√§ggen och marken √§r de tv√• kateterna." : "The ladder acts as the hypotenuse in a triangle. The wall and the ground are the two legs.", latex: `x = \\sqrt{${t.c}^2 - ${t.b}^2}` }],
            metadata: { variation_key: 'app_ladder', difficulty: 3 }
        };
    }

    // --- LEVEL 5: CONVERSE ---
    private level5_Converse(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['conv_check', 'conv_missing', 'conv_trap']);
        
        if (v === 'conv_trap') {
            const s1 = 2, s2 = 2, s3 = 5;
            const ans = lang === 'sv' ? "Nej" : "No";
            return {
                renderData: {
                    description: lang === 'sv' ? `Kan en triangel med sidorna ${s1}, ${s2} och ${s3} vara r√§tvinklig?` : `Can a triangle with sides ${s1}, ${s2} and ${s3} be right-angled?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"]
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Det h√§r √§r en kuggfr√•ga! Dessa sidl√§ngder kan inte ens bilda en triangel, eftersom summan av de tv√• kortaste sidorna ($2+2=4$) √§r mindre √§n den l√§ngsta sidan (5)." : "This is a trick question! These side lengths cannot even form a triangle, as the sum of the two shortest sides ($2+2=4$) is less than the longest side (5)." }],
                metadata: { variation_key: 'conv_trap', difficulty: 2 }
            };
        }

        const t = this.getTriple();
        if (v === 'conv_missing') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Sidorna i en triangel √§r ${t.a} cm och ${t.b} cm. Hur l√•ng m√•ste den tredje sidan vara f√∂r att triangeln ska bli r√§tvinklig?` : `The sides of a triangle are ${t.a} cm and ${t.b} cm. How long must the third side be for the triangle to be right-angled?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(t.c.toString()),
                clues: [{ text: lang === 'sv' ? "Anv√§nd Pythagoras sats f√∂r att ber√§kna vad den hypotenusa som kr√§vs √§r." : "Use Pythagoras' theorem to calculate what the required hypotenuse is.", latex: `\\sqrt{${t.a}^2 + ${t.b}^2}` }],
                metadata: { variation_key: 'conv_missing', difficulty: 3 }
            };
        }

        const isRight = Math.random() > 0.5;
        const c = isRight ? t.c : t.c + 1;
        const ans = isRight ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");

        return {
            renderData: {
                description: lang === 'sv' ? `√Ñr en triangel med sidorna ${t.a}, ${t.b} och ${c} r√§tvinklig?` : `Is a triangle with sides ${t.a}, ${t.b} and ${c} right-angled?`,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"]
            },
            token: this.toBase64(ans),
            clues: [{ text: lang === 'sv' ? "Kontrollera om likheten $a^2 + b^2 = c^2$ st√§mmer f√∂r sidorna." : "Check if the equality $a^2 + b^2 = c^2$ holds for the sides.", latex: `${t.a}^2 + ${t.b}^2 = ${t.a*t.a + t.b*t.b} \\text{ vs } ${c}^2 = ${c*c}` }],
            metadata: { variation_key: 'conv_check', difficulty: 3 }
        };
    }

    // --- LEVEL 6: ADVANCED MIXED ---
    private level6_AdvancedMixed(lang: string): any {
        const t = this.getTriple();
        const x1 = MathUtils.randomInt(-5, 0), y1 = MathUtils.randomInt(-5, 0);
        const x2 = x1 + t.a, y2 = y1 + t.b;

        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Ber√§kna avst√•ndet mellan punkterna (${x1}, ${y1}) och (${x2}, ${y2}) i ett koordinatsystem.`
                    : `Calculate the distance between points (${x1}, ${y1}) and (${x2}, ${y2}) in a coordinate system.`,
                answerType: 'numeric'
            },
            token: this.toBase64(t.c.toString()),
            clues: [
                { text: lang === 'sv' ? "Skillnaden i x-koordinater och y-koordinater mellan punkterna bildar kateterna i en t√§nkt r√§tvinklig triangel." : "The difference in x-coordinates and y-coordinates between the points forms the legs of an imaginary right-angled triangle.", latex: `\\Delta x = ${t.a}, \\Delta y = ${t.b}` },
                { text: lang === 'sv' ? "Avst√•ndet mellan punkterna √§r d√• hypotenusan i denna triangel." : "The distance between the points is then the hypotenuse of this triangle.", latex: `d = \\sqrt{${t.a}^2 + ${t.b}^2}` }
            ],
            metadata: { variation_key: 'advanced_mixed', difficulty: 5 }
        };
    }
}

// FILE END: src\core\generators\PythagorasGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ScaleGen {
    // Standard shapes for visuals
    private static readonly SHAPES = ['arrow', 'star', 'lightning', 'key', 'heart', 'cloud', 'moon', 'sun'];

    // --- CONTEXT LIBRARY ---
    private static readonly SCENARIOS = {
        map: [
            { sv: "en karta", en: "a map", contextSv: "avst√•ndet", contextEn: "the distance", unit: "km" },
            { sv: "en vandringskarta", en: "a hiking map", contextSv: "stigen", contextEn: "the trail", unit: "m" },
            { sv: "ett sj√∂kort", en: "a nautical chart", contextSv: "rutten", contextEn: "the route", unit: "km" }
        ],
        blueprint: [
            { sv: "en ritning", en: "a blueprint", contextSv: "v√§ggen", contextEn: "the wall", unit: "m" },
            { sv: "en planl√∂sning", en: "a floor plan", contextSv: "rummet", contextEn: "the room", unit: "m" },
            { sv: "en konstruktionsritning", en: "a construction drawing", contextSv: "balken", contextEn: "the beam", unit: "m" }
        ],
        model: [
            { sv: "en modell", en: "a model", contextSv: "bilen", contextEn: "the car", unit: "m" },
            { sv: "en leksaksbil", en: "a toy car", contextSv: "bilen", contextEn: "the car", unit: "m" },
            { sv: "ett modellflygplan", en: "a model airplane", contextSv: "vingbredden", contextEn: "the wingspan", unit: "m" }
        ],
        microscope: [
            { sv: "en bild i ett mikroskop", en: "a microscope image", contextSv: "cellen", contextEn: "the cell", unit: "mm" },
            { sv: "en f√∂rstoring", en: "a magnification", contextSv: "insekten", contextEn: "the insect", unit: "mm" },
            { sv: "en detaljbild", en: "a detailed image", contextSv: "chipet", contextEn: "the chip", unit: "mm" }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_LinearFluency(lang);
            case 3: return this.level3_MixedScenarios(lang);
            case 4: return this.level4_DetermineScale(lang);
            case 5: return this.level5_NoPictures(lang);
            case 6: return this.level6_AreaScaleDeep(lang);
            case 7: return this.level7_Mixed(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'concept_lie':
            case 'concept_match':
                return this.level1_Concepts(lang, key);
            
            case 'calc_real':
            case 'calc_image':
            case 'find_scale':
            case 'calc_magnification':
                return this.level2_LinearFluency(lang, key);
            
            case 'map_real':
            case 'blueprint_draw':
            case 'microscope_calc':
            case 'model_real':
                return this.level3_MixedScenarios(lang, key);
            
            case 'determine_reduction':
            case 'determine_magnification':
                return this.level4_DetermineScale(lang, key);
            
            case 'word_problem':
                return this.level5_NoPictures(lang);
            
            case 'area_concept':
            case 'area_reverse':
            case 'area_calc_small':
            case 'area_calc_large':
                return this.level6_AreaScaleDeep(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    // --- HELPERS ---
    
    private formatNum(n: number): string {
        return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPTS ---
    private level1_Concepts(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['concept_lie', 'concept_match']);

        if (v === 'concept_lie') {
             const scale = MathUtils.randomChoice([2, 5, 10, 100]);
             const correctStatement = lang === 'sv' 
                ? `Verkligheten √§r ${scale} g√•nger st√∂rre √§n vad bilden visar.` 
                : `Reality is ${scale} times larger than what the image shows.`;
             const falseStatement = lang === 'sv'
                ? `Bilden √§r ritad i naturlig storlek (skala 1:1).`
                : `The image is drawn in natural size (scale 1:1).`;
             const trivialStatement = lang === 'sv'
                ? `Skalan 1:${scale} inneb√§r en f√∂rminskning av verkligheten.`
                : `The scale 1:${scale} represents a reduction of reality.`;

             const options = MathUtils.shuffle([correctStatement, falseStatement, trivialStatement]);
             
             return {
                renderData: {
                    description: lang === 'sv' ? `Studera skalan 1:${scale}. Vilket av f√∂ljande p√•st√•enden √§r FALSKT?` : `Study the scale 1:${scale}. Which of the following statements is FALSE?`,
                    answerType: 'multiple_choice',
                    options: options,
                    geometry: { type: 'scale_single', label: `1:${scale}`, shape: 'map' }
                },
                token: this.toBase64(falseStatement),
                clues: [{ text: lang === 'sv' ? `En skala p√• 1:${scale} betyder att 1 cm p√• bilden motsvarar ${scale} cm i verkligheten.` : `A scale of 1:${scale} means that 1 cm in the image corresponds to ${scale} cm in reality.` }],
                metadata: { variation_key: 'concept_lie', difficulty: 1 }
             };
        }

        const isReduction = Math.random() > 0.5;
        const ratio = MathUtils.randomChoice([5, 10, 20, 50]);
        const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
        
        const correct = isReduction 
            ? (lang === 'sv' ? `Verkligheten √§r ${ratio} g√•nger st√∂rre √§n bilden.` : `Reality is ${ratio} times larger than the image.`)
            : (lang === 'sv' ? `Bilden √§r ${ratio} g√•nger st√∂rre √§n verkligheten.` : `The image is ${ratio} times larger than reality.`);
        
        const wrong = isReduction
            ? (lang === 'sv' ? `Bilden √§r ${ratio} g√•nger st√∂rre √§n verkligheten.` : `The image is ${ratio} times larger than reality.`)
            : (lang === 'sv' ? `Verkligheten √§r ${ratio} g√•nger st√∂rre √§n bilden.` : `Reality is ${ratio} times larger than the image.`);

        return {
            renderData: {
                description: lang === 'sv' ? `Vad inneb√§r det att en bild √§r ritad i skalan ${scaleStr}?` : `What does it mean if an image is drawn in the scale ${scaleStr}?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([correct, wrong, lang === 'sv' ? "Bilden och verkligheten √§r exakt lika stora." : "The image and reality are exactly the same size."]),
                geometry: { 
                    type: 'scale_compare', 
                    leftLabel: lang === 'sv' ? 'Bild' : 'Image', 
                    rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                    leftValue: isReduction ? 1 : ratio,
                    rightValue: isReduction ? ratio : 1,
                    shape: 'arrow'
                }
            },
            token: this.toBase64(correct),
            clues: [{ text: lang === 'sv' ? "Siffran 1 representerar alltid bilden/ritningen. Det andra talet visar f√∂rh√•llandet till verkligheten." : "The number 1 always represents the image/drawing. The other number shows the relationship to reality." }],
            metadata: { variation_key: 'concept_match', difficulty: 1 }
        };
    }

    // --- LEVEL 2: LINEAR FLUENCY ---
    private level2_LinearFluency(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['calc_real', 'calc_image', 'find_scale', 'calc_magnification']);
        const shape = MathUtils.randomChoice(ScaleGen.SHAPES);

        if (v === 'calc_real') {
            const scale = MathUtils.randomChoice([5, 10, 20, 50]);
            const imgCm = MathUtils.randomInt(2, 12);
            const ans = imgCm * scale;
            
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `En modell √§r byggd i skala 1:${scale}. P√• modellen m√§ts en l√§ngd till ${imgCm} cm. Hur l√•ng √§r motsvarande del i verkligheten?`
                        : `A model is built in scale 1:${scale}. On the model, a length measures ${imgCm} cm. How long is the corresponding part in reality?`,
                    answerType: 'numeric', suffix: 'cm',
                    geometry: { type: 'scale_compare', leftLabel: 'Modell', rightLabel: 'Verklighet', leftValue: 1, rightValue: scale, shape }
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? `Eftersom skalan √§r en f√∂rminskning (1:${scale}), √§r verkligheten ${scale} g√•nger st√∂rre √§n modellen.` : `Since the scale is a reduction (1:${scale}), reality is ${scale} times larger than the model.`, latex: `${imgCm} \\cdot ${scale} = ${ans}` }],
                metadata: { variation_key: 'calc_real', difficulty: 2 }
            };
        }

        if (v === 'calc_image') {
            const scale = MathUtils.randomChoice([10, 20, 50, 100]);
            const imgCm = MathUtils.randomInt(3, 10);
            const realCm = imgCm * scale;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Ett f√∂rem√•l √§r ${realCm} cm l√•ngt i verkligheten. Hur l√•ngt blir f√∂rem√•let p√• en ritning som √§r gjord i skala 1:${scale}?`
                        : `An object is ${realCm} cm long in reality. How long will the object be on a drawing made in scale 1:${scale}?`,
                    answerType: 'numeric', suffix: 'cm',
                    geometry: { type: 'scale_compare', leftLabel: 'Ritning', rightLabel: 'Verklighet', leftValue: 1, rightValue: scale, shape: 'house' }
                },
                token: this.toBase64(imgCm.toString()),
                clues: [{ text: lang === 'sv' ? `P√• ritningen blir f√∂rem√•let ${scale} g√•nger mindre √§n i verkligheten. Dela verklighetens l√§ngd med skalan.` : `On the drawing, the object becomes ${scale} times smaller than in reality. Divide the real length by the scale.`, latex: `\\frac{${realCm}}{${scale}} = ${imgCm}` }],
                metadata: { variation_key: 'calc_image', difficulty: 2 }
            };
        }

        if (v === 'find_scale') {
            const scale = MathUtils.randomChoice([2, 5, 10, 20, 50]);
            const imgCm = MathUtils.randomInt(2, 10);
            const realCm = imgCm * scale;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `En detalj p√• en bild √§r ${imgCm} cm. Samma detalj √§r ${realCm} cm i verkligheten. Vilken skala √§r bilden ritad i?`
                        : `A detail in an image is ${imgCm} cm. The same detail is ${realCm} cm in reality. In what scale is the image drawn?`,
                    answerType: 'text', placeholder: '1:X',
                    geometry: { type: 'scale_single', label: '?', shape: 'magnifying_glass' }
                },
                token: this.toBase64(`1:${scale}`),
                clues: [{ text: lang === 'sv' ? "Ta reda p√• hur m√•nga g√•nger st√∂rre verkligheten √§r genom att dividera dess l√§ngd med bildens l√§ngd." : "Find out how many times larger reality is by dividing its length by the image length.", latex: `\\frac{${realCm}}{${imgCm}} = ${scale}` }],
                metadata: { variation_key: 'find_scale', difficulty: 2 }
            };
        }

        // Magnification (X:1)
        const scale = MathUtils.randomChoice([5, 10, 20]);
        const realMm = MathUtils.randomInt(2, 8);
        const imgMm = realMm * scale;
        
        return {
            renderData: {
                description: lang === 'sv'
                    ? `En liten insekt har f√∂rstorats i skala ${scale}:1. P√• bilden √§r insekten ${imgMm} mm l√•ng. Hur l√•ng √§r den i verkligheten?`
                    : `A small insect has been magnified in scale ${scale}:1. In the picture, the insect is ${imgMm} mm long. How long is it in reality?`,
                answerType: 'numeric', suffix: 'mm',
                geometry: { type: 'scale_compare', leftLabel: 'Bild', rightLabel: 'Verklighet', leftValue: scale, rightValue: 1, shape: 'ladybug' }
            },
            token: this.toBase64(realMm.toString()),
            clues: [{ text: lang === 'sv' ? `Skalan ${scale}:1 inneb√§r att bilden √§r ${scale} g√•nger st√∂rre √§n verkligheten. Dela bildens l√§ngd med skalan.` : `The scale ${scale}:1 means the image is ${scale} times larger than reality. Divide the image length by the scale.`, latex: `\\frac{${imgMm}}{${scale}} = ${realMm}` }],
            metadata: { variation_key: 'calc_magnification', difficulty: 2 }
        };
    }

    // --- LEVEL 3: MIXED SCENARIOS ---
    private level3_MixedScenarios(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['map_real', 'blueprint_draw', 'microscope_calc', 'model_real']);
        
        if (v === 'map_real') {
            const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.map);
            const scale = MathUtils.randomChoice([10000, 50000, 100000]);
            const mapCm = MathUtils.randomInt(2, 10);
            const realCm = mapCm * scale;
            const useKm = realCm >= 100000;
            const ans = useKm ? realCm / 100000 : realCm / 100;
            const unit = useKm ? (lang === 'sv' ? 'km' : 'km') : (lang === 'sv' ? 'm' : 'm');

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `P√• ${scenario.sv} i skala 1:${this.formatNum(scale)} m√§ts ${scenario.contextSv} till ${mapCm} cm. Hur l√•ngt √§r detta i verkligheten?`
                        : `On ${scenario.en} in scale 1:${this.formatNum(scale)}, ${scenario.contextEn} measures ${mapCm} cm. How long is this in reality?`,
                    answerType: 'numeric', suffix: unit
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `R√§kna f√∂rst ut avst√•ndet i centimeter.` : `First calculate the distance in centimeters.`, latex: `${mapCm} \\cdot ${scale} = ${this.formatNum(realCm)} \\text{ cm}` },
                    { text: lang === 'sv' ? `Omvandla sedan fr√•n cm till ${unit}.` : `Then convert from cm to ${unit}.`, latex: useKm ? `\\frac{${realCm}}{100\\,000} = ${ans}` : `\\frac{${realCm}}{100} = ${ans}` }
                ],
                metadata: { variation_key: 'map_real', difficulty: 3 }
            };
        }

        if (v === 'blueprint_draw') {
            const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.blueprint);
            const scale = 50;
            const realM = MathUtils.randomInt(2, 8);
            const ans = (realM * 100) / scale;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `${scenario.sv.charAt(0).toUpperCase() + scenario.sv.slice(1)} √§r ritad i skala 1:${scale}. I verkligheten √§r ${scenario.contextSv} ${realM} m. Hur l√•ng blir den p√• ritningen?`
                        : `${scenario.en.charAt(0).toUpperCase() + scenario.en.slice(1)} is drawn in scale 1:${scale}. In reality, ${scenario.contextEn} is ${realM} m. How long will it be on the drawing?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "G√∂r f√∂rst om verklighetens meter till centimeter." : "First convert the real meters to centimeters.", latex: `${realM} \\cdot 100 = ${realM * 100} \\text{ cm}` },
                    { text: lang === 'sv' ? `Dela sedan med skalan ${scale} f√∂r att f√• ritningens m√•tt.` : `Then divide by the scale ${scale} to get the drawing's dimension.`, latex: `\\frac{${realM * 100}}{${scale}} = ${ans}` }
                ],
                metadata: { variation_key: 'blueprint_draw', difficulty: 3 }
            };
        }

        if (v === 'microscope_calc') {
            const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.microscope);
            const scale = MathUtils.randomChoice([10, 50, 100]);
            const realMm = MathUtils.randomChoice([0.1, 0.2, 0.5, 2]);
            const ansMm = realMm * scale;
            const ans = ansMm >= 10 ? ansMm / 10 : ansMm;
            const unit = ansMm >= 10 ? 'cm' : 'mm';

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `I ${scenario.sv} som har skalan ${scale}:1 √§r ${scenario.contextSv} ${realMm.toString().replace('.', ',')} mm l√•ng i verkligheten. Hur l√•ng √§r den p√• bilden?`
                        : `In ${scenario.en} which has the scale ${scale}:1, ${scenario.contextEn} is ${realMm} mm long in reality. How long is it in the image?`,
                    answerType: 'numeric', suffix: unit
                },
                token: this.toBase64(ans.toString()),
                clues: [{ text: lang === 'sv' ? `Multiplicera verklighetens l√§ngd med f√∂rstoringsfaktorn ${scale}.` : `Multiply the real length by the magnification factor ${scale}.`, latex: `${realMm} \\cdot ${scale} = ${ansMm} \\text{ mm}` }],
                metadata: { variation_key: 'microscope_calc', difficulty: 3 }
            };
        }

        // Default to model_real
        const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.model);
        const scale = MathUtils.randomChoice([18, 24, 43]);
        const imgCm = MathUtils.randomInt(5, 25);
        const realCm = imgCm * scale;
        const ans = Math.round((realCm / 100) * 10) / 10;

        return {
            renderData: {
                description: lang === 'sv'
                    ? `${scenario.sv.charAt(0).toUpperCase() + scenario.sv.slice(1)} √§r byggd i skala 1:${scale}. P√• modellen √§r ${scenario.contextSv} ${imgCm} cm. Hur l√•ngt √§r det i verkligheten? Svara i meter.`
                    : `${scenario.en.charAt(0).toUpperCase() + scenario.en.slice(1)} is built in scale 1:${scale}. On the model, ${scenario.contextEn} is ${imgCm} cm. How long is it in reality? Answer in meters.`,
                answerType: 'numeric', suffix: 'm'
            },
            token: this.toBase64(ans.toString().replace('.', ',')),
            clues: [{ text: lang === 'sv' ? `Multiplicera modellens l√§ngd med ${scale} och dela sedan med 100 f√∂r att f√• meter.` : `Multiply the model's length by ${scale} and then divide by 100 to get meters.`, latex: `\\frac{${imgCm} \\cdot ${scale}}{100} = ${ans}` }],
            metadata: { variation_key: 'model_real', difficulty: 3 }
        };
    }

    // --- LEVEL 4: DETERMINE SCALE ---
    private level4_DetermineScale(lang: string, variationKey?: string): any {
        const v = variationKey || (Math.random() < 0.7 ? 'determine_reduction' : 'determine_magnification');
        
        if (v === 'determine_reduction') {
            const scale = MathUtils.randomChoice([20, 40, 50, 100, 200]);
            const imgCm = MathUtils.randomInt(2, 10);
            const realM = (imgCm * scale) / 100;
            const realMStr = realM.toString().replace('.', ',');

            const desc = lang === 'sv'
                ? `En v√§gg √§r ${realMStr} m l√•ng i verkligheten. P√• en ritning har v√§ggen l√§ngden ${imgCm} cm. Vilken skala √§r ritningen gjord i?`
                : `A wall is ${realMStr} m long in reality. On a drawing, the wall has a length of ${imgCm} cm. What scale is the drawing made in?`;

            return {
                renderData: {
                    description: desc,
                    answerType: 'text', placeholder: '1:X',
                    geometry: { type: 'scale_single', label: '?', shape: 'blueprint' }
                },
                token: this.toBase64(`1:${scale}`),
                clues: [
                    { text: lang === 'sv' ? `G√∂r f√∂rst om meter till centimeter: ${realMStr} m = ${realM * 100} cm.` : `First convert meters to centimeters: ${realMStr} m = ${realM * 100} cm.` },
                    { text: lang === 'sv' ? "Dela sedan det verkliga m√•ttet med ritningens m√•tt f√∂r att f√• skalfaktorn." : "Then divide the real dimension by the drawing's dimension to get the scale factor.", latex: `\\frac{${realM * 100}}{${imgCm}} = ${scale}` }
                ],
                metadata: { variation_key: 'determine_reduction', difficulty: 3 }
            };
        }

        // determine_magnification
        const scale = MathUtils.randomChoice([5, 10, 20]);
        const realMm = MathUtils.randomInt(2, 5);
        const imgCm = (realMm * scale) / 10;
        const imgCmStr = imgCm.toString().replace('.', ',');

        const desc = lang === 'sv'
            ? `Ett litet fr√∂ √§r ${realMm} mm l√•ngt. P√• en bild √§r fr√∂et ${imgCmStr} cm l√•ngt. Vilken skala har bilden?`
            : `A small seed is ${realMm} mm long. In a picture, the seed is ${imgCmStr} cm long. What scale does the picture have?`;

        return {
            renderData: {
                description: desc,
                answerType: 'text', placeholder: 'X:1',
                geometry: { type: 'scale_single', label: '?', shape: 'magnifying_glass' }
            },
            token: this.toBase64(`${scale}:1`),
            clues: [
                { text: lang === 'sv' ? `G√∂r om centimeter till millimeter: ${imgCmStr} cm = ${imgCm * 10} mm.` : `Convert centimeters to millimeters: ${imgCmStr} cm = ${imgCm * 10} mm.` },
                { text: lang === 'sv' ? "Dela bildens m√•tt med verklighetens m√•tt f√∂r att f√• f√∂rstoringen." : "Divide the image dimension by the real dimension to get the magnification.", latex: `\\frac{${imgCm * 10}}{${realMm}} = ${scale}` }
            ],
            metadata: { variation_key: 'determine_magnification', difficulty: 3 }
        };
    }

    // --- LEVEL 5: NO PICTURES ---
    private level5_NoPictures(lang: string): any {
        const data = this.level3_MixedScenarios(lang);
        data.renderData.geometry = null; // Enforce mental model
        data.metadata.variation_key = 'word_problem';
        return data;
    }

    // --- LEVEL 6: AREA SCALE DEEP ---
    private level6_AreaScaleDeep(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['area_concept', 'area_reverse', 'area_calc_small', 'area_calc_large']);

        if (v === 'area_concept') {
            const L = MathUtils.randomChoice([2, 3, 5, 10]);
            const sq = L * L;
            const correct = lang === 'sv' ? `${sq} g√•nger st√∂rre` : `${sq} times larger`;
            
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Om alla l√§ngder i en figur f√∂rstoras enligt l√§ngdskalan 1:${L}, hur m√•nga g√•nger st√∂rre blir d√• figurens area?`
                        : `If all lengths in a figure are magnified according to the length scale 1:${L}, how many times larger does the figure's area become?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, lang === 'sv' ? `${L} g√•nger st√∂rre` : `${L} times larger`, lang === 'sv' ? `${L * 2} g√•nger st√∂rre` : `${L * 2} times larger`]),
                    geometry: { type: 'scale_single', label: `1:${L}`, shape: 'square' }
                },
                token: this.toBase64(correct),
                clues: [{ text: lang === 'sv' ? "Viktig regel: Areaskalan √§r alltid l√§ngdskalan i kvadrat." : "Important rule: The area scale is always the length scale squared.", latex: `\\text{Areaskala} = ${L}^2 = ${sq}` }],
                metadata: { variation_key: 'area_concept', difficulty: 4 }
            };
        }

        if (v === 'area_reverse') {
            const L = MathUtils.randomChoice([2, 3, 4, 5]);
            const smallA = MathUtils.randomChoice([5, 10, 20]);
            const largeA = smallA * (L * L);

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Arean av en liten figur √§r ${smallA} cm¬≤ och arean av en likformig stor figur √§r ${largeA} cm¬≤. Vilken l√§ngdskala r√•der mellan figurerna?`
                        : `The area of a small figure is ${smallA} cm¬≤ and the area of a similar large figure is ${largeA} cm¬≤. What length scale exists between the figures?`,
                    answerType: 'text', placeholder: '1:X'
                },
                token: this.toBase64(`1:${L}`),
                clues: [
                    { text: lang === 'sv' ? `R√§kna f√∂rst ut areaskalan: ${largeA} / ${smallA} = ${L*L}.` : `First calculate the area scale: ${largeA} / ${smallA} = ${L*L}.`, latex: "" },
                    { text: lang === 'sv' ? "Dra sedan kvadratroten ur areaskalan f√∂r att hitta l√§ngdskalan." : "Then take the square root of the area scale to find the length scale.", latex: `\\sqrt{${L*L}} = ${L}` }
                ],
                metadata: { variation_key: 'area_reverse', difficulty: 4 }
            };
        }

        const L = MathUtils.randomChoice([2, 3, 4]);
        const smallA = MathUtils.randomInt(5, 15);
        const largeA = smallA * (L * L);
        const findLarge = v === 'area_calc_large';

        return {
            renderData: {
                description: lang === 'sv'
                    ? (findLarge 
                        ? `L√§ngdskalan mellan tv√• figurer √§r 1:${L}. Den lilla figuren har arean ${smallA} cm¬≤. Ber√§kna den stora figurens area.` 
                        : `L√§ngdskalan mellan tv√• figurer √§r 1:${L}. Den stora figuren har arean ${largeA} cm¬≤. Ber√§kna den lilla figurens area.`)
                    : (findLarge 
                        ? `The length scale between two figures is 1:${L}. The small figure has an area of ${smallA} cm¬≤. Calculate the large figure's area.` 
                        : `The length scale between two figures is 1:${L}. The large figure has an area of ${largeA} cm¬≤. Calculate the small figure's area.`),
                answerType: 'numeric', suffix: 'cm¬≤'
            },
            token: this.toBase64(findLarge ? largeA.toString() : smallA.toString()),
            clues: [
                { text: lang === 'sv' ? `Areaskalan √§r l√§ngdskalan i kvadrat: $${L}^2 = ${L*L}$.` : `The area scale is the length scale squared: $${L}^2 = ${L*L}$.` },
                { text: lang === 'sv' ? (findLarge ? `Multiplicera lilla arean med ${L*L}.` : `Dividera stora arean med ${L*L}.`) : (findLarge ? `Multiply the small area by ${L*L}.` : `Divide the large area by ${L*L}.`) }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }

    // --- LEVEL 7: MIXED ---
    private level7_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(2, 6);
        const res = this.generate(subLevel, lang);
        res.metadata.mixed = true;
        return res;
    }
}

// FILE END: src\core\generators\ScaleGen.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class SimilarityGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concept(lang);
            case 2: return this.level2_CalcSide(lang);
            case 3: return this.level3_TopTriangle(lang);
            case 4: return this.level4_Pythagoras(lang);
            default: return this.level1_Concept(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'sim_rect_check':
            case 'sim_tri_angle_check':
            case 'sim_tri_side_check':
            case 'sim_concept_lie':
                return this.level1_Concept(lang, key);
            
            case 'sim_calc_big':
            case 'sim_calc_small':
            case 'sim_find_k':
            case 'sim_calc_lie':
                return this.level2_CalcSide(lang, key);
            
            case 'transversal_total':
            case 'transversal_extension':
            case 'transversal_concept_id':
                return this.level3_TopTriangle(lang, key);
            
            case 'pythagoras_sim_hyp':
            case 'pythagoras_sim_leg':
                return this.level4_Pythagoras(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPT (Identifying Similarity) ---
    private level1_Concept(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sim_rect_check', 'sim_tri_angle_check', 'sim_tri_side_check', 'sim_concept_lie']);
        const isSimilar = Math.random() > 0.5;

        if (v === 'sim_concept_lie') {
            const sTrue1 = lang === 'sv' ? "Alla liksidiga trianglar √§r likformiga." : "All equilateral triangles are similar.";
            const sTrue2 = lang === 'sv' ? "Alla cirklar √§r likformiga med varandra." : "All circles are similar to each other.";
            const sLie = lang === 'sv' ? "Alla rektanglar √§r likformiga." : "All rectangles are similar.";
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden om likformighet √§r FALSKT?" : "Which of the following statements about similarity is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sLie])
                },
                token: this.toBase64(sLie),
                clues: [{ text: lang === 'sv' ? "F√∂r att rektanglar ska vara likformiga m√•ste f√∂rh√•llandet mellan l√•ngsida och kortsida vara detsamma. En kvadrat och en smal rektangel √§r inte likformiga." : "For rectangles to be similar, the ratio between the long side and the short side must be the same. A square and a thin rectangle are not similar." }],
                metadata: { variation_key: 'sim_concept_lie', difficulty: 1 }
            };
        }

        let geom: any = { type: 'similarity_compare' };
        let desc = "";
        let clues = [];

        if (v === 'sim_rect_check') {
            geom.shapeType = 'rectangle';
            const w1 = 4, h1 = 2;
            const k = isSimilar ? 2 : 1.5;
            const w2 = w1 * 2; // 8
            const h2 = isSimilar ? h1 * 2 : h1 * 1.2; // 4 or 2.4

            geom.left = { labels: { b: w1, h: h1 } };
            geom.right = { labels: { b: w2, h: h2 } };
            desc = lang === 'sv' ? "Avg√∂r om rektanglarna √§r likformiga." : "Determine if the rectangles are similar.";
            clues.push({ text: lang === 'sv' ? "Dela de motsvarande sidorna med varandra. Om kvoten blir densamma √§r de likformiga." : "Divide corresponding sides by each other. If the quotient is the same, they are similar.", latex: `\\frac{${w2}}{${w1}} = ${w2/w1} \\quad \\text{vs} \\quad \\frac{${h2}}{${h1}} = ${h2/h1}` });
        } 
        else if (v === 'sim_tri_angle_check') {
            geom.shapeType = 'triangle';
            const a1 = 60, a2 = 70;
            const b1 = isSimilar ? a1 : a1 + 10;
            geom.left = { labels: { a1: `${a1}¬∞`, a2: `${a2}¬∞` } };
            geom.right = { labels: { a1: `${b1}¬∞`, a2: `${a2}¬∞` } };
            desc = lang === 'sv' ? "√Ñr de tv√• trianglarna likformiga baserat p√• vinklarna?" : "Are the two triangles similar based on their angles?";
            clues.push({ text: lang === 'sv' ? "Tv√• trianglar √§r likformiga om de har exakt samma vinklar." : "Two triangles are similar if they have exactly the same angles." });
        }
        else {
            geom.shapeType = 'triangle';
            const s1 = 3, s2 = 5;
            const k = isSimilar ? 3 : 2;
            const r1 = s1 * 3;
            const r2 = isSimilar ? s2 * 3 : s2 * 2.5;
            geom.left = { labels: { s1: s1, s2: s2 } };
            geom.right = { labels: { s1: r1, s2: r2 } };
            desc = lang === 'sv' ? "Unders√∂k sidorna. √Ñr trianglarna likformiga?" : "Examine the sides. Are the triangles similar?";
            clues.push({ text: lang === 'sv' ? "Kontrollera om b√•da sidorna har f√∂rstorats med samma skala." : "Check if both sides have been magnified by the same scale.", latex: `\\frac{${r1}}{${s1}} = ${r1/s1} \\quad \\text{vs} \\quad \\frac{${r2}}{${s2}} = ${r2/s2}` });
        }

        const correct = isSimilar ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");
        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"],
                geometry: geom
            },
            token: this.toBase64(correct),
            clues,
            metadata: { variation_key: v, difficulty: 1 }
        };
    }

    // --- LEVEL 2: CALCULATE SIDE ---
    private level2_CalcSide(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sim_calc_big', 'sim_calc_small', 'sim_find_k']);
        const k = MathUtils.randomChoice([1.5, 2, 3, 5]);
        const s1 = 4, s2 = 6;
        const bigS1 = s1 * k, bigS2 = s2 * k;

        if (v === 'sim_find_k') {
            return {
                renderData: {
                    geometry: { type: 'similarity_compare', shapeType: 'rectangle', left: { labels: { b: s1, h: s2 } }, right: { labels: { b: bigS1, h: bigS2 } } },
                    description: lang === 'sv' ? "Figurerna √§r likformiga. Vilken √§r skalan (l√§ngdskalan) fr√•n den lilla till den stora figuren?" : "The shapes are similar. What is the scale (length scale) from the small to the large shape?",
                    answerType: 'numeric'
                },
                token: this.toBase64(k.toString()),
                clues: [{ text: lang === 'sv' ? "Du hittar skalan genom att dela den nya l√§ngden med den gamla l√§ngden." : "You find the scale by dividing the new length by the old length.", latex: `k = \\frac{${bigS1}}{${s1}} = ${k}` }],
                metadata: { variation_key: 'sim_find_k', difficulty: 2 }
            };
        }

        const findBig = v === 'sim_calc_big';
        const ans = findBig ? bigS1 : s1;

        return {
            renderData: {
                geometry: { 
                    type: 'similarity_compare', 
                    shapeType: 'triangle', 
                    left: { labels: findBig ? { s1: s1, s2: s2 } : { s1: 'x', s2: s2 } }, 
                    right: { labels: findBig ? { s1: 'x', s2: bigS2 } : { s1: bigS1, s2: bigS2 } } 
                },
                description: lang === 'sv' ? "Ber√§kna l√§ngden p√• den ok√§nda sidan x i de likformiga figurerna." : "Calculate the length of the unknown side x in the similar shapes.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Hitta skalan genom att j√§mf√∂ra sidorna du redan k√§nner till." : "Step 1: Find the scale by comparing the sides you already know.", latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` },
                { text: lang === 'sv' ? (findBig ? "Steg 2: Multiplicera den lilla sidan med skalan." : "Steg 2: Dela den stora sidan med skalan.") : (findBig ? "Step 2: Multiply the small side by the scale." : "Step 2: Divide the large side by the scale."), latex: findBig ? `${s1} \\cdot ${k} = ${ans}` : `${bigS1} / ${k} = ${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: TOP TRIANGLE ---
    private level3_TopTriangle(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['transversal_total', 'transversal_extension', 'transversal_concept_id']);
        const top = 5, add = 3, smallBase = 4;
        const tot = top + add;
        const scale = tot / top; // 1.6
        const ans = smallBase * scale; // 6.4

        if (v === 'transversal_concept_id') {
            const ansLabel = lang === 'sv' ? "Topptriangeln och hela triangeln" : "The top triangle and the whole triangle";
            return {
                renderData: {
                    description: lang === 'sv' ? "I en figur med en topptriangel skapad av en parallelltransversal, vilka tv√• figurer √§r likformiga?" : "In a figure with a top triangle created by a parallel transversal, which two shapes are similar?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ansLabel, lang === 'sv' ? "Topptriangeln och den nedre fyrh√∂rningen" : "The top triangle and the bottom quadrilateral", lang === 'sv' ? "Inga figurer √§r likformiga" : "No shapes are similar"])
                },
                token: this.toBase64(ansLabel),
                clues: [{ text: lang === 'sv' ? "Eftersom linjerna √§r parallella f√•r de tv√• trianglarna samma vinklar och blir d√§rmed likformiga." : "Since the lines are parallel, the two triangles get the same angles and thus become similar." }],
                metadata: { variation_key: 'transversal_concept_id', difficulty: 2 }
            };
        }

        const isExt = v === 'transversal_extension';
        const visualLabels = isExt 
            ? { left_top: top, left_bot: add, base_top: smallBase, base_bot: 'x' }
            : { left_top: top, left_tot: tot, base_top: smallBase, base_bot: 'x' };

        return {
            renderData: {
                geometry: { type: 'transversal', labels: visualLabels },
                description: lang === 'sv' ? "Ber√§kna l√§ngden p√• basen x med hj√§lp av likformighet." : "Calculate the length of the base x using similarity.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Identifiera de tv√• likformiga trianglarna: den lilla toppen och den stora helheten." : "Identify the two similar triangles: the small top and the large whole." },
                { text: lang === 'sv' ? (isExt ? `Hela sidans l√§ngd √§r ${top} + ${add} = ${tot}.` : `Skalan hittas genom att dela den stora sidan med den lilla.`) : (isExt ? `The total side length is ${top} + ${add} = ${tot}.` : `The scale is found by dividing the large side by the small one.`), latex: `k = \\frac{${tot}}{${top}} = ${scale}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: PYTHAGORAS & SIMILARITY ---
    private level4_Pythagoras(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['pythagoras_sim_hyp', 'pythagoras_sim_leg']);
        const a = 3, b = 4, c = 5;
        const k = 2;
        const bigA = a*k, bigB = b*k, bigC = c*k;

        const isHyp = v === 'pythagoras_sim_hyp';
        return {
            renderData: {
                geometry: { 
                    type: 'similarity_compare', shapeType: 'triangle', 
                    left: { labels: { b: a, h: b, hyp: c } }, 
                    right: { labels: isHyp ? { b: bigA, h: bigB, hyp: 'x' } : { b: 'x', h: bigB, hyp: bigC } } 
                },
                description: lang === 'sv' ? "Anv√§nd likformighet (eller Pythagoras sats) f√∂r att ber√§kna x." : "Use similarity (or Pythagoras' theorem) to calculate x.",
                answerType: 'numeric'
            },
            token: this.toBase64((isHyp ? bigC : bigA).toString()),
            clues: [
                { text: lang === 'sv' ? "Hitta skalan mellan trianglarna f√∂rst." : "First find the scale between the triangles.", latex: `k = \\frac{${bigB}}{${b}} = ${k}` },
                { text: lang === 'sv' ? `Multiplicera motsvarande sida i den lilla triangeln med skalan ${k}.` : `Multiply the corresponding side in the small triangle by the scale ${k}.`, latex: isHyp ? `${c} \\cdot ${k} = ${bigC}` : `${a} \\cdot ${k} = ${bigA}` }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\SimilarityGen.ts

// =======================================================
// FILE START: src\core\generators\StatisticsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class StatisticsGen {
    // --- CONTEXT LIBRARY ---
    private static readonly SCENARIOS = {
        lists: [
            { id: 'shoe', sv: "skostorlekar", en: "shoe sizes", unit: "", min: 35, max: 45 },
            { id: 'goals', sv: "gjorda m√•l", en: "goals scored", unit: "m√•l", min: 0, max: 6 },
            { id: 'temp', sv: "temperaturer", en: "temperatures", unit: "¬∞C", min: 15, max: 25 },
            { id: 'age', sv: "√•ldrar", en: "ages", unit: "√•r", min: 10, max: 16 },
            { id: 'points', sv: "po√§ng", en: "points", unit: "p", min: 5, max: 20 },
            { id: 'height', sv: "l√§ngder", en: "heights", unit: "cm", min: 150, max: 170 },
            { id: 'sleep', sv: "s√∂mntimmar", en: "hours of sleep", unit: "h", min: 6, max: 10 }
        ],
        real_world: [
            { sv: "l√∂ner", en: "salaries", unit: "kr", min: 25, max: 45, suffix: 'k' },
            { sv: "huspriser", en: "house prices", unit: "kr", min: 2, max: 8, suffix: ' milj.' },
            { sv: "t√§vlingsresultat", en: "competition scores", unit: "p", min: 50, max: 100, suffix: '' }
        ],
        shopping: [
            { sv: "√§pplen", en: "apples", unit: "kr/kg", min: 15, max: 35 },
            { sv: "godis", en: "candy", unit: "kr/hg", min: 8, max: 15 },
            { sv: "potatis", en: "potatoes", unit: "kr/kg", min: 10, max: 20 },
            { sv: "oxfil√©", en: "beef fillet", unit: "kr/kg", min: 300, max: 600 },
            { sv: "lax", en: "salmon", unit: "kr/kg", min: 200, max: 400 }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ModeRange(lang);
            case 2: return this.level2_Mean(lang);
            case 3: return this.level3_Median(lang);
            case 4: return this.level4_ReverseMean(lang);
            case 5: return this.level5_FrequencyTable(lang);
            case 6: return this.level6_RealWorldMixed(lang);
            default: return this.level1_ModeRange(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'find_mode':
            case 'find_range':
            case 'stats_lie':
            case 'find_min_max':
                return this.level1_ModeRange(lang, key);
            
            case 'calc_mean':
            case 'mean_concept_balance':
            case 'mean_negatives':
                return this.level2_Mean(lang, key);
            
            case 'median_odd':
            case 'median_even':
            case 'median_lie':
                return this.level3_Median(lang, key);
            
            case 'reverse_mean_calc':
            case 'mean_target_score':
                return this.level4_ReverseMean(lang, key);
            
            case 'freq_mean':
            case 'freq_count':
            case 'freq_mode':
            case 'freq_range':
                return this.level5_FrequencyTable(lang, key);
            
            case 'real_outlier_shift':
            case 'real_measure_choice':
            case 'real_weighted_avg':
            case 'real_weighted_missing':
                return this.level6_RealWorldMixed(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: MODE & RANGE ---
    private level1_ModeRange(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['find_mode', 'find_range', 'stats_lie', 'find_min_max']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);
        const len = MathUtils.randomInt(6, 9);
        const list: number[] = [];
        
        const modeVal = MathUtils.randomInt(s.min, s.max);
        if (v !== 'find_min_max') {
            for(let i=0; i<3; i++) list.push(modeVal); 
            for(let i=0; i<len-3; i++) list.push(MathUtils.randomInt(s.min, s.max));
        } else {
            for(let i=0; i<len; i++) list.push(MathUtils.randomInt(s.min, s.max));
        }
        
        const shuffled = [...list].sort(() => Math.random() - 0.5);
        const setStr = shuffled.join(', ');

        if (v === 'find_mode') {
            return {
                renderData: { 
                    description: lang === 'sv' ? `H√§r √§r en lista √∂ver ${s.sv}: ${setStr}. Vilket √§r typv√§rdet f√∂r detta datamaterial?` : `Here is a list of ${s.en}: ${setStr}. What is the mode for this data set?`,
                    answerType: 'numeric' 
                },
                token: this.toBase64(modeVal.toString()),
                clues: [{ text: lang === 'sv' ? "Typv√§rdet √§r det tal som f√∂rekommer flest g√•nger i en samling data. Det √§r det mest 'typiska' v√§rdet." : "The mode is the value that appears most frequently in a data set. It is the most 'typical' value." }],
                metadata: { variation_key: 'find_mode', difficulty: 1 }
            };
        }

        if (v === 'find_range') {
            const min = Math.min(...list);
            const max = Math.max(...list);
            return {
                renderData: { 
                    description: lang === 'sv' ? `Studera listan √∂ver ${s.sv}: ${setStr}. Vad √§r variationsbredden f√∂r dessa v√§rden?` : `Study the list of ${s.en}: ${setStr}. What is the range for these values?`,
                    answerType: 'numeric' 
                },
                token: this.toBase64((max - min).toString()),
                clues: [{ text: lang === 'sv' ? "Variationsbredden ber√§knas genom att ta det st√∂rsta v√§rdet minus det minsta v√§rdet i listan." : "The range is calculated by taking the largest value minus the smallest value in the list.", latex: `${max} - ${min} = ${max - min}` }],
                metadata: { variation_key: 'find_range', difficulty: 1 }
            };
        }

        if (v === 'find_min_max') {
            const min = Math.min(...list);
            const max = Math.max(...list);
            const isMin = Math.random() > 0.5;
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket √§r det ${isMin ? 'minsta' : 'st√∂rsta'} v√§rdet i f√∂ljande lista: ${setStr}?` : `What is the ${isMin ? 'minimum' : 'maximum'} value in the following list: ${setStr}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64((isMin ? min : max).toString()),
                clues: [{ text: lang === 'sv' ? "G√• igenom listan metodiskt och leta efter det absolut l√§gsta eller h√∂gsta talet." : "Go through the list methodically and look for the absolute lowest or highest number." }],
                metadata: { variation_key: 'find_min_max', difficulty: 1 }
            };
        }

        // Spot the Lie
        const min = Math.min(...list);
        const max = Math.max(...list);
        const range = max - min;
        const t1 = lang === 'sv' ? `Typv√§rdet √§r ${modeVal}` : `Mode is ${modeVal}`;
        const t2 = lang === 'sv' ? `Variationsbredden √§r ${range}` : `Range is ${range}`;
        const sFalse = lang === 'sv' ? `Minsta v√§rdet √§r ${min - 2}` : `Min value is ${min - 2}`;

        return {
            renderData: {
                description: lang === 'sv' ? `Granska listan: ${setStr}. Vilket av p√•st√•endena nedan √§r FALSKT?` : `Review the list: ${setStr}. Which of the statements below is FALSE?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([t1, t2, sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [{ text: lang === 'sv' ? "G√• igenom varje p√•st√•ende och kontrollera det mot siffrorna i listan." : "Go through each statement and verify it against the numbers in the list." }],
            metadata: { variation_key: 'stats_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 2: MEAN ---
    private level2_Mean(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['calc_mean', 'mean_concept_balance', 'mean_negatives']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);

        if (v === 'mean_negatives' || s.id === 'temp') {
            const list = Array.from({length: 4}, () => MathUtils.randomInt(-5, 5));
            const sum = list.reduce((a, b) => a + b, 0);
            const mean = Math.round((sum / 4) * 10) / 10;
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna medeltemperaturen f√∂r f√∂ljande m√§tv√§rden: ${list.join('¬∞C, ')}¬∞C.` : `Calculate the mean temperature for the following readings: ${list.join('¬∞C, ')}¬∞C.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(mean.toString()),
                clues: [{ text: lang === 'sv' ? "Addera alla temperaturer (t√§nk p√• de negativa talen) och dela summan med 4." : "Add all temperatures (mind the negative numbers) and divide the sum by 4.", latex: `\\frac{${list.join(' + ')}}{4} = ${mean}` }],
                metadata: { variation_key: 'mean_negatives', difficulty: 3 }
            };
        }

        if (v === 'mean_concept_balance') {
            const oldMean = 20;
            const newVal = MathUtils.randomChoice([10, 30]);
            const isLower = newVal < oldMean;
            const ans = isLower ? (lang === 'sv' ? "Det minskar" : "It decreases") : (lang === 'sv' ? "Det √∂kar" : "It increases");
            return {
                renderData: {
                    description: lang === 'sv' ? `Om medelv√§rdet f√∂r en grupp √§r ${oldMean} och en ny person med v√§rdet ${newVal} g√•r med i gruppen, vad h√§nder med medelv√§rdet?` : `If the mean for a group is ${oldMean} and a new person with the value ${newVal} joins the group, what happens to the mean?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Det √∂kar", "Det minskar", "Det √§r of√∂r√§ndrat"] : ["It increases", "It decreases", "It stays unchanged"]
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Om det nya v√§rdet √§r l√§gre √§n snittet dras medelv√§rdet ner, och om det √§r h√∂gre dras det upp." : "If the new value is lower than the average, the mean is pulled down, and if it is higher, it is pulled up." }],
                metadata: { variation_key: 'mean_concept_balance', difficulty: 2 }
            };
        }

        const count = MathUtils.randomInt(4, 6);
        const list = Array.from({length: count}, () => MathUtils.randomInt(s.min, s.max));
        const sum = list.reduce((a, b) => a + b, 0);
        const mean = Math.round((sum / count) * 10) / 10;

        return {
            renderData: {
                description: lang === 'sv' ? `R√§kna ut medelv√§rdet f√∂r dessa ${s.sv}: ${list.join(', ')}.` : `Calculate the mean for these ${s.en}: ${list.join(', ')}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(mean.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Addera alla tal f√∂r att f√• den totala summan." : "Step 1: Add all numbers to get the total sum.", latex: list.join(' + ') + ` = ${sum}` },
                { text: lang === 'sv' ? `Steg 2: Dividera summan med antalet tal (${count}).` : `Step 2: Divide the sum by the number of values (${count}).`, latex: `\\frac{${sum}}{${count}} = ${mean}` }
            ],
            metadata: { variation_key: 'calc_mean', difficulty: 2 }
        };
    }

    // --- LEVEL 3: MEDIAN ---
    private level3_Median(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['median_odd', 'median_even', 'median_lie']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);
        const count = v === 'median_even' ? 6 : 5;
        const list = Array.from({length: count}, () => MathUtils.randomInt(s.min, s.max));
        const sorted = [...list].sort((a, b) => a - b);
        
        let median = 0;
        if (count % 2 !== 0) {
            median = sorted[Math.floor(count / 2)];
        } else {
            median = (sorted[count/2 - 1] + sorted[count/2]) / 2;
        }

        if (v === 'median_lie') {
            const lie = sorted[0]; // Using min as a lie for median
            const sTrue = lang === 'sv' ? `Medianen √§r ${median}` : `Median is ${median}`;
            const sLie = lang === 'sv' ? `Medianen √§r ${lie}` : `Median is ${lie}`;
            return {
                renderData: {
                    description: lang === 'sv' ? `Lista: ${list.join(', ')}. Vilket p√•st√•ende om medianen st√§mmer?` : `List: ${list.join(', ')}. Which statement about the median is true?`,
                    answerType: 'multiple_choice',
                    options: [sTrue, sLie]
                },
                token: this.toBase64(sTrue),
                clues: [{ text: lang === 'sv' ? "Sortera alltid listan i storleksordning innan du letar efter det mittersta v√§rdet." : "Always sort the list in size order before looking for the middle value." }],
                metadata: { variation_key: 'median_lie', difficulty: 2 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Best√§m medianen f√∂r f√∂ljande ${s.sv}: ${list.sort(() => Math.random() - 0.5).join(', ')}.` : `Determine the median for the following ${s.en}: ${list.sort(() => Math.random() - 0.5).join(', ')}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(median.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Sortera talen fr√•n minst till st√∂rst." : "Step 1: Sort the numbers from smallest to largest.", latex: sorted.join(', ') },
                { text: lang === 'sv' ? (count % 2 !== 0 ? "Steg 2: Eftersom det √§r ett udda antal tal √§r medianen det tal som st√•r precis i mitten." : "Steg 2: Vid ett j√§mnt antal tal √§r medianen medelv√§rdet av de tv√• talen i mitten.") : (count % 2 !== 0 ? "Step 2: Since there is an odd number of values, the median is the value exactly in the middle." : "Step 2: With an even number of values, the median is the average of the two middle values."), latex: median.toString() }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 4: REVERSE MEAN ---
    private level4_ReverseMean(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['reverse_mean_calc', 'mean_target_score']);
        
        if (v === 'mean_target_score') {
            const score1 = MathUtils.randomInt(10, 15), score2 = MathUtils.randomInt(12, 18);
            const targetMean = 16;
            const required = (targetMean * 3) - score1 - score2;
            return {
                renderData: {
                    description: lang === 'sv' ? `P√• de tv√• f√∂rsta proven fick du ${score1} och ${score2} po√§ng. Vad beh√∂ver du f√• p√• det tredje provet f√∂r att ditt medelv√§rde ska bli exakt ${targetMean}?` : `On the first two tests, you scored ${score1} and ${score2} points. What do you need on the third test for your mean to be exactly ${targetMean}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(required.toString()),
                clues: [
                    { text: lang === 'sv' ? `Steg 1: R√§kna ut vad summan av de tre proven m√•ste vara.` : `Step 1: Calculate what the sum of the three tests must be.`, latex: `3 \\cdot ${targetMean} = ${targetMean * 3}` },
                    { text: lang === 'sv' ? `Steg 2: Dra ifr√•n de po√§ng du redan har.` : `Step 2: Subtract the points you already have.`, latex: `${targetMean * 3} - ${score1} - ${score2} = ${required}` }
                ],
                metadata: { variation_key: 'mean_target_score', difficulty: 4 }
            };
        }

        const count = 4, mean = 15;
        const total = mean * count; // 60
        const v1 = 12, v2 = 18, v3 = 14;
        const missing = total - (v1 + v2 + v3);

        return {
            renderData: {
                description: lang === 'sv' ? `Medelv√§rdet av fyra tal √§r ${mean}. Tre av talen √§r ${v1}, ${v2} och ${v3}. Vilket √§r det fj√§rde talet?` : `The mean of four numbers is ${mean}. Three of the numbers are ${v1}, ${v2}, and ${v3}. What is the fourth number?`,
                answerType: 'numeric'
            },
            token: this.toBase64(missing.toString()),
            clues: [{ text: lang === 'sv' ? "Om du vet medelv√§rdet kan du r√§kna ut den totala summan genom att multiplicera med antalet tal." : "If you know the mean, you can calculate the total sum by multiplying by the count.", latex: `${mean} \\cdot 4 = ${total}` }],
            metadata: { variation_key: 'reverse_mean_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 5: FREQUENCY TABLES ---
    private level5_FrequencyTable(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['freq_mean', 'freq_count', 'freq_mode', 'freq_range']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);
        const rows = [[1, 2], [2, 5], [3, 3], [4, 1]]; // Value, Count
        const totalCount = 11;
        const totalSum = (1*2) + (2*5) + (3*3) + (4*1); // 2 + 10 + 9 + 4 = 25
        
        if (v === 'freq_mode') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Tabellen visar ${s.sv}. Vilket √§r typv√§rdet?` : `The table shows ${s.en}. What is the mode?`,
                    answerType: 'numeric',
                    geometry: { type: 'frequency_table', headers: lang === 'sv' ? ['V√§rde', 'Antal'] : ['Value', 'Count'], rows }
                },
                token: this.toBase64("2"),
                clues: [{ text: lang === 'sv' ? "Leta efter det v√§rde som har h√∂gst siffra i kolumnen 'Antal'." : "Look for the value that has the highest number in the 'Count' column." }],
                metadata: { variation_key: 'freq_mode', difficulty: 2 }
            };
        }

        if (v === 'freq_count') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Hur m√•nga observationer gjordes totalt enligt tabellen?" : "How many observations were made in total according to the table?",
                    answerType: 'numeric',
                    geometry: { type: 'frequency_table', headers: lang === 'sv' ? ['V√§rde', 'Antal'] : ['Value', 'Count'], rows }
                },
                token: this.toBase64(totalCount.toString()),
                clues: [{ text: lang === 'sv' ? "Summera alla siffror i kolumnen 'Antal'." : "Sum all the numbers in the 'Count' column.", latex: `2 + 5 + 3 + 1 = ${totalCount}` }],
                metadata: { variation_key: 'freq_count', difficulty: 2 }
            };
        }

        const mean = Math.round((totalSum / totalCount) * 10) / 10;
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna medelv√§rdet utifr√•n frekvenstabellen (avrunda till en decimal).` : `Calculate the mean based on the frequency table (round to one decimal).`,
                answerType: 'numeric',
                geometry: { type: 'frequency_table', headers: lang === 'sv' ? ['V√§rde', 'Antal'] : ['Value', 'Count'], rows }
            },
            token: this.toBase64(mean.toString()),
            clues: [{ text: lang === 'sv' ? "Multiplicera varje v√§rde med dess antal, addera resultaten och dela med totala antalet observationer." : "Multiply each value by its count, add the results, and divide by the total number of observations.", latex: `\\frac{${totalSum}}{${totalCount}} = ${mean}` }],
            metadata: { variation_key: 'freq_mean', difficulty: 3 }
        };
    }

    // --- LEVEL 6: REAL WORLD ---
    private level6_RealWorldMixed(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['real_outlier_shift', 'real_measure_choice', 'real_weighted_avg', 'real_weighted_missing']);

        if (v === 'real_weighted_missing') {
            const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.shopping);
            const w1 = 2, p1 = 20;
            const w2 = 3;
            const targetAvg = 26;
            // (2*20 + 3*x) / 5 = 26 -> 40 + 3x = 130 -> 3x = 90 -> x = 30
            const ans = 30;

            return {
                renderData: {
                    description: lang === 'sv' ? `Du k√∂per 2 kg ${s.sv} f√∂r 20 kr/kg och 3 kg till av en annan sort. Medelpriset blev 26 kr/kg. Vad kostade den andra sorten per kg?` : `You buy 2 kg of ${s.en} for 20 kr/kg and 3 kg more of another kind. The mean price was 26 kr/kg. What was the price of the other kind per kg?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: R√§kna ut den totala kostnaden f√∂r alla 5 kg." : "Step 1: Calculate the total cost for all 5 kg.", latex: `5 \\cdot 26 = 130` },
                    { text: lang === 'sv' ? "Steg 2: Ta bort kostnaden f√∂r de f√∂rsta 2 kilona." : "Step 2: Subtract the cost of the first 2 kg.", latex: `130 - (2 \\cdot 20) = 90` },
                    { text: lang === 'sv' ? "Steg 3: Dela resten p√• de 3 kilona som √§r kvar." : "Step 3: Divide the remainder by the remaining 3 kg.", latex: `90 / 3 = ${ans}` }
                ],
                metadata: { variation_key: 'real_weighted_missing', difficulty: 4 }
            };
        }

        if (v === 'real_outlier_shift') {
            const dataset = [25, 27, 28, 80]; // k salaries
            const diff = 13; // (160/4 = 40) vs (80/3 = 26.6) approx 13
            return {
                renderData: {
                    description: lang === 'sv' ? "M√•nadsl√∂nerna p√• ett litet f√∂retag √§r 25k, 27k, 28k och 80k. Hur mycket √§ndras medelv√§rdet om vi tar bort chefen som tj√§nar 80k? (Svara i hela tusentals kronor)" : "The monthly salaries at a small company are 25k, 27k, 28k, and 80k. By how much does the mean change if we remove the boss who earns 80k? (Answer in whole thousands)",
                    answerType: 'numeric'
                },
                token: this.toBase64(diff.toString()),
                clues: [{ text: lang === 'sv' ? "R√§kna ut snittet f√∂r alla fyra, sedan snittet f√∂r bara de tre anst√§llda, och j√§mf√∂r." : "Calculate the average for all four, then the average for just the three employees, and compare." }],
                metadata: { variation_key: 'real_outlier_shift', difficulty: 4 }
            };
        }

        // Default to measure choice
        const ans = lang === 'sv' ? "Median" : "Median";
        return {
            renderData: {
                description: lang === 'sv' ? "I en unders√∂kning om huspriser finns det ett extremt dyrt lyxhus som kostar tio g√•nger mer √§n de andra. Vilket centralm√•tt b√∂r man anv√§nda f√∂r att f√• en r√§ttvis bild av vad ett 'vanligt' hus kostar?" : "In a survey of house prices, there is one extremely expensive luxury house that costs ten times more than the others. Which measure of central tendency should be used to give a fair picture of what a 'typical' house costs?",
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Medelv√§rde", "Median", "Variationsbredd"] : ["Mean", "Median", "Range"]
            },
            token: this.toBase64(ans),
            clues: [{ text: lang === 'sv' ? "Medelv√§rdet p√•verkas kraftigt av extremv√§rden (outliers), medan medianen f√∂rblir stabil." : "The mean is heavily influenced by outliers, while the median remains stable." }],
            metadata: { variation_key: 'real_measure_choice', difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\StatisticsGen.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class TenPowersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_MultDivBig(lang);
            case 2: return this.level2_Concepts(lang);
            case 3: return this.level3_DecimalPowers(lang);
            default: return this.level1_MultDivBig(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'big_mult_std':
            case 'big_div_std':
            case 'big_missing_factor':
            case 'power_discovery':
                return this.level1_MultDivBig(lang, key);
            
            case 'reciprocal_equivalence':
            case 'concept_spot_lie':
                return this.level2_Concepts(lang, key);
            
            case 'decimal_div_std':
            case 'decimal_mult_std':
            case 'decimal_logic_trap':
                return this.level3_DecimalPowers(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private fixFloat(n: number) { 
        return parseFloat(n.toFixed(8)); 
    }

    // --- LEVEL 1: MULT/DIV BY 10, 100, 1000 & POWERS ---
    private level1_MultDivBig(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['big_mult_std', 'big_div_std', 'big_missing_factor', 'power_discovery']);

        // Variation A: Standard Forward Calc (10, 100, 1000)
        if (v === 'big_mult_std' || v === 'big_div_std') {
            const power = MathUtils.randomChoice([10, 100, 1000, 10000]);
            const isMult = v === 'big_mult_std';
            const num = MathUtils.randomInt(5, 95) / (Math.random() > 0.5 ? 1 : 10);
            const ans = isMult ? num * power : this.fixFloat(num / power);
            const zeros = Math.round(Math.log10(power));

            const desc = lang === 'sv' 
                ? "Ber√§kna v√§rdet av uttrycket nedan." 
                : "Calculate the value of the expression below.";

            return {
                renderData: {
                    latex: isMult ? `${num} \\cdot ${power}` : `${num} / ${power}`,
                    description: desc,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? `Steg 1: R√§kna antalet nollor i talet ${power}. Det √§r ${zeros} stycken.` 
                            : `Step 1: Count the number of zeros in ${power}. There are ${zeros}.`, 
                        latex: `10^{${zeros}} = ${power}` 
                    },
                    { 
                        text: lang === 'sv' 
                            ? `Steg 2: Flytta kommatecknet ${zeros} steg √•t ${isMult ? 'h√∂ger s√• att talet blir st√∂rre.' : 'v√§nster s√• att talet blir mindre.'}` 
                            : `Step 2: Move the decimal point ${zeros} steps to the ${isMult ? 'right to make the number larger.' : 'left to make the number smaller.'}`, 
                        latex: `${num} \\rightarrow ${ans}`
                    }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }

        // Variation B: Missing Power Factor (Inverse)
        if (v === 'big_missing_factor') {
            const power = MathUtils.randomChoice([10, 100, 1000]);
            const num = MathUtils.randomInt(5, 50);
            const isMult = Math.random() > 0.5;
            const res = isMult ? num * power : this.fixFloat(num / power);

            return {
                renderData: {
                    latex: isMult ? `${num} \\cdot ? = ${res}` : `${num} / ? = ${res}`,
                    description: lang === 'sv' ? "Vilken tiopotens saknas f√∂r att likheten ska st√§mma?" : "Which power of ten is missing for the equality to be correct?",
                    answerType: 'numeric'
                },
                token: this.toBase64(power.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? `J√§mf√∂r starttalet ${num} med resultatet ${res}. Hur m√•nga steg har kommatecknet flyttats?` 
                            : `Compare the start number ${num} with the result ${res}. How many places has the decimal point moved?`, 
                        latex: "" 
                    },
                    { 
                        text: lang === 'sv' 
                            ? `Varje steg motsvarar en nolla. Eftersom det flyttats ${Math.round(Math.log10(power))} steg √§r den saknade tiopotensen en etta f√∂ljd av ${Math.round(Math.log10(power))} nollor.` 
                            : `Each step corresponds to one zero. Since it moved ${Math.round(Math.log10(power))} places, the missing power is a one followed by ${Math.round(Math.log10(power))} zeros.`, 
                        latex: `10^{${Math.round(Math.log10(power))}} = ${power}` 
                    }
                ],
                metadata: { variation_key: 'big_missing_factor', difficulty: 2 }
            };
        }

        // Variation C: Power Discovery
        const pVal = MathUtils.randomInt(2, 6);
        const num = Math.pow(10, pVal);
        return {
            renderData: {
                description: lang === 'sv' ? `Skriv talet ${num.toLocaleString(lang)} som en potens med basen 10.` : `Write the number ${num.toLocaleString(lang)} as a power with base 10.`,
                latex: `${num} = 10^{?}`,
                answerType: 'structured_power'
            },
            token: this.toBase64(`10^${pVal}`),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? `R√§kna hur m√•nga nollor som f√∂ljer efter siffran 1. Antalet nollor √§r samma sak som exponenten i en tiopotens.` 
                        : `Count how many zeros follow the digit 1. The number of zeros is the same as the exponent in a power of ten.`, 
                    latex: `10^{${pVal}} = ${num}` 
                }
            ],
            metadata: { variation_key: 'power_discovery', difficulty: 2 }
        };
    }

    // --- LEVEL 2: CONCEPTUAL RECIPROCALS ---
    private level2_Concepts(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['reciprocal_equivalence', 'concept_spot_lie']);

        // Variation A: The "Same As" Reciprocal Logic
        if (v === 'reciprocal_equivalence') {
            const scenarios = [
                { op: 'mul', val: 0.1, equiv: 10, equivOp: 'div' },
                { op: 'mul', val: 0.01, equiv: 100, equivOp: 'div' },
                { op: 'div', val: 0.1, equiv: 10, equivOp: 'mul' },
                { op: 'div', val: 0.01, equiv: 100, equivOp: 'mul' }
            ];
            const s = MathUtils.randomChoice(scenarios);
            const opText = lang === 'sv' 
                ? (s.op === 'mul' ? "multiplicera med" : "dividera med") 
                : (s.op === 'mul' ? "multiplying by" : "dividing by");
            const targetText = lang === 'sv'
                ? (s.equivOp === 'mul' ? "multiplicera med..." : "dividera med...")
                : (s.equivOp === 'mul' ? "multiplying by..." : "dividing by...");

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Att ${opText} ${s.val} ger samma resultat som att ${targetText}` 
                        : `To ${opText} ${s.val} gives the same result as ${targetText}`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(["10", "100", "0.1", "0.01", "1000"])
                },
                token: this.toBase64(s.equiv.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? `Kom ih√•g att ${s.val} motsvarar en ${s.equiv === 10 ? 'tiondel' : 'hundradel'}.` 
                            : `Remember that ${s.val} corresponds to one ${s.equiv === 10 ? 'tenth' : 'hundredth'}.`, 
                        latex: `${s.val} = \\frac{1}{${s.equiv}}` 
                    },
                    { 
                        text: lang === 'sv' 
                            ? `Att r√§kna ut en ${s.equiv === 10 ? 'tiondel' : 'hundradel'} av ett tal √§r matematiskt identiskt med att dela talet med ${s.equiv}.` 
                            : `Calculating one ${s.equiv === 10 ? 'tenth' : 'hundredth'} of a number is mathematically identical to dividing the number by ${s.equiv}.`, 
                        latex: ""
                    }
                ],
                metadata: { variation_key: 'reciprocal_equivalence', difficulty: 2 }
            };
        }

        // Variation B: Spot the Lie
        const generateStmt = (isCorrect: boolean) => {
            const num = MathUtils.randomInt(3, 9) * 10;
            const type = MathUtils.randomInt(1, 3);
            if (type === 1) { // Mult 0.1
                return isCorrect ? `${num} ¬∑ 0,1 = ${num/10}` : `${num} ¬∑ 0,1 = ${num * 10}`;
            } else if (type === 2) { // Div 0.1
                return isCorrect ? `${num} / 0,1 = ${num * 10}` : `${num} / 0,1 = ${num / 10}`;
            } else { // Mult 0.01
                return isCorrect ? `${num} ¬∑ 0,01 = ${this.fixFloat(num/100).toString().replace('.', ',')}` : `${num} ¬∑ 0,01 = ${num / 10}`;
            }
        };

        const sFalse = generateStmt(false);
        return {
            renderData: {
                description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden om tiopotenser √§r FALSKT?" : "Which of the following statements about powers of ten is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([generateStmt(true), generateStmt(true), sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [
                { 
                    text: lang === 'sv' ? "Kontrollera om talet i resultatet har blivit st√∂rre eller mindre. Multiplikation med tal mindre √§n 1 ska g√∂ra talet mindre, medan division ska g√∂ra det st√∂rre." : "Check if the resulting number has become larger or smaller. Multiplying by numbers less than 1 should make the number smaller, while division should make it larger.", 
                    latex: "" 
                }
            ],
            metadata: { variation_key: 'concept_spot_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 3: DECIMAL POWERS (0.1, 0.01, 0.001) ---
    private level3_DecimalPowers(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['decimal_div_std', 'decimal_mult_std', 'decimal_logic_trap']);
        const factor = MathUtils.randomChoice([0.1, 0.01, 0.001]);
        const num = MathUtils.randomInt(5, 50);

        if (v === 'decimal_div_std') {
            const ans = this.fixFloat(num / factor);
            const equivMult = Math.round(1 / factor);
            
            return {
                renderData: {
                    latex: `${num} / ${factor.toString().replace('.', ',')}`,
                    description: lang === 'sv' ? "Ber√§kna resultatet av divisionen." : "Calculate the result of the division.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? `Att dividera med ${factor.toString().replace('.', ',')} √§r detsamma som att multiplicera med ${equivMult}.` 
                            : `Dividing by ${factor} is the same as multiplying by ${equivMult}.`, 
                        latex: `\\frac{1}{${factor}} = ${equivMult}` 
                    },
                    { 
                        text: lang === 'sv' 
                            ? `N√§r vi dividerar med ett tal som √§r mindre √§n 1 blir resultatet alltid ST√ñRRE √§n starttalet.` 
                            : `When we divide by a number less than 1, the result is always LARGER than the starting number.`, 
                        latex: `${num} \\cdot ${equivMult} = ${ans}` 
                    }
                ],
                metadata: { variation_key: 'decimal_div_std', difficulty: 3 }
            };
        }

        if (v === 'decimal_mult_std') {
            const ans = this.fixFloat(num * factor);
            const equivDiv = Math.round(1 / factor);

            return {
                renderData: {
                    latex: `${num} \\cdot ${factor.toString().replace('.', ',')}`,
                    description: lang === 'sv' ? "Ber√§kna resultatet av multiplikationen." : "Calculate the result of the multiplication.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? `Att multiplicera med ${factor.toString().replace('.', ',')} √§r samma sak som att dividera med ${equivDiv}.` 
                            : `Multiplying by ${factor} is the same as dividing by ${equivDiv}.`, 
                        latex: `${factor} = \\frac{1}{${equivDiv}}` 
                    },
                    { 
                        text: lang === 'sv' 
                            ? `Flytta kommatecknet √•t v√§nster f√∂r att g√∂ra talet mindre.` 
                            : `Move the decimal point to the left to make the number smaller.`, 
                        latex: `${num} / ${equivDiv} = ${ans}` 
                    }
                ],
                metadata: { variation_key: 'decimal_mult_std', difficulty: 3 }
            };
        }

        // Variation C: Decimal Logic Discovery (Inverse)
        const isMult = Math.random() > 0.5;
        const result = isMult ? this.fixFloat(num * factor) : this.fixFloat(num / factor);
        const correctStmt = lang === 'sv' 
            ? `${num} ${isMult ? '¬∑' : '/'} ${factor.toString().replace('.', ',')} = ${result.toString().replace('.', ',')}`
            : `${num} ${isMult ? '¬∑' : '/'} ${factor} = ${result}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden √§r matematiskt korrekt?" : "Which of the following statements is mathematically correct?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([
                    correctStmt,
                    lang === 'sv' ? `${num} ${isMult ? '¬∑' : '/'} ${1/factor} = ${result.toString().replace('.', ',')}` : `${num} ${isMult ? '¬∑' : '/'} ${1/factor} = ${result}`,
                    lang === 'sv' ? `${num} ${isMult ? '¬∑' : '/'} 1 = ${result.toString().replace('.', ',')}` : `${num} ${isMult ? '¬∑' : '/'} 1 = ${result}`
                ])
            },
            token: this.toBase64(correctStmt),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? `Kontrollera om resultatet (${result.toString().replace('.', ',')}) √§r st√∂rre eller mindre √§n starttalet (${num}).` 
                        : `Check if the result (${result}) is larger or smaller than the start number (${num}).`, 
                    latex: "" 
                }
            ],
            metadata: { variation_key: 'decimal_logic_trap', difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class VolumeGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Cuboid(lang);
            case 2: return this.level2_TriPrism(lang);
            case 3: return this.level3_Cylinder(lang);
            case 4: return this.level4_PyramidCone(lang);
            case 5: return this.level5_SphereComposite(lang);
            case 6: return this.level6_Mixed(lang);
            case 7: return this.level7_Units(lang);
            case 8: return this.level8_SurfaceArea(lang);
            default: return this.level1_Cuboid(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'vol_cuboid_std':
            case 'vol_cuboid_inverse':
            case 'vol_cuboid_scaling':
                return this.level1_Cuboid(lang, key);
            
            case 'vol_tri_prism_std':
            case 'vol_tri_prism_inverse':
                return this.level2_TriPrism(lang, key);
            
            case 'vol_cyl_std':
            case 'vol_cyl_est':
            case 'vol_cyl_inverse':
                return this.level3_Cylinder(lang, key);
            
            case 'vol_pyramid_std':
            case 'vol_cone_rule3':
            case 'vol_cone_std':
                return this.level4_PyramidCone(lang, key);
            
            case 'vol_sphere_std':
            case 'vol_silo_std':
            case 'vol_icecream_std':
                return this.level5_SphereComposite(lang, key);
            
            case 'vol_sphere_diameter':
            case 'vol_icecream_diameter':
                return this.level6_Mixed(lang, key);
            
            case 'vol_units_liter':
            case 'vol_units_m3':
                return this.level7_Units(lang, key);
            
            case 'sa_cuboid':
            case 'sa_cylinder':
            case 'sa_cone':
            case 'sa_sphere':
                return this.level8_SurfaceArea(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CUBOID ---
    private level1_Cuboid(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_cuboid_std', 'vol_cuboid_inverse', 'vol_cuboid_scaling']);

        if (v === 'vol_cuboid_inverse') {
            const w = MathUtils.randomInt(3, 6), d = MathUtils.randomInt(3, 6), h = MathUtils.randomInt(4, 12);
            const baseArea = w * d;
            const vol = baseArea * h;

            return {
                renderData: {
                    geometry: { type: 'cuboid', labels: { w, d, h: '?' } },
                    description: lang === 'sv' 
                        ? `Ett r√§tblock har volymen ${vol} cm¬≥. Vi vet att bottenarean √§r ${baseArea} cm¬≤. Hur h√∂gt √§r r√§tblocket?` 
                        : `A rectangular prism has a volume of ${vol} cm¬≥. We know the base area is ${baseArea} cm¬≤. What is the height?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "Volymen ber√§knas som Basytan multiplicerat med H√∂jden. F√∂r att hitta h√∂jden g√∂r vi tv√§rtom och dividerar volymen med basytan." : "Volume is calculated as Base Area multiplied by Height. To find the height, we do the inverse and divide the volume by the base area.", latex: `h = \\frac{\\text{Volym}}{\\text{Basarea}} = \\frac{${vol}}{${baseArea}}` }
                ],
                metadata: { variation_key: 'vol_cuboid_inverse', difficulty: 2 }
            };
        }

        if (v === 'vol_cuboid_scaling') {
            const factor = MathUtils.randomChoice([2, 3]);
            const q = lang === 'sv' 
                ? `Om du har en l√•da och g√∂r den ${factor} g√•nger h√∂gre (utan att √§ndra bredden eller djupet), vad h√§nder d√• med l√•dans volym?` 
                : `If you have a box and make it ${factor} times taller (without changing the width or depth), what happens to the volume of the box?`;
            const ans = lang === 'sv' ? `Den blir ${factor} g√•nger st√∂rre` : `It becomes ${factor} times larger`;

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, lang === 'sv' ? "Den √§ndras inte" : "It doesn't change", lang === 'sv' ? `Den blir ${factor * factor} g√•nger st√∂rre` : `It becomes ${factor * factor} times larger`]),
                    geometry: { type: 'cuboid', labels: { w: 'b', d: 'd', h: 'h' } }
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Volymen √§r direkt proportionell mot h√∂jden. Om en sida v√§xer s√• v√§xer volymen med samma faktor." : "Volume is directly proportional to height. If one dimension grows, the volume grows by the same factor.", latex: `V_{ny} = b \\cdot d \\cdot (${factor}h) = ${factor} \\cdot (b \\cdot d \\cdot h)` }],
                metadata: { variation_key: 'vol_cuboid_scaling', difficulty: 2 }
            };
        }

        // Standard Calculation with context
        const items = [
            { sv: "en tegelsida", en: "a brick", w: 5, d: 10, h: 4 },
            { sv: "en container", en: "a container", w: 3, d: 6, h: 3 },
            { sv: "ett paket", en: "a package", w: 4, d: 8, h: 5 }
        ];
        const item = MathUtils.randomChoice(items);
        const w = item.w, d = item.d, h = item.h;
        const vol = w * d * h;

        return {
            renderData: { 
                geometry: { type: 'cuboid', labels: { w, d, h } }, 
                description: lang === 'sv' ? `Ber√§kna volymen f√∂r ${item.sv} med m√•tten som visas i figuren.` : `Calculate the volume of ${item.en} using the dimensions shown in the figure.`, 
                answerType: 'numeric', suffix: 'cm¬≥'
            },
            token: this.toBase64(vol.toString()),
            clues: [{ text: lang === 'sv' ? "T√§nk p√• volym som att vi r√§knar ut hur m√•nga 'sockerbitar' (kubikcentimeter) som f√•r plats. Vi tar basytan (bredd ¬∑ djup) och staplar den p√• h√∂jden." : "Think of volume as counting how many 'sugar cubes' (cubic centimeters) fit. We take the base area (width ¬∑ depth) and stack it up by the height.", latex: `V = ${w} \\cdot ${d} \\cdot ${h}` }],
            metadata: { variation_key: 'vol_cuboid_std', difficulty: 1 }
        };
    }

    // --- LEVEL 2: TRIANGULAR PRISM ---
    private level2_TriPrism(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_tri_prism_std', 'vol_tri_prism_inverse']);
        const b = MathUtils.randomInt(4, 8), hTri = MathUtils.randomInt(4, 6), length = MathUtils.randomInt(10, 20);
        const baseArea = (b * hTri) / 2;
        const vol = baseArea * length;

        if (v === 'vol_tri_prism_inverse') {
            return {
                renderData: {
                    geometry: { type: 'triangular_prism', labels: { b, h: hTri, l: '?' } },
                    description: lang === 'sv' ? `Ett triangul√§rt prisma (som t.ex. ett t√§lt) har volymen ${vol} cm¬≥. Triangelns bas √§r ${b} cm och dess h√∂jd √§r ${hTri} cm. Hur l√•ngt √§r prismat?` : `A triangular prism (like a tent) has a volume of ${vol} cm¬≥. The triangle's base is ${b} cm and its height is ${hTri} cm. How long is the prism?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(length.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: R√§kna ut arean p√• den triangul√§ra kortsidan (basytan)." : "Step 1: Calculate the area of the triangular side (the base area).", latex: `B = \\frac{${b} \\cdot ${hTri}}{2} = ${baseArea}` },
                    { text: lang === 'sv' ? "Steg 2: Dela den totala volymen med basytan f√∂r att hitta l√§ngden." : "Step 2: Divide the total volume by the base area to find the length.", latex: `L = \\frac{${vol}}{${baseArea}} = ${length}` }
                ],
                metadata: { variation_key: 'vol_tri_prism_inverse', difficulty: 3 }
            };
        }

        const scenarios = [
            { sv: "ett t√§lt", en: "a tent" },
            { sv: "en chokladask", en: "a chocolate box" }
        ];
        const s = MathUtils.randomChoice(scenarios);

        return {
            renderData: {
                geometry: { type: 'triangular_prism', labels: { b, h: hTri, l: length } },
                description: lang === 'sv' ? `Ber√§kna volymen f√∂r ${s.sv} som har formen av ett triangul√§rt prisma.` : `Calculate the volume of ${s.en} which has the shape of a triangular prism.`,
                answerType: 'numeric', suffix: 'cm¬≥'
            },
            token: this.toBase64(vol.toString()),
            clues: [
                { text: lang === 'sv' ? "Principen f√∂r alla prismor √§r densamma: Ber√§kna arean p√• 'botten' (h√§r triangeln) och multiplicera med l√§ngden/h√∂jden." : "The principle for all prisms is the same: Calculate the area of the 'base' (here the triangle) and multiply by the length/height.", latex: `B = \\frac{${b} \\cdot ${hTri}}{2} = ${baseArea}` },
                { text: lang === 'sv' ? `Volymen blir d√• ${baseArea} ¬∑ ${length}.` : `The volume is then ${baseArea} ¬∑ ${length}.`, latex: `${vol}` }
            ],
            metadata: { variation_key: 'vol_tri_prism_std', difficulty: 2 }
        };
    }

    // --- LEVEL 3: CYLINDER ---
    private level3_Cylinder(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_cyl_std', 'vol_cyl_est', 'vol_cyl_inverse']);
        const r = MathUtils.randomInt(2, 5), h = MathUtils.randomInt(5, 12);
        const pi = 3.14;
        const vol = Math.round(pi * r * r * h);

        if (v === 'vol_cyl_est') {
            const threshold = Math.floor(3 * r * r * h);
            const q = lang === 'sv' ? `En cylinder har radien ${r} cm och h√∂jden ${h} cm. √Ñr volymen st√∂rre eller mindre √§n ${threshold} cm¬≥?` : `A cylinder has a radius of ${r} cm and a height of ${h} cm. Is the volume greater or smaller than ${threshold} cm¬≥?`;
            const ans = lang === 'sv' ? "St√∂rre" : "Greater";
            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["St√∂rre", "Mindre"] : ["Greater", "Smaller"],
                    geometry: { type: 'cylinder', labels: { r, h } }
                },
                token: this.toBase64(ans),
                clues: [{ text: lang === 'sv' ? "Eftersom pi ($\approx 3,14$) √§r st√∂rre √§n 3, kommer den verkliga volymen alltid att vara st√∂rre √§n om vi bara r√§knar med 3." : "Since pi ($\approx 3.14$) is larger than 3, the actual volume will always be larger than if we only calculate using 3." }],
                metadata: { variation_key: 'vol_cyl_est', difficulty: 2 }
            };
        }

        if (v === 'vol_cyl_inverse') {
            const baseArea = Math.round(pi * r * r);
            const totalVol = baseArea * h;
            return {
                renderData: {
                    description: lang === 'sv' ? `En l√§skburk har volymen ${totalVol} cm¬≥ och en bottenarea p√• ${baseArea} cm¬≤. Hur h√∂g √§r burken?` : `A soda can has a volume of ${totalVol} cm¬≥ and a base area of ${baseArea} cm¬≤. How tall is the can?`,
                    answerType: 'numeric', suffix: 'cm',
                    geometry: { type: 'cylinder', labels: { r, h: '?' } }
                },
                token: this.toBase64(h.toString()),
                clues: [{ text: lang === 'sv' ? "Dela den totala volymen med arean p√• cirkelbotten f√∂r att f√• fram h√∂jden." : "Divide the total volume by the area of the circular base to find the height.", latex: `h = \\frac{${totalVol}}{${baseArea}}` }],
                metadata: { variation_key: 'vol_cyl_inverse', difficulty: 3 }
            };
        }

        return {
            renderData: { 
                description: lang === 'sv' ? "Ber√§kna cylinderns volym. Anv√§nd $\\pi \\approx 3,14$ och avrunda svaret till ett heltal." : "Calculate the cylinder's volume. Use $\\pi \\approx 3.14$ and round your answer to the nearest integer.", 
                answerType: 'numeric', suffix: 'cm¬≥',
                geometry: { type: 'cylinder', labels: { r, h } }
            },
            token: this.toBase64(vol.toString()),
            clues: [{ text: lang === 'sv' ? "Formeln f√∂r en cylinders volym √§r bottenarean (en cirkel) g√•nger h√∂jden." : "The formula for a cylinder's volume is the base area (a circle) times the height.", latex: `V = \\pi \\cdot r^2 \\cdot h = 3,14 \\cdot ${r}^2 \\cdot ${h}` }],
            metadata: { variation_key: 'vol_cyl_std', difficulty: 2 }
        };
    }

    // --- LEVEL 4: PYRAMID & CONE ---
    private level4_PyramidCone(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_pyramid_std', 'vol_cone_rule3', 'vol_cone_std']);

        if (v === 'vol_pyramid_std') {
            const s = MathUtils.randomInt(4, 8), h = 9; 
            const vol = (s * s * h) / 3;
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna volymen f√∂r en pyramid med en kvadratisk bas d√§r sidan √§r ${s} cm och h√∂jden √§r ${h} cm.` : `Calculate the volume of a pyramid with a square base where the side is ${s} cm and the height is ${h} cm.`,
                    answerType: 'numeric', suffix: 'cm¬≥',
                    geometry: { type: 'pyramid', labels: { s, h } }
                },
                token: this.toBase64(vol.toString()),
                clues: [{ text: lang === 'sv' ? "En pyramid har precis en tredjedel av volymen hos ett r√§tblock med samma m√•tt. R√§kna ut basytan g√•nger h√∂jden och dela med 3." : "A pyramid has exactly one-third the volume of a rectangular prism with the same dimensions. Calculate the base area times the height and divide by 3.", latex: `V = \\frac{${s} \\cdot ${s} \\cdot ${h}}{3} = ${vol}` }],
                metadata: { variation_key: 'vol_pyramid_std', difficulty: 3 }
            };
        }

        if (v === 'vol_cone_rule3') {
            return {
                renderData: {
                    description: lang === 'sv' ? "T√§nk dig en cylinder och en kon med exakt samma radie och h√∂jd. Hur m√•nga koner beh√∂ver du t√∂mma i cylindern f√∂r att den ska bli helt full?" : "Imagine a cylinder and a cone with the exact same radius and height. How many cones do you need to empty into the cylinder for it to be completely full?",
                    answerType: 'multiple_choice',
                    options: ["2", "3", "4", "3,14"],
                    geometry: { type: 'cone', labels: { r: 'r', h: 'h' } }
                },
                token: this.toBase64("3"),
                clues: [{ text: lang === 'sv' ? "Detta √§r 'tredjedelsregeln'. Spetsiga figurer rymmer alltid en tredjedel s√• mycket som deras raka motsvarigheter." : "This is the 'one-third rule'. Pointy shapes always hold one-third as much as their straight counterparts." }],
                metadata: { variation_key: 'vol_cone_rule3', difficulty: 2 }
            };
        }

        const r = 3, h = 10;
        const vol = Math.round((3.14 * r * r * h) / 3);
        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna volymen f√∂r konen i figuren. Anv√§nd 3,14 f√∂r pi och avrunda till ett heltal." : "Calculate the volume of the cone in the figure. Use 3.14 for pi and round to an integer.",
                answerType: 'numeric', suffix: 'cm¬≥',
                geometry: { type: 'cone', labels: { r, h } }
            },
            token: this.toBase64(vol.toString()),
            clues: [{ text: lang === 'sv' ? "Ber√§kna arean av cirkeln i botten, multiplicera med h√∂jden och dela sedan med 3 eftersom konen smalnar av till en spets." : "Calculate the area of the circle at the bottom, multiply by the height, and then divide by 3 because the cone narrows to a point.", latex: `V = \\frac{3,14 \\cdot ${r}^2 \\cdot ${h}}{3}` }],
            metadata: { variation_key: 'vol_cone_std', difficulty: 3 }
        };
    }

    // --- LEVEL 5: SPHERE & COMPOSITE ---
    private level5_SphereComposite(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_sphere_std', 'vol_silo_std', 'vol_icecream_std']);
        const r = 3; 
        const pi = 3.14;

        if (v === 'vol_sphere_std') {
            const vol = Math.round((4 * pi * Math.pow(r, 3)) / 3);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna volymen av ett klot (en boll) med radien 3 cm. Anv√§nd 3,14 f√∂r pi." : "Calculate the volume of a sphere (a ball) with a radius of 3 cm. Use 3.14 for pi.",
                    answerType: 'numeric', suffix: 'cm¬≥',
                    geometry: { type: 'sphere', labels: { r } }
                },
                token: this.toBase64(vol.toString()),
                clues: [{ text: lang === 'sv' ? "Anv√§nd standardformeln f√∂r ett klot." : "Use the standard formula for a sphere.", latex: `V = \\frac{4 \\cdot 3,14 \\cdot 3^3}{3}` }],
                metadata: { variation_key: 'vol_sphere_std', difficulty: 3 }
            };
        }

        if (v === 'vol_silo_std') {
            const hCyl = 10;
            const vCyl = pi * r * r * hCyl;
            const vHemi = (2 * pi * Math.pow(r, 3)) / 3;
            const total = Math.round(vCyl + vHemi);
            return {
                renderData: {
                    description: lang === 'sv' ? "En silo best√•r av en cylinder och ett halvklot som tak. Ber√§kna den totala volymen f√∂r hela silon." : "A silo consists of a cylinder and a hemisphere as a roof. Calculate the total volume for the entire silo.",
                    answerType: 'numeric', suffix: 'cm¬≥',
                    geometry: { type: 'silo', labels: { r, h: hCyl } }
                },
                token: this.toBase64(total.toString()),
                clues: [{ text: lang === 'sv' ? "Dela upp figuren: Ber√§kna f√∂rst cylinderns volym och l√§gg sedan till volymen f√∂r ett halvt klot." : "Split the figure: First calculate the cylinder's volume and then add the volume of half a sphere.", latex: `V_{total} = (\\pi \\cdot r^2 \\cdot h) + (\\frac{2 \\cdot \\pi \\cdot r^3}{3})` }],
                metadata: { variation_key: 'vol_silo_std', difficulty: 4 }
            };
        }

        const hCone = 9;
        const vCone = (pi * r * r * hCone) / 3;
        const vHemi = (2 * pi * Math.pow(r, 3)) / 3;
        const total = Math.round(vCone + vHemi);
        return {
            renderData: {
                description: lang === 'sv' ? "En glasstrut best√•r av en kon och en glasskula (halvklot) p√• toppen. Ber√§kna den sammanlagda volymen." : "An ice cream cone consists of a cone and a scoop (hemisphere) on top. Calculate the combined volume.",
                answerType: 'numeric', suffix: 'cm¬≥',
                geometry: { type: 'ice_cream', labels: { r, h: hCone } }
            },
            token: this.toBase64(total.toString()),
            clues: [{ text: lang === 'sv' ? "Ber√§kna volymen f√∂r konen och halvklotet separat och addera dem sedan." : "Calculate the volume of the cone and the hemisphere separately and then add them together." }],
            metadata: { variation_key: 'vol_icecream_std', difficulty: 4 }
        };
    }

    // --- LEVEL 6: MIXED DIAMETER ---
    private level6_Mixed(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_sphere_diameter', 'vol_icecream_diameter']);
        const d = 10, r = 5;

        if (v === 'vol_sphere_diameter') {
            const vol = Math.round((4 * 3.14 * Math.pow(r, 3)) / 3);
            return {
                renderData: {
                    description: lang === 'sv' ? `Ett klot har diametern ${d} cm. Ber√§kna klotets volym. ` : `A sphere has a diameter of ${d} cm. Calculate the sphere's volume.`,
                    answerType: 'numeric', suffix: 'cm¬≥',
                    geometry: { type: 'sphere', show: 'diameter', labels: { d } }
                },
                token: this.toBase64(vol.toString()),
                clues: [{ text: lang === 'sv' ? "Formeln f√∂r volym kr√§ver radien. Radien √§r h√§lften av diametern." : "The formula for volume requires the radius. The radius is half the diameter.", latex: `r = \\frac{${d}}{2} = ${r}` }],
                metadata: { variation_key: 'vol_sphere_diameter', difficulty: 3 }
            };
        }

        const h = 12;
        const vCone = (3.14 * r * r * h) / 3;
        const vHemi = (2 * 3.14 * Math.pow(r, 3)) / 3;
        const total = Math.round(vCone + vHemi);
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna volymen f√∂r en glasstrut d√§r diametern √§r ${d} cm och konens h√∂jd √§r ${h} cm.` : `Calculate the volume of an ice cream cone where the diameter is ${d} cm and the cone's height is ${h} cm.`,
                answerType: 'numeric', suffix: 'cm¬≥',
                geometry: { type: 'ice_cream', show: 'diameter', labels: { d, h } }
            },
            token: this.toBase64(total.toString()),
            clues: [{ text: lang === 'sv' ? "B√∂rja med att r√§kna ut radien (diametern / 2) och anv√§nd den f√∂r att ber√§kna konens och halvklotets volymer." : "Begin by calculating the radius (diameter / 2) and use it to calculate the volumes of the cone and the hemisphere." }],
            metadata: { variation_key: 'vol_icecream_diameter', difficulty: 4 }
        };
    }

    // --- LEVEL 7: UNITS ---
    private level7_Units(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_units_liter', 'vol_units_m3']);

        if (v === 'vol_units_m3') {
            const w = 4, d = 5, h = 2; 
            const m3 = w * d * h;
            const liters = m3 * 1000;
            return {
                renderData: {
                    description: lang === 'sv' ? `En pool har m√•tten ${w} m x ${d} m x ${h} m. Hur m√•nga liter vatten rymmer den n√§r den √§r helt full?` : `A pool has the dimensions ${w} m x ${d} m x ${h} m. How many liters of water does it hold when completely full?`,
                    answerType: 'numeric', suffix: 'liter'
                },
                token: this.toBase64(liters.toString()),
                clues: [
                    { text: lang === 'sv' ? "R√§kna f√∂rst ut volymen i kubikmeter genom att multiplicera de tre sidorna." : "First calculate the volume in cubic meters by multiplying the three sides.", latex: `${w} \\cdot ${d} \\cdot ${h} = ${m3} \\text{ m}^3` },
                    { text: lang === 'sv' ? "Omvandla sedan till liter. Kom ih√•g att 1 m¬≥ motsvarar exakt 1000 liter." : "Then convert to liters. Remember that 1 m¬≥ corresponds to exactly 1000 liters.", latex: `${m3} \\cdot 1000 = ${liters}` }
                ],
                metadata: { variation_key: 'vol_units_m3', difficulty: 4 }
            };
        }

        const w = 50, d = 20, h = 30; 
        const liters = (w * d * h) / 1000;
        return {
            renderData: {
                description: lang === 'sv' ? `Ett akvarium har m√•tten ${w} cm, ${d} cm och ${h} cm. Hur m√•nga liter vatten rymmer det? (Tips: 1 liter = 1 dm¬≥).` : `An aquarium has the dimensions ${w} cm, ${d} cm, and ${h} cm. How many liters of water does it hold? (Hint: 1 liter = 1 dm¬≥).`,
                answerType: 'numeric', suffix: 'liter'
            },
            token: this.toBase64(liters.toString()),
            clues: [
                { text: lang === 'sv' ? "Det enklaste s√§ttet √§r att f√∂rst g√∂ra om alla m√•tt fr√•n cm till dm." : "The easiest way is to first convert all measurements from cm to dm.", latex: `50 \\text{ cm} = 5 \\text{ dm}, \\, 20 \\text{ cm} = 2 \\text{ dm}, \\, 30 \\text{ cm} = 3 \\text{ dm}` },
                { text: lang === 'sv' ? "Volymen i dm¬≥ √§r detsamma som antalet liter." : "The volume in dm¬≥ is the same as the number of liters.", latex: `5 \\cdot 2 \\cdot 3 = ${liters} \\text{ dm}^3` }
            ],
            metadata: { variation_key: 'vol_units_liter', difficulty: 3 }
        };
    }

    // --- LEVEL 8: SURFACE AREA ---
    private level8_SurfaceArea(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sa_cuboid', 'sa_cylinder', 'sa_cone', 'sa_sphere']);

        if (v === 'sa_cuboid') {
            const w = 3, d = 4, h = 5;
            const area = 2 * (w*d + w*h + d*h);
            return {
                renderData: {
                    description: lang === 'sv' ? `Du ska sl√• in ett paket (r√§tblock) med m√•tten ${w} cm, ${d} cm och ${h} cm. Hur stor area har paketet som ska t√§ckas av papper?` : `You are wrapping a gift (rectangular prism) with dimensions ${w} cm, ${d} cm, and ${h} cm. What is the surface area of the gift to be covered by paper?`,
                    answerType: 'numeric', suffix: 'cm¬≤',
                    geometry: { type: 'cuboid', labels: { w, d, h } }
                },
                token: this.toBase64(area.toString()),
                clues: [{ text: lang === 'sv' ? "Ett r√§tblock har sex sidor som sitter ihop parvis. R√§kna ut arean f√∂r de tre olika sidotyperna och dubblera dem." : "A rectangular prism has six faces that come in identical pairs. Calculate the area for the three different face types and double them.", latex: `2(${w}\\cdot${d}) + 2(${w}\\cdot${h}) + 2(${d}\\cdot${h})` }],
                metadata: { variation_key: 'sa_cuboid', difficulty: 4 }
            };
        }

        if (v === 'sa_sphere') {
            const r = 5;
            const area = Math.round(4 * 3.14 * r * r);
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna begr√§nsningsarean (ytarean) f√∂r ett klot med radien ${r} cm. Anv√§nd 3,14 f√∂r pi.` : `Calculate the surface area for a sphere with a radius of ${r} cm. Use 3.14 for pi.`,
                    answerType: 'numeric', suffix: 'cm¬≤',
                    geometry: { type: 'sphere', labels: { r } }
                },
                token: this.toBase64(area.toString()),
                clues: [{ text: lang === 'sv' ? "Anv√§nd formeln f√∂r ett klots begr√§nsningsarea." : "Use the formula for a sphere's surface area.", latex: `A = 4 \\cdot \\pi \\cdot r^2` }],
                metadata: { variation_key: 'sa_sphere', difficulty: 4 }
            };
        }

        if (v === 'sa_cone') {
            const r = 3, h = 4, s = 5; // 3-4-5 triple
            const area = Math.round(3.14 * r * r + 3.14 * r * s);
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna den totala begr√§nsningsarean f√∂r en kon d√§r radien √§r ${r} cm och den sneda sidan (s) √§r ${s} cm.` : `Calculate the total surface area for a cone where the radius is ${r} cm and the slant height (s) is ${s} cm.`,
                    answerType: 'numeric', suffix: 'cm¬≤',
                    geometry: { type: 'cone', labels: { r, h, s } }
                },
                token: this.toBase64(area.toString()),
                clues: [{ text: lang === 'sv' ? "Addera arean f√∂r cirkelbotten och den b√∂jda mantelytan." : "Add the area of the circular base and the curved lateral surface.", latex: `A = (\\pi \\cdot r^2) + (\\pi \\cdot r \\cdot s)` }],
                metadata: { variation_key: 'sa_cone', difficulty: 5 }
            };
        }

        // Standard Cylinder fallback
        const r = 3, h = 7;
        const total = Math.round(2 * 3.14 * r * r + 2 * 3.14 * r * h);
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna den totala begr√§nsningsarean f√∂r en cylinder med radien ${r} cm och h√∂jden ${h} cm.` : `Calculate the total surface area for a cylinder with a radius of ${r} cm and a height of ${h} cm.`,
                answerType: 'numeric', suffix: 'cm¬≤',
                geometry: { type: 'cylinder', labels: { r, h } }
            },
            token: this.toBase64(total.toString()),
            clues: [{ text: lang === 'sv' ? "Ber√§kna arean f√∂r de tv√• cirklarna (botten och lock) plus arean f√∂r mantelytan (sidan)." : "Calculate the area for the two circles (base and top) plus the area for the lateral surface (the side).", latex: `A = 2(\\pi \\cdot r^2) + (2 \\cdot \\pi \\cdot r \\cdot h)` }],
            metadata: { variation_key: 'sa_cylinder', difficulty: 5 }
        };
    }
}

// FILE END: src\core\generators\VolumeGen.ts

// =======================================================
// FILE START: src\core\interfaces\Generator.ts
// =======================================================

export interface QuestionData {
    text?: string;
    renderData?: any; // Preferred
    visual?: any;     // Legacy
    answer: string | number;
    clues: string[];
}

export interface Generator {
    /**
     * Generates a new question.
     * @param level Difficulty level (1-9)
     * @param lang Language code ('sv' | 'en')
     */
    generate(level: number, lang: string): QuestionData;

    /**
     * Optional: Custom validation logic for answers.
     * @param userAnswer The user's input
     * @param systemAnswer The generated correct answer
     */
    validate?(userAnswer: string, systemAnswer: string): boolean;
}

// FILE END: src\core\interfaces\Generator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        exponents: 6,
        fraction_basics: 5,
        fraction_arith: 5,
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 6,
        volume: 8,
        graph: 5,
        similarity: 4,
        percent: 6,
        probability: 8,
        statistics: 6,
        pythagoras: 6,
        change_factor: 5,
        angles: 6,
        patterns: 5
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        // Fallback to 5 if topic not found, but we aim to list all
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export const UI_STRINGS = {
    sv: {
        // --- General UI ---
        submit: "Svara",
        next: "N√§sta fr√•ga",
        correct: "R√§tt!",
        incorrect: "Inte riktigt, f√∂rs√∂k igen",
        try_again: "F√∂rs√∂k igen",
        score: "Po√§ng",
        streak: "Svit",
        level: "Niv√•",
        loading: "Laddar...",
        error: "Fel vid laddning",
        dashboard_title: "V√§lj omr√•de att √∂va p√•",
        backBtn: "Meny",
        history: "Historik",
        noHistory: "Inga svar √§n.",
        btnHint: "Ledtr√•d",
        btnSolution: "Visa l√∂sning",
        btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        placeholder: "Skriv ditt svar...",
        hintsTitle: "Ledtr√•dar",
        clueUsed: "Hj√§lp",
        donow: "Startuppgift",
        donow_title: "Uppstart (Do Now)",
        donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
        donow_gen: "Generera",
        donow_show_all: "Visa alla",
        donow_hide_all: "D√∂lj alla",
        donow_regenerate: "Nytt Set",
        aboutBtn: "Om skaparen",
        levelUpTitle: "Niv√• upp?", 
        levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", 
        levelUpYes: "Ja, k√∂r!", 
        levelUpNo: "Nej, stanna h√§r",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Aritmetik",
            negative: "Negativa Tal",
            simplification: "F√∂renkling",
            linear_eq: "Ekvationer",
            linear_eq_prob: "Probleml√∂sning",
            geometry: "Geometri",
            volume: "Volym & Area",
            similarity: "Likformighet",
            scale: "Skala",
            linear_graph: "R√§ta Linjen",
            ten_powers: "Tiopotenser",
            percent: "Procent",           // NEW
            exponents: "Potenser",        // NEW
            probability: "Sannolikhet",   // NEW
            statistics: "Statistik",      // NEW
            pythagoras: "Pythagoras Sats" // NEW
        },

        // --- Math Vocabulary (Common) ---
        common: {
            calculate: "Ber√§kna",
            equation: "Ekvation",
            simplify: "F√∂renkla",
            solve: "L√∂s ut x",
            evaluate: "Ber√§kna",
            find_k: "Best√§m k-v√§rdet",
            find_m: "Best√§m m-v√§rdet",
            find_equation: "Best√§m linjens ekvation",
            match_graph: "Vilken ekvation h√∂r till grafen?",
            determine_equation: "Best√§m ekvationen f√∂r linjen som g√•r genom:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Ber√§kna summan",
            sub: "Ber√§kna differensen",
            mul: "Ber√§kna produkten",
            div: "Ber√§kna kvoten",
            mixed: "Ber√§kna",
            missing_term: "Hitta det saknade talet"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Vi har ekvationen: $${eq}$`,
            multiply: (k: any) => `Multiplicera b√•da sidor med $${k}$ f√∂r att bli av med divisionen.`,
            divide: (k: any) => `Dividera b√•da sidor med $${k}$ f√∂r att f√• $x$ ensamt.`,
            add: (k: any) => `Addera $${k}$ p√• b√•da sidor.`,
            subtract: (k: any) => `Subtrahera $${k}$ p√• b√•da sidor.`,
            distribute: (k: any) => `Multiplicera in $${k}$ i parentesen.`,
            sub_var: (term: string) => `Subtrahera $${term}$ fr√•n b√•da sidor f√∂r att samla $x$ p√• en sida.`,
            collect: "Samla lika termer",
            expand: "Utveckla parentesen",
            factorise: "Faktorisera uttrycket",
            substitute: "Ers√§tt och ber√§kna"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Att addera ett negativt tal √§r samma som subtraktion.",
            sub_neg: "Tv√• minus blir plus (‚Äì ‚Äì blir +).",
            mul_neg_neg: "Minus g√•nger minus blir plus.",
            mul_pos_neg: "Plus g√•nger minus blir minus.",
            div_sign_same: "Lika tecken ger positivt svar.",
            div_sign_diff: "Olika tecken ger negativt svar.",
            simple_calc: "Ber√§kna:", 
            step_calc: "Ber√§kna:",
            plus_plus: "Positivt + Positivt",
            plus_minus: "Positivt + Negativt",
            minus_plus: "Negativt + Positivt",
            minus_minus: "Negativt - Negativt",
            mixed: "Blandat",
            multiplication: "Multiplikation",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "Best√§m m-v√§rdet (d√§r linjen sk√§r y-axeln).", en: "Find the intercept (m)." },
            q_slope: { sv: "Best√§m k-v√§rdet (lutningen).", en: "Find the slope (k)." },
            q_func: { sv: "Best√§m linjens ekvation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Titta p√• grafen: Var sk√§r linjen y-axeln (d√§r $x=0$)?",
            step_intercept: (m:any) => `Linjen sk√§r y-axeln vid $y = ${m}$.`,
            step_delta: "Lutningen $k$ √§r skillnaden i $y$ delat med skillnaden i $x$.",
            step_slope_calc: "R√§kna rutor: Hur mycket √§ndras $y$ n√§r vi g√•r 1 steg √•t h√∂ger?",
            find_m: "Hitta m-v√§rdet (sk√§rning med y-axeln).",
            find_k: "Hitta k-v√§rdet (lutningen).",
            parallel: "Best√§m lutningen f√∂r en linje som √§r parallell med:",
            perpendicular: "Best√§m lutningen f√∂r en linje som √§r vinkelr√§t mot:",
            find_gradient: "Ber√§kna lutningen (k)",
            find_intercept: "Hitta y-axelsk√§rningen (m)"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Skala",
            real: "Verklig str√§cka",
            map_dist: "Avst√•nd p√• kartan",
            ratio: "Skala",
            problem_map_to_real: "Ber√§kna det verkliga avst√•ndet.",
            problem_real_to_map: "Ber√§kna avst√•ndet p√• kartan.",
            problem_find_scale: "Best√§m kartans skala.",
            reduction: "F√∂rminskning",
            enlargement: "F√∂rstoring",
            reality: "Verkligheten",
            drawing: "Bilden",
            rule_reduction: "N√§r skalan √§r 1:X √§r bilden mindre √§n verkligheten.",
            rule_enlargement: "N√§r skalan √§r X:1 √§r bilden st√∂rre √§n verkligheten.",
            step_plug_in: "S√§tt in v√§rdena i formeln: $\\frac{\\text{Bild}}{\\text{Verklighet}}$",
            calc_cm: "R√§kna f√∂rst ut det i cm.",
            conv_m: "Omvandla till meter (1 m = 100 cm).",
            conv_same: "Se till att b√•da m√•tten har samma enhet.",
            setup_ratio: "St√§ll upp f√∂rh√•llandet Bild : Verklighet.",
            step_simplify: "F√∂renkla br√•ket.",
            calc_area_img: "Ber√§kna bildens area.",
            calc_area_real: "Ber√§kna verklighetens area.",
            calc_area_scale: "Areaskalan √§r l√§ngdskalan i kvadrat."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "L√∂s ekvationen och ber√§kna $x$.",
            task_write: "Skriv en ekvation som beskriver situationen (du beh√∂ver inte l√∂sa den).",
            clue_var: "L√•t $x$ vara det vi s√∂ker.",
            clue_total: "S√§tt uttrycket lika med totalen.",
            expl_rate_val: "Pris per styck g√•nger antal.",
            expl_fixed_val: "L√§gg till den fasta avgiften.",
            expl_item_cost: "Kostnaden f√∂r varorna innan rabatt.",
            expl_discount_sub: "Subtrahera rabatten.",
            expl_person1: "Person 1 har $x$.",
            expl_person2_more: "Person 2 har mer.",
            expl_person2_less: "Person 2 har mindre.",
            expl_compare_sum: "Summan av b√•da √§r totalen.",
            a_buy: { sv: "Du k√∂per $a$ st {item} f√∂r $x$ kr/st och en p√•se f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $a$ {item} for $x$ kr each and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "En taxiresa kostar $b$ kr i startavgift och $a$ kr per km. Resan kostar totalt $c$ kr. Hur m√•nga km ($x$) √•kte du?", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "Du k√∂per $a$ st {item} som kostar $x$ kr/st. Du har en rabattkupong p√• $b$ kr. Du betalar totalt $c$ kr.", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "{name1} och {name2} samlar p√• {item}. {name2} har $a$ fler √§n {name1}. Tillsammans har de $c$ st. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "{name1} och {name2} har $c$ {item} tillsammans. {name2} har $b$ f√§rre √§n {name1}. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Ber√§kna arean",
            perimeter: "Ber√§kna omkretsen",
            circumference: "Ber√§kna omkretsen",
            volume: "Ber√§kna volymen",
            surface_area: "Ber√§kna begr√§nsningsarean",
            similarity: "Likformighet",
            scale_factor: "Hitta skalfaktorn (k)",
            missing_side: "Ber√§kna den saknade sidan",
            shape: "Figur",
            cube: "Kub",
            cuboid: "R√§tblock",
            cylinder: "Cylinder",
            sphere: "Klot",
            cone: "Kon",
            triangle: "Triangel",
            rectangle: "Rektangel",
            circle: "Cirkel",
            parallelogram: "Parallellogram",
            trapezium: "Trapets"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplikation med tiopotenser",
            div: "Division med tiopotenser",
            standard_form: "Grundpotensform",
            prefix: "Prefix"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Ber√§kna delen",
            find_whole: "Hitta det hela",
            change: "F√∂r√§ndring",
            visual: "Andel (Bild)"
        },
        statistics: {
            mean: "Medelv√§rde",
            median: "Median",
            mode: "Typv√§rde",
            range: "Variationsbredd",
            table: "Frekvenstabell"
        },
        probability: {
            chance: "Sannolikhet",
            complement: "Komplementh√§ndelse",
            compound: "Sammansatt h√§ndelse",
            marbles: "Kulor",
            spinner: "Snurrhjul"
        },
        pythagoras: {
            theorem: "Pythagoras sats",
            hypotenuse: "Hypotenusa",
            leg: "Katet",
            distance: "Avst√•nd"
        },
        exponents: {
            power: "Potens",
            base: "Bas",
            exponent: "Exponent",
            root: "Kvadratrot",
            sci_not: "Grundpotensform",
            zero_rule: "Nollregeln"
        },

        // --- Shapes ---
        shapes: {
            square: "kvadrat",
            rectangle: "rektangel",
            circle: "cirkel",
            triangle: "triangel",
            rhombus: "romb",
            parallelogram: "parallellogram",
            pentagon: "femh√∂rning",
            hexagon: "sexh√∂rning",
            octagon: "√•ttah√∂rning",
            star: "stj√§rna",
            arrow: "pil",
            heart: "hj√§rta",
            cross: "kors",
            lightning: "blixt",
            kite: "drake",
            cube: "kub",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "kon",
            sphere: "klot"
        },
        shapes_plural: {
            rectangle: "rektanglar",
            triangle: "trianglar",
            circle: "cirklar",
            semicircle: "halvcirklar",
            parallelogram: "parallellogram"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    },

    en: {
        // --- General UI ---
        submit: "Submit Answer",
        next: "Next Question",
        correct: "Correct!",
        incorrect: "Incorrect.",
        try_again: "Try Again",
        score: "Score",
        streak: "Streak",
        level: "Level",
        loading: "Loading...",
        error: "Error loading question",
        dashboard_title: "Choose a topic to practice",
        backBtn: "Menu",
        history: "History",
        noHistory: "No answers yet.",
        btnHint: "Hint",
        btnSolution: "Show Solution",
        btnSkip: "Skip",
        btnNext: "Next ‚û°",
        placeholder: "Enter your answer...",
        hintsTitle: "Hints",
        clueUsed: "Clue",
        donow: "Do Now",
        donow_title: "Do Now Activity",
        donow_desc: "Select up to 3 levels. System generates 6 questions total.",
        donow_gen: "Generate",
        donow_show_all: "Show All",
        donow_hide_all: "Hide All",
        donow_regenerate: "New Set",
        aboutBtn: "About",
        levelUpTitle: "Level Up?", 
        levelUpDesc: "You seem to know this! Do you want to skip to the next level?", 
        levelUpYes: "Yes, let's go!", 
        levelUpNo: "No, stay here",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Arithmetic",
            negative: "Negative Numbers",
            simplification: "Simplification",
            linear_eq: "Linear Equations",
            linear_eq_prob: "Equation Problems",
            geometry: "Geometry",
            volume: "Volume & Surface Area",
            similarity: "Similarity",
            scale: "Scale & Maps",
            linear_graph: "Linear Graphs",
            ten_powers: "Powers of 10",
            percent: "Percentage",
            exponents: "Exponents & Roots",
            probability: "Probability",
            statistics: "Statistics",
            pythagoras: "Pythagoras"
        },

        // --- Math Vocabulary ---
        common: {
            calculate: "Calculate",
            equation: "Equation",
            simplify: "Simplify",
            solve: "Solve for x",
            evaluate: "Evaluate",
            find_k: "Find the gradient (k)",
            find_m: "Find the y-intercept (m)",
            find_equation: "Find the equation of the line",
            match_graph: "Which equation matches the graph?",
            determine_equation: "Determine the equation of the line passing through:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Calculate the sum",
            sub: "Calculate the difference",
            mul: "Calculate the product",
            div: "Calculate the quotient",
            mixed: "Evaluate the expression",
            missing_term: "Find the missing number"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Equation: $${eq}$`,
            multiply: (k: any) => `Multiply both sides by $${k}$ to remove the division.`,
            divide: (k: any) => `Divide both sides by $${k}$ to isolate $x$.`,
            add: (k: any) => `Add $${k}$ to both sides.`,
            subtract: (k: any) => `Subtract $${k}$ from both sides.`,
            distribute: (k: any) => `Distribute $${k}$ into the parentheses.`,
            sub_var: (term: string) => `Subtract $${term}$ from both sides to collect $x$ on one side.`,
            collect: "Collect like terms",
            expand: "Expand the brackets",
            factorise: "Factorise the expression",
            substitute: "Substitute and evaluate"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Adding a negative number is the same as subtraction.",
            sub_neg: "Subtracting a negative number is the same as addition (‚Äì ‚Äì becomes +).",
            mul_neg_neg: "Negative times negative becomes positive.",
            mul_pos_neg: "Positive times negative becomes negative.",
            div_sign_same: "Same signs give a positive result.",
            div_sign_diff: "Different signs give a negative result.",
            simple_calc: "Calculate:",
            step_calc: "Calculate:",
            plus_plus: "Positive + Positive",
            plus_minus: "Positive + Negative",
            minus_plus: "Negative + Positive",
            minus_minus: "Negative - Negative",
            mixed: "Mixed",
            multiplication: "Multiplication",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "", en: "Find the intercept (m)." },
            q_slope: { sv: "", en: "Find the slope (k)." },
            q_func: { sv: "", en: "Find the line equation ($y = kx + m$)."},
            look_x0: "Look at the graph: Where does the line cross the y-axis (where $x=0$)?",
            step_intercept: (m:any) => `The line crosses the y-axis at $y = ${m}$.`,
            step_delta: "The slope $k$ is the change in $y$ divided by the change in $x$.",
            step_slope_calc: "Count squares: How much does $y$ change when we go 1 step to the right?",
            find_m: "Find the m-value (y-intercept).",
            find_k: "Find the k-value (slope).",
            parallel: "Find the slope of a line parallel to:",
            perpendicular: "Find the slope of a line perpendicular to:",
            find_gradient: "Calculate the gradient",
            find_intercept: "Find the intercept"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Map Scale",
            real: "Real Distance",
            map_dist: "Map Distance",
            ratio: "Ratio",
            problem_map_to_real: "Calculate the real world distance.",
            problem_real_to_map: "Calculate the distance on the map.",
            problem_find_scale: "Determine the scale of the map.",
            reduction: "Reduction",
            enlargement: "Enlargement",
            reality: "Reality",
            drawing: "Drawing",
            rule_reduction: "When the scale is 1:X, the image is smaller than reality.",
            rule_enlargement: "When the scale is X:1, the image is larger than reality.",
            step_plug_in: "Insert the values into the formula: $\\frac{\\text{Image}}{\\text{Reality}}$",
            calc_cm: "Calculate it in cm first.",
            conv_m: "Convert to meters (1 m = 100 cm).",
            conv_same: "Ensure both measurements have the same unit.",
            setup_ratio: "Set up the ratio Image : Reality.",
            step_simplify: "Simplify the fraction.",
            calc_area_img: "Calculate the area of the image.",
            calc_area_real: "Calculate the area of reality.",
            calc_area_scale: "The area scale is the length scale squared."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "Solve the equation and calculate $x$.",
            task_write: "Write an equation that describes the situation (you don't need to solve it).",
            clue_var: "Let $x$ be what we are looking for.",
            clue_total: "Set the expression equal to the total.",
            expl_rate_val: "Price per item times quantity.",
            expl_fixed_val: "Add the fixed fee.",
            expl_item_cost: "The cost of items before discount.",
            expl_discount_sub: "Subtract the discount.",
            expl_person1: "Person 1 has $x$.",
            expl_person2_more: "Person 2 has more.",
            expl_person2_less: "Person 2 has less.",
            expl_compare_sum: "The sum of both is the total.",
            a_buy: { sv: "", en: "You buy $a$ {item} for $x$ kr/st and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Calculate the Area",
            perimeter: "Calculate the Perimeter",
            circumference: "Calculate the Circumference",
            volume: "Calculate the Volume",
            surface_area: "Calculate the Surface Area",
            similarity: "Similarity",
            scale_factor: "Find the Scale Factor",
            missing_side: "Find the missing side length",
            shape: "Shape",
            cube: "Cube",
            cuboid: "Rectangular Prism",
            cylinder: "Cylinder",
            sphere: "Sphere",
            cone: "Cone",
            triangle: "Triangle",
            rectangle: "Rectangle",
            circle: "Circle",
            parallelogram: "Parallelogram",
            trapezium: "Trapezium"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplication by powers of 10",
            div: "Division by powers of 10",
            standard_form: "Standard Form (Scientific Notation)",
            prefix: "Unit Prefixes"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Calculate Part",
            find_whole: "Find Whole",
            change: "Change",
            visual: "Proportion (Visual)"
        },
        statistics: {
            mean: "Mean",
            median: "Median",
            mode: "Mode",
            range: "Range",
            table: "Frequency Table"
        },
        probability: {
            chance: "Probability",
            complement: "Complementary Event",
            compound: "Compound Event",
            marbles: "Marbles",
            spinner: "Spinner"
        },
        pythagoras: {
            theorem: "Pythagorean Theorem",
            hypotenuse: "Hypotenuse",
            leg: "Leg",
            distance: "Distance"
        },
        exponents: {
            power: "Power",
            base: "Base",
            exponent: "Exponent",
            root: "Square Root",
            sci_not: "Scientific Notation",
            zero_rule: "Zero Rule"
        },

        // --- Shapes ---
        shapes: {
            square: "square",
            rectangle: "rectangle",
            circle: "circle",
            triangle: "triangle",
            rhombus: "rhombus",
            parallelogram: "parallelogram",
            pentagon: "pentagon",
            hexagon: "hexagon",
            octagon: "octagon",
            star: "star",
            arrow: "arrow",
            heart: "heart",
            cross: "cross",
            lightning: "lightning",
            kite: "kite",
            cube: "cube",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "cone",
            sphere: "sphere"
        },
        shapes_plural: {
            rectangle: "rectangles",
            triangle: "triangles",
            circle: "circles",
            semicircle: "semicircles",
            parallelogram: "parallelograms"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    }
};

export const TERMS = UI_STRINGS;

// Helper to handle both string and object keys safely
export function t(lang: Language, keyOrObj: string | { sv: string, en: string }): string {
    const l = (lang === 'en') ? 'en' : 'sv';
    
    // Check if input is a localized object {sv:..., en:...}
    if (typeof keyOrObj === 'object' && keyOrObj !== null) {
        // @ts-ignore
        return keyOrObj[l] || keyOrObj['sv'] || "";
    }
    
    // Check if input is a dot-notation string "geometry.area"
    if (typeof keyOrObj === 'string') {
        if (keyOrObj.includes('.')) {
            const keys = keyOrObj.split('.');
            let value: any = UI_STRINGS[l];
            for (const k of keys) {
                if (value && value[k]) {
                    value = value[k];
                } else {
                    return keyOrObj; // Return key if missing
                }
            }
            return typeof value === 'string' ? value : keyOrObj;
        }
        
        // Direct key lookup in UI root
        // @ts-ignore
        return UI_STRINGS[l][keyOrObj] || keyOrObj;
    }
    
    return String(keyOrObj);
}

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\MathUtils.ts
// =======================================================

export class MathUtils {
    static randomInt(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static randomFloat(min: number, max: number, decimals: number = 1): number {
        const val = Math.random() * (max - min) + min;
        return Number(val.toFixed(decimals));
    }

    static randomChoice<T>(arr: T[]): T {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    static gcd(a: number, b: number): number {
        return b === 0 ? a : MathUtils.gcd(b, a % b);
    }

    // FIX: This method is required by PythagorasGen and others
    static shuffle<T>(array: T[]): T[] {
        const arr = [...array]; // Create a copy to avoid mutating original
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }
}

// FILE END: src\core\utils\MathUtils.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: src\index.css
// =======================================================

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
  -webkit-font-smoothing: antialiased;
  @apply bg-gray-50 text-gray-800;
}

/* Legacy Animations */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Custom Scrollbar from Legacy Code */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Print Styles for Do Now Grid */
.print-break-inside-avoid {
  break-inside: avoid;
}

/* Katex Adjustments */
.katex {
  font-size: 1.1em;
}

// FILE END: src\index.css

// =======================================================
// FILE START: src\lib\supabaseClient.js
// =======================================================

import { createClient } from '@supabase/supabase-js';

// Vite uses import.meta.env to access .env variables
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Create a single instance of the Supabase client to use across your app
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// FILE END: src\lib\supabaseClient.js

// =======================================================
// FILE START: src\main.jsx
// =======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// FILE END: src\main.jsx

// =======================================================
// FILE START: tailwind.config.js
// =======================================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Legacy Color Palette
        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
      },
      fontFamily: { 
        sans: ['Inter', 'sans-serif'] 
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      }
    },
  },
  plugins: [],
}

// FILE END: tailwind.config.js

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    
    "strict": false,               
    "noImplicitAny": false,        
    "strictNullChecks": false,     
    "suppressImplicitAnyIndexErrors": true, 
    
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["src", "api"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/$1" },
    { "source": "/(.*)", "destination": "/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json

// =======================================================
// FILE START: vite.config.js
// =======================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@core': path.resolve(__dirname, './src/core'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  }
})

// FILE END: vite.config.js
