PROJECT EXPORT GENERATED AT 2026-02-17T07:43:27.108Z

--- FILE STRUCTURE ---
api\answer.ts
api\batch.ts
api\curriculum.ts
api\debug.ts
api\question.ts
backup_UI.html
bundle_project.ts
dev-server.ts
index.html
package-lock.json
package.json
postcss.config.js
src\App.jsx
src\components\modals\AboutModal.jsx
src\components\modals\ContentModal.jsx
src\components\modals\LevelUpModal.jsx
src\components\modals\LgrModal.jsx
src\components\modals\StatsModal.jsx
src\components\modals\StreakModal.jsx
src\components\practice\CluePanel.jsx
src\components\practice\HistoryList.jsx
src\components\practice\MobileDrawer.jsx
src\components\ui\Button.jsx
src\components\ui\InputComponents.jsx
src\components\ui\MathText.jsx
src\components\views\AuthView.jsx
src\components\views\Dashboard.jsx
src\components\views\DoNowConfig.jsx
src\components\views\DoNowGrid.jsx
src\components\views\PracticeView.jsx
src\components\views\QuestionStudio.jsx
src\components\visuals\AngleComponents.jsx
src\components\visuals\ComplexGeometry.jsx
src\components\visuals\GeometryComponents.jsx
src\components\visuals\GeometryShapes.jsx
src\components\visuals\GraphCanvas.jsx
src\components\visuals\PatternComponents.jsx
src\components\visuals\ProbabilityTree.jsx
src\components\visuals\ProbabilityVisuals.jsx
src\components\visuals\ScaleVisuals.jsx
src\components\visuals\SimpleTextLevel.jsx
src\components\visuals\StatisticsVisuals.jsx
src\components\visuals\VolumeVisualization.jsx
src\constants\content_map.js
src\constants\curriculum.js
src\constants\localization.js
src\constants\skillBuckets.js
src\core\generators\AnglesGen.ts
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ChangeFactorGen.ts
src\core\generators\ExponentsGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\FractionArithGen.ts
src\core\generators\FractionBasicsGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\OrderOperationsGen.ts
src\core\generators\PatternsGen.ts
src\core\generators\PercentGen.ts
src\core\generators\ProbabilityGen.ts
src\core\generators\PythagorasGen.ts
src\core\generators\ScaleGen.ts
src\core\generators\SimilarityGen.ts
src\core\generators\StatisticsGen.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGen.ts
src\core\interfaces\Generator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\MathUtils.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
src\index.css
src\lib\supabaseClient.js
src\main.jsx
tailwind.config.js
tsconfig.json
vercel.json
vite.config.js

==================================================


// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: "Method not allowed. Use POST." });
    }

    try {
        const { answer, token, streak = 0 } = req.body;

        if (!token) {
            return res.status(400).json({ error: "Missing token" });
        }

        // 1. Decode the correct answer from the Base64 token
        const correctAnswer = Buffer.from(token, 'base64').toString('utf-8');

        // 2. Normalize inputs for comparison
        // We remove spaces and convert to lowercase to be forgiving
        // e.g. "x + 5" should match "x+5"
        const normalize = (str: any) => String(str).toLowerCase().replace(/\s+/g, '').replace(',', '.');
        
        const userClean = normalize(answer);
        const correctClean = normalize(correctAnswer);

        const isCorrect = userClean === correctClean;

        let newStreak = streak;
        let levelUp = false;

        // 3. Update Streak Logic
        if (isCorrect) {
            newStreak++;
            // Propose level up every 8 correct answers
            if (newStreak > 0 && newStreak % 8 === 0) {
                levelUp = true;
            }
        } else {
            newStreak = 0;
        }

        return res.status(200).json({
            correct: isCorrect,
            correctAnswer, // Send back correct answer so UI can display it if wrong
            newStreak,
            levelUp
        });

    } catch (error) {
        console.error("Answer Validation Error:", error);
        return res.status(500).json({ error: "Validation failed." });
    }
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

// IMPORTS
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { PatternsGen } from '../src/core/generators/PatternsGen.js';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen.js';
import { FractionArithGen } from '../src/core/generators/FractionArithGen.js';
import { PercentGen } from '../src/core/generators/PercentGen.js';
import { ChangeFactorGen } from '../src/core/generators/ChangeFactorGen.js';
import { ExponentsGen } from '../src/core/generators/ExponentsGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { AnglesGen } from '../src/core/generators/AnglesGen.js';
import { PythagorasGen } from '../src/core/generators/PythagorasGen.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { StatisticsGen } from '../src/core/generators/StatisticsGen.js';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen.js';
import { OrderOperationsGen } from '../src/core/generators/OrderOperationsGen.js';

// COMPLETE TOPIC MAP (Aligned with skillBuckets.js)
const TopicMap: Record<string, any> = {
  // Algebra & Patterns
  'equations': LinearEquationGen,
  'equations_word': LinearEquationGen, // Delegated internally
  'expressions': ExpressionSimplificationGen,
  'patterns': PatternsGen,
  'graphs': LinearGraphGenerator,

  // Arithmetic
  'basic_arithmetic': BasicArithmeticGen,
  'negatives': NegativeNumbersGen,
  'fractions_basics': FractionBasicsGen,
  'fraction_arith': FractionArithGen,
  'percent': PercentGen,
  'change_factor': ChangeFactorGen,
  'exponents': ExponentsGen,
  'ten_powers': TenPowersGen,
  // NYTT: Mappning f√∂r prioriteringsregler
  'order_of_operations': OrderOperationsGen,

  // Geometry
  'geometry': GeometryGenerator,
  'angles': AnglesGen,
  'pythagoras': PythagorasGen,
  'scale': ScaleGen,
  'similarity': SimilarityGen,
  'volume': VolumeGen,

  // Data
  'statistics': StatisticsGen,
  'probability': ProbabilityGen
};

export default async function handler(req: VercelRequest, res: VercelResponse) {
  // 1. CORS & Preflight
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
  res.setHeader(
    'Access-Control-Allow-Headers',
    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
  );

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  try {
    let body = req.body;
    if (typeof body === 'string') {
      try {
        body = JSON.parse(body);
      } catch (e) {
        return res.status(400).json({ error: 'Invalid JSON body' });
      }
    }

    const { requests } = body; // Matches App.jsx contract

    if (!requests || !Array.isArray(requests)) {
      return res.status(400).json({ error: 'Missing or invalid "requests" array in payload' });
    }

    console.log("Processing Batch:", JSON.stringify(requests));

    const questions: any[] = [];
    let globalIndex = 1;

    // 3. Generation Loop
    for (const item of requests) {
      const { topic, variation, level, lang } = item;
      
      const GeneratorClass = TopicMap[topic];

      if (!GeneratorClass) {
        console.warn(`Generator not found for topic: ${topic}`);
        questions.push({
          id: `err-${globalIndex}`,
          text: `Error: Generator for topic '${topic}' not found.`,
          answer: "N/A",
          type: "error"
        });
        globalIndex++;
        continue;
      }

      const generator = new GeneratorClass();

      try {
        let questionData;
        
        // PHASE 2 LOGIC: Priority on Variation
        if (variation && typeof generator.generateByVariation === 'function') {
          questionData = generator.generateByVariation(variation, lang);
        } else {
          questionData = generator.generate(level || 1, lang);
        }

        questions.push({
          ...questionData,
          id: `q-${globalIndex}-${Date.now()}`,
          number: globalIndex,
          topic_id: topic,
          variation_key: variation || 'generic',
          is_generated: true
        });

        globalIndex++;

      } catch (genError) {
        console.error(`Generation error for ${topic}/${variation}:`, genError);
        questions.push({
          id: `err-${globalIndex}`,
          text: `Error generating question for ${topic}.`,
          answer: "Error",
          meta: { error: true }
        });
        globalIndex++;
      }
    }

    // 4. Success Response - Direct Array (Matches App.jsx)
    return res.status(200).json(questions);

  } catch (error: any) {
    console.error("Critical Batch API Error:", error);
    return res.status(500).json({ 
      error: 'Internal Server Error', 
      details: error.message 
    });
  }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang.",
      "F√∂rm√•ga att anv√§nda matematikens uttrycksformer f√∂r att samtala om, argumentera och redog√∂ra f√∂r fr√•gest√§llningar, ber√§kningar och slutsatser."
    ],

    // Centralt Inneh√•ll (Core Content)
    // Mapped to specific modules in the app
    centralt_innehall: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        modules: ["arithmetic", "negative", "ten_powers", "exponents", "percent", "fraction_basics", "fraction_arith"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.", // arithmetic
          "Talsystemets utveckling fr√•n naturliga tal till reella tal.", // negative
          "Tal i br√•k- och decimalform samt deras anv√§ndning i vardagliga och matematiska situationer.", // fraction_basics
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform.", // fraction_arith
          "Procent f√∂r att uttrycka f√∂r√§ndring och f√∂r√§ndringsfaktor samt ber√§kningar med procent i vardagliga situationer och i situationer inom olika √§mnesomr√•den.", // percent, change_factor
          "Potensform f√∂r att uttrycka sm√• och stora tal samt anv√§ndning av prefix." // ten_powers, exponents
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["simplify", "equation", "linear_graph"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.", // simplify
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Algebraiska m√∂nster och hur de kan beskrivas med uttryck.",
          "Metoder f√∂r ekvationsl√∂sning.", // equation
          "Funktioner och r√§ta linjens ekvation." // linear_graph
        ]
      },
      geometri: {
        category: "Geometri",
        modules: ["geometry", "scale", "volume", "similarity", "pythagoras","angles"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt. Skala vid f√∂rminskning och f√∂rstoring av en- och tv√•dimensionella objekt.", // scale
          "Likformighet och symmetri i planet.", // similarity
          "Geometriska satser och formler och behovet av argumentation f√∂r deras giltighet. Pythagoras sats.", // pythagoras
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta.", // geometry, volume
          "Vinkelbegreppet och vinkelm√§tning. Vinkelsumman i m√•ngh√∂rningar." // Vinklar
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"], // change_factor fits here too conceptually, but mapped to statistics in app structure
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      statistik: {
        category: "Sannolikhet och statistik",
        modules: ["probability", "statistics", "change_factor"], // Added change_factor here as requested
        content: [
          "Likformig sannolikhet och metoder f√∂r att ber√§kna sannolikhet i vardagliga situationer.", // probability
          "Tabeller och diagram f√∂r att beskriva resultat fr√•n unders√∂kningar.", // statistics
          "L√§gesm√•tt: medelv√§rde, median och typv√§rde.", // statistics
          "Spridningsm√•tt: variationsbredd.", // statistics
          "F√∂r√§ndringsfaktor och procentuella f√∂r√§ndringar." // change_factor
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"],
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\debug.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import fs from 'fs';
import path from 'path';

export default function handler(req: VercelRequest, res: VercelResponse) {
    try {
        // Look for the generators folder relative to this executing function
        const generatorsPath = path.join(process.cwd(), 'src/core/generators');
        
        let files: string[] = [];
        if (fs.existsSync(generatorsPath)) {
            files = fs.readdirSync(generatorsPath);
        } else {
            files = ["Generators folder not found at: " + generatorsPath];
        }

        res.status(200).json({
            status: "Debug Online",
            cwd: process.cwd(),
            foundFiles: files
        });
    } catch (error) {
        res.status(500).json({ error: String(error) });
    }
}

// FILE END: api\debug.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// IMPORTS
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExponentsGen } from '../src/core/generators/ExponentsGen.js';
import { PercentGen } from '../src/core/generators/PercentGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen.js'; // Added to match batch.ts
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { PythagorasGen } from '../src/core/generators/PythagorasGen.js';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen.js';
import { StatisticsGen } from '../src/core/generators/StatisticsGen.js';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen.js';
import { FractionArithGen } from '../src/core/generators/FractionArithGen.js';
import { ChangeFactorGen } from '../src/core/generators/ChangeFactorGen.js';
import { AnglesGen } from '../src/core/generators/AnglesGen.js';
import { PatternsGen } from '../src/core/generators/PatternsGen.js';
import { OrderOperationsGen } from '../src/core/generators/OrderOperationsGen.js';

interface VercelRequest extends IncomingMessage {
    query: Record<string, string | string[]>;
    body: any;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
};

// --- ADAPTER: LEGACY FRACTIONS GENERATOR ---
class LegacyFractionsGen {
    public generate(level: number, lang: string = 'sv'): any {
        if (level <= 5) return new FractionBasicsGen().generate(level, lang);
        return new FractionArithGen().generate(level - 5, lang);
    }
    public generateByVariation(key: string, lang: string): any {
         try { return new FractionBasicsGen().generateByVariation(key, lang); } 
         catch { return new FractionArithGen().generateByVariation(key, lang); }
    }
}

// --- UNIFIED TOPIC MAP ---
// Maps ALL keys (Dashboard, Studio, and Legacy) to the correct Generator Class
const TopicMap: Record<string, any> = {
  // 1. ARITHMETIC
  'basic_arithmetic': BasicArithmeticGen,
  'arithmetic': BasicArithmeticGen,
  
  'negatives': NegativeNumbersGen,
  'negative': NegativeNumbersGen,
  
  'fractions_basics': FractionBasicsGen,
  'fraction_arith': FractionArithGen,
  'fractions': LegacyFractionsGen,
  
  'percent': PercentGen,
  'percentages': PercentGen,
  'ten_powers': TenPowersGen,
  'exponents': ExponentsGen,
  'order_of_operations': OrderOperationsGen,

  // 2. ALGEBRA
  'expressions': ExpressionSimplificationGen,
  'simplify': ExpressionSimplificationGen,
  'expression_simplification': ExpressionSimplificationGen,
  
  'equation': LinearEquationGen,        // Dashboard singular (FIXED)
  'equations': LinearEquationGen,       // Studio/General plural
  'linear-equations': LinearEquationGen,
  'algebra': LinearEquationGen,
  
  'equations_word': LinearEquationProblemGen, // Specific for word problems
  
  'patterns': PatternsGen,
  'pattern': PatternsGen,
  
  'graphs': LinearGraphGenerator,
  'graph': LinearGraphGenerator,
  'linear_graph': LinearGraphGenerator,
  
  'change_factor': ChangeFactorGen,

  // 3. GEOMETRY
  'geometry': GeometryGenerator,
  'geometry_cat': GeometryGenerator,
  'geom': GeometryGenerator,
  
  'angles': AnglesGen,
  'angle': AnglesGen,
  
  'volume': VolumeGen,
  'similarity': SimilarityGen,
  'pythagoras': PythagorasGen,
  'scale': ScaleGen,

  // 4. DATA
  'statistics': StatisticsGen,
  'stats': StatisticsGen,
  'data': StatisticsGen,
  'probability': ProbabilityGen
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    // Standard CORS headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    const body = req.body || {};
    const query = (req as any).query || {}; 

    // 1. Extract Parameters
    const rawTopic = query.topic || body.topic || query.category || body.category;
    const level = query.level || body.level;
    const variation = query.variation || body.variation; 
    const lang = query.lang || body.lang || 'sv';

    if (!rawTopic) {
        return res.status(400).json({ error: "Missing 'topic' parameter" });
    }

    // 2. Resolve Generator
    const GeneratorClass = TopicMap[String(rawTopic)];

    if (!GeneratorClass) {
        console.warn(`[API] Generator not found for topic: ${rawTopic}`);
        return res.status(400).json({ 
            error: `Generator not found for topic: ${rawTopic}.`,
            details: "Check api/question.ts TopicMap."
        });
    }

    try {
        const generator = new GeneratorClass();
        let question;

        // 3. GENERATION LOGIC
        if (variation && typeof generator.generateByVariation === 'function') {
            question = generator.generateByVariation(String(variation), String(lang));
        } else {
            const safeLevel = Number(level) || 1;
            if (typeof generator.generate === 'function') {
                question = generator.generate(safeLevel, String(lang));
            } else {
                question = generator.generate(1, String(lang));
            }
        }

        res.status(200).json(question);

    } catch (error: any) {
        console.error(`API Generation Error [${rawTopic}]:`, error);
        res.status(500).json({ error: 'Internal Server Error', details: error.message });
    }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: dev-server.ts
// =======================================================

import express, { Request, Response } from 'express';
import cors from 'cors';
import { register } from 'tsconfig-paths';
import path from 'path';

// 1. Register Path Aliases (@core/*) from tsconfig
// This ensures the backend logic can find files in src/core
import tsConfig from './tsconfig.json' assert { type: "json" };

const baseUrl = path.resolve(process.cwd(), tsConfig.compilerOptions.baseUrl || '.');
const cleanup = register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths,
});

// 2. Import API Handlers
// We import these AFTER registering paths so they resolve correctly
import questionHandler from './api/question';
import answerHandler from './api/answer';
import curriculumHandler from './api/curriculum';
import batchHandler from './api/batch'; // <--- ADDED: Import the batch handler

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// 3. Vercel -> Express Adapter
// Vercel functions are (req, res) => void, which matches Express,
// but we wrap them to ensure errors are caught.
const adapter = (handler: any) => async (req: Request, res: Response) => {
    try {
        await handler(req, res);
    } catch (err) {
        console.error("API Error:", err);
        res.status(500).json({ error: 'Internal Server Error', details: String(err) });
    }
};

// 4. Define Routes
// These must match the filenames in your /api folder
app.get('/api/question', adapter(questionHandler));
app.post('/api/answer', adapter(answerHandler));
app.get('/api/curriculum', adapter(curriculumHandler));
app.post('/api/batch', adapter(batchHandler)); // <--- ADDED: Register the route

// 5. Start Server
app.listen(PORT, () => {
    console.log(`\nüöÄ Backend Simulation running at http://localhost:${PORT}`);
    console.log(`   - /api/question`);
    console.log(`   - /api/answer`);
    console.log(`   - /api/curriculum`);
    console.log(`   - /api/batch`); // <--- ADDED: Log the new route
    console.log(`\nüé® Frontend running at http://localhost:5173 (Proxy active)\n`);
});

// FILE END: dev-server.ts

// =======================================================
// FILE START: index.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <!-- 1. Fix Quirks Mode by adding DOCTYPE -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- 2. Relaxed CSP for Supabase, Google Auth, and KaTeX CDNs -->
    <!-- Note: In production, 'unsafe-inline' is often required for React/Tailwind styles -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://apis.google.com;
        style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://fonts.googleapis.com;
        img-src 'self' data: https://*.supabase.co https://lh3.googleusercontent.com;
        connect-src 'self' https://*.supabase.co https://*.google.com;
        font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net;
        frame-src 'self' https://*.supabase.co https://accounts.google.com;
    ">

    <title>Anpassa - Math Platform</title>
</head>
<body class="bg-slate-50">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
</body>
</html>

// FILE END: index.html

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"vite\"",
    "dev:frontend": "vite",
    "dev:server": "tsx watch dev-server.ts",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.95.3",
    "katex": "^0.16.9",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vercel/node": "^5.5.28",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.7.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.6"
  }
}


// FILE END: package.json

// =======================================================
// FILE START: postcss.config.js
// =======================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// FILE END: postcss.config.js

// =======================================================
// FILE START: src\App.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import { supabase } from './lib/supabaseClient';
import { BarChart3 } from 'lucide-react';

// Views
import Dashboard from './components/views/Dashboard';
import PracticeView from './components/views/PracticeView';
import DoNowConfig from './components/views/DoNowConfig'; 
import DoNowGrid from './components/views/DoNowGrid';
import AuthView from './components/views/AuthView';
import QuestionStudio from './components/views/QuestionStudio'; 

// Modals
import AboutModal from './components/modals/AboutModal';
import LgrModal from './components/modals/LgrModal';
import StatsModal from './components/modals/StatsModal';
import StreakModal from './components/modals/StreakModal'; 
import ContentModal from './components/modals/ContentModal'; 
import MobileDrawer from './components/practice/MobileDrawer';

// Data & Constants
import { UI_TEXT, LEVEL_DESCRIPTIONS } from './constants/localization';

const DEVELOPER_MODE = true; 

function App() {
    // --- 1. AUTH & PROFILE STATE ---
    const [session, setSession] = useState(null);
    const [profile, setProfile] = useState(null);
    const [loadingProfile, setLoadingProfile] = useState(true);

    // --- 2. UI NAVIGATION STATE ---
    const [view, setView] = useState('dashboard');
    const [lang, setLang] = useState('sv');
    const [topic, setTopic] = useState('');
    const [level, setLevel] = useState(0);

    // --- 3. GAMEPLAY STATE ---
    const [question, setQuestion] = useState(null);
    const [input, setInput] = useState('');
    const [feedback, setFeedback] = useState(null);
    const [loading, setLoading] = useState(false);
    const [streak, setStreak] = useState(0);
    const [totalCorrect, setTotalCorrect] = useState(0);
    const [revealedClues, setRevealedClues] = useState([]);
    const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);
    const [usedHelp, setUsedHelp] = useState(false);

    // --- 4. SESSION STATS & HISTORY ---
    const [sessionStats, setSessionStats] = useState({
        attempted: 0, 
        correctNoHelp: 0, 
        correctHelp: 0, 
        incorrect: 0, 
        skipped: 0, 
        maxStreak: 0
    });
    
    // Structure: { topicId: { levelNumber: { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 } } }
    const [granularStats, setGranularStats] = useState({});
    
    const [history, setHistory] = useState([]);
    const [levelUpAvailable, setLevelUpAvailable] = useState(false);
    
    // --- 5. MODALS & UI STATE ---
    const [aboutOpen, setAboutOpen] = useState(false);
    const [statsOpen, setStatsOpen] = useState(false);
    const [timeUpOpen, setTimeUpOpen] = useState(false);
    const [lgrOpen, setLgrOpen] = useState(false);
    const [contentOpen, setContentOpen] = useState(false); 
    const [showStreakModal, setShowStreakModal] = useState(false);
    const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);

    // --- 6. ASSIGNMENTS & STUDIO STATE ---
    const [assignments, setAssignments] = useState([]); 
    const [doNowQuestions, setDoNowQuestions] = useState([]);
    const [doNowConfig, setDoNowConfig] = useState([]); 
    const [savedPacket, setSavedPacket] = useState([]); 

    // --- 7. TIMER STATE ---
    const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

    const ui = UI_TEXT[lang];

    // --- 8. HELPER: UPDATE GRANULAR STATS ---
    const updateStats = (type) => {
        // 1. Update Global Session Stats
        setSessionStats(prev => ({
            ...prev,
            attempted: type !== 'skipped' ? prev.attempted + 1 : prev.attempted,
            [type]: prev[type] + 1
        }));

        // 2. Update Granular Topic/Level Stats for StatsModal
        if (topic && level) {
            setGranularStats(prev => {
                const topicData = prev[topic] || {};
                const levelData = topicData[level] || { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 };
                
                return {
                    ...prev,
                    [topic]: {
                        ...topicData,
                        [level]: {
                            ...levelData,
                            [type]: (levelData[type] || 0) + 1
                        }
                    }
                };
            });
        }
    };

    // --- 9. SMART NAVIGATION ---
    useEffect(() => {
        window.history.replaceState({ view: 'dashboard' }, '');
        const handlePopState = (event) => {
            const nextView = event.state?.view || 'dashboard';
            setView(nextView);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
    }, []);

    const navigate = (destination) => {
        if (destination !== view) {
            window.history.pushState({ view: destination }, '');
            setView(destination);
        }
    };

    // --- HELPER: GET OR CREATE PROFILE ---
    const getOrCreateProfile = async (user) => {
        try {
            const { data, error } = await supabase.from('profiles').select('*').eq('id', user.id).single();
            if (data && !error) return data;
            if (error && error.code === 'PGRST116') {
                const { data: newProfile } = await supabase.from('profiles').insert([{ id: user.id, full_name: 'User', role: 'student' }]).select().single();
                return newProfile;
            }
            return null;
        } catch (e) { return null; }
    };

    useEffect(() => {
        let mounted = true;
        
        supabase.auth.getSession().then(({ data: { session: initSession } }) => {
            if (mounted) {
                if (initSession) {
                    setSession(initSession);
                    getOrCreateProfile(initSession.user).then(p => {
                        if (mounted) { setProfile(p); setLoadingProfile(false); }
                    });
                } else {
                    setLoadingProfile(false);
                }
            }
        });

        const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, currentSession) => {
            if (!mounted) return;
            setSession(currentSession);
            if (currentSession) {
                const userProfile = await getOrCreateProfile(currentSession.user);
                if (mounted) { 
                    setProfile(userProfile); 
                    setLoadingProfile(false);
                    if (view === 'auth') setView('dashboard'); 
                }
            } else {
                setProfile(null);
                setLoadingProfile(false);
            }
        });

        return () => { mounted = false; subscription.unsubscribe(); };
    }, []);

    const handleLogout = async () => { 
        await supabase.auth.signOut(); 
        setSession(null);
        setProfile(null);
        navigate('dashboard');
    };

    // --- GAMEPLAY HANDLERS ---
    const fetchQuestion = async (t, l, lg, force) => {
        if (!force && (showStreakModal || levelUpAvailable || timeUpOpen)) return;
        setLoading(true); setFeedback(null); setInput(''); setRevealedClues([]); setUsedHelp(false); setIsSolutionRevealed(false); setLevelUpAvailable(false);
        try {
            const res = await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}${force ? `&force=true&t=${Date.now()}` : ''}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            setQuestion(data);
        } catch (e) { console.error(e); setQuestion(null); } finally { setLoading(false); }
    };

    const startPractice = () => {
        if (topic && level) { 
            setStreak(0); 
            navigate('practice');
            if (timerSettings.duration > 0) setTimerSettings(prev => ({ ...prev, isActive: true })); 
            fetchQuestion(topic, level, lang); 
        }
    };

    const quitPractice = () => { 
        setStreak(0); 
        navigate('dashboard');
        setQuestion(null); 
    };

    const handleHint = () => {
        if (question?.clues && revealedClues.length < question.clues.length) {
            setUsedHelp(true);
            const nextClue = question.clues[revealedClues.length];
            setRevealedClues(prev => [...prev, nextClue]);
        }
    };

    const handleSolution = () => {
        if (question?.clues) {
            setUsedHelp(true);
            setRevealedClues(question.clues);
            setIsSolutionRevealed(true);
            setStreak(0);
        }
    };

    const handleSkip = () => {
        updateStats('skipped');
        setStreak(0);
        fetchQuestion(topic, level, lang, true);
    };

    const handleChangeLevel = (delta) => {
        const newLevel = level + delta;
        if (newLevel >= 1 && LEVEL_DESCRIPTIONS[topic]?.[newLevel]) {
            setLevel(newLevel);
            fetchQuestion(topic, newLevel, lang, true);
        }
    };

    const handleSubmit = async (e, directInput) => {
        if (e) e.preventDefault();
        if (feedback === 'correct') return;
        let finalInput = directInput !== undefined ? directInput : input;
        if (!question || !finalInput) return;
        
        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        try {
            const res = await fetch('/api/answer', { 
                method: 'POST', headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ answer: finalInput, token: question.token, streak, level, topic, usedHelp: helpUsed, solutionUsed: isSolutionRevealed, attempts: (question.attempts || 0) }) 
            });
            const result = await res.json();
            
            if (result.correct) {
                if (!isSolutionRevealed) {
                    setHistory(prev => [{ topic, level, correct: true, text: question.renderData.latex || question.renderData.description, clueUsed: helpUsed, time: Date.now() }, ...prev]);
                    setStreak(result.newStreak);
                    setTotalCorrect(prev => prev + 1);
                    
                    // Track granular stats for success
                    updateStats(helpUsed ? 'correctHelp' : 'correctNoHelp');

                    if ([15, 20, 30, 40, 50].includes(result.newStreak)) setShowStreakModal(true);
                    else if (result.levelUp) setLevelUpAvailable(true);
                    else setTimeout(() => fetchQuestion(topic, level, lang), 1500);
                }
                setFeedback('correct');
            } else {
                const currentAttempts = (question.attempts || 0) + 1;
                setQuestion({...question, attempts: currentAttempts});
                
                // Track granular stats for failure
                updateStats('incorrect');

                if (currentAttempts >= 2) { 
                    if (!isSolutionRevealed) setHistory(prev => [{ topic, level, correct: false, text: question.renderData.latex || question.renderData.description, clueUsed: true, time: Date.now() }, ...prev]);
                    setUsedHelp(true); setRevealedClues(question.clues || []); setIsSolutionRevealed(true); setStreak(0);
                } else if (question.clues) {
                    setUsedHelp(true); setRevealedClues(prev => [...prev, question.clues[prev.length] || question.clues[0]]);
                }
                setFeedback('incorrect'); setStreak(0);
            }
        } catch (e) { console.error(e); }
    };

    const handleDoNowGenerate = async (selectedConfig, rawPacket) => {
        if (!selectedConfig || selectedConfig.length === 0) return;
        setDoNowConfig(selectedConfig);
        if (rawPacket) setSavedPacket(rawPacket); 
        setLoading(true);
        const requestsPayload = selectedConfig.map(s => ({ topic: s.topic, level: s.level, variation: s.variation, lang }));
        try {
            const res = await fetch('/api/batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ requests: requestsPayload }) });
            const data = await res.json();
            if (Array.isArray(data)) { setDoNowQuestions(data); navigate('donow_grid'); }
        } catch (e) { console.error("Do Now Error:", e); } 
        finally { setLoading(false); }
    };

    // --- TIMER HELPERS ---
    const toggleTimer = (minutes) => setTimerSettings({ duration: minutes * 60, remaining: minutes * 60, isActive: minutes > 0 });
    const resetTimer = () => setTimerSettings({ duration: 0, remaining: 0, isActive: false });
    const formatTime = (seconds) => `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;

    // --- RENDER LOGIC ---
    if (loadingProfile) return (
        <div className="h-screen flex items-center justify-center bg-white">
            <div className="animate-pulse text-indigo-600 font-black uppercase tracking-tighter text-2xl">Laddar...</div>
        </div>
    );

    if (view === 'donow_config') return <div className="min-h-screen bg-gray-50"><DoNowConfig ui={ui} lang={lang} onBack={() => navigate('dashboard')} onGenerate={handleDoNowGenerate} /></div>;
    if (view === 'donow_grid') return <DoNowGrid questions={doNowQuestions} ui={ui} lang={lang} onBack={() => navigate('question_studio')} onClose={() => navigate('dashboard')} onRefreshAll={() => handleDoNowGenerate(doNowConfig, null)} />;
    if (view === 'question_studio') {
        return (
            <div className="min-h-screen bg-gray-50 flex flex-col">
                <header className="bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-center sticky top-0 z-50">
                    <h1 className="text-xl font-black text-indigo-600 tracking-tighter cursor-pointer" onClick={() => navigate('dashboard')}>Anpassa Studio</h1>
                    <button onClick={() => navigate('dashboard')} className="text-sm font-bold text-slate-400 hover:text-slate-600 uppercase">St√§ng Studio</button>
                </header>
                <QuestionStudio onDoNowGenerate={handleDoNowGenerate} ui={ui} lang={lang} initialPacket={savedPacket} />
            </div>
        );
    }

    return (
        <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
            <AboutModal visible={aboutOpen} onClose={() => setAboutOpen(false)} ui={ui} />
            <LgrModal visible={lgrOpen} onClose={() => setLgrOpen(false)} ui={ui} />
            <ContentModal visible={contentOpen} onClose={() => setContentOpen(false)} /> 
            <StatsModal visible={statsOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setStatsOpen(false)} title={ui.stats_title} />
            <StatsModal visible={timeUpOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setTimeUpOpen(false)} title={ui.stats_times_up} />
            <StreakModal visible={showStreakModal} onClose={() => setShowStreakModal(false)} streak={streak} ui={ui} />
            <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} ui={ui} />

            <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                    <div className="flex items-center gap-4">
                        <h1 className="text-xl font-black text-indigo-600 tracking-tighter cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                        {view === 'dashboard' && timerSettings.remaining > 0 && (
                            <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                <span>‚è∏ {ui.timer_paused}</span>
                                <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                            </div>
                        )}
                    </div>
                    <div className="flex items-center gap-3">
                        <button onClick={() => setLang(prev => prev === 'sv' ? 'en' : 'sv')} className="text-2xl hover:scale-110 transition-transform mr-2" title="Switch Language">
                            {lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}
                        </button>
                        
                        {/* --- RESTORED STATS BUTTON --- */}
                        <button 
                            onClick={() => setStatsOpen(true)}
                            className="p-2 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-full transition-all"
                            title={ui.stats_title}
                        >
                            <BarChart3 size={20} />
                        </button>

                        <div className="bg-emerald-100 text-emerald-700 px-3 py-1 rounded-full text-xs font-bold shadow-sm border border-emerald-200">‚úÖ {totalCorrect}</div>
                        <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold shadow-sm border border-yellow-200">üî• {streak}</div>
                        
                        {session ? (
                            <button onClick={handleLogout} className="text-xs font-bold text-slate-400 hover:text-red-500 uppercase ml-2 transition-colors">Logga ut</button>
                        ) : (
                            <button 
                                className="text-xs font-bold text-slate-300 cursor-not-allowed uppercase ml-2 transition-colors"
                                title="Login is currently disabled"
                            >
                                Logga in
                            </button>
                        )}
                    </div>
                </div>
            </header>

            <div className="flex-1 flex flex-col">
                {view === 'dashboard' ? (
                    <Dashboard
                        lang={lang} selectedTopic={topic} selectedLevel={level} userRole={DEVELOPER_MODE ? 'teacher' : (profile?.role || 'student')} assignments={assignments} 
                        onSelect={(t, l) => { setTopic(t); setLevel(l); }} 
                        onStart={startPractice} 
                        timerSettings={timerSettings} toggleTimer={toggleTimer} resetTimer={resetTimer} ui={ui} 
                        onLgrOpen={() => setLgrOpen(true)} onContentOpen={() => setContentOpen(true)} onAboutOpen={() => setAboutOpen(true)}
                        onStatsOpen={() => setStatsOpen(true)} onStudioOpen={() => navigate('question_studio')} onDoNowOpen={() => navigate('donow_config')} 
                    />
                ) : (
                    <PracticeView
                        lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} 
                        handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip}
                        handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{ history, topic, level }} 
                        actions={{ retry: (force) => fetchQuestion(topic, level, lang, force), goBack: quitPractice }} 
                        levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} 
                        timerSettings={timerSettings} formatTime={formatTime} setMobileHistoryOpen={setMobileHistoryOpen}
                    />
                )}
            </div>
        </div>
    );
}

export default App;

// FILE END: src\App.jsx

// =======================================================
// FILE START: src\components\modals\AboutModal.jsx
// =======================================================

import React from 'react';

const AboutModal = ({ visible, onClose, ui }) => {
    if (!visible) return null;
    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1">‚úï</button>

                <div className="mb-4 flex justify-center">
                    <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100">
                        <img
                            src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                            alt="Creator"
                            className="w-full h-full object-cover"
                        />
                    </div>
                </div>

                <div className="text-center mb-6">
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                    <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                    <hr className="my-4 border-gray-200" />
                    <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" /></svg>
                        {ui.contactLink}
                    </a>
                </div>
            </div>
        </div>
    );
};

export default AboutModal;

// FILE END: src\components\modals\AboutModal.jsx

// =======================================================
// FILE START: src\components\modals\ContentModal.jsx
// =======================================================

import React from 'react';
import { CONTENT_MAP } from '../../constants/content_map';
import { X, BookOpen, Layers, ChevronRight } from 'lucide-react';

const ContentModal = ({ visible, onClose, lang = 'sv' }) => {
    if (!visible) return null;

    // --- INTERNAL UI TRANSLATIONS ---
    const TEXT = {
        sv: {
            title: "Inneh√•llskarta",
            subtitle: "Progression och niv√•er",
            example: "Ex",
            close: "St√§ng"
        },
        en: {
            title: "Content Map",
            subtitle: "Progression and levels",
            example: "Ex",
            close: "Close"
        }
    };

    const t = TEXT[lang] || TEXT.sv;

    // Mapping colors to Tailwind classes for headings and level badges
    const themeClasses = {
        pink: {
            bg: "bg-pink-600",
            text: "text-pink-600",
            light: "bg-pink-50",
            border: "border-pink-100"
        },
        indigo: {
            bg: "bg-indigo-600",
            text: "text-indigo-600",
            light: "bg-indigo-50",
            border: "border-indigo-100"
        },
        amber: {
            bg: "bg-amber-500",
            text: "text-amber-600",
            light: "bg-amber-50",
            border: "border-amber-100"
        },
        rose: {
            bg: "bg-rose-500",
            text: "text-rose-600",
            light: "bg-rose-50",
            border: "border-rose-100"
        }
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-md animate-in fade-in duration-300">
            <div className="bg-white w-full max-w-5xl max-h-[90vh] rounded-[2rem] shadow-2xl flex flex-col overflow-hidden animate-in zoom-in-95 duration-300">
                
                {/* Compact Header */}
                <div className="bg-white border-b border-slate-100 px-6 py-4 flex justify-between items-center shrink-0">
                    <div className="flex items-center gap-3">
                        <div className="w-10 h-10 bg-indigo-600 rounded-xl flex items-center justify-center text-white shadow-md">
                            <BookOpen size={20} />
                        </div>
                        <div>
                            <h2 className="text-xl font-black text-slate-800 tracking-tight uppercase italic leading-none">{t.title}</h2>
                            <p className="text-slate-400 text-[10px] font-bold uppercase tracking-widest mt-1">{t.subtitle}</p>
                        </div>
                    </div>
                    <button 
                        onClick={onClose} 
                        className="w-10 h-10 flex items-center justify-center rounded-xl bg-slate-50 text-slate-400 hover:text-rose-500 transition-all active:scale-90"
                    >
                        <X size={20} strokeWidth={3} />
                    </button>
                </div>

                {/* Main Content Area */}
                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar bg-slate-50/20">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {CONTENT_MAP.map((category) => {
                            const theme = themeClasses[category.color] || themeClasses.indigo;
                            return (
                                <div key={category.id} className="bg-white rounded-3xl border border-slate-200 shadow-sm flex flex-col overflow-hidden">
                                    {/* Category Strip */}
                                    <div className={`${theme.bg} px-5 py-2 flex items-center gap-2`}>
                                        <Layers size={14} className="text-white/80" />
                                        <h3 className="text-[11px] font-black text-white uppercase tracking-widest">
                                            {category.title[lang]}
                                        </h3>
                                    </div>

                                    <div className="p-4 space-y-5">
                                        {category.topics.map((topic) => (
                                            <div key={topic.id} className="space-y-2">
                                                {/* Topic Small Header */}
                                                <div className="flex items-center gap-2 mb-1 px-1">
                                                    <div className={`w-1.5 h-1.5 rounded-full ${theme.bg}`}></div>
                                                    <span className="text-xs font-black text-slate-800 uppercase tracking-tight italic">
                                                        {topic.name[lang]}
                                                    </span>
                                                </div>

                                                {/* Levels List - Compressed */}
                                                <div className="divide-y divide-slate-50">
                                                    {topic.levels.map((lvl) => (
                                                        <div 
                                                            key={lvl.lvl} 
                                                            className="flex items-center gap-3 py-1.5 px-1 hover:bg-slate-50 transition-colors rounded-lg group"
                                                        >
                                                            <div className={`w-6 h-6 shrink-0 rounded-md flex items-center justify-center text-[10px] font-black text-white ${theme.bg}`}>
                                                                {lvl.lvl}
                                                            </div>
                                                            <div className="flex-1 min-w-0 flex items-baseline justify-between gap-2">
                                                                <span className="text-[13px] font-bold text-slate-600 truncate">
                                                                    {lvl.desc[lang]}
                                                                </span>
                                                                <span className="text-[14px] text-slate-800 font-mono italic shrink-0">
                                                                    {t.example}: {lvl.ex}
                                                                </span>
                                                            </div>
                                                            <ChevronRight size={12} className="text-slate-200 opacity-0 group-hover:opacity-100" />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>

                {/* Footer */}
                <div className="bg-white border-t border-slate-100 p-4 flex justify-end shrink-0">
                    <button 
                        onClick={onClose} 
                        className="px-8 py-3 bg-slate-900 hover:bg-indigo-600 text-white rounded-xl font-black text-[10px] uppercase tracking-widest transition-all active:scale-95"
                    >
                        {t.close}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ContentModal;

// FILE END: src\components\modals\ContentModal.jsx

// =======================================================
// FILE START: src\components\modals\LevelUpModal.jsx
// =======================================================

import React from 'react';

const LevelUpModal = ({ visible, ui, onNext, onStay, lang }) => {
    if (!visible) return null;

    // Robust Fallback Logic: Ensure text exists even if UI keys are missing
    // We use the 'lang' prop to determine the default language
    const currentLang = lang || 'sv'; 
    
    const defaultTitle = currentLang === 'sv' ? "Niv√• upp?" : "Level Up?";
    const defaultDesc = currentLang === 'sv' 
        ? "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?" 
        : "You seem to know this! Do you want to skip to the next level?";
    const defaultYes = currentLang === 'sv' ? "Ja, k√∂r!" : "Yes, let's go!";
    const defaultNo = currentLang === 'sv' ? "Nej, stanna h√§r" : "No, stay here";

    const title = ui?.levelUpTitle || defaultTitle;
    const desc = ui?.levelUpDesc || defaultDesc;
    const btnYes = ui?.levelUpYes || defaultYes;
    const btnNo = ui?.levelUpNo || defaultNo;

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <div className="text-center mb-6">
                    <div className="text-5xl mb-4">üöÄ</div>
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{title}</h3>
                    <p className="text-gray-600">{desc}</p>
                </div>
                <div className="flex flex-col gap-3">
                    <button 
                        onClick={onNext} 
                        className="w-full py-4 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                    >
                        {btnYes}
                    </button>
                    <button 
                        onClick={onStay} 
                        className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95"
                    >
                        {btnNo}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default LevelUpModal;

// FILE END: src\components\modals\LevelUpModal.jsx

// =======================================================
// FILE START: src\components\modals\LgrModal.jsx
// =======================================================

import React, { useState, useEffect } from 'react';

const LgrModal = ({ visible, onClose, ui }) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (visible && !data) {
            setLoading(true);
            fetch('/api/curriculum')
                .then(res => res.json())
                .then(d => { setData(d); setLoading(false); })
                .catch(err => { console.error(err); setLoading(false); });
        }
    }, [visible, data]);

    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden animate-bounce-in">
                <div className="flex justify-between items-start mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                    <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600 transition-colors text-xl font-bold">‚úï</button>
                </div>

                <div className="flex-1 overflow-y-auto custom-scrollbar pr-2">
                    {loading ? (
                        <div className="flex justify-center items-center py-12">
                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-sky-600"></div>
                        </div>
                    ) : data ? (
                        <div className="space-y-8">
                            <p className="text-slate-600 italic border-l-4 border-sky-200 pl-4 py-1">{data.description}</p>
                            
                            {/* Syfte */}
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                <ul className="space-y-2">
                                    {data.syfte.map((item, i) => (
                                        <li key={i} className="flex gap-3 text-sm text-slate-700">
                                            <span className="text-sky-500 font-bold">‚Ä¢</span>
                                            {item}
                                        </li>
                                    ))}
                                </ul>
                            </div>

                            {/* Centralt Inneh√•ll */}
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Centralt Inneh√•ll (√•k 7-9)</h4>
                                <div className="grid gap-6">
                                    {/* FIX: Changed data.mapping to data.centralt_innehall */}
                                    {data.centralt_innehall && Object.entries(data.centralt_innehall).map(([key, section]) => (
                                        <div key={key} className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                            <h5 className="font-bold text-slate-900 mb-2 text-sm">{section.category}</h5>
                                            <ul className="list-disc pl-5 space-y-1 text-xs text-slate-600">
                                                {section.content.map((c, i) => <li key={i}>{c}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                    )}
                </div>

                <div className="mt-6 pt-4 border-t border-slate-100 text-center shrink-0">
                    <a href="https://www.skolverket.se" target="_blank" rel="noreferrer" className="text-xs text-sky-600 hover:underline">K√§lla: Skolverket (Lgr22)</a>
                </div>
            </div>
        </div>
    );
};

export default LgrModal;

// FILE END: src\components\modals\LgrModal.jsx

// =======================================================
// FILE START: src\components\modals\StatsModal.jsx
// =======================================================

import React from 'react';
import { CATEGORIES } from '../../constants/localization';

const LevelBreakdown = ({ granularStats, ui, lang }) => {
    const topics = Object.keys(granularStats);
    if (topics.length === 0) return null;

    return (
        <div className="mt-6 border-t border-gray-100 pt-4 w-full">
            <h4 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-4">
                {ui.level_breakdown}
            </h4>
            <div className="space-y-4">
                {topics.map(topicKey => {
                    const topicLevels = granularStats[topicKey];
                    const levels = Object.keys(topicLevels).sort((a, b) => Number(a) - Number(b));

                    let topicLabel = topicKey;
                    for (const catKey in CATEGORIES) {
                        const found = CATEGORIES[catKey].topics.find(t => t.id === topicKey);
                        if (found) {
                            topicLabel = found.label[lang];
                            break;
                        }
                    }

                    return (
                        <div key={topicKey} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                            <h5 className="font-bold text-gray-700 text-sm mb-2 capitalize">{topicLabel}</h5>
                            <div className="space-y-2">
                                {levels.map(lvl => {
                                    const stats = topicLevels[lvl];
                                    const total = stats.skipped + stats.incorrect + stats.correctHelp + stats.correctNoHelp;
                                    if (total === 0) return null;

                                    const pSkip = (stats.skipped / total) * 100;
                                    const pWrong = (stats.incorrect / total) * 100;
                                    const pHelp = (stats.correctHelp / total) * 100;
                                    const pCorrect = (stats.correctNoHelp / total) * 100;
                                    const unassistedPct = Math.round(pCorrect);

                                    return (
                                        <div key={lvl} className="flex flex-col gap-1 mb-3 last:mb-0">
                                            <div className="flex justify-between items-center text-xs font-medium text-gray-500 mb-1">
                                                <span>{lang === 'sv' ? 'Niv√•' : 'Level'} {lvl}</span>
                                            </div>
                                            <div className="flex w-full h-3 rounded-full overflow-hidden bg-gray-200">
                                                {pSkip > 0 && <div style={{ width: `${pSkip}%` }} className="bg-gray-400" />}
                                                {pWrong > 0 && <div style={{ width: `${pWrong}%` }} className="bg-red-500" />}
                                                {pHelp > 0 && <div style={{ width: `${pHelp}%` }} className="bg-yellow-400" />}
                                                {pCorrect > 0 && <div style={{ width: `${pCorrect}%` }} className="bg-green-500" />}
                                            </div>
                                            <div className="flex flex-wrap gap-x-3 text-[10px] text-gray-500 mt-1">
                                                <span className="text-gray-500 font-semibold">{ui.stat_skip}: {stats.skipped}</span>
                                                <span className="text-red-600 font-semibold">{ui.stat_wrong}: {stats.incorrect}</span>
                                                <span className="text-yellow-600 font-semibold">{ui.stat_help}: {stats.correctHelp}</span>
                                                <span className="text-green-600 font-semibold">{ui.stat_correct}: {stats.correctNoHelp}</span>
                                            </div>
                                            <div className="text-[10px] text-gray-400 italic">
                                                {ui.stat_total}: {total} ({unassistedPct}% unassisted)
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const StatsModal = ({ visible, stats, granularStats, ui, onClose, title, lang }) => {
    if (!visible) return null;
    const attemptCount = stats.attempted || 0;
    const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

    return (
        <div className="fixed inset-0 z-[100] flex sm:items-center justify-center sm:p-4 bg-white sm:bg-black/50 sm:backdrop-blur-sm fade-in">
            <div className="bg-white w-full h-full sm:h-auto sm:max-h-[90vh] sm:rounded-2xl sm:shadow-2xl sm:max-w-md p-6 relative flex flex-col sm:border-4 sm:border-blue-500 overflow-y-auto custom-scrollbar">
                <div className="flex justify-between items-center mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-gray-900">{title || ui.stats_title}</h3>
                    <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 sm:hidden">‚úï</button>
                </div>

                <div className="shrink-0 grid grid-cols-2 gap-4 text-left text-sm mb-6">
                    <div className="text-gray-500">{ui.stats_longest_streak}</div>
                    <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                    <div className="text-gray-500">{ui.stats_attempted}</div>
                    <div className="font-bold text-right">{stats.attempted}</div>
                    <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                    <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_correct_help}</div>
                    <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_incorrect}</div>
                    <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                    <div className="text-gray-500">{ui.stats_skipped}</div>
                    <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                </div>

                <LevelBreakdown granularStats={granularStats} ui={ui} lang={lang} />

                <button onClick={onClose} className="mt-8 w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg shrink-0 hidden sm:block">
                    {ui.stats_close}
                </button>
            </div>
        </div>
    );
};

export default StatsModal;

// FILE END: src\components\modals\StatsModal.jsx

// =======================================================
// FILE START: src\components\modals\StreakModal.jsx
// =======================================================

import React from 'react';

const StreakModal = ({ visible, streak, ui, onClose }) => {
    if (!visible) return null;

    let icon = "ü•â";
    if (streak >= 50) icon = "üëë";
    else if (streak >= 40) icon = "üèÜ";
    else if (streak >= 30) icon = "ü•á";
    else if (streak >= 20) icon = "ü•à";
    else if (streak >= 15) icon = "ü•â";

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                <button 
                    onClick={onClose} 
                    className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                >
                    {ui.btn_close_streak}
                </button>
            </div>
        </div>
    );
};

export default StreakModal;

// FILE END: src\components\modals\StreakModal.jsx

// =======================================================
// FILE START: src\components\practice\CluePanel.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const CluePanel = ({ revealedClues, question, ui, isSolutionRevealed, lang }) => {
    if (!revealedClues || revealedClues.length === 0) {
        return (
            <div className="flex flex-col items-center justify-center py-6 text-center px-4">
                <span className="text-xl mb-1 opacity-20">üí°</span>
                <p className="text-[9px] uppercase tracking-widest text-slate-300 font-bold italic">
                    {ui.noCluesLabel || (lang === 'sv' ? "Inga ledtr√•dar √§n" : "No hints yet")}
                </p>
            </div>
        );
    }

    const totalCluesCount = question?.clues?.length || 0;

    return (
        <div className="animate-fade-in flex flex-col h-full">
            {/* COMPACT HEADER */}
            <div className="flex items-center justify-between mb-3 pb-1 border-b border-orange-100">
                <span className="text-[9px] font-black text-orange-700 uppercase tracking-tighter italic">
                    {ui.hintsTitle || "Ledtr√•dar"}
                </span>
                <span className="bg-orange-100 text-orange-700 text-[8px] font-black px-1.5 py-0.5 rounded-full">
                    {revealedClues.length} / {totalCluesCount}
                </span>
            </div>

            {/* CLUE LIST */}
            <div className="space-y-5 overflow-y-auto pr-1 custom-scrollbar">
                {revealedClues.map((clue, i) => {
                    // 1. DEFENSIVE DATA EXTRACTION
                    // This handles { text: "" }, { sv: "" }, or just a string ""
                    let textContent = "";
                    if (typeof clue === 'object') {
                        textContent = clue.text || clue[lang] || clue.sv || clue.en || "";
                    } else {
                        textContent = clue;
                    }

                    const latexContent = typeof clue === 'object' ? clue.latex : null;
                    const isTheFinalClue = i === totalCluesCount - 1;
                    const showLatex = !isTheFinalClue || isSolutionRevealed;

                    return (
                        <div key={i} className="group animate-slide-down border-l-2 border-orange-200 pl-3">
                            {/* Step Indicator */}
                            <div className="text-[8px] font-black text-orange-400 uppercase tracking-widest mb-1">
                                {lang === 'sv' ? 'Steg' : 'Step'} {i + 1}
                            </div>

                            {/* 2. PEDAGOGICAL DESCRIPTION */}
                            {textContent && (
                                <div className="text-[11px] sm:text-xs text-slate-700 font-medium leading-relaxed mb-2 break-words">
                                    {/* If text contains math symbols, use MathText. Otherwise, use a standard span */}
                                    {textContent.includes('$') || textContent.includes('\\') ? (
                                        <MathText text={textContent} />
                                    ) : (
                                        <span>{textContent}</span>
                                    )}
                                </div>
                            )}
                            
                            {/* 3. MATHEMATICAL VISUAL (Mathbox) */}
                            {latexContent && (
                                <div className={`transition-all duration-500 ${showLatex ? 'opacity-100' : 'opacity-40 grayscale blur-[1px]'}`}>
                                    <div className="bg-orange-50/50 p-2 rounded-lg border border-orange-100 text-center shadow-sm overflow-x-auto min-h-[36px] flex items-center justify-center">
                                        {showLatex ? (
                                            <div className="scale-90 origin-center">
                                                {/* Ensure LaTeX is wrapped in $ delimiters */}
                                                <MathText text={latexContent.includes('$') ? latexContent : `$${latexContent}$`} />
                                            </div>
                                        ) : (
                                            <div className="text-[8px] text-orange-400 font-black italic uppercase tracking-tighter">
                                                {lang === 'sv' ? "L√∂s steget f√∂r att se svar" : "Solve step to see answer"}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default CluePanel;

// FILE END: src\components\practice\CluePanel.jsx

// =======================================================
// FILE START: src\components\practice\HistoryList.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const HistoryList = ({ history, ui }) => {
    return (
        <div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                <h2 className="font-bold text-gray-700">{ui.history}</h2>
                <span className="text-xs text-gray-400">{history.length}</span>
            </div>
            <div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px] custom-scrollbar">
                {history.length === 0 ? (
                    <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>
                ) : (
                    history.map((entry, i) => (
                        <div 
                            key={i} 
                            className={`p-3 rounded-lg border-l-4 text-sm ${
                                entry.correct 
                                    ? 'border-emerald-500 bg-emerald-50' 
                                    : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')
                            }`}
                        >
                            <div className="flex justify-between items-start mb-1">
                                <span className="font-semibold capitalize text-gray-700">
                                    {entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span>
                                </span>
                                <span className="text-xs text-gray-400">
                                    {new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                            </div>
                            
                            <div className="text-gray-600 mb-1 line-clamp-2">
                                <MathText text={entry.text} />
                            </div>

                            {!entry.correct && !entry.skipped && entry.correctAnswer && (
                                <div className="text-xs text-red-600 mt-1 font-medium">
                                    <MathText text={`Correct: ${entry.correctAnswer}`} />
                                </div>
                            )}

                            <div className="mt-2">
                                {entry.clueUsed && (
                                    <span className="inline-block px-1.5 py-0.5 bg-orange-100 text-orange-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">
                                        {ui.clueUsed}
                                    </span>
                                )} 
                                <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${
                                    entry.correct 
                                        ? 'bg-emerald-100 text-emerald-700' 
                                        : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')
                                }`}>
                                    {entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}
                                </span>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default HistoryList;

// FILE END: src\components\practice\HistoryList.jsx

// =======================================================
// FILE START: src\components\practice\MobileDrawer.jsx
// =======================================================

import React from 'react';
import HistoryList from './HistoryList';

const MobileDrawer = ({ open, onClose, history, ui }) => {
    return (
        <>
            {open && <div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}
            <div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}>
                <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                    <h2 className="font-bold text-gray-700">{ui.history}</h2>
                    <button onClick={onClose} className="text-gray-400">‚úï</button>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                    <HistoryList history={history} ui={ui} />
                </div>
            </div>
        </>
    );
};

export default MobileDrawer;

// FILE END: src\components\practice\MobileDrawer.jsx

// =======================================================
// FILE START: src\components\ui\Button.jsx
// =======================================================

import React from 'react';

export const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  className = '', 
  disabled = false,
  fullWidth = false 
}) => {
  const baseStyles = "px-4 py-2 rounded-lg font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-math-blue text-white hover:bg-blue-600 focus:ring-math-blue shadow-sm",
    secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500",
    success: "bg-math-green text-white hover:bg-green-600 focus:ring-math-green shadow-sm",
    danger: "bg-math-red text-white hover:bg-red-600 focus:ring-math-red shadow-sm",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
    >
      {children}
    </button>
  );
};

// FILE END: src\components\ui\Button.jsx

// =======================================================
// FILE START: src\components\ui\InputComponents.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

// =====================================================================
// FRACTION INPUT COMPONENT
// =====================================================================
export const FractionInput = ({ value, onChange, allowMixed = false, autoFocus = false }) => {
    const wholeRef = useRef(null);
    const numRef = useRef(null);
    const denRef = useRef(null);

    // Safe parsing of the value
    let w = "", n = "", d = "";
    const strVal = value || "";

    if (strVal.includes(' ')) {
        const parts = strVal.split(' ');
        w = parts[0];
        if (parts[1] && parts[1].includes('/')) {
            [n, d] = parts[1].split('/');
        } else {
            n = parts[1] || "";
        }
    } else if (strVal.includes('/')) {
        [n, d] = strVal.split('/');
    } else {
        n = strVal;
    }

    const update = (newW, newN, newD) => {
        let res = "";
        if (newW) {
            res += newW;
            if (newN || newD) res += " ";
        }
        if (newN || newD) {
            res += `${newN}/${newD}`;
        }
        onChange(res);
    };

    // Auto-focus logic
    useEffect(() => {
        if (autoFocus) {
            if (allowMixed) wholeRef.current?.focus();
            else numRef.current?.focus();
        }
    }, [autoFocus, allowMixed]);

    return (
        <div className="inline-flex items-center gap-2 font-mono text-xl text-slate-800">
            {allowMixed && (
                <input
                    ref={wholeRef}
                    className="w-12 h-14 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                    value={w}
                    onChange={(e) => update(e.target.value, n, d)}
                    placeholder="0"
                />
            )}
            <div className="flex flex-col items-center gap-1">
                <input
                    ref={numRef}
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={n}
                    onChange={(e) => update(w, e.target.value, d)}
                    placeholder="n"
                />
                <div className="w-full h-0.5 bg-slate-800 rounded-full"></div>
                <input
                    ref={denRef}
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={d}
                    onChange={(e) => update(w, n, e.target.value)}
                    placeholder="d"
                />
            </div>
        </div>
    );
};

// =====================================================================
// EXPONENT INPUT COMPONENT
// =====================================================================
export const ExponentInput = ({ value, onChange, autoFocus = false }) => {
    const baseRef = useRef(null);
    const expRef = useRef(null);

    let base = "", exp = "";
    const strVal = value || "";
    
    if (strVal.includes('^')) {
        [base, exp] = strVal.split('^');
    } else {
        base = strVal;
    }

    const update = (newBase, newExp) => {
        if (newExp !== "") onChange(`${newBase}^${newExp}`);
        else onChange(newBase);
    };

    useEffect(() => {
        if (autoFocus) baseRef.current?.focus();
    }, [autoFocus]);

    return (
        <div className="inline-flex items-start font-mono text-xl text-slate-800 pt-4">
            <input
                ref={baseRef}
                className="w-16 h-12 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                value={base}
                onChange={(e) => update(e.target.value, exp)}
                placeholder="x"
            />
            <input
                ref={expRef}
                className="w-10 h-8 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-sm relative -top-3 ml-1 shadow-sm"
                value={exp}
                onChange={(e) => update(base, e.target.value)}
                placeholder="n"
            />
        </div>
    );
};

// =====================================================================
// SCIENTIFIC NOTATION INPUT COMPONENT
// =====================================================================
export const ScientificInput = ({ value, onChange, autoFocus = false }) => {
    const mantissaRef = useRef(null);
    const expRef = useRef(null);

    let mantissa = "", exponent = "";
    const strVal = value || "";

    // Parse values from format "a*10^n"
    if (strVal.includes('*10^')) {
        [mantissa, exponent] = strVal.split('*10^');
    } else {
        mantissa = strVal;
    }

    const update = (newM, newE) => {
        // Construct string format for internal state
        if (newE !== "") {
            onChange(`${newM}*10^${newE}`);
        } else {
            onChange(newM);
        }
    };

    useEffect(() => {
        if (autoFocus) mantissaRef.current?.focus();
    }, [autoFocus]);

    return (
        <div className="inline-flex items-center font-mono text-slate-800">
            {/* Mantissa (a) */}
            <input
                ref={mantissaRef}
                type="text"
                inputMode="decimal"
                className="w-20 h-14 text-center border-2 border-slate-300 rounded-xl focus:border-indigo-500 focus:outline-none bg-white text-2xl font-bold shadow-sm"
                value={mantissa}
                onChange={(e) => update(e.target.value, exponent)}
                placeholder="a"
            />

            {/* Times 10 Base */}
            <span className="mx-2 text-2xl font-bold text-slate-400">¬∑ 10</span>

            {/* Exponent (n) */}
            <div className="relative -top-4">
                <input
                    ref={expRef}
                    type="text"
                    inputMode="numeric"
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded-lg focus:border-indigo-500 focus:outline-none bg-white text-lg font-bold shadow-sm"
                    value={exponent}
                    onChange={(e) => update(mantissa, e.target.value)}
                    placeholder="n"
                />
            </div>
        </div>
    );
};

// FILE END: src\components\ui\InputComponents.jsx

// =======================================================
// FILE START: src\components\ui\MathText.jsx
// =======================================================

import React from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css'; // Ensure CSS is imported

const MathText = ({ text, className = "", large = false }) => {
    if (!text) return null;

    // 1. Patch common LaTeX color syntax differences if necessary
    const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');

    // 2. Split by $ delimiters
    const parts = patchedText.split(/(\$[^\$]+\$)/g);

    return (
        <span className={className}>
            {parts.map((part, index) => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const tex = part.slice(1, -1);
                    try {
                        const html = katex.renderToString(tex, { 
                            throwOnError: false, 
                            displayMode: large 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index} className="text-red-500">{part}</span>;
                    }
                } else if (part.includes('\\')) {
                    // Catch-all for stray LaTeX without $ delimiters (legacy support)
                    try {
                        const html = katex.renderToString(part, { 
                            throwOnError: false, 
                            displayMode: false 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index}>{part}</span>;
                    }
                }
                return <span key={index}>{part}</span>;
            })}
        </span>
    );
};

export default MathText;

// FILE END: src\components\ui\MathText.jsx

// =======================================================
// FILE START: src\components\views\AuthView.jsx
// =======================================================

import React, { useState } from 'react';
import { supabase } from '../../lib/supabaseClient';

const AuthView = ({ ui, lang }) => {
    const [loading, setLoading] = useState(false);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [fullName, setFullName] = useState('');
    const [role, setRole] = useState('student');
    const [isSignUp, setIsSignUp] = useState(false);
    const [message, setMessage] = useState(null);

    const handleAuth = async (e) => {
        e.preventDefault();
        setLoading(true);
        setMessage(null);

        if (isSignUp && password !== confirmPassword) {
            setMessage({ 
                type: 'error', 
                text: lang === 'sv' ? "L√∂senorden matchar inte!" : "Passwords do not match!" 
            });
            setLoading(false);
            return;
        }

        try {
            if (isSignUp) {
                const { data, error: authError } = await supabase.auth.signUp({ 
                    email, 
                    password,
                    options: {
                        data: { full_name: fullName, role: role }
                    }
                });
                if (authError) throw authError;

                if (data.user) {
                    await supabase.from('profiles').insert([{ 
                        id: data.user.id, 
                        full_name: fullName, 
                        role: role,
                        alias: role === 'student' ? `User-${Math.floor(Math.random() * 10000)}` : null
                    }]);
                }
                setMessage({ 
                    type: 'success', 
                    text: lang === 'sv' ? "Konto skapat! Kolla din e-post." : "Account created! Check your email." 
                });
            } else {
                const { error: signInError } = await supabase.auth.signInWithPassword({ email, password });
                if (signInError) throw signInError;
            }
        } catch (error) {
            setMessage({ type: 'error', text: error.message });
        } finally {
            setLoading(false);
        }
    };

    const handleSocialLogin = async (provider) => {
        setLoading(true);
        const { error } = await supabase.auth.signInWithOAuth({
            provider: provider,
            options: {
                redirectTo: window.location.origin,
                data: { role: role } 
            }
        });
        if (error) setMessage({ type: 'error', text: error.message });
        setLoading(false);
    };

    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-slate-50 p-6">
            <div className="w-full max-w-md bg-white rounded-3xl shadow-2xl p-8 border border-slate-200">
                <div className="text-center mb-6">
                    <h1 className="text-4xl font-black text-indigo-600 mb-1 tracking-tighter">Anpassa</h1>
                    <p className="text-slate-500 text-sm font-medium font-mono">
                        {isSignUp ? (lang === 'sv' ? "SKAPA KONTO" : "CREATE ACCOUNT") : (lang === 'sv' ? "V√ÑLKOMMEN TILLBAKA" : "WELCOME BACK")}
                    </p>
                </div>

                <div className="mb-6">
                    <label className="block text-[10px] font-black uppercase tracking-widest text-slate-400 mb-2 text-center">
                        {lang === 'sv' ? "Jag √§r en..." : "I am a..."}
                    </label>
                    <div className="flex gap-2 p-1 bg-slate-100 rounded-2xl">
                        <button type="button" onClick={() => setRole('student')} className={`flex-1 py-2 rounded-xl text-sm font-bold transition-all ${role === 'student' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500'}`}>
                            {lang === 'sv' ? "Elev" : "Student"}
                        </button>
                        <button type="button" onClick={() => setRole('teacher')} className={`flex-1 py-2 rounded-xl text-sm font-bold transition-all ${role === 'teacher' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500'}`}>
                            {lang === 'sv' ? "L√§rare" : "Teacher"}
                        </button>
                    </div>
                </div>

                <div className="mb-6">
                    <button 
                        onClick={() => handleSocialLogin('google')}
                        className="w-full flex items-center justify-center gap-3 p-4 border-2 border-slate-100 rounded-2xl hover:bg-slate-50 hover:border-indigo-100 transition-all font-bold text-slate-600 shadow-sm"
                    >
                        <svg className="w-6 h-6" viewBox="0 0 24 24"><path fill="#EA4335" d="M12 5c1.6 0 3 .6 4.1 1.6l3.1-3.1C17.3 1.6 14.8 1 12 1 7.7 1 4.1 3.5 2.3 7.1l3.7 2.9C6.9 7.1 9.3 5 12 5z"/><path fill="#4285F4" d="M23.5 12.3c0-.8-.1-1.6-.2-2.3H12v4.4h6.5c-.3 1.5-1.2 2.7-2.4 3.5l3.8 3c2.2-2 3.6-5 3.6-8.6z"/><path fill="#FBBC05" d="M6 14.7c-.2-.7-.4-1.5-.4-2.3s.2-1.6.4-2.3L2.3 7.1C1.4 8.7 1 10.3 1 12s.4 3.3 1.3 4.9l3.7-2.2z"/><path fill="#34A853" d="M12 23c3 0 5.5-1 7.4-2.7l-3.8-3c-1 .7-2.3 1.2-3.6 1.2-2.7 0-5.1-2.1-5.9-4.9l-3.7 2.9C4.1 20.5 7.7 23 12 23z"/></svg>
                        {lang === 'sv' ? "Logga in med Google" : "Continue with Google"}
                    </button>
                </div>

                <div className="relative mb-6">
                    <div className="absolute inset-0 flex items-center"><span className="w-full border-t border-slate-100"></span></div>
                    <div className="relative flex justify-center text-[10px] uppercase tracking-tighter"><span className="bg-white px-3 text-slate-300 font-black">{lang === 'sv' ? "Eller e-post" : "Or Email"}</span></div>
                </div>

                <form onSubmit={handleAuth} className="space-y-3">
                    {isSignUp && (
                        <div>
                            <input type="text" placeholder={lang === 'sv' ? "Namn" : "Name"} className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" value={fullName} onChange={(e) => setFullName(e.target.value)} required />
                        </div>
                    )}
                    <input type="email" placeholder="Email" className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" value={email} onChange={(e) => setEmail(e.target.value)} required />
                    <input type="password" placeholder={lang === 'sv' ? "L√∂senord" : "Password"} className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" value={password} onChange={(e) => setPassword(e.target.value)} required />
                    
                    {isSignUp && (
                        <input 
                            type="password" 
                            placeholder={lang === 'sv' ? "Bekr√§fta l√∂senord" : "Confirm password"} 
                            className="w-full p-4 rounded-2xl bg-slate-50 border border-slate-200 outline-none focus:ring-2 focus:ring-indigo-500/20" 
                            value={confirmPassword} 
                            onChange={(e) => setConfirmPassword(e.target.value)} 
                            required 
                        />
                    )}

                    <button disabled={loading} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-black py-4 rounded-2xl shadow-lg shadow-indigo-100 transition-all active:scale-[0.98] disabled:opacity-50 mt-2">
                        {loading ? '...' : (isSignUp ? (lang === 'sv' ? "SKAPA KONTO" : "CREATE ACCOUNT") : (lang === 'sv' ? "LOGGA IN" : "LOG IN"))}
                    </button>
                </form>

                {message && (
                    <div className={`mt-4 p-4 rounded-2xl text-xs font-bold text-center ${message.type === 'error' ? 'bg-red-50 text-red-600 border border-red-100' : 'bg-green-50 text-green-600 border border-green-100'}`}>
                        {message.text}
                    </div>
                )}

                <div className="mt-8 text-center border-t border-slate-50 pt-6">
                    <button onClick={() => setIsSignUp(!isSignUp)} className="text-indigo-600 hover:text-indigo-800 text-sm font-bold transition-colors">
                        {isSignUp ? (lang === 'sv' ? "Har redan ett konto? Logga in" : "Already have an account? Log In") : (lang === 'sv' ? "Inget konto? G√• med h√§r" : "No account? Join here")}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default AuthView;

// FILE END: src\components\views\AuthView.jsx

// =======================================================
// FILE START: src\components\views\Dashboard.jsx
// =======================================================

import React, { useState } from 'react';
import { 
  ChevronDown, 
  ChevronUp, 
  ChevronRight,
  Zap,
  Play, 
  Clock, 
  Book, 
  Map, 
  Info, 
  Award, 
  BarChart3, 
  PenTool, 
  Calendar,
  Sparkles
} from 'lucide-react';

// Using the import path from your source code
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '@/constants/localization';

const COLOR_VARIANTS = {
    pink: {
        bgLight: 'bg-pink-50', bgDark: 'bg-pink-500', border: 'border-pink-100', text: 'text-pink-700', ring: 'ring-pink-500', borderSolid: 'border-pink-500', icon: 'text-pink-500'
    },
    indigo: {
        bgLight: 'bg-indigo-50', bgDark: 'bg-indigo-500', border: 'border-indigo-100', text: 'text-indigo-700', ring: 'ring-indigo-500', borderSolid: 'border-indigo-500', icon: 'text-indigo-500'
    },
    emerald: {
        bgLight: 'bg-emerald-50', bgDark: 'bg-emerald-500', border: 'border-emerald-100', text: 'text-emerald-700', ring: 'ring-emerald-500', borderSolid: 'border-emerald-500', icon: 'text-emerald-500'
    },
    purple: {
        bgLight: 'bg-purple-50', bgDark: 'bg-purple-500', border: 'border-purple-100', text: 'text-purple-700', ring: 'ring-purple-500', borderSolid: 'border-purple-500', icon: 'text-purple-500'
    },
    yellow: {
        bgLight: 'bg-yellow-50', bgDark: 'bg-yellow-500', border: 'border-yellow-100', text: 'text-yellow-700', ring: 'ring-yellow-500', borderSolid: 'border-yellow-500', icon: 'text-yellow-500'
    }
};

const Dashboard = ({ 
    lang = 'sv', 
    selectedTopic, 
    selectedLevel, 
    onSelect, 
    onStart, 
    timerSettings, 
    toggleTimer, 
    resetTimer, 
    ui, 
    onLgrOpen, 
    onContentOpen,
    onAboutOpen,
    onStatsOpen,
    onStudioOpen,
    userRole = 'student',
    assignments = [],
    recommended = []
}) => {
    // Defaulting to algebra being expanded for a smooth landing
    const [expandedCategory, setExpandedCategory] = useState('algebra');

    // --- INTERNAL TRANSLATIONS ---
    const TEXT = {
        sv: {
            welcome_badge: "V√§lkommen till Anpassa",
            welcome_title: "Dags att bem√§stra matematiken.",
            current_assignments: "Aktuella Uppgifter",
            assignment_status: (count) => `Du har ${count} aktiva uppdrag fr√•n din l√§rare.`,
            daily_tip: "Dagens Tips",
            tip_body: "Sl√• p√• timern f√∂r att hj√§lpa dig skapa en bra rutin att √∂va 15 minuter och sen ta en kort paus!",
            timer_title: "Timer",
            timer_off: "Timer av",
            timer_reset: "Nollst√§ll",
            studio_section: "Anpassa Studion",
            studio_title: "Question Studio",
            studio_desc: "Skapa Do Now & Arbetsblad",
            stats_title: "Dagens statistik",
            stats_desc: "Kolla hur det gick idag",
            curriculum_title: "Kursmaterial",
            topics_count: (count) => `${count} delmoment tillg√§ngliga`,
            select_level: "V√§lj niv√•",
            level_label: "Niv√•",
            start_btn: "B√∂rja √∂va",
            resources: "Resurser",
            content_map: "Inneh√•llskarta",
            lgr_link: "LGR 22 Koppling",
            about_link: "Om skaparen",
            brand_motto: "R√§tt st√∂d. Direkt."
        },
        en: {
            welcome_badge: "Welcome to Adapt",
            welcome_title: "Time to master mathematics.",
            current_assignments: "Current Assignments",
            assignment_status: (count) => `You have ${count} active assignments from your teacher.`,
            daily_tip: "Daily Tip",
            tip_body: "Turn on the timer to help you create a routine of practicing for 15 minutes and then taking a short break!",
            timer_title: "Timer",
            timer_off: "Timer off",
            timer_reset: "Reset",
            studio_section: "Adapt Studio",
            studio_title: "Question Studio",
            studio_desc: "Create Do Now & Worksheets",
            stats_title: "Your stats today",
            stats_desc: "See your progress",
            curriculum_title: "Course Material",
            topics_count: (count) => `${count} topics available`,
            select_level: "Select Level",
            level_label: "Level",
            start_btn: "Start practicing",
            resources: "Resources",
            content_map: "Content Map",
            lgr_link: "Curriculum Links",
            about_link: "About Creator",
            brand_motto: "Right support. Instantly."
        }
    };

    const t = TEXT[lang] || TEXT.sv;

    const getStyles = (category) => {
        const color = category.color || 'emerald';
        return COLOR_VARIANTS[color] || COLOR_VARIANTS.emerald;
    };

    return (
        <div className="max-w-5xl mx-auto w-full p-4 fade-in flex flex-col min-h-screen pb-32">
            
            {/* --- LANDING PANE / HERO SECTION --- */}
            <header className="mb-12">
                <div className="bg-gradient-to-br from-indigo-600 to-purple-700 rounded-[2.5rem] p-8 md:p-12 text-white shadow-2xl relative overflow-hidden">
                    <div className="relative z-10">
                        <div className="flex items-center gap-3 mb-4">
                            <span className="bg-white/20 backdrop-blur-md px-4 py-1 rounded-full text-xs font-bold uppercase tracking-widest border border-white/10">
                                {t.welcome_badge}
                            </span>
                        </div>
                        <h1 className="text-4xl md:text-6xl font-black mb-6 tracking-tight leading-none">
                            {t.welcome_title}
                        </h1>
                        
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-8">
                            {assignments.length > 0 ? (
                                <div className="bg-white/10 backdrop-blur-md rounded-3xl p-6 border border-white/10 hover:bg-white/15 transition-all cursor-pointer group">
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="font-bold flex items-center gap-2"><Calendar size={18}/> {t.current_assignments}</h3>
                                        <ChevronRight size={18} className="group-hover:translate-x-1 transition-transform"/>
                                    </div>
                                    <p className="text-sm text-indigo-100">{t.assignment_status(assignments.length)}</p>
                                </div>
                            ) : (
                                <div className="bg-white/10 backdrop-blur-md rounded-3xl p-6 border border-white/10">
                                    <h3 className="font-bold flex items-center gap-2 mb-2"><Sparkles size={18}/> {t.daily_tip}</h3>
                                    <p className="text-sm text-indigo-100">{t.tip_body}</p>
                                </div>
                            )}

                            <div className="bg-white/10 backdrop-blur-md rounded-3xl p-6 border border-white/10 flex items-center justify-between">
                                <div>
                                    <h3 className="font-bold flex items-center gap-2 mb-1"><Clock size={18}/> {t.timer_title}</h3>
                                    <div className="flex items-center gap-2 mt-2">
                                        <select
                                            value={timerSettings.duration / 60}
                                            onChange={(e) => toggleTimer(Number(e.target.value))}
                                            className="bg-slate-900/50 border-none text-white py-1 px-3 rounded-lg text-sm font-bold focus:ring-2 focus:ring-white/50"
                                        >
                                            <option value="0">{t.timer_off}</option>
                                            {[5, 10, 15, 30, 45, 60].map(m => <option key={m} value={m}>{m} min</option>)}
                                        </select>
                                        {timerSettings.duration > 0 && (
                                            <button onClick={resetTimer} className="text-[10px] uppercase font-black text-red-300 hover:text-white transition-colors">{t.timer_reset}</button>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div className="absolute top-[-20%] right-[-10%] w-96 h-96 bg-white/10 rounded-full blur-3xl"></div>
                </div>
            </header>

            {/* --- TEACHER COMMAND CENTER --- */}
            {userRole === 'teacher' && (
                <section className="mb-12 animate-in fade-in slide-in-from-top-4 duration-500">
                    <div className="flex items-center gap-3 mb-4 px-4">
                        <PenTool size={18} className="text-slate-400" />
                        <h2 className="text-sm font-black text-slate-500 uppercase tracking-widest">{t.studio_section}</h2>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mx-4">
                        <button 
                            onClick={onStudioOpen}
                            className="flex items-center justify-between p-6 bg-slate-900 text-white rounded-[2rem] hover:bg-indigo-600 transition-all shadow-xl group text-left"
                        >
                            <div className="flex items-center gap-4">
                                <div className="w-12 h-12 bg-white/10 rounded-2xl flex items-center justify-center">
                                    <Zap size={24} fill="currentColor" />
                                </div>
                                <div className="text-left">
                                    <span className="block font-black text-lg">{t.studio_title}</span>
                                    <span className="text-xs text-slate-400 group-hover:text-indigo-100">{t.studio_desc}</span>
                                </div>
                            </div>
                            <ChevronRight size={20} />
                        </button>

                        <button 
                            onClick={onStatsOpen}
                            className="flex items-center justify-between p-6 bg-white border border-slate-200 rounded-[2rem] hover:border-indigo-500 transition-all shadow-sm group text-left"
                        >
                            <div className="flex items-center gap-4">
                                <div className="w-12 h-12 bg-indigo-50 rounded-2xl flex items-center justify-center text-indigo-600">
                                    <BarChart3 size={24} />
                                </div>
                                <div className="text-left">
                                    <span className="block font-black text-lg text-slate-800">{t.stats_title}</span>
                                    <span className="text-xs text-slate-500">{t.stats_desc}</span>
                                </div>
                            </div>
                            <ChevronRight size={20} className="text-slate-300" />
                        </button>
                    </div>
                </section>
            )}

            {/* --- CURRICULUM GRID --- */}
            <div className="flex flex-col gap-6 mx-4">
                <div className="flex items-center gap-3 mb-2">
                    <Book size={18} className="text-slate-400" />
                    <h2 className="text-sm font-black text-slate-500 uppercase tracking-widest">{t.curriculum_title}</h2>
                </div>

                {Object.entries(CATEGORIES).map(([catKey, category]) => {
                    const styles = getStyles(category);
                    const isExpanded = expandedCategory === catKey;
                    
                    return (
                        <div key={catKey} className={`bg-white rounded-[2rem] border-2 transition-all duration-500 overflow-hidden ${isExpanded ? `shadow-2xl ${styles.borderSolid}` : 'border-transparent shadow-sm hover:border-slate-200'}`}>
                            <button 
                                onClick={() => setExpandedCategory(isExpanded ? null : catKey)}
                                className={`w-full p-6 flex items-center justify-between text-left ${isExpanded ? styles.bgLight : ''}`}
                            >
                                <div className="flex items-center gap-4">
                                    <div className={`w-12 h-12 rounded-2xl flex items-center justify-center ${styles.bgDark} text-white shadow-lg`}>
                                        <Award size={24} />
                                    </div>
                                    <div>
                                        <h3 className={`text-xl font-black text-slate-800 uppercase tracking-tight`}>{category.label[lang]}</h3>
                                        <p className="text-xs text-slate-500 font-medium">{t.topics_count(category.topics.length)}</p>
                                    </div>
                                </div>
                                {isExpanded ? <ChevronUp size={24} className="text-slate-400" /> : <ChevronDown size={24} className="text-slate-400" />}
                            </button>
                            
                            <div className={`transition-all duration-500 ease-in-out ${isExpanded ? 'max-h-[2000px] opacity-100 p-6' : 'max-h-0 opacity-0 pointer-events-none'}`}>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    {category.topics.map(topic => (
                                        <div key={topic.id} className="bg-slate-50 rounded-3xl p-5 border border-slate-100 hover:bg-white hover:shadow-xl hover:border-indigo-100 transition-all group">
                                            <div className="font-bold text-slate-800 mb-4 ml-1 flex items-center justify-between">
                                                {topic.label[lang]}
                                                <div className={`w-2 h-2 rounded-full ${styles.bgDark} opacity-0 group-hover:opacity-100 transition-opacity`}></div>
                                            </div>
                                            <div className="relative">
                                                <select 
                                                    value={selectedTopic === topic.id ? selectedLevel : 0} 
                                                    onChange={(e) => onSelect(topic.id, Number(e.target.value))} 
                                                    className={`w-full p-3 pl-4 bg-white border border-slate-200 rounded-2xl text-sm font-bold focus:outline-none appearance-none cursor-pointer transition-all ${selectedTopic === topic.id ? `ring-4 ${styles.ring} border-transparent` : ''}`}
                                                >
                                                    <option value={0} disabled>{t.select_level}</option>
                                                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                        if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                        return (
                                                            <option key={lvl} value={lvl}>
                                                                {lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang] || ""}
                                                            </option>
                                                        );
                                                    })}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-4 flex items-center text-slate-400">
                                                    <ChevronDown size={16} />
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>

            {/* --- FIXED START ACTION BAR --- */}
            <div className={`fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-30 transition-all duration-500 ${selectedTopic ? 'translate-y-0 opacity-100' : 'translate-y-20 opacity-0'}`}>
                <button 
                    onClick={onStart} 
                    className="px-12 py-5 rounded-full font-black text-xl shadow-[0_20px_50px_rgba(249,115,22,0.4)] bg-orange-500 text-white pointer-events-auto flex items-center gap-4 hover:scale-110 hover:bg-orange-600 active:scale-95 transition-all uppercase tracking-tighter"
                >
                    {t.start_btn} <Play fill="currentColor" size={20} />
                </button>
            </div>

            {/* --- RESOURCE FOOTER HUB --- */}
            <footer className="mt-20 py-12 border-t border-slate-100 grid grid-cols-1 md:grid-cols-3 gap-8 px-4 text-center md:text-left">
                <div className="space-y-4">
                    <h4 className="text-xs font-black text-slate-400 uppercase tracking-widest">{t.resources}</h4>
                    <div className="flex flex-col gap-2">
                        <button onClick={onContentOpen} className="flex items-center justify-center md:justify-start gap-2 text-slate-600 hover:text-indigo-600 font-bold transition-colors">
                            <Map size={16} /> {t.content_map}
                        </button>
                        <button onClick={onLgrOpen} className="flex items-center justify-center md:justify-start gap-2 text-slate-600 hover:text-indigo-600 font-bold transition-colors">
                            <Book size={16} /> {t.lgr_link}
                        </button>
                    </div>
                </div>

                <div className="space-y-4">
                    <h4 className="text-xs font-black text-slate-400 uppercase tracking-widest">Support</h4>
                    <div className="flex flex-col gap-2">
                        <button onClick={onAboutOpen} className="flex items-center justify-center md:justify-start gap-2 text-slate-600 hover:text-indigo-600 font-bold transition-colors">
                            <Info size={16} /> {t.about_link}
                        </button>
                    </div>
                </div>

                <div className="flex flex-col items-center md:items-end justify-center">
                    <h2 className="text-3xl font-black text-slate-200 tracking-tighter italic">
                        {lang === 'sv' ? 'ANPASSA' : 'ADAPT'}
                    </h2>
                    <p className="text-[10px] text-slate-400 mt-1 uppercase font-bold">{t.brand_motto}</p>
                </div>
            </footer>
        </div>
    );
};

export default Dashboard;

// FILE END: src\components\views\Dashboard.jsx

// =======================================================
// FILE START: src\components\views\DoNowConfig.jsx
// =======================================================

import React, { useState } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const DoNowConfig = ({ ui, onBack, onGenerate, lang }) => {
    const [selected, setSelected] = useState([]);

    const handleToggle = (topicId, level) => {
        setSelected(prev => {
            const exists = prev.find(p => p.topic === topicId && p.level === level);
            if (exists) {
                return prev.filter(p => !(p.topic === topicId && p.level === level));
            } else {
                if (prev.length >= 3) return prev; // Max 3
                return [...prev, { topic: topicId, level }];
            }
        });
    };

    return (
        <div className="max-w-5xl mx-auto p-6 h-full flex flex-col">
            <div className="flex justify-between items-center mb-6">
                <button onClick={onBack} className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2">
                    <span>‚Üê</span> {ui.backBtn}
                </button>
                <h2 className="text-2xl font-bold text-slate-800">{ui.donow_title}</h2>
                <button
                    onClick={() => onGenerate(selected)}
                    disabled={selected.length === 0}
                    className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
                >
                    {ui.donow_gen} ({selected.length}/3)
                </button>
            </div>

            <p className="text-slate-500 mb-6 text-center">{ui.donow_desc}</p>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-6 overflow-y-auto custom-scrollbar pb-10">
                {Object.entries(CATEGORIES).map(([catKey, category]) => (
                    <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                        <h3 className="font-bold text-slate-700 mb-3 border-b pb-2">{category.label[lang]}</h3>
                        <div className="space-y-4">
                            {category.topics.map(topic => (
                                <div key={topic.id}>
                                    <div className="text-xs font-bold text-slate-400 uppercase mb-2">{topic.label[lang]}</div>
                                    <div className="flex flex-col gap-2">
                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                            if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                            const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);
                                            return (
                                                <button
                                                    key={lvl}
                                                    onClick={() => handleToggle(topic.id, lvl)}
                                                    className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${isSelected ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'}`}
                                                >
                                                    <span className="font-mono font-bold w-6 text-center bg-white/50 rounded">{lvl}</span>
                                                    <span className="truncate">{LEVEL_DESCRIPTIONS[topic.id][lvl][lang]}</span>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default DoNowConfig;

// FILE END: src\components\views\DoNowConfig.jsx

// =======================================================
// FILE START: src\components\views\DoNowGrid.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
// FIX: Lagt till .jsx fil√§ndelse och importerat alla n√∂dv√§ndiga komponenter fr√•n god-filen
import { GeometryVisual, GraphCanvas, VolumeVisualization } from '../visuals/GeometryComponents.jsx';
import { X, Maximize, Minimize, ZoomIn, ZoomOut, RefreshCw, Eye, EyeOff } from 'lucide-react';

/**
 * MATH DISPLAY COMPONENT
 * Renders LaTeX content using KaTeX if available.
 */
const MathDisplay = ({ content, className }) => {
    const containerRef = useRef(null);
    useEffect(() => {
        const doRender = () => {
            if (window.renderMathInElement && containerRef.current) {
                window.renderMathInElement(containerRef.current, {
                    delimiters: [{ left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }],
                    throwOnError: false
                });
            }
        };
        if (content) {
            if (window.renderMathInElement) doRender();
            else { 
                const i = setInterval(() => { 
                    if (window.renderMathInElement) { 
                        doRender(); 
                        clearInterval(i); 
                    } 
                }, 100); 
                return () => clearInterval(i); 
            }
        }
    }, [content]);
    return <div ref={containerRef} className={className}>{content}</div>;
};

// Tillg√§ngliga textstorlekar f√∂r projektoroptimering
const TEXT_SIZES = ['text-sm', 'text-base', 'text-lg', 'text-xl', 'text-2xl', 'text-3xl'];

/**
 * DO NOW CARD COMPONENT
 * Individual task card with visual support and answer reveal.
 */
const DoNowCard = ({ index, q, showAnswer, onToggleAnswer, onFocus, lang, textSizeClass, isFocused = false }) => {
    const decode = (str) => { try { return atob(str); } catch { return str; } };

    const renderVisualContent = () => {
        if (!q.renderData) return null;
        if (q.renderData.graph) return <GraphCanvas data={q.renderData.graph} />;
        if (q.renderData.geometry) {
            const geom = q.renderData.geometry;
            const volumeTypes = ['cuboid', 'cylinder', 'cone', 'sphere', 'hemisphere', 'pyramid', 'triangular_prism', 'silo', 'ice_cream', 'volume'];
            if (volumeTypes.includes(geom.type)) {
                return <VolumeVisualization data={geom} width={isFocused ? 400 : 280} height={isFocused ? 250 : 180} />;
            }
            return <GeometryVisual data={geom} />;
        }
        return null;
    };

    const hasVisual = q.renderData?.graph || q.renderData?.geometry;

    return (
        <div 
            onClick={onFocus}
            className={`relative rounded-[1.5rem] border-2 transition-all flex flex-col overflow-hidden h-full select-none shadow-sm group
            ${isFocused ? 'bg-white border-indigo-500 shadow-2xl' : 'bg-white border-slate-200 hover:border-indigo-400 hover:shadow-md cursor-zoom-in'}
            ${showAnswer && !isFocused ? 'bg-emerald-50 border-emerald-500 ring-4 ring-emerald-500/10' : ''}`}
        >
            {/* Header */}
            <div className={`px-4 py-2 flex justify-between items-center border-b transition-colors ${showAnswer && !isFocused ? 'bg-emerald-100/50 border-emerald-200' : 'bg-slate-50 border-slate-100'}`}>
                <span className={`text-[10px] font-black uppercase tracking-widest ${showAnswer && !isFocused ? 'text-emerald-700' : 'text-slate-400'}`}>
                    {lang === 'sv' ? 'Uppgift' : 'Task'} {index + 1}
                </span>
                {q.topic && (
                    <span className="text-[9px] font-bold text-slate-400 uppercase tracking-tighter bg-white px-2 py-0.5 rounded-full border border-slate-200">
                        {q.topic.split('_')[0]}
                    </span>
                )}
            </div>

            {/* Content Area - Added significantly higher padding when in focus mode */}
            <div className={`flex-1 flex flex-col justify-center items-center text-center relative overflow-hidden transition-all duration-300 
                ${isFocused ? 'p-12 md:p-16 lg:p-24' : 'p-4'}`}>
                
                {hasVisual && (
                    <div className={`w-full flex justify-center items-center ${isFocused ? 'mb-12' : 'mb-6'}`}>
                        <div className="transform scale-110 lg:scale-125 origin-center">
                            {renderVisualContent()}
                        </div>
                    </div>
                )}
                
                {/* Question Text - Increased horizontal padding when focused to prevent border collision */}
                <div className={`font-bold text-slate-800 leading-tight ${textSizeClass} transition-all my-auto ${isFocused ? 'px-12 md:px-20' : 'px-2'}`}>
                    <MathDisplay content={q.renderData?.description} />
                    {q.renderData?.latex && (
                        <div className={`text-indigo-600 font-serif ${isFocused ? 'mt-6' : 'mt-3'}`}>
                            <MathDisplay content={`$$${q.renderData.latex}$$`} />
                        </div>
                    )}
                </div>
                
                {/* Options - Spaced out more when focused */}
                {q.renderData?.options && q.renderData.options.length > 0 && (
                    <div className={`grid grid-cols-2 gap-4 w-full ${isFocused ? 'mt-12 px-12 pb-12' : 'mt-6 px-2 pb-2'}`}>
                        {q.renderData.options.map((opt, idx) => (
                            <div key={idx} className={`bg-white border-2 border-slate-100 rounded-xl flex items-center gap-3 shadow-sm
                                ${isFocused ? 'p-6 text-xl' : 'p-3 text-base font-bold text-left text-slate-700'}`}>
                                <span className="w-8 h-8 shrink-0 bg-slate-100 text-slate-400 rounded-lg flex items-center justify-center text-xs font-black">
                                    {String.fromCharCode(65 + idx)}
                                </span>
                                <MathDisplay className="truncate" content={opt} />
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {/* Answer Toggle Button (Discrete in corner) */}
            {!isFocused && (
                <button 
                    onClick={(e) => { e.stopPropagation(); onToggleAnswer(); }}
                    className={`absolute bottom-3 right-3 w-10 h-10 rounded-full flex items-center justify-center transition-all shadow-md active:scale-90
                    ${showAnswer ? 'bg-emerald-600 text-white' : 'bg-white text-slate-400 border border-slate-200 hover:text-indigo-600 hover:border-indigo-200'}`}
                    title={lang === 'sv' ? "Visa/D√∂lj svar" : "Show/Hide answer"}
                >
                    {showAnswer ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
            )}

            {/* Answer Footer (Shown when active) */}
            {showAnswer && (
                <div className={`bg-emerald-600 text-white py-4 text-center shrink-0 animate-in slide-in-from-bottom duration-300 ${isFocused ? 'mt-auto' : ''}`}>
                    <div className="text-xs font-black uppercase tracking-[0.2em] mb-1 opacity-80">FACIT</div>
                    <div className={`${isFocused ? 'text-5xl' : 'text-3xl'} font-black tracking-tighter leading-none`}>
                        <MathDisplay content={decode(q.token)} />
                        {q.renderData?.suffix && <span className={`${isFocused ? 'text-2xl' : 'text-lg'} ml-2 opacity-90 uppercase`}>{q.renderData.suffix}</span>}
                    </div>
                </div>
            )}
        </div>
    );
};

export default function DoNowGrid({ questions, ui, onBack, onClose, lang, onRefreshAll }) {
    const [revealed, setRevealed] = useState({});
    const [focusedIndex, setFocusedIndex] = useState(null);
    const [showAll, setShowAll] = useState(false);
    const [isFullscreen, setIsFullscreen] = useState(false);
    const [textSizeIndex, setTextSizeIndex] = useState(3); // Default: text-xl

    useEffect(() => {
        const handleEsc = (e) => { if (e.key === 'Escape') setFocusedIndex(null); };
        window.addEventListener('keydown', handleEsc);
        return () => {
            window.removeEventListener('keydown', handleEsc);
            if (document.fullscreenElement) document.exitFullscreen().catch(() => {});
        };
    }, []);

    const toggleFullscreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => setIsFullscreen(true)).catch(e => console.error(e));
        } else {
            if (document.exitFullscreen) document.exitFullscreen().then(() => setIsFullscreen(false));
        }
    };

    const handleSafeExit = (callback) => {
        if (document.fullscreenElement) document.exitFullscreen().finally(() => callback());
        else callback();
    };

    const toggleOne = (i) => setRevealed(prev => ({ ...prev, [i]: !prev[i] }));
    
    const toggleAll = () => {
        if (showAll) setRevealed({});
        else {
            const all = {};
            questions.forEach((_, i) => all[i] = true);
            setRevealed(all);
        }
        setShowAll(!showAll);
    };

    const adjustText = (delta) => {
        setTextSizeIndex(prev => Math.max(0, Math.min(prev + delta, TEXT_SIZES.length - 1)));
    };

    const handleRefresh = () => {
        setRevealed({}); 
        setShowAll(false); 
        setFocusedIndex(null);
        onRefreshAll();
    };

    return (
        <div className="h-screen w-screen bg-slate-200 flex flex-col overflow-hidden font-sans relative">
            
            {/* Whiteboard Focus Overlay */}
            {focusedIndex !== null && (
                <div 
                    className="fixed inset-0 z-[60] bg-white/95 backdrop-blur-sm flex items-start justify-center pt-16 px-12 pb-12 animate-in fade-in duration-300 cursor-zoom-out"
                    onClick={() => setFocusedIndex(null)}
                >
                    <div 
                        className="w-full max-w-5xl h-auto transform lg:scale-105 shadow-2xl rounded-[3rem] cursor-default bg-white border border-slate-200"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <DoNowCard 
                            index={focusedIndex} 
                            q={questions[focusedIndex]} 
                            showAnswer={!!revealed[focusedIndex]} 
                            onToggleAnswer={() => toggleOne(focusedIndex)}
                            onFocus={() => {}}
                            lang={lang} 
                            textSizeClass="text-4xl"
                            isFocused={true}
                        />
                    </div>
                    {/* Floating Close Hint */}
                    <div className="absolute bottom-8 left-1/2 -translate-x-1/2 px-6 py-2 bg-slate-900/10 text-slate-400 rounded-full font-black text-xs uppercase tracking-widest pointer-events-none">
                        {lang === 'sv' ? 'Klicka utanf√∂r f√∂r att √•terg√•' : 'Click outside to return'}
                    </div>
                </div>
            )}

            {/* Header */}
            <header className="bg-slate-900 text-white px-6 py-3 shrink-0 flex justify-between items-center shadow-2xl z-20">
                <div className="flex items-center gap-6">
                    <button 
                        onClick={() => handleSafeExit(onBack)} 
                        className="group flex items-center gap-2 text-slate-400 hover:text-white font-black text-xs uppercase tracking-widest transition-all"
                    >
                        <div className="w-8 h-8 rounded-lg bg-white/5 flex items-center justify-center group-hover:bg-indigo-600 transition-colors">‚Üê</div>
                        STUDIO
                    </button>
                    <div className="h-6 w-px bg-slate-700"></div>
                    <div className="flex flex-col">
                        <h1 className="text-base font-black tracking-tighter italic text-indigo-400 leading-none">DO NOW GRID</h1>
                        <span className="text-[9px] font-bold text-slate-500 tracking-widest uppercase">Classroom Session</span>
                    </div>
                </div>

                <div className="flex items-center gap-3">
                    <div className="flex items-center bg-white/10 rounded-xl p-1 border border-white/10 mr-4">
                        <button onClick={() => adjustText(-1)} className="p-2 hover:bg-white/10 rounded-lg text-slate-300 transition-colors"><ZoomOut size={18} /></button>
                        <div className="w-px h-4 bg-white/10 mx-1"></div>
                        <button onClick={() => adjustText(1)} className="p-2 hover:bg-white/10 rounded-lg text-slate-300 transition-colors"><ZoomIn size={18} /></button>
                    </div>

                    <button 
                        onClick={handleRefresh} 
                        className="px-5 py-2.5 bg-indigo-600/20 hover:bg-indigo-600 text-indigo-400 hover:text-white rounded-xl text-xs font-black transition-all uppercase tracking-wider border border-indigo-500/30 flex items-center gap-2"
                    >
                        <RefreshCw size={14} /> {lang === 'sv' ? 'NYTT SET' : 'NEW SET'}
                    </button>

                    <button 
                        onClick={toggleAll} 
                        className={`px-6 py-2.5 rounded-xl font-black text-xs transition-all shadow-lg flex items-center gap-2 uppercase tracking-widest ${showAll ? 'bg-rose-500 text-white hover:bg-rose-600' : 'bg-emerald-500 text-white hover:bg-emerald-600'}`}
                    >
                        <span>{showAll ? 'üôà' : 'üëÅÔ∏è'}</span>
                        {showAll ? (lang === 'sv' ? "D√ñLJ FACIT" : "HIDE ANSWERS") : (lang === 'sv' ? "VISA FACIT" : "SHOW ANSWERS")}
                    </button>
                    
                    <div className="h-6 w-px bg-slate-700 mx-2"></div>

                    <button onClick={toggleFullscreen} className="text-slate-400 hover:text-white transition-colors p-2 bg-white/5 rounded-xl">
                        {isFullscreen ? <Minimize size={20} /> : <Maximize size={20} />}
                    </button>

                    <button onClick={() => handleSafeExit(onClose)} className="text-slate-400 hover:text-rose-500 transition-colors p-2 bg-white/5 rounded-xl"><X size={20} /></button>
                </div>
            </header>

            {/* Grid Container */}
            <main className="flex-1 p-6 overflow-hidden">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 grid-rows-2 gap-6 h-full w-full max-w-[1800px] mx-auto">
                    {questions.slice(0, 6).map((q, i) => (
                        <div key={i} className="min-h-0 min-w-0">
                            <DoNowCard 
                                index={i} 
                                q={q} 
                                showAnswer={!!revealed[i]} 
                                onToggleAnswer={() => toggleOne(i)} 
                                onFocus={() => setFocusedIndex(i)}
                                lang={lang} 
                                textSizeClass={TEXT_SIZES[textSizeIndex]} 
                            />
                        </div>
                    ))}
                </div>
            </main>
        </div>
    );
}

// FILE END: src\components\views\DoNowGrid.jsx

// =======================================================
// FILE START: src\components\views\PracticeView.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual, StaticGeometryVisual } from '../visuals/GeometryComponents';
import CluePanel from '../practice/CluePanel';
import HistoryList from '../practice/HistoryList';
import LevelUpModal from '../modals/LevelUpModal';
import { LEVEL_DESCRIPTIONS, CATEGORIES } from '../../constants/localization'; 
import { FractionInput, ScientificInput } from '../ui/InputComponents';

const PracticeView = ({ 
    lang, ui, question, loading, feedback, input, setInput, 
    handleSubmit, handleHint, handleSolution, handleSkip, 
    handleChangeLevel, revealedClues, uiState, actions, 
    levelUpAvailable, setLevelUpAvailable, isSolutionRevealed, 
    timerSettings, formatTime
}) => {
    const [scaleInputLeft, setScaleInputLeft] = useState('');
    const [scaleInputRight, setScaleInputRight] = useState('');
    const [powerBase, setPowerBase] = useState('');
    const [powerExp, setPowerExp] = useState('');
    const [sciMantissa, setSciMantissa] = useState('');
    const [sciExp, setSciExp] = useState('');

    const inputRef = useRef(null);
    const [shake, setShake] = useState(false);
    const retryRef = useRef(actions.retry);

    useEffect(() => { retryRef.current = actions.retry; }, [actions.retry]);
    
    useEffect(() => {
        if (feedback === 'correct' && isSolutionRevealed) {
            const timer = setTimeout(() => { retryRef.current(); }, 1500);
            return () => clearTimeout(timer);
        }
    }, [feedback, isSolutionRevealed]);

    useEffect(() => {
        if (question && !loading) {
            setScaleInputLeft(''); setScaleInputRight('');
            setPowerBase(question.renderData.prefillBase || '');
            setPowerExp(''); setSciMantissa(''); setSciExp('');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            if (window.innerWidth >= 768 && !feedback && !levelUpAvailable && inputRef.current) {
                setTimeout(() => inputRef.current?.focus(), 50);
            }
        }
    }, [question, loading, feedback, levelUpAvailable]);

    const descriptionText = typeof question?.renderData?.description === 'object' ? question.renderData.description[lang] : question?.renderData?.description;
    
    const handleChoiceClick = (choice) => { 
        if (feedback === 'correct') return; 
        setInput(choice); 
        handleSubmit({ preventDefault: () => { } }, choice); 
    };

    const renderVisual = () => {
        if (!question?.renderData) return null;
        if (question.renderData.graph) return <GraphCanvas data={question.renderData.graph} />;
        const geom = question.renderData.geometry;
        if (geom) {
            if (geom.type === 'frequency_table') return <GeometryVisual data={geom} />; 
            const volumeTypes = ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'];
            if (volumeTypes.includes(geom.type)) return <VolumeVisualization data={geom} />;
            return <GeometryVisual data={geom} />;
        }
        if (uiState.topic === 'geometry') return <StaticGeometryVisual description={descriptionText} />;
        if (question.renderData.latex) {
             return <div className="text-2xl sm:text-4xl font-serif text-indigo-600 my-2 text-center overflow-x-auto py-1"><MathText text={`$$${question.renderData.latex}$$`} large={true} /></div>;
        }
        return null;
    };

    const getSubmitLabel = () => {
        if (feedback === 'correct') return ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°");
        if (feedback === 'incorrect') return ui.tagWrong || "Incorrect";
        return ui.btnCheck || (lang === 'sv' ? "Svara" : "Submit");
    };

    // Localization for Topic and Sidebar Titles
    const localizedTopic = CATEGORIES[uiState.topic] ? CATEGORIES[uiState.topic][lang] : uiState.topic;
    const cluesLabel = ui.hintsTitle || (lang === 'sv' ? "Ledtr√•dar" : "Hints");
    const historyLabel = ui.historyTitle || (lang === 'sv' ? "Historik" : "History");

    const maxLevels = Object.keys(LEVEL_DESCRIPTIONS[uiState.topic] || {}).length;

    return (
        <div className="max-w-7xl mx-auto w-full p-2 sm:p-4 fade-in min-h-screen">
            <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => { setLevelUpAvailable(false); actions.retry(true); }} lang={lang} />
            
            {/* STICKY HEADER */}
            <header className="flex justify-between items-center mb-4 bg-white/90 backdrop-blur-md p-2 px-4 rounded-2xl shadow-sm border border-slate-100 sticky top-2 z-20">
                <div className="flex-shrink-0">
                    <button onClick={actions.goBack} className="text-slate-500 hover:text-indigo-600 font-bold text-[10px] uppercase tracking-wider transition-all">
                        <span>‚Üê</span> {ui.backBtn}
                    </button>
                </div>

                <div className="flex-1 text-center px-4 overflow-hidden">
                    <span className="text-[10px] font-black uppercase tracking-[0.2em] text-slate-400 italic block truncate">
                        {localizedTopic}
                    </span>
                </div>

                <div className="flex-shrink-0 flex items-center gap-2">
                    {timerSettings.isActive && (
                        <div className={`font-mono text-[10px] font-bold px-2 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-rose-50 text-rose-600 border-rose-100' : 'bg-slate-50 text-slate-400 border-slate-100'}`}>
                            {formatTime(timerSettings.remaining)}
                        </div>
                    )}
                    <div className="flex items-center bg-indigo-50 rounded-xl p-1 border border-indigo-100">
                        <button onClick={() => handleChangeLevel(-1)} disabled={uiState.level <= 1} className="w-6 h-6 flex items-center justify-center rounded-lg hover:bg-white text-indigo-400 disabled:opacity-20 text-xs">&lt;</button>
                        <span className="text-[9px] font-black uppercase px-2 text-indigo-700 italic min-w-[50px] text-center">
                            {uiState.level < maxLevels ? `Lv ${uiState.level}` : 'MAX'}
                        </span>
                        <button onClick={() => handleChangeLevel(1)} disabled={uiState.level >= maxLevels} className="w-6 h-6 flex items-center justify-center rounded-lg hover:bg-white text-indigo-400 disabled:opacity-20 text-xs">&gt;</button>
                    </div>
                </div>
            </header>

            <div className="flex flex-col lg:flex-row gap-4 items-start">
                <main className="flex-1 w-full bg-white rounded-3xl shadow-xl overflow-hidden border border-slate-100">
                    {loading ? (
                        <div className="py-20 text-center"><div className="w-8 h-8 border-4 border-t-indigo-600 rounded-full animate-spin mx-auto"></div></div>
                    ) : (
                        <div className="p-4 sm:p-6 lg:p-8">
                            <div className="mb-4 flex justify-center bg-slate-50 rounded-2xl p-4 min-h-[160px] max-h-[280px] items-center border border-slate-100 shadow-inner relative overflow-hidden">
                                {renderVisual()}
                            </div>
                            
                            <div className="mb-6 text-center max-w-xl mx-auto">
                                <h2 className="text-lg sm:text-xl font-medium text-slate-700 leading-snug">
                                    <MathText text={descriptionText} />
                                </h2>
                            </div>
                            
                            <div className="max-w-sm mx-auto">
                                {question.renderData.answerType === 'multiple_choice' ? (
                                    <div className="grid grid-cols-1 gap-2">
                                        {(question.renderData.options || []).map((choice, idx) => (
                                            <button key={idx} onClick={() => handleChoiceClick(choice)} className={`p-3 rounded-xl font-bold text-base transition-all border-2 text-left flex items-center gap-3 ${feedback === 'correct' && choice === input ? 'bg-emerald-500 border-emerald-500 text-white' : 'bg-white border-slate-100 text-slate-600 hover:border-indigo-400'}`} disabled={feedback !== null}>
                                                <span className="w-5 h-5 rounded-md bg-slate-100 text-slate-400 flex items-center justify-center text-[9px]">{String.fromCharCode(65 + idx)}</span>
                                                <MathText text={choice} />
                                            </button>
                                        ))}
                                    </div>
                                ) : (
                                    <form onSubmit={(e) => { e.preventDefault(); if (feedback !== 'correct') handleSubmit(e, input); else actions.retry(true); }} className="space-y-4">
                                        <div className={`relative ${shake ? 'animate-shake' : ''}`}>
                                            {question.renderData.answerType === 'fraction' ? (
                                                <div className="flex justify-center py-2 scale-90"><FractionInput value={input} onChange={setInput} allowMixed={true} autoFocus={false} /></div>
                                            ) : (
                                                <input ref={inputRef} type="text" value={input} onChange={(e) => setInput(e.target.value)} className="w-full p-4 text-center text-2xl font-bold border-2 rounded-2xl outline-none transition-all border-slate-100 bg-slate-50 focus:border-indigo-500" placeholder="?" disabled={feedback === 'correct'} />
                                            )}
                                            {question.renderData.answerType === 'structured_scientific' && (
                                                <div className="flex justify-center py-4">
                                                <ScientificInput value={input} onChange={setInput} autoFocus={true} />
                                                </div>
                                            )}
                                            {feedback === 'correct' && <div className="absolute -right-3 -top-3 text-2xl">‚úÖ</div>}
                                        </div>
                                        <button type="submit" className={`w-full py-3 rounded-xl font-bold text-lg text-white transition-all ${feedback === 'correct' ? 'bg-emerald-500' : 'bg-indigo-600 shadow-lg'}`}>
                                            {getSubmitLabel()}
                                        </button>
                                    </form>
                                )}
                            </div>

                            <div className="mt-6 flex gap-2 justify-center">
                                <button onClick={handleHint} disabled={!question.clues || revealedClues.length >= question.clues.length} className="px-3 py-1.5 text-[9px] font-bold uppercase tracking-wider rounded-lg bg-amber-50 text-amber-700 border border-amber-100 disabled:opacity-30">üí° {ui.btnHint}</button>
                                <button onClick={handleSolution} disabled={!question.clues || isSolutionRevealed} className="px-3 py-1.5 text-[9px] font-bold uppercase tracking-wider rounded-lg bg-slate-100 text-slate-500 border border-slate-200 disabled:opacity-30">üîë {ui.btnSolution}</button>
                                <button onClick={handleSkip} className="px-3 py-1.5 text-[9px] font-bold uppercase tracking-wider rounded-lg bg-indigo-50 text-indigo-600 border border-indigo-100">‚è≠Ô∏è {ui.btnSkip}</button>
                            </div>
                        </div>
                    )}
                </main>

                <aside className="w-full lg:w-72 shrink-0 flex flex-col gap-4">
                    {/* Clue Panel */}
                    <div className="bg-white rounded-3xl p-5 shadow-lg border border-slate-100 flex-1 min-h-[140px]">
                        <div className="flex items-center gap-2 mb-3">
                            <span className="text-xs">üí°</span>
                            <h3 className="text-[9px] font-black uppercase tracking-widest text-slate-400 italic">
                                {cluesLabel}
                            </h3>
                        </div>
                        <CluePanel 
                            revealedClues={revealedClues} 
                            question={question} 
                            ui={ui} 
                            isSolutionRevealed={isSolutionRevealed}
                            lang={lang} 
                        />
                    </div>
                    
                    {/* History Panel */}
                    <div className="bg-white rounded-3xl p-5 shadow-lg border border-slate-100 h-[240px] flex flex-col">
                        <div className="flex items-center gap-2 mb-3">
                            <span className="text-xs">üìú</span>
                            <h3 className="text-[9px] font-black uppercase tracking-widest text-slate-400 italic">
                                {historyLabel}
                            </h3>
                        </div>
                        <div className="flex-1 overflow-y-auto custom-scrollbar pr-1">
                            <HistoryList history={uiState.history} ui={ui} />
                        </div>
                    </div>
                </aside>
            </div>
        </div>
    );
};

export default PracticeView;

// FILE END: src\components\views\PracticeView.jsx

// =======================================================
// FILE START: src\components\views\QuestionStudio.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import { 
  ChevronRight, Plus, Trash2, Layout, Send, Info, Layers, Search, Zap, FileText, Grid3X3, RefreshCcw, Bug, Loader2, Maximize2, CheckCircle2, AlertTriangle, Filter
} from 'lucide-react';
import { SKILL_BUCKETS } from '../../constants/skillBuckets.js';

// --- VISUAL COMPONENT IMPORTS ---
import { GeometryVisual, GraphCanvas, VolumeVisualization } from '../visuals/GeometryComponents.jsx';

// --- THEME CONFIGURATION ---
const CATEGORY_THEMES = {
  algebra: { bg: 'bg-indigo-100', text: 'text-indigo-700', border: 'border-indigo-200', icon: 'bg-indigo-500' },
  arithmetic: { bg: 'bg-emerald-100', text: 'text-emerald-700', border: 'border-emerald-200', icon: 'bg-emerald-500' },
  geometry_cat: { bg: 'bg-amber-100', text: 'text-amber-700', border: 'border-amber-200', icon: 'bg-amber-500' },
  data: { bg: 'bg-rose-100', text: 'text-rose-700', border: 'border-rose-200', icon: 'bg-rose-500' }
};

const MathDisplay = ({ content }) => {
    const containerRef = useRef(null);

    useEffect(() => {
        const loadKaTeX = () => {
            if (!document.getElementById('katex-css')) {
                const link = document.createElement('link');
                link.id = 'katex-css';
                link.rel = 'stylesheet';
                link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
                document.head.appendChild(link);
            }

            if (!window.renderMathInElement) {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
                script.onload = () => {
                    const autoRender = document.createElement('script');
                    autoRender.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js';
                    autoRender.onload = doRender;
                    document.head.appendChild(autoRender);
                };
                document.head.appendChild(script);
            } else {
                doRender();
            }
        };

        const doRender = () => {
            if (window.renderMathInElement && containerRef.current) {
                window.renderMathInElement(containerRef.current, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                    ],
                    throwOnError: false
                });
            }
        };

        if (content) loadKaTeX();
    }, [content]);

    return (
        <div ref={containerRef} className="math-content leading-relaxed whitespace-pre-wrap text-inherit">
            {content}
        </div>
    );
};

export default function QuestionStudio({ onDoNowGenerate, ui, lang = 'sv', initialPacket }) {
  // --- INTERNAL TRANSLATIONS ---
  const TEXT = {
    sv: {
      studio: "Studio",
      donow_title: "Do Now Grid",
      donow_desc: "Rutn√§t f√∂r gemensam uppstart p√• tavlan.",
      worksheet_title: "Arbetsblad",
      worksheet_desc: "Anpassade arbetsblad till elever.",
      library: "Bibliotek",
      change_mode: "Byt l√§ge",
      search_placeholder: "S√∂k omr√•de...",
      sections_label: "Avsnitt",
      variants_label: "Varianter",
      basic_group: "Grundl√§ggande",
      board_label: "Tavlan",
      new_example: "Nytt exempel",
      preview_error: "Kunde inte ladda f√∂rhandsgranskning",
      preview_error_hint: "Kontrollera att backend-generatorn √§r korrekt kopplad.",
      select_hint: "V√§lj variation f√∂r att f√∂rhandsgranska",
      hint_label: "Ledtr√•d",
      no_hint: "Ingen ledtr√•d tillg√§nglig.",
      selected_questions: "Utvalda fr√•gor",
      empty_packet: "Inga fr√•gor",
      create_donow: "Skapa",
      publish: "Publicera",
      close: "St√§ng"
    },
    en: {
      studio: "Studio",
      donow_title: "Do Now Grid",
      donow_desc: "Grid for shared lesson starters on the board.",
      worksheet_title: "Worksheet",
      worksheet_desc: "Custom worksheets for students.",
      library: "Library",
      change_mode: "Change mode",
      search_placeholder: "Search topics...",
      sections_label: "Sections",
      variants_label: "Variants",
      basic_group: "Basics",
      board_label: "The Board",
      new_example: "New Example",
      preview_error: "Could not load preview",
      preview_error_hint: "Check that the backend generator is correctly connected.",
      select_hint: "Select a variation to preview",
      hint_label: "Hint",
      no_hint: "No hint available.",
      selected_questions: "Selected Questions",
      empty_packet: "Empty packet",
      create_donow: "Create",
      publish: "Publish",
      close: "Close"
    }
  };

  const t = TEXT[lang] || TEXT.sv;

  // If we have an initial packet, default to 'donow' mode so the user sees their cart
  const [setupMode, setSetupMode] = useState(initialPacket && initialPacket.length > 0 ? 'donow' : null); 
  const [selectedTopicId, setSelectedTopicId] = useState('basic_arithmetic');
  
  // Initialize packet with the saved state if available
  const [packet, setPacket] = useState(initialPacket || []);
  
  const [previewData, setPreviewData] = useState(null);
  const [activePreviewKey, setActivePreviewKey] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [isPreviewLoading, setIsPreviewLoading] = useState(false);
  const [previewError, setPreviewError] = useState(null);

  useEffect(() => {
    setPreviewData(null);
    setActivePreviewKey(null);
    setPreviewError(null);
  }, [selectedTopicId]);

  // Refactored to handle localized object in SKILL_BUCKETS
  const allTopics = Object.values(SKILL_BUCKETS).flatMap(cat => 
    Object.entries(cat.topics).map(([id, data]) => ({ 
        id, 
        categoryName: cat.name[lang], 
        categoryId: cat.id, 
        ...data 
    }))
  );

  const currentTopic = allTopics.find(tp => tp.id === selectedTopicId) || allTopics[0];

  // --- SMART GROUPING ---
  const groupedVariations = React.useMemo(() => {
    if (!currentTopic?.variations) return {};
    const groups = {};
    
    currentTopic.variations.forEach(v => {
        const localizedName = v.name[lang] || v.name.sv || "";
        const parts = localizedName.split(':');
        const groupName = parts.length > 1 ? parts[0].trim() : t.basic_group;
        const displayName = parts.length > 1 ? parts.slice(1).join(':').trim() : localizedName;
        
        if (!groups[groupName]) groups[groupName] = [];
        groups[groupName].push({ ...v, displayName });
    });
    
    return groups;
  }, [currentTopic, lang, t.basic_group]);

  const triggerPreview = async (variationKey) => {
    setIsPreviewLoading(true);
    setActivePreviewKey(variationKey);
    setPreviewError(null);
    setPreviewData(null); 

    try {
        const currentLang = lang || 'sv';
        const res = await fetch(`/api/question?topic=${selectedTopicId}&variation=${variationKey}&lang=${currentLang}`);
        
        if (!res.ok) {
            throw new Error(`Server returned ${res.status}`);
        }

        const data = await res.json();
        
        if (!data || !data.renderData) {
            throw new Error("Invalid data format from generator");
        }

        setPreviewData(data);
    } catch (err) {
        console.error("Preview failed:", err);
        setPreviewError(err.message || t.preview_error);
    } finally {
        setIsPreviewLoading(false);
    }
  };

  const addToPacket = (variation) => {
    if (setupMode === 'donow' && packet.length >= 6) return; 
    setPacket([...packet, {
      id: crypto.randomUUID(),
      topicId: selectedTopicId,
      variationKey: variation.key,
      name: variation.name[lang] || variation.name.sv, // Store the localized name string
      quantity: setupMode === 'donow' ? 1 : 5, 
    }]);
  };

  const removeFromPacket = (id) => setPacket(packet.filter(p => p.id !== id));

  const handleFinalAction = () => {
    if (typeof onDoNowGenerate !== 'function') return;

    if (setupMode === 'donow') {
      const config = packet.map(p => {
          const levelMatch = p.variationKey.match(/\d+/);
          const extractedLevel = levelMatch ? parseInt(levelMatch[0]) : 1;

          return {
            topic: p.topicId,
            level: extractedLevel, 
            variation: p.variationKey 
          };
      });
      onDoNowGenerate(config, packet);
    }
  };

  /**
   * REFINED VISUAL RENDERER
   * Uses the central GeometryVisual dispatcher to handle all complex shapes
   * (House, Portal, L-shape) as well as Graphs and Volume.
   */
  const renderVisual = () => {
    if (!previewData?.renderData) return null;
    
    if (previewData.renderData.graph) {
        return (
            <div className="scale-90 origin-top transform-gpu">
                <GraphCanvas data={previewData.renderData.graph} />
            </div>
        );
    }

    if (previewData.renderData.geometry) {
        const data = previewData.renderData.geometry;
        return (
            <div className="scale-90 lg:scale-100 origin-top transform-gpu flex justify-center w-full">
                <GeometryVisual data={data} />
            </div>
        );
    }

    return null;
  };

  const filteredTopics = allTopics.filter(tp => 
    tp.name[lang].toLowerCase().includes(searchTerm.toLowerCase()) || 
    tp.categoryName.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (!setupMode) {
    return (
      <div className="flex-1 flex flex-col items-center justify-center bg-slate-50 p-6">
        <div className="max-w-4xl w-full text-center space-y-12 animate-in fade-in zoom-in-95 duration-500">
            <h2 className="text-6xl font-black text-slate-900 tracking-tighter uppercase italic tracking-widest">{t.studio}</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <button onClick={() => setSetupMode('donow')} className="group p-12 bg-white border-2 border-slate-100 rounded-[3rem] hover:border-indigo-600 hover:shadow-2xl transition-all text-left">
                    <div className="w-20 h-20 bg-indigo-50 rounded-3xl flex items-center justify-center text-indigo-600 mb-6 group-hover:scale-110 transition-transform"><Grid3X3 size={40} /></div>
                    <h3 className="text-3xl font-black text-slate-800 mb-2 uppercase tracking-tighter">{t.donow_title}</h3>
                    <p className="text-lg text-slate-500 leading-relaxed font-medium">{t.donow_desc}</p>
                </button>
                <button onClick={() => setSetupMode('worksheet')} className="group p-12 bg-white border-2 border-slate-100 rounded-[3rem] hover:border-emerald-600 hover:shadow-2xl transition-all text-left">
                    <div className="w-20 h-20 bg-emerald-50 rounded-3xl flex items-center justify-center text-emerald-600 mb-6 group-hover:scale-110 transition-transform"><FileText size={40} /></div>
                    <h3 className="text-3xl font-black text-slate-800 mb-2 uppercase tracking-tighter">{t.worksheet_title}</h3>
                    <p className="text-lg text-slate-500 leading-relaxed font-medium">{t.worksheet_desc}</p>
                </button>
            </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-[calc(100vh-64px)] bg-slate-100 overflow-hidden font-sans text-slate-900">
      
      {/* PANE 1: SIDEBAR */}
      <div className="w-70 bg-white border-r border-slate-200 flex flex-col shadow-sm shrink-0 font-medium">
        <div className="p-6 border-b border-slate-100 space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="font-black uppercase tracking-widest text-xs text-slate-400 italic">{t.library}</h2>
            <button onClick={() => setSetupMode(null)} className="text-xs font-black text-indigo-600 uppercase hover:underline">{t.change_mode}</button>
          </div>
          <div className="relative">
            <Search className="absolute left-3.5 top-4 text-slate-400" size={18} />
            <input 
              type="text" placeholder={t.search_placeholder} 
              className="w-full pl-12 pr-4 py-3.5 bg-slate-100 border-transparent focus:bg-white focus:ring-2 focus:ring-indigo-500 rounded-2xl text-base outline-none font-bold"
              value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
        </div>
        <div className="flex-1 overflow-y-auto p-4 space-y-6">
          {Object.values(SKILL_BUCKETS).map(cat => {
            const catTopics = Object.entries(cat.topics).filter(([id]) => filteredTopics.some(ft => ft.id === id));
            if (catTopics.length === 0) return null;
            
            const theme = CATEGORY_THEMES[cat.id] || CATEGORY_THEMES['algebra'];
            
            return (
              <div key={cat.id}>
                <div className={`inline-block px-3 py-1 rounded-lg mb-3 ${theme.bg} ${theme.text} border ${theme.border}`}>
                    <h3 className="text-[10px] font-black uppercase tracking-widest">{cat.name[lang]}</h3>
                </div>
                
                <div className="space-y-1.5 pl-1">
                  {catTopics.map(([id, data]) => (
                    <button
                      key={id} onClick={() => setSelectedTopicId(id)}
                      className={`w-full text-left px-4 py-3 text-[15px] rounded-2xl transition-all flex items-center justify-between group ${
                        selectedTopicId === id ? 'bg-slate-900 text-white shadow-xl font-bold' : 'text-slate-600 hover:bg-slate-50'
                      }`}
                    >
                      <span className="truncate">{data.name[lang]}</span>
                      <ChevronRight size={16} className={selectedTopicId === id ? 'opacity-100' : 'opacity-20'} />
                    </button>
                  ))}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* PANE 2: VARIATIONS */}
      <div className="w-[320px] bg-slate-50 border-r border-slate-200 flex flex-col overflow-hidden shrink-0">
        <div className="p-6 border-b border-slate-200 bg-white shrink-0 shadow-sm z-10">
            <h1 className="text-lg font-black text-slate-900 uppercase truncate italic tracking-tight">{currentTopic?.name[lang]}</h1>
            <p className="text-xs text-slate-400 font-bold uppercase tracking-widest mt-1">
                {Object.keys(groupedVariations).length} {t.sections_label} ‚Ä¢ {currentTopic?.variations.length} {t.variants_label}
            </p>
        </div>
        
        <div className="flex-1 overflow-y-auto p-6 space-y-8 shadow-inner custom-scrollbar relative">
            {Object.entries(groupedVariations).map(([groupName, variations]) => (
                <div key={groupName} className="animate-in fade-in slide-in-from-bottom-4 duration-500">
                    <div className="flex items-center gap-3 mb-4 sticky top-0 bg-slate-50/95 backdrop-blur-sm py-2 z-10">
                        <div className="h-px flex-1 bg-slate-300"></div>
                        <span className="text-[10px] font-black text-slate-400 uppercase tracking-widest bg-slate-200/50 px-2 py-1 rounded">{groupName}</span>
                        <div className="h-px flex-1 bg-slate-300"></div>
                    </div>

                    <div className="space-y-3">
                        {variations.map(v => (
                            <div 
                                key={v.key} onClick={() => triggerPreview(v.key)}
                                className={`p-5 rounded-[2rem] border-2 transition-all cursor-pointer relative group ${
                                    activePreviewKey === v.key ? 'border-indigo-500 bg-white shadow-xl ring-2 ring-indigo-100' : 'border-white bg-white hover:border-indigo-200 shadow-sm'
                                }`}
                            >
                                <div className="flex justify-between items-start gap-4">
                                    <div className="min-w-0">
                                        <h4 className={`font-bold text-[15px] leading-tight transition-colors ${activePreviewKey === v.key ? 'text-indigo-700' : 'text-slate-700'}`}>
                                            {v.displayName}
                                        </h4>
                                        <p className="text-[13px] text-slate-400 mt-1.5 leading-relaxed font-medium line-clamp-2">{v.desc[lang]}</p>
                                    </div>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); addToPacket(v); }}
                                        className="p-2.5 bg-slate-100 text-slate-400 rounded-xl hover:bg-indigo-600 hover:text-white transition-all shadow-sm group-hover:scale-105 active:scale-90 shrink-0"
                                    >
                                        <Plus size={20} strokeWidth={3} />
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            ))}
        </div>
      </div>

      {/* PANE 3: THE BOARD */}
      <div className="flex-1 bg-slate-200 p-6 flex flex-col overflow-hidden relative">
        <div className="flex-1 bg-white rounded-[2.5rem] shadow-2xl border border-slate-300 overflow-hidden flex flex-col mx-auto w-full max-w-2xl">
            <div className="bg-slate-900 px-6 py-4 text-white flex items-center justify-between shrink-0">
                <div className="flex items-center gap-3">
                    <div className={`w-2.5 h-2.5 rounded-full ${isPreviewLoading ? 'bg-yellow-400 animate-spin' : 'bg-red-500 animate-pulse'}`} />
                    <span className="text-[10px] font-black uppercase tracking-widest text-slate-400 italic">{t.board_label}</span>
                </div>
                {activePreviewKey && !previewError && (
                    <button 
                        onClick={() => triggerPreview(activePreviewKey)} disabled={isPreviewLoading}
                        className="text-[10px] bg-white/10 hover:bg-white/20 px-4 py-2 rounded-full font-black uppercase transition-all flex items-center gap-2"
                    >
                        <RefreshCcw size={12} className={isPreviewLoading ? 'animate-spin' : ''} /> {t.new_example}
                    </button>
                )}
            </div>
            
            <div className="p-10 flex-1 flex flex-col items-center justify-center text-center relative overflow-y-auto custom-scrollbar">
                {isPreviewLoading && (
                    <div className="absolute inset-0 bg-white/60 backdrop-blur-sm z-20 flex flex-col items-center justify-center gap-3">
                        <Loader2 className="animate-spin text-indigo-600" size={40} />
                    </div>
                )}
                
                {previewError ? (
                    <div className="text-red-400 flex flex-col items-center gap-4">
                        <AlertTriangle size={60} />
                        <p className="font-bold">{previewError}</p>
                        <p className="text-sm opacity-75">{t.preview_error_hint}</p>
                    </div>
                ) : !previewData ? (
                    <div className="text-slate-300 flex flex-col items-center gap-4 grayscale opacity-20">
                        <Maximize2 size={80} strokeWidth={0.5} />
                        <p className="text-sm font-black uppercase tracking-widest leading-relaxed">{t.select_hint}</p>
                    </div>
                ) : (
                    <div className="w-full space-y-6 animate-in fade-in zoom-in-95 duration-500 py-2">
                        <div className="w-full flex justify-center">
                             {renderVisual()}
                        </div>

                        {previewData.renderData && (
                            <>
                                <div className="text-xl text-slate-800 font-bold tracking-tight px-6 leading-relaxed">
                                    <MathDisplay content={previewData.renderData.description} />
                                </div>
                                
                                {previewData.renderData.latex && (
                                    <div className="text-2xl font-serif text-indigo-600 py-6 px-4 bg-indigo-50/50 rounded-3xl border border-indigo-100 shadow-inner overflow-x-auto mx-6">
                                        <MathDisplay content={`$$${previewData.renderData.latex}$$`} />
                                    </div>
                                )}

                                {previewData.renderData.options && previewData.renderData.options.length > 0 && (
                                    <div className="grid grid-cols-2 gap-3 px-6 mt-6">
                                        {previewData.renderData.options.map((opt, idx) => (
                                            <div key={idx} className="bg-slate-50 border border-slate-200 rounded-2xl p-4 flex items-center gap-4 text-left shadow-sm">
                                                <div className="w-8 h-8 rounded-xl bg-white border border-slate-200 flex items-center justify-center text-[12px] font-black text-slate-400 shrink-0">
                                                    {String.fromCharCode(65 + idx)}
                                                </div>
                                                <div className="text-sm font-semibold text-slate-700">
                                                    <MathDisplay content={opt} />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                
                                <div className="pt-8 border-t border-slate-100 text-left px-8 mx-4">
                                    <div className="flex items-center gap-2 mb-2">
                                        <Info size={16} className="text-indigo-500" />
                                        <h5 className="text-[10px] font-black text-slate-400 uppercase tracking-widest italic">{t.hint_label}</h5>
                                    </div>
                                    <p className="text-base text-slate-500 italic leading-relaxed font-medium">
                                        <MathDisplay content={previewData.clues?.[0]?.text || t.no_hint} />
                                    </p>
                                </div>
                            </>
                        )}
                    </div>
                )}
            </div>
        </div>
      </div>

      {/* PANE 4: THE CART */}
      <div className="w-60 bg-white border-l border-slate-200 flex flex-col shadow-2xl relative z-10 shrink-0 font-medium">
        <div className="p-6 border-b border-slate-100 flex items-center justify-between bg-slate-50/50">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-indigo-600 rounded-2xl flex items-center justify-center text-white text-sm font-black shadow-lg">
              {packet.length}
            </div>
            <h2 className="text-xs font-black text-slate-600 uppercase tracking-widest tracking-tighter italic">{t.selected_questions}</h2>
          </div>
          {packet.length > 0 && (
            <button onClick={() => setPacket([])} className="p-2 text-slate-300 hover:text-red-500 transition-colors">
              <Trash2 size={20} />
            </button>
          )}
        </div>

        <div className="flex-1 overflow-y-auto p-4 space-y-3 bg-white shadow-inner">
          {packet.length === 0 ? (
            <div className="h-full flex flex-col items-center justify-center text-center p-8 text-slate-200 grayscale opacity-50">
              <Layers size={48} strokeWidth={1} className="mb-2" />
              <p className="text-[10px] font-black uppercase tracking-widest">{t.empty_packet}</p>
            </div>
          ) : (
            packet.map((item) => (
              <div key={item.id} className="p-4 bg-slate-50 border border-slate-200 rounded-2xl relative group transition-all hover:bg-white hover:shadow-md">
                <div className="flex justify-between items-start mb-2">
                  <span className="text-[8px] font-black text-indigo-500 uppercase tracking-tighter bg-indigo-50 px-2 py-0.5 rounded truncate max-w-[120px]">
                    {allTopics.find(tp => tp.id === item.topicId)?.name[lang]}
                  </span>
                  <button onClick={() => removeFromPacket(item.id)} className="p-1 text-red-400 hover:bg-red-50 rounded transition-all"><Trash2 size={14} /></button>
                </div>
                <h5 className="text-[14px] font-bold text-slate-800 leading-tight mb-3">{item.name}</h5>
              </div>
            ))
          )}
        </div>

        <div className="p-8 border-t border-slate-100 bg-white shrink-0">
          <button 
            onClick={handleFinalAction} disabled={packet.length === 0}
            className={`w-full py-5 rounded-[2rem] font-black flex items-center justify-center gap-3 transition-all shadow-2xl tracking-tighter uppercase italic text-lg ${
                setupMode === 'donow' ? 'bg-indigo-600 hover:bg-indigo-700 text-white shadow-indigo-100' : 'bg-emerald-600 hover:bg-emerald-700 text-white shadow-emerald-100'
            } disabled:opacity-30 active:scale-95`}
          >
            <Send size={24} /> {setupMode === 'donow' ? t.create_donow : t.publish}
          </button>
        </div>
      </div>
    </div>
  );
}

// FILE END: src\components\views\QuestionStudio.jsx

// =======================================================
// FILE START: src\components\visuals\AngleComponents.jsx
// =======================================================

import React from 'react';

// =====================================================================
// ANGLE VISUALIZATION COMPONENT
// Handles drawing rays, arcs, and labels for angle geometry problems.
// =====================================================================

const AngleVisual = ({ data }) => {
    // Data expected structure:
    // {
    //   type: 'angle',
    //   lines: [[p1, p2], ...],
    //   arcs: [{center, startAngle, endAngle, radius, label, color}],
    //   labels: [{x, y, text}],
    //   polygons: [{points: "x1,y1 x2,y2..."}]
    // }

    if (!data) return null;

    const { lines = [], arcs = [], labels = [], polygons = [] } = data;
    const width = 300;
    const height = 250;
    
    // Helper to draw an arc
    const drawArc = (arc, i) => {
        const { x, y } = arc.center;
        const r = arc.radius || 30;
        
        // Convert to radians (SVG Y is down, so standard math angles are inverted)
        const start = -arc.startAngle * (Math.PI / 180);
        const end = -arc.endAngle * (Math.PI / 180);
        
        const x1 = x + r * Math.cos(start);
        const y1 = y + r * Math.sin(start);
        const x2 = x + r * Math.cos(end);
        const y2 = y + r * Math.sin(end);
        
        let diff = arc.endAngle - arc.startAngle;
        while(diff < 0) diff += 360;
        
        const largeArc = diff > 180 ? 1 : 0;
        const sweep = 0; // Inverted Y logic
        
        const d = `M ${x} ${y} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} ${sweep} ${x2} ${y2} Z`;
        
        const midAngle = -(arc.startAngle + arc.endAngle) / 2 * (Math.PI / 180);
        const lx = x + (r + 25) * Math.cos(midAngle);
        const ly = y + (r + 25) * Math.sin(midAngle);

        return (
            <g key={`arc-${i}`}>
                <path d={d} fill={arc.color || "rgba(255, 165, 0, 0.2)"} stroke={arc.stroke || "orange"} strokeWidth="2" />
                {arc.label && (
                    <text x={lx} y={ly} textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#374151">
                        {arc.label}
                    </text>
                )}
            </g>
        );
    };

    return (
        <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} className="mx-auto bg-white rounded-lg shadow-sm border border-slate-100">
            {/* Draw Polygons (if any) */}
            {polygons.map((poly, i) => (
                <polygon 
                    key={`poly-${i}`} 
                    points={poly.points} 
                    fill="rgba(59, 130, 246, 0.1)" 
                    stroke="#3b82f6" 
                    strokeWidth="2" 
                />
            ))}

            {/* Draw Lines */}
            {lines.map((line, i) => (
                <line 
                    key={`line-${i}`} 
                    x1={line.x1} y1={line.y1} 
                    x2={line.x2} y2={line.y2} 
                    stroke="#1e293b" 
                    strokeWidth="3" 
                    strokeLinecap="round" 
                />
            ))}

            {/* Draw Arcs/Angles */}
            {arcs.map((arc, i) => drawArc(arc, i))}

            {/* Draw Independent Labels */}
            {labels.map((lbl, i) => (
                <text 
                    key={`lbl-${i}`} 
                    x={lbl.x} y={lbl.y} 
                    textAnchor="middle" 
                    fontSize={lbl.size || "18"} 
                    fontWeight="bold" 
                    fill={lbl.color || "#1f2937"}
                >
                    {lbl.text}
                </text>
            ))}
        </svg>
    );
};

export default AngleVisual;

// FILE END: src\components\visuals\AngleComponents.jsx

// =======================================================
// FILE START: src\components\visuals\ComplexGeometry.jsx
// =======================================================

import React from 'react';

export const TransversalVisual = ({ data }) => {
    const labels = data.labels;
    return (
        <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
            <polygon points="150,30 50,220 250,220" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.3" />
            <line x1="100" y1="125" x2="200" y2="125" stroke="#059669" strokeWidth="3" />
            <path d="M 150 125 l -5 -5 m 5 5 l -5 5" stroke="#059669" strokeWidth="2" fill="none"/>
            <path d="M 150 220 l -5 -5 m 5 5 l -5 5" stroke="#10b981" strokeWidth="2" fill="none"/>

            {/* Standard Labels */}
            <text x="85" y="80" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_top}</text>
            <text x="150" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_top}</text>
            <text x="150" y="240" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_bot}</text>

            {/* Conditional Labels: Total Bracket OR Bottom Extension */}
            {labels.left_tot && (
                <g transform="translate(-10, 0)"> 
                    <line x1="110" y1="20" x2="10" y2="210" stroke="#64748b" strokeWidth="2" />
                    <line x1="110" y1="20" x2="120" y2="25" stroke="#64748b" strokeWidth="2" />
                    <line x1="10" y1="210" x2="20" y2="215" stroke="#64748b" strokeWidth="2" />
                    <text x="50" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end" dominantBaseline="middle">{labels.left_tot}</text>
                </g>
            )}
            {labels.left_bot && (
                <text x="65" y="170" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_bot}</text>
            )}
        </svg>
    );
};

export const CompositeVisual = ({ data }) => {
    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200" className="border border-gray-100 rounded-lg bg-white shadow-sm">
                {data.subtype === 'house' ? (
                    <>
                        <rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <text x="160" y="120" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                        <text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                        <text x="130" y="60" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h_roof}</text>
                    </>
                ) : (
                    <>
                        <rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                        <text x="160" y="120" textAnchor="start" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                    </>
                )}
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\ComplexGeometry.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryComponents.jsx
// =======================================================

import React from 'react';

// 3D & Graphing
import { GraphCanvas } from './GraphCanvas';
import { VolumeVisualization } from './VolumeVisualization';

// Statistics & Probability
import { FrequencyTable, PercentGrid } from './StatisticsVisuals';
import { ProbabilityMarbles, ProbabilitySpinner } from './ProbabilityVisuals';
import ProbabilityTree from './ProbabilityTree';

// 2D Geometry & Utilities
import { RenderShape } from './GeometryShapes';
import { ScaleVisual, SimilarityCompare, CompareShapesArea } from './ScaleVisuals';
import { TransversalVisual, CompositeVisual } from './ComplexGeometry';
import PatternVisual from './PatternComponents';
import AngleVisual from './AngleComponents';

export const GeometryVisual = ({ data }) => {
    if (!data) return null;

    // --- ANGLE VISUAL ---
    if (data.type === 'angle') {
        return <AngleVisual data={data} />;
    }
    // --- PATTERNS ---
    if (data.type === 'pattern') {
        return <PatternVisual data={data} />;
    }
    // --- PROBABILITY TREES ---
    if (data.type === 'probability_tree') {
        return <ProbabilityTree data={data} />;
    }

    // --- FREQUENCY TABLE ---
    if (data.type === 'frequency_table') {
        return <FrequencyTable data={data} />;
    }

    // --- PROBABILITY MARBLES ---
    if (data.type === 'probability_marbles') {
        return <ProbabilityMarbles data={data} />;
    }

    // --- PROBABILITY SPINNER ---
    if (data.type === 'probability_spinner') {
        return <ProbabilitySpinner data={data} />;
    }

    // --- PERCENT GRID ---
    if (data.type === 'percent_grid') {
        return <PercentGrid data={data} />;
    }

    // --- SIMILARITY COMPARISON ---
    if (data.type === 'similarity_compare') {
        return <SimilarityCompare data={data} />;
    }

    // --- SCALES (Single & Compare) ---
    if (data.type === 'scale_single' || data.type === 'scale_compare') { 
        return <ScaleVisual data={data} />;
    }

    // --- TRANSVERSAL ---
    if (data.type === 'transversal') {
        return <TransversalVisual data={data} />;
    }

    // --- AREA COMPARISON ---
    if (data.type === 'compare_shapes_area') {
        return <CompareShapesArea data={data} />;
    }

    // --- BASIC & COMPOSITE SHAPES (Dispatcher) ---
    // UPDATED: 'composite' is now handled by RenderShape which has logic for new and legacy subtypes
    if (['rectangle', 'square', 'parallelogram', 'triangle', 'circle', 'semicircle', 'quarter_circle', 'composite'].includes(data.type)) {
        return (
            <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
                <RenderShape type={data.type} dims={data} labels={data.labels} />
            </svg>
        );
    }
    
    // Fallback or Legacy Composite (if any types remain that RenderShape doesn't handle)
    // Since RenderShape handles all 'composite' subtypes now, this might be redundant
    // but kept just in case of other 'composite' variants from ComplexGeometry.
    if (data.type === 'composite_legacy') { // Renaming or removing to prevent conflict
        return <CompositeVisual data={data} />;
    }

    return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>;
};

// Re-export these for backward compatibility if other files import them from here
export { GraphCanvas, VolumeVisualization };

export const StaticGeometryVisual = ({ description }) => { 
    if (!description) return null; 
    const d = description.toLowerCase(); 
    if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; 
    return null; 
};

// FILE END: src\components\visuals\GeometryComponents.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryShapes.jsx
// =======================================================

import React from 'react';

// Helper for text generation
export const mkTxt = (x, y, txt, anchor = "middle", baseline = "middle", color = "#374151") =>
    <text key={`${x}-${y}-${txt}`} x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill={color} fontSize="20">{txt}</text>;

export const RenderShape = ({ type, dims, labels, areaText, offsetX = 0, offsetY = 0, scale = 1 }) => {
    const cx = 150 + offsetX;
    const cy = 125 + offsetY;
    const safeDims = dims || {};
    // Ensure width and height have fallbacks to prevent NaN
    const rawW = safeDims.width || safeDims.w || 10;
    const rawH = safeDims.height || safeDims.h || 10;
    const rawR = safeDims.radius || safeDims.r || 5;

    const maxDim = Math.max(rawW, rawH, rawR * 2) || 10;
    const baseScale = (120 / maxDim) * scale;
    
    const sw = rawW * baseScale;
    const sh = rawH * baseScale;
    const sr = rawR * baseScale;

    // Use passed labels or fallback to dimension values if no label object exists
    const safeLabels = labels || {};
    const l_b = safeLabels.b || safeLabels.base || safeLabels.width || safeLabels.w;
    const l_h = safeLabels.h || safeLabels.height;
    const l_hyp = safeLabels.hyp || safeLabels.hypotenuse || safeLabels.c || safeLabels.diagonal;
    const l_slant = safeLabels.slant || safeLabels.s; // For parallelogram slant side
    
    // Angle Labels
    const l_a1 = safeLabels.a1;
    const l_a2 = safeLabels.a2;

    // Side Labels for Similarity (s1, s2)
    const l_s1 = safeLabels.s1;
    const l_s2 = safeLabels.s2;

    if (type === 'rectangle' || type === 'square') {
        return (
            <g>
                <rect x={cx - sw / 2} y={cy - sh / 2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {l_b && mkTxt(cx, cy + sh / 2 + 25, l_b)}
                {l_h && mkTxt(cx + sw / 2 + 15, cy, l_h, "start")}
                {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
            </g>
        );
    }

    if (type === 'parallelogram') {
        const skew = sw * 0.25; // fixed skew amount for visual
        // Points: BottomLeft, BottomRight, TopRight, TopLeft
        const xBL = cx - sw / 2 - skew/2;
        const xBR = cx + sw / 2 - skew/2;
        const xTR = cx + sw / 2 + skew/2;
        const xTL = cx - sw / 2 + skew/2;
        
        const yTop = cy - sh / 2;
        const yBot = cy + sh / 2;

        const path = `${xBL},${yBot} ${xBR},${yBot} ${xTR},${yTop} ${xTL},${yTop}`;

        return (
            <g>
                {/* Dotted Height Line */}
                <line x1={xTL} y1={yTop} x2={xTL} y2={yBot} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                {/* Main Shape */}
                <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                
                {/* Base Label */}
                {l_b && mkTxt((xBL + xBR)/2, yBot + 25, l_b)}
                
                {/* Height Label (Internal) */}
                {l_h && mkTxt(xTL + 10, (yTop+yBot)/2, l_h, "start")}
                
                {/* Slant Side Label (Right Side) for Perimeter */}
                {l_slant && mkTxt((xBR+xTR)/2 + 10, (yBot+yTop)/2, l_slant, "start")}

                {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
            </g>
        );
    }

    if (type === 'triangle') {
        const L = cx - sw / 2; 
        const R = cx + sw / 2;
        const T = cy - sh / 2; 
        const B = cy + sh / 2;
        
        if (safeDims.subtype === 'right') {
            const p1 = { x: L, y: T }; const p2 = { x: L, y: B }; const p3 = { x: R, y: B };
            const path = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
            return (
                <g>
                    <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                    {l_h && mkTxt(L - 15, cy, l_h)}
                    {l_b && mkTxt(cx, B + 25, l_b)}
                    {l_hyp && mkTxt(cx + 10, cy - 10, l_hyp, "start")}
                </g>
            );
        } else {
            // Isosceles / Generic Triangle
            const points = `${L},${B} ${R},${B} ${cx},${T}`;
            return (
                <g>
                    <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                    <polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                    {l_b && mkTxt(cx, B + 25, l_b)}
                    {l_h && mkTxt(cx + 5, cy, l_h, "start")}
                    
                    {l_s1 && mkTxt(L - 10, cy, l_s1, "end")}
                    {l_s2 && mkTxt(R + 10, cy, l_s2, "start")}

                    {l_a1 && (
                        <>
                            <path d={`M ${L + 15} ${B} A 15 15 0 0 0 ${L + 8} ${B - 13}`} fill="none" stroke="#374151" strokeWidth="2" />
                            <text x={L - 10} y={B - 5} fontSize="16" fontWeight="bold" fill="#374151">{l_a1}</text>
                        </>
                    )}
                    
                    {l_a2 && (
                        <>
                            <path d={`M ${R - 15} ${B} A 15 15 0 0 1 ${R - 8} ${B - 13}`} fill="none" stroke="#374151" strokeWidth="2" />
                            <text x={R + 10} y={B - 5} fontSize="16" fontWeight="bold" fill="#374151">{l_a2}</text>
                        </>
                    )}
                </g>
            );
        }
    }
    if (type === 'circle') {
        const isDiameter = safeDims.show === 'diameter';
        const labelTxt = safeLabels.val || (safeLabels.r ? `r=${safeLabels.r}` : (safeLabels.diameter ? `d=${safeLabels.diameter}` : null));
        return (
            <g>
                <circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {isDiameter ? (
                    <>
                        <line x1={cx - sr} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" strokeDasharray="4" />
                        {labelTxt && <text x={cx} y={cy - 15} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>}
                    </>
                ) : (
                    <>
                        <circle cx={cx} cy={cy} r={3} fill="#374151" />
                        <line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" />
                        {labelTxt && <text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>}
                    </>
                )}
            </g>
        );
    }

    // --- NEW: Semicircle ---
    if (type === 'semicircle') {
        const isDiameter = safeDims.show === 'diameter';
        const rVal = safeLabels.r;
        const dVal = safeLabels.diameter;
        const dPath = `M ${cx - sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx + sr} ${cy} Z`; 
        
        return (
            <g>
                <path d={dPath} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {isDiameter ? (
                    <>
                        <line x1={cx - sr} y1={cy + 15} x2={cx + sr} y2={cy + 15} stroke="#374151" strokeWidth="2" markerEnd="url(#arrow)" markerStart="url(#arrow)" />
                        <text x={cx} y={cy + 35} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{dVal ? `d=${dVal}` : ''}</text>
                    </>
                ) : (
                    <>
                        <line x1={cx} y1={cy} x2={cx + sr*0.7} y2={cy - sr*0.7} stroke="#374151" strokeWidth="2" />
                        <text x={cx + 15} y={cy - 25} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
                        <circle cx={cx} cy={cy} r={3} fill="#374151" />
                    </>
                )}
            </g>
        );
    }

    // --- NEW: Quarter Circle ---
    if (type === 'quarter_circle') {
        const rVal = safeLabels.r;
        const originX = cx - sr/2;
        const originY = cy + sr/2;
        
        const dPath = `M ${originX} ${originY} L ${originX + sr} ${originY} A ${sr} ${sr} 0 0 0 ${originX} ${originY - sr} Z`;

        return (
            <g>
                <path d={dPath} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                <text x={originX + sr/2} y={originY + 20} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
                <text x={originX - 15} y={originY - sr/2} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
            </g>
        );
    }
    
    // --- COMBINED SHAPES (Level 4) ---
    if (type === 'composite') {
        const lab = labels || {};
        
        if (dims.subtype === 'rect_right_tri') {
            const wRect = (lab.w || 10) * baseScale;
            const hRect = (lab.h || 10) * baseScale;
            const wTri = (lab.tri_b || 5) * baseScale;
            const totalW = wRect + wTri;
            const startX = cx - totalW / 2;
            const startY = cy + hRect / 2;

            return (
                <g>
                    <rect x={startX} y={startY - hRect} width={wRect} height={hRect} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <polygon points={`${startX + wRect},${startY} ${startX + wRect + wTri},${startY} ${startX + wRect},${startY - hRect}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {mkTxt(startX + wRect/2, startY + 20, lab.w)} 
                    {mkTxt(startX - 15, startY - hRect/2, lab.h)} 
                    {mkTxt(startX + wRect + wTri/2, startY + 20, lab.tri_b)} 
                </g>
            );
        }

        if (dims.subtype === 'l_shape') {
            const vW = (lab.vW || 3) * baseScale;
            const vH = (lab.vH || 8) * baseScale;
            const hW = (lab.hW || 6) * baseScale; // This is the extension width
            const hH = (lab.hH || 3) * baseScale;
            
            const showTotal = !!lab.totalW;
            
            const totW = vW + hW; 
            const totH = Math.max(vH, hH);
            const startX = cx - totW / 2;
            const startY = cy + totH / 2; 
            const p = `${startX},${startY} ${startX + vW + hW},${startY} ${startX + vW + hW},${startY - hH} ${startX + vW},${startY - hH} ${startX + vW},${startY - vH} ${startX},${startY - vH}`;
            return (
                <g>
                    <polygon points={p} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {mkTxt(startX + vW/2, startY - vH - 15, lab.vW)}
                    {mkTxt(startX - 15, startY - vH/2, lab.vH)}
                    
                    {/* Right Side Label */}
                    {mkTxt(startX + vW + hW + 15, startY - hH/2, lab.hH)}

                    {/* Bottom Label logic */}
                    {showTotal ? (
                        <>
                            {/* Draw a dimension line for total width */}
                            <line x1={startX} y1={startY + 25} x2={startX + totW} y2={startY + 25} stroke="#374151" strokeWidth="1" />
                            <line x1={startX} y1={startY + 20} x2={startX} y2={startY + 30} stroke="#374151" strokeWidth="1" />
                            <line x1={startX + totW} y1={startY + 20} x2={startX + totW} y2={startY + 30} stroke="#374151" strokeWidth="1" />
                            {mkTxt(startX + totW/2, startY + 45, lab.totalW)}
                        </>
                    ) : (
                        mkTxt(startX + vW + hW/2, startY + 20, lab.hW) // Fallback to extension label
                    )}
                </g>
            );
        }

        if (dims.subtype === 'house_area') {
            const s = (lab.s || 10) * baseScale;
            const hTri = (lab.h_tri || 5) * baseScale;
            
            const startX = cx - s/2;
            const startY = cy + s/2; 

            return (
                <g>
                    <rect x={startX} y={startY - s} width={s} height={s} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <polygon points={`${startX},${startY - s} ${startX + s},${startY - s} ${cx},${startY - s - hTri}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <line x1={cx} y1={startY - s} x2={cx} y2={startY - s - hTri} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />

                    {mkTxt(cx, startY + 20, lab.s)} 
                    {mkTxt(startX - 15, startY - s/2, lab.s)} 
                    {mkTxt(cx + 15, startY - s - hTri/2, lab.h_tri, "start")} 
                </g>
            );
        }
        
        if (dims.subtype === 'house' || dims.subtype === 'portal') {
             return (
                <g>
                    {dims.subtype === 'house' ? (
                        <>
                            <rect x={cx - 50} y={cy - 20} width={100} height={80} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <polygon points={`${cx - 50},${cy - 20} ${cx + 50},${cy - 20} ${cx},${cy - 80}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            {mkTxt(cx + 60, cy + 20, lab.h)}
                            {mkTxt(cx, cy + 80, lab.w)}
                            {mkTxt(cx + 30, cy - 40, lab.h_roof)}
                        </>
                    ) : (
                        <>
                            <rect x={cx - 50} y={cy - 50} width={100} height={100} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <path d={`M ${cx - 50} ${cy - 50} A 50 50 0 0 1 ${cx + 50} ${cy - 50}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            {mkTxt(cx, cy + 70, lab.w)}
                            {mkTxt(cx + 60, cy, lab.h, "start")}
                        </>
                    )}
                </g>
            );
        }
    }

    return null;
};

// FILE END: src\components\visuals\GeometryShapes.jsx

// =======================================================
// FILE START: src\components\visuals\GraphCanvas.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

export const GraphCanvas = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const range = data.range || 10;
        ctx.clearRect(0, 0, width, height);
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const toX = (val) => (val + range) * (width / (range * 2));
        const toY = (val) => height - (val + range) * (height / (range * 2));
        
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        for (let i = -range; i <= range; i += data.gridStep || 1) {
            ctx.beginPath(); ctx.moveTo(toX(i), 0); ctx.lineTo(toX(i), height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, toY(i)); ctx.lineTo(width, toY(i)); ctx.stroke();
        }
        ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(width, toY(0)); ctx.stroke();
        ctx.fillStyle = '#6b7280';
        const step = data.labelStep || 2;
        for (let i = -range; i <= range; i += step) {
            if (i === 0) continue;
            const xPos = toX(i); const yOrigin = toY(0);
            ctx.beginPath(); ctx.moveTo(xPos, yOrigin - 3); ctx.lineTo(xPos, yOrigin + 3); ctx.stroke();
            ctx.fillText(i.toString(), xPos, yOrigin + 12);
            const yPos = toY(i); const xOrigin = toX(0);
            ctx.beginPath(); ctx.moveTo(xOrigin - 3, yPos); ctx.lineTo(xOrigin + 3, yPos); ctx.stroke();
            ctx.fillText(i.toString(), xOrigin - 12, yPos);
        }
        data.lines.forEach(line => {
            ctx.strokeStyle = line.color || '#dc2626'; ctx.lineWidth = 3;
            ctx.beginPath();
            const x1 = -range; const y1 = line.slope * x1 + line.intercept;
            const x2 = range; const y2 = line.slope * x2 + line.intercept;
            ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke();
        });
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};

// FILE END: src\components\visuals\GraphCanvas.jsx

// =======================================================
// FILE START: src\components\visuals\PatternComponents.jsx
// =======================================================

import React from 'react';

/**
 * PatternVisual hanterar rendering av algebraiska m√∂nster.
 * Den st√∂der t√§ndstickor (stick-figures), prickar och sifferf√∂ljder.
 */
const PatternVisual = ({ data }) => {
    if (!data) return null;

    const { subtype, sequence, figures = [] } = data;

    // --- Rendera en enkel sifferf√∂ljd (Niv√• 1-2) ---
    if (subtype === 'sequence') {
        return (
            <div className="flex flex-wrap justify-center gap-4 py-8">
                {sequence.map((num, i) => (
                    <div key={i} className="flex items-center">
                        <div className="w-12 h-12 flex items-center justify-center bg-white border-2 border-indigo-100 rounded-lg shadow-sm text-xl font-bold text-indigo-600 font-mono">
                            {num === '?' ? <span className="animate-pulse text-gray-400">?</span> : num}
                        </div>
                        {i < sequence.length - 1 && <span className="ml-4 text-gray-300">,</span>}
                    </div>
                ))}
            </div>
        );
    }

    // --- Rendera t√§ndsticksm√∂nster (Niv√• 3-5) ---
    if (subtype === 'matchsticks') {
        return (
            <div className="flex flex-col items-center gap-6 w-full overflow-x-auto py-4">
                <div className="flex justify-center items-end gap-12 min-w-max px-4">
                    {figures.map((fig, idx) => (
                        <div key={idx} className="flex flex-col items-center gap-4">
                            <svg 
                                width={fig.width || 100} 
                                height={fig.height || 100} 
                                viewBox={`0 0 ${fig.width || 100} ${fig.height || 100}`}
                            >
                                {fig.sticks.map((s, i) => (
                                    <line 
                                        key={i}
                                        x1={s.x1} y1={s.y1} x2={s.x2} y2={s.y2}
                                        stroke="#f59e0b"
                                        strokeWidth="4"
                                        strokeLinecap="round"
                                        className="drop-shadow-sm"
                                    />
                                ))}
                                {fig.sticks.map((s, i) => (
                                    <circle key={`head-${i}`} cx={s.x1} cy={s.y1} r="3" fill="#ef4444" />
                                ))}
                            </svg>
                            <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">
                                Figur {idx + 1}
                            </span>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    return null;
};

export default PatternVisual;

// FILE END: src\components\visuals\PatternComponents.jsx

// =======================================================
// FILE START: src\components\visuals\ProbabilityTree.jsx
// =======================================================

import React from 'react';

/**
 * ProbabilityTree handles the rendering of:
 * 1. Standard Probability Trees (Top-down)
 * 2. Combinatorial Pathways (A to B)
 * 3. Constrained Pathways (A to B with obstacles)
 */
const ProbabilityTree = ({ data }) => {
    if (!data) return null;

    const { subtype, layers, groups, initialCounts, targetBranch, obstacles = [] } = data;

    // --- MODE: PATHWAYS (Combinatorics A -> B) ---
    if (subtype === 'pathway') {
        const width = 400;
        const height = 220;
        const padding = 50;
        
        // Define layers for the network
        const layerCounts = layers || [1, 2, 3, 1];
        const stepX = (width - padding * 2) / (layerCounts.length - 1);

        const getPos = (lIdx, nIdx, count) => {
            const x = padding + lIdx * stepX;
            const layerHeight = 140;
            const startY = (height - layerHeight) / 2;
            const spacing = layerHeight / (count > 1 ? count - 1 : 1);
            const y = count === 1 ? height / 2 : startY + nIdx * spacing;
            return { x, y };
        };

        return (
            <div className="flex justify-center w-full py-6 bg-slate-50 rounded-xl border border-slate-200 shadow-inner overflow-x-auto">
                <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                    <defs>
                        <filter id="nodeShadow">
                            <feDropShadow dx="0" dy="1" stdDeviation="1" floodOpacity="0.1"/>
                        </filter>
                    </defs>

                    {/* 1. Draw Paths (Lines) */}
                    {layerCounts.map((count, lIdx) => {
                        if (lIdx === layerCounts.length - 1) return null;
                        const nextCount = layerCounts[lIdx + 1];
                        
                        return Array.from({ length: count }).map((_, nIdx) => {
                            const start = getPos(lIdx, nIdx, count);
                            return Array.from({ length: nextCount }).map((__, nextNIdx) => {
                                const end = getPos(lIdx + 1, nextNIdx, nextCount);
                                
                                // Obstacle Logic: Only check if obstacles exist in data
                                const isBlocked = obstacles.some(o => 
                                    o.layer === lIdx && o.from === nIdx && o.to === nextNIdx
                                );

                                return (
                                    <g key={`path-${lIdx}-${nIdx}-${nextNIdx}`}>
                                        <line 
                                            x1={start.x} y1={start.y} x2={end.x} y2={end.y}
                                            stroke={isBlocked ? "#fee2e2" : "#cbd5e1"} 
                                            strokeWidth={isBlocked ? "1.5" : "2.5"}
                                            strokeDasharray={isBlocked ? "4 2" : "0"}
                                            strokeLinecap="round"
                                        />
                                        {/* Visual Block Marker */}
                                        {isBlocked && (
                                            <g transform={`translate(${(start.x + end.x)/2}, ${(start.y + end.y)/2})`}>
                                                <circle r="9" fill="white" stroke="#ef4444" strokeWidth="1" />
                                                <circle r="7" fill="#ef4444" />
                                                <line x1="-3.5" y1="0" x2="3.5" y2="0" stroke="white" strokeWidth="2.5" strokeLinecap="round" />
                                            </g>
                                        )}
                                    </g>
                                );
                            });
                        });
                    })}

                    {/* 2. Draw Nodes */}
                    {layerCounts.map((count, lIdx) => (
                        Array.from({ length: count }).map((_, nIdx) => {
                            const { x, y } = getPos(lIdx, nIdx, count);
                            const isStart = lIdx === 0;
                            const isEnd = lIdx === layerCounts.length - 1;
                            
                            return (
                                <g key={`n-${lIdx}-${nIdx}`}>
                                    <circle 
                                        cx={x} cy={y} r={isStart || isEnd ? 9 : 5} 
                                        fill={isStart || isEnd ? "#6366f1" : "white"} 
                                        stroke={isStart || isEnd ? "none" : "#94a3b8"}
                                        strokeWidth="2"
                                        filter="url(#nodeShadow)"
                                    />
                                    {(isStart || isEnd) && (
                                        <text x={x} y={y - 18} textAnchor="middle" className="text-sm font-black fill-indigo-600 tracking-tighter">
                                            {isStart ? 'A' : 'B'}
                                        </text>
                                    )}
                                </g>
                            );
                        })
                    ))}
                </svg>
            </div>
        );
    }

    // --- MODE: STANDARD TREE (Probability L5) ---
    const width = 400;
    const height = 320;
    const nodeRadius = 6;
    const total = initialCounts[0] + initialCounts[1];
    const centerX = width / 2;

    const root = { x: centerX, y: 40 };
    const s1 = [
        { x: centerX - 100, y: 140, label: groups[0], count: initialCounts[0], total: total },
        { x: centerX + 100, y: 140, label: groups[1], count: initialCounts[1], total: total }
    ];
    const s2 = [
        { x: centerX - 145, y: 270, parent: 0, label: groups[0], c: initialCounts[0] - 1, t: total - 1 },
        { x: centerX - 55, y: 270, parent: 0, label: groups[1], c: initialCounts[1], t: total - 1 },
        { x: centerX + 55, y: 270, parent: 1, label: groups[0], c: initialCounts[0], t: total - 1 },
        { x: centerX + 145, y: 270, parent: 1, label: groups[1], c: initialCounts[1] - 1, t: total - 1 }
    ];

    const renderProbLabel = (x1, y1, x2, y2, num, den, bId) => {
        const mx = (x1 + x2) / 2;
        const my = (y1 + y2) / 2;
        const isT = targetBranch === bId;
        return (
            <g>
                <rect x={mx - 22} y={my - 16} width="44" height="32" fill="white" stroke={isT ? "#6366f1" : "#e2e8f0"} strokeWidth={isT ? "2" : "1"} rx="6" />
                <text x={mx} y={my + 5} textAnchor="middle" className={`text-sm font-bold ${isT ? 'fill-indigo-600 animate-pulse' : 'fill-slate-600'}`}>
                    {isT ? 'x' : `${num}/${den}`}
                </text>
            </g>
        );
    };

    return (
        <div className="flex justify-center w-full py-4 bg-white rounded-2xl border border-slate-200 shadow-sm overflow-x-auto">
            <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                {s1.map((n, i) => (
                    <g key={`l1-${i}`}>
                        <line x1={root.x} y1={root.y} x2={n.x} y2={n.y} stroke="#e2e8f0" strokeWidth="2.5" />
                        <text x={n.x} y={n.y - 18} textAnchor="middle" className="text-[10px] font-black fill-slate-400 uppercase tracking-widest">{n.label}</text>
                        {renderProbLabel(root.x, root.y, n.x, n.y, n.count, n.total, `s1_${i}`)}
                    </g>
                ))}
                {s2.map((n, i) => {
                    const p = s1[n.parent];
                    return (
                        <g key={`l2-${i}`}>
                            <line x1={p.x} y1={p.y} x2={n.x} y2={n.y} stroke="#e2e8f0" strokeWidth="2" />
                            <text x={n.x} y={n.y + 22} textAnchor="middle" className="text-[10px] font-bold fill-slate-400 uppercase tracking-wide">{n.label}</text>
                            {renderProbLabel(p.x, p.y, n.x, n.y, n.c, n.t, `s2_${i}`)}
                        </g>
                    );
                })}
                <circle cx={root.x} cy={root.y} r={nodeRadius} fill="#cbd5e1" />
                {s1.map((n, i) => <circle key={`cn1-${i}`} cx={n.x} cy={n.y} r={nodeRadius} fill="#94a3b8" />)}
                {s2.map((n, i) => <circle key={`cn2-${i}`} cx={n.x} cy={n.y} r={nodeRadius} fill="#94a3b8" />)}
            </svg>
        </div>
    );
};

export default ProbabilityTree;

// FILE END: src\components\visuals\ProbabilityTree.jsx

// =======================================================
// FILE START: src\components\visuals\ProbabilityVisuals.jsx
// =======================================================

import React from 'react';

export const ProbabilityMarbles = ({ data }) => {
    const { red, blue, green } = data.items;
    const colors = [];
    for(let i=0; i<red; i++) colors.push('#ef4444');
    for(let i=0; i<blue; i++) colors.push('#3b82f6');
    for(let i=0; i<green; i++) colors.push('#22c55e');
    
    const mixed = [];
    while(colors.length) {
        if (colors.length % 3 === 0) mixed.push(colors.pop()); 
        else mixed.unshift(colors.pop());
    }

    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200" className="bg-slate-100 rounded-full border-4 border-slate-300 shadow-inner">
                {mixed.map((c, i) => {
                    const angle = i * 2.4; 
                    const dist = 15 + i * 4; 
                    const x = 100 + dist * Math.cos(angle);
                    const y = 100 + dist * Math.sin(angle);
                    return <circle key={i} cx={x} cy={y} r={12} fill={c} stroke="rgba(0,0,0,0.2)" strokeWidth="1" />;
                })}
            </svg>
        </div>
    );
};

export const ProbabilitySpinner = ({ data }) => {
    const { sections } = data; 
    const radius = 80; const cx = 100; const cy = 100;
    const step = (2 * Math.PI) / sections;
    const colors = ['#3b82f6', '#ef4444', '#22c55e', '#eab308', '#a855f7', '#ec4899']; 
    const slices = [];
    for (let i = 0; i < sections; i++) {
        const startAngle = i * step - Math.PI/2; 
        const endAngle = (i + 1) * step - Math.PI/2;
        const x1 = cx + radius * Math.cos(startAngle); const y1 = cy + radius * Math.sin(startAngle);
        const x2 = cx + radius * Math.cos(endAngle); const y2 = cy + radius * Math.sin(endAngle);
        const largeArc = step > Math.PI ? 1 : 0;
        const pathData = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
        slices.push(<path key={i} d={pathData} fill={colors[i % colors.length]} stroke="white" strokeWidth="2" />);
    }
    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200">
                {slices}
                <polygon points="100,20 90,40 110,40" fill="#1e293b" />
                <circle cx="100" cy="100" r="5" fill="#1e293b" />
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\ProbabilityVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\ScaleVisuals.jsx
// =======================================================

import React from 'react';
import { RenderShape } from './GeometryShapes';

export const ScaleVisual = ({ data }) => {
    const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ', arrow: '‚û°', star: '‚≠ê', lightning: '‚ö°', key: 'üîë', heart: '‚ù§Ô∏è', cloud: '‚òÅÔ∏è', moon: 'üåô', sun: '‚òÄÔ∏è', magnifying_glass: 'üîç', map: 'üó∫Ô∏è', car: 'üöó', ladybug: 'üêû', house: 'üè†' }; 
    const emoji = shapeEmojis[data.shape] || 'üì¶'; 
    const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl select-none" style={{ fontSize: size }}>{emoji}</div>; 
    
    if (data.type === 'scale_single') {
        return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="80px" /><span className="bg-white px-4 py-2 rounded shadow text-3xl font-bold font-mono border border-gray-200">{data.label}</span></div>; 
    }
    return (
        <div className="flex items-center justify-center gap-4 sm:gap-8 my-6">
            <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="60px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.leftValue}</span></div>
            <div className="text-gray-300 text-3xl">‚Üí</div>
            <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="100px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.rightValue}</span></div>
        </div>
    ); 
};

export const SimilarityCompare = ({ data }) => {
    const shapeType = data.shapeType || 'triangle';
    const leftDims = { ...data.left, width: 40, height: 40, radius: 20, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
    const rightDims = { ...data.right, width: 60, height: 60, radius: 30, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
    return (
        <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
            <RenderShape type={shapeType} dims={leftDims} labels={data.left.labels} offsetX={-25} scale={0.8} />
            <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
            <RenderShape type={shapeType} dims={rightDims} labels={data.right.labels} offsetX={225} scale={1.2} />
        </svg>
    );
};

export const CompareShapesArea = ({ data }) => {
    return (
            <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
            <RenderShape type={data.shapeType} dims={data.left} areaText={data.left.area} offsetX={-25} scale={0.8} />
            <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
            <RenderShape type={data.shapeType} dims={data.right} areaText={data.right.area} offsetX={225} scale={1.2} />
        </svg>
    );
};

// FILE END: src\components\visuals\ScaleVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\SimpleTextLevel.jsx
// =======================================================

import React from 'react';

const SimpleTextLevel = ({ data }) => {
  return (
    <div className="text-content">
      <p>{data.question}</p>
    </div>
  );
};

// We simply don't add the property, or explicitly set it to false
// SimpleTextLevel.requiresCanvas = false; 

export default SimpleTextLevel;

// FILE END: src\components\visuals\SimpleTextLevel.jsx

// =======================================================
// FILE START: src\components\visuals\StatisticsVisuals.jsx
// =======================================================

import React from 'react';

export const FrequencyTable = ({ data }) => {
    const { headers, rows } = data;
    return (
        <div className="flex justify-center my-4 w-full px-2">
            {/* Added max-h and overflow-auto to prevent the table from pushing out the container height */}
            <div className="border border-slate-300 rounded-lg overflow-auto shadow-sm bg-white w-full max-w-md max-h-[300px]">
                <table className="w-full text-sm text-left border-collapse">
                    <thead className="bg-slate-100 text-slate-700 font-bold uppercase text-xs sticky top-0">
                        <tr>
                            {headers.map((h, i) => (
                                <th key={i} className="px-4 py-3 border-b text-center">
                                    {h}
                                </th>
                            ))}
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                        {rows.map((row, rI) => (
                            <tr key={rI} className="hover:bg-slate-50 transition-colors">
                                {row.map((cell, cI) => (
                                    <td key={cI} className="px-4 py-2 text-center font-mono text-slate-600">
                                        {cell}
                                    </td>
                                ))}
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export const PercentGrid = ({ data }) => {
    const { colored = 0 } = data;
    
    // We use a constant coordinate system (100x100) inside the viewBox
    const internalSize = 100;
    const cellSize = internalSize / 10;
    const cells = [];

    for (let i = 0; i < 100; i++) {
        const x = (i % 10) * cellSize;
        const y = Math.floor(i / 10) * cellSize;
        const isColored = i < colored;

        cells.push(
            <rect 
                key={i} 
                x={x + 0.5} 
                y={y + 0.5} 
                width={cellSize - 1} 
                height={cellSize - 1} 
                fill={isColored ? "#3b82f6" : "#f1f5f9"} 
                stroke={isColored ? "#2563eb" : "#e2e8f0"} 
                strokeWidth="0.5"
                rx="1.5" 
            />
        );
    }

    return (
        <div className="flex justify-center items-center p-4 w-full h-full min-h-[200px]">
            {/* Removing fixed width/height attributes from <svg>.
                Using 'aspect-square' and 'max-h-full' to ensure it stays 
                within the practiceView container boundaries.
            */}
            <svg 
                viewBox={`0 0 ${internalSize} ${internalSize}`} 
                className="w-full h-full max-w-[280px] max-h-full drop-shadow-sm"
                preserveAspectRatio="xMidYMid meet"
            >
                {cells}
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\StatisticsVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\VolumeVisualization.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

/**
 * VolumeVisualization - Corrected for rendering stability and scaling logic.
 * Ensures all 3D volume types (cuboids, prisms, pyramids, spheres, etc.) 
 * render correctly in the QuestionStudio preview pane.
 */
export const VolumeVisualization = ({ data, width = 200, height = 200 }) => {
    const canvasRef = useRef(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        
        // Internal resolution (doubled for sharpness on all screens)
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;

        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = '#1f2937'; 
        ctx.fillStyle = '#f3f4f6';
        ctx.lineWidth = 3; 
        ctx.lineJoin = 'round'; 

        // High visibility font settings
        const fontSize = 28; 
        ctx.font = `bold ${fontSize}px Inter, system-ui, sans-serif`; 
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";

        const drawLabel = (text, x, y, color='#be123c') => { 
            if (text === undefined || text === null) return;
            const labelStr = String(text);
            ctx.save(); 
            
            const m = ctx.measureText(labelStr);
            const pW = 10;
            const pH = 6;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)'; 
            ctx.beginPath();
            // Fallback for older environments without roundRect
            if (ctx.roundRect) {
                ctx.roundRect(x - m.width/2 - pW, y - fontSize/2 - pH, m.width + (pW * 2), fontSize + (pH * 2), 8);
                ctx.fill();
            } else {
                ctx.fillRect(x - m.width/2 - pW, y - fontSize/2 - pH, m.width + (pW * 2), fontSize + (pH * 2));
            }
            
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.fillStyle = color; 
            ctx.fillText(labelStr, x, y); 
            ctx.restore(); 
        };

        const drawDashed = (x1, y1, x2, y2) => { 
            ctx.save(); 
            ctx.setLineDash([10, 10]); 
            ctx.beginPath(); 
            ctx.moveTo(x1, y1); 
            ctx.lineTo(x2, y2); 
            ctx.stroke(); 
            ctx.restore(); 
        };

        // --- SAFE SCALING LOGIC ---
        const labels = data.labels || {};
        const type = (data.type || '').toLowerCase();

        // Use parseInt to strip potential units (e.g., "10 cm" -> 10) and ensure valid numbers
        const valW = parseInt(labels.w || labels.s || labels.b) || 10;
        const valH = parseInt(labels.h) || 10;
        const valD = parseInt(labels.d || labels.l) || 10;
        
        // Fixed: Calculate valR safely to avoid NaN during scale calculation
        const rawD = parseInt(labels.d);
        const valR = parseInt(labels.r) || (rawD ? rawD / 2 : 5);

        let logicalW = 10, logicalH = 10;

        if (type === 'cuboid') {
            logicalW = valW + (valD * 0.6);
            logicalH = valH + (valD * 0.6);
        } else if (type === 'triangular_prism') {
            logicalW = valW + (valD * 0.8);
            logicalH = valH + (valD * 0.4);
        } else if (type === 'pyramid') {
            logicalW = valW + (valD * 0.6);
            logicalH = valH + (valD * 0.6);
        } else if (type === 'sphere') {
            logicalW = valR * 2.6;
            logicalH = valR * 2.6;
        } else {
            logicalW = valR * 3; 
            logicalH = valH + (valR * 0.8);
        }

        const scale = (Math.min(w, h) * 0.52) / Math.max(logicalW, logicalH);
        const labelGap = 42; 

        // --- DRAWING FUNCTIONS ---

        if (type === 'cuboid') {
            const dw = valW * scale;
            const dh = valH * scale;
            const dd = valD * scale * 0.5;
            const x0 = cx - (dw + dd) / 2;
            const y0 = cy + (dh - dd) / 2;

            drawDashed(x0 + dd, y0 - dd, x0 + dd, y0 - dh - dd);
            drawDashed(x0, y0, x0 + dd, y0 - dd);
            drawDashed(x0 + dd, y0 - dd, x0 + dw + dd, y0 - dd);

            ctx.strokeRect(x0, y0 - dh, dw, dh);
            ctx.beginPath();
            ctx.moveTo(x0, y0 - dh); ctx.lineTo(x0 + dd, y0 - dh - dd);
            ctx.lineTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw, y0 - dh);
            ctx.moveTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dd);
            ctx.lineTo(x0 + dw, y0);
            ctx.stroke();

            drawLabel(labels.w, x0 + dw/2, y0 + labelGap);
            drawLabel(labels.h, x0 - labelGap - 10, y0 - dh/2);
            drawLabel(labels.d, x0 + dw + dd + 25, y0 - dh/2 - dd/2);
        } 
        else if (type === 'triangular_prism') {
            const b = valW * scale;
            const hTri = valH * scale;
            const l = valD * scale * 0.7;
            const x0 = cx - (b + l) / 2;
            const y0 = cy + (hTri / 2);

            ctx.beginPath();
            ctx.moveTo(x0, y0); ctx.lineTo(x0 + b, y0); ctx.lineTo(x0 + b/2, y0 - hTri); ctx.closePath(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x0 + b/2, y0 - hTri); ctx.lineTo(x0 + b/2 + l, y0 - hTri - l*0.2);
            ctx.lineTo(x0 + b + l, y0 - l*0.2); ctx.lineTo(x0 + b, y0);
            ctx.moveTo(x0 + b/2 + l, y0 - hTri - l*0.2); ctx.lineTo(x0 + b + l, y0 - l*0.2);
            ctx.stroke();

            drawDashed(x0 + b/2, y0, x0 + b/2, y0 - hTri);
            drawLabel(labels.h, x0 + b/2 - 25, y0 - hTri/2);
            drawLabel(labels.b, x0 + b/2, y0 + labelGap);
            drawLabel(labels.l, x0 + b + l/2 + 25, y0 - l*0.1);
        }
        else if (type === 'pyramid') {
            const pw = valW * scale;
            const ph = valH * scale;
            const pd = valD * scale * 0.5;
            const x0 = cx - (pw + pd)/2;
            const y0 = cy + (ph/2);
            const apex = { x: x0 + pw/2 + pd/2, y: y0 - pd/2 - ph };

            ctx.beginPath();
            ctx.moveTo(x0, y0); ctx.lineTo(x0 + pw, y0); ctx.lineTo(x0 + pw + pd, y0 - pd);
            ctx.stroke();
            drawDashed(x0, y0, x0 + pd, y0 - pd);
            drawDashed(x0 + pd, y0 - pd, x0 + pw + pd, y0 - pd);

            ctx.beginPath();
            ctx.moveTo(x0, y0); ctx.lineTo(apex.x, apex.y);
            ctx.lineTo(x0 + pw, y0); ctx.lineTo(apex.x, apex.y);
            ctx.lineTo(x0 + pw + pd, y0 - pd);
            ctx.stroke();
            drawDashed(x0 + pd, y0 - pd, apex.x, apex.y);
            drawDashed(apex.x, y0 - pd/2, apex.x, apex.y);

            drawLabel(labels.h, apex.x + labelGap + 15, (y0 - pd/2 + apex.y)/2);
            drawLabel(labels.w || labels.s, x0 + pw/2, y0 + labelGap);
        }
        else {
            // ROUNDED SHAPES logic
            const r = valR * scale;
            const vh = valH * scale;

            const drawCircleBase = (x, y, rad, isDashed = false) => {
                ctx.beginPath();
                ctx.ellipse(x, y, rad, rad/3, 0, 0, Math.PI, false);
                ctx.stroke();
                if (isDashed) {
                    ctx.save(); ctx.setLineDash([8,8]);
                    ctx.beginPath(); ctx.ellipse(x, y, rad, rad/3, 0, Math.PI, 2*Math.PI, false);
                    ctx.stroke(); ctx.restore();
                } else {
                    ctx.beginPath(); ctx.ellipse(x, y, rad, rad/3, 0, Math.PI, 2*Math.PI, false);
                    ctx.stroke();
                }
            };

            const drawRadiusOrDiameter = (x, y, rad) => {
                const isDiam = data.show === 'diameter';
                const labelText = isDiam ? (labels.d ? `d = ${labels.d}` : `d = ${valR * 2}`) : (labels.r ? `r = ${labels.r}` : `r = ${valR}`);
                if (isDiam) {
                    drawDashed(x - rad, y, x + rad, y);
                    drawLabel(labelText, x, y - labelGap);
                } else {
                    ctx.beginPath(); ctx.arc(x, y, 6, 0, 2*Math.PI); ctx.fill();
                    drawDashed(x, y, x + rad, y);
                    drawLabel(labelText, x + rad/2, y - labelGap);
                }
            };

            if (type === 'cylinder' || type === 'silo') {
                const yTop = cy - vh/2; const yBot = cy + vh/2;
                drawCircleBase(cx, yTop, r, false);
                drawCircleBase(cx, yBot, r, true);
                ctx.beginPath();
                ctx.moveTo(cx - r, yTop); ctx.lineTo(cx - r, yBot);
                ctx.moveTo(cx + r, yTop); ctx.lineTo(cx + r, yBot);
                ctx.stroke();
                if (type === 'silo') { ctx.beginPath(); ctx.arc(cx, yTop, r, Math.PI, 0); ctx.stroke(); }
                drawRadiusOrDiameter(cx, yTop, r);
                drawLabel(labels.h, cx + r + labelGap, cy);
            }
            else if (type === 'cone' || type === 'ice_cream') {
                const yBase = type === 'cone' ? cy + vh/2 : cy - 20;
                const apexY = type === 'cone' ? yBase - vh : yBase + vh;
                drawCircleBase(cx, yBase, r, type === 'cone');
                ctx.beginPath();
                ctx.moveTo(cx - r, yBase); ctx.lineTo(cx, apexY); ctx.lineTo(cx + r, yBase);
                ctx.stroke();
                if (type === 'ice_cream') { ctx.beginPath(); ctx.arc(cx, yBase, r, Math.PI, 0); ctx.stroke(); }
                drawRadiusOrDiameter(cx, yBase, r);
                drawLabel(labels.h, cx + r + labelGap, (yBase + apexY)/2);
            }
            else if (type === 'sphere') {
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2*Math.PI); ctx.stroke();
                drawRadiusOrDiameter(cx, cy, r);
            }
        }
    }, [data, width, height]);

    return (
        <div className="flex justify-center items-center w-full h-full min-h-[260px] p-4 bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
            <canvas 
                ref={canvasRef} 
                width={width * 2} 
                height={height * 2} 
                style={{ width: '100%', height: '100%', maxWidth: width, maxHeight: height }}
                className="object-contain"
            />
        </div>
    );
};

// FILE END: src\components\visuals\VolumeVisualization.jsx

// =======================================================
// FILE START: src\constants\content_map.js
// =======================================================

/**
 * CONTENT_MAP
 * En omfattande guide √∂ver alla √§mnesomr√•den och progressioner i Anpassa.
 * F√§rgkodad per kategori f√∂r att matcha gr√§nssnittet.
 */

export const CONTENT_MAP = [
    // ==========================================
    // 1. TALUPPFATTNING & ARITMETIK (Pink)
    // ==========================================
    {
        id: 'arithmetic',
        title: { sv: "Taluppfattning & Aritmetik", en: "Number Theory & Arithmetic" },
        color: "pink",
        topics: [
            {
                id: "arithmetic",
                name: { sv: "De Fyra R√§knes√§tten", en: "The 4 Operations" },
                levels: [
                    { lvl: 1, desc: { sv: "Addition: Uppst√§llning", en: "Addition: Column Method" }, ex: "345 + 129" },
                    { lvl: 2, desc: { sv: "Subtraktion: V√§xling", en: "Subtraction: Borrowing" }, ex: "502 - 148" },
                    { lvl: 3, desc: { sv: "Decimaltal: Vertikal r√§kning", en: "Decimals: Vertical" }, ex: "12,45 + 8,7" },
                    { lvl: 4, desc: { sv: "Multiplikation: Tabelltr√§ning", en: "Multiplication: Tables" }, ex: "7 √ó 8" },
                    { lvl: 5, desc: { sv: "Multiplikation: Uppst√§llning", en: "Mult: Column Method" }, ex: "23 √ó 4" },
                    { lvl: 6, desc: { sv: "Multiplikation: Decimaler", en: "Mult: Decimals" }, ex: "0,5 √ó 12" },
                    { lvl: 7, desc: { sv: "Kort Division: Grunder", en: "Short Division: Basics" }, ex: "84 / 4" },
                    { lvl: 8, desc: { sv: "Heltal: Blandat", en: "Mixed Integers" }, ex: "45 + 12, 7 √ó 9" },
                    { lvl: 9, desc: { sv: "Decimaler: Blandat", en: "Mixed Decimals" }, ex: "1,2 + 0,8, 0,5 √ó 4" }
                ]
            },
            {
                id: "order_of_operations",
                name: { sv: "Prioriteringsregler", en: "Order of Operations" },
                levels: [
                    { lvl: 1, desc: { sv: "Grundl√§ggande prioritering", en: "Basic Priority" }, ex: "5 + 2 √ó 3" },
                    { lvl: 2, desc: { sv: "Anv√§nda parenteser", en: "Using Parentheses" }, ex: "(5 + 2) √ó 3" },
                    { lvl: 3, desc: { sv: "Br√•kstreck som gruppering", en: "Fraction Bar Grouping" }, ex: "(10-2)/4 + 5" },
                    { lvl: 4, desc: { sv: "Potenser & Kombinationer", en: "Powers & Combinations" }, ex: "3¬≤ + 2 √ó (10-4)" }
                ]
            },
            {
                id: "fraction_basics",
                name: { sv: "Br√•k: Grunder", en: "Fractions: Basics" },
                levels: [
                    { lvl: 1, desc: { sv: "Visuella Br√•k", en: "Visual Fractions" }, ex: "1/4 f√§rgad" },
                    { lvl: 2, desc: { sv: "Andel av antal", en: "Fraction of a quantity" }, ex: "1/4 av 20" },
                    { lvl: 3, desc: { sv: "Blandad form & Br√•kform", en: "Mixed & Improper" }, ex: "1 1/2 <-> 3/2" },
                    { lvl: 4, desc: { sv: "F√∂rkortning & F√∂rl√§ngning", en: "Simplifying & Extending" }, ex: "2/4 = 1/2" },
                    { lvl: 5, desc: { sv: "Decimaltal <-> Br√•k", en: "Decimals <-> Fractions" }, ex: "1/5 = 0,2" }
                ]
            },
            {
                id: "fraction_arith",
                name: { sv: "Br√•kr√§kning", en: "Fraction Arithmetic" },
                levels: [
                    { lvl: 1, desc: { sv: "Add/Sub: Lika n√§mnare", en: "Add/Sub: Same denom" }, ex: "1/5 + 2/5" },
                    { lvl: 2, desc: { sv: "Add/Sub: Olika n√§mnare", en: "Add/Sub: Diff denom" }, ex: "1/2 + 1/4" },
                    { lvl: 3, desc: { sv: "Blandade tal", en: "Mixed Numbers" }, ex: "1 1/2 + 3/4" },
                    { lvl: 4, desc: { sv: "Multiplikation", en: "Multiplication" }, ex: "2/3 √ó 4/5" },
                    { lvl: 5, desc: { sv: "Division", en: "Division" }, ex: "1/2 / 1/4" }
                ]
            },
            {
                id: "negative",
                name: { sv: "Negativa Tal", en: "Negative Numbers" },
                levels: [
                    { lvl: 1, desc: { sv: "Grunder & Tallinjen", en: "Basics & Number line" }, ex: "-5 < -2" },
                    { lvl: 2, desc: { sv: "Add/Sub: Fluency", en: "Add/Sub: Fluency" }, ex: "5 + (-8)" },
                    { lvl: 3, desc: { sv: "Multiplikation", en: "Multiplication" }, ex: "(-3) √ó (-4)" },
                    { lvl: 4, desc: { sv: "Division", en: "Division" }, ex: "(-12) / 3" },
                    { lvl: 5, desc: { sv: "Blandade r√§knes√§tt", en: "Mixed operations" }, ex: "(-2) + 3 √ó (-4)" }
                ]
            },
            {
                id: "ten_powers",
                name: { sv: "10, 100, 1000", en: "Powers of Ten" },
                levels: [
                    { lvl: 1, desc: { sv: "Multiplikation & Division", en: "Mult & Div" }, ex: "3,5 √ó 100" },
                    { lvl: 2, desc: { sv: "Begrepp & Potensform", en: "Concepts & Power form" }, ex: "1000 = 10¬≥" },
                    { lvl: 3, desc: { sv: "Division med 0,1 & 0,01", en: "Div by 0.1 & 0.01" }, ex: "5 / 0,1" }
                ]
            },
            {
                id: "exponents",
                name: { sv: "Potenser & R√∂tter", en: "Exponents & Roots" },
                levels: [
                    { lvl: 1, desc: { sv: "Grunder & Definitioner", en: "Foundations" }, ex: "3¬≤ = 9, x‚Å∞ = 1" },
                    { lvl: 2, desc: { sv: "Tiopotenser", en: "Powers of Ten" }, ex: "10‚Å¥, 10‚Åª¬≤" },
                    { lvl: 3, desc: { sv: "Grundpotensform", en: "Scientific Notation" }, ex: "4,5 √ó 10¬≥" },
                    { lvl: 4, desc: { sv: "Kvadratr√∂tter", en: "Square Roots" }, ex: "‚àö25 = 5" },
                    { lvl: 5, desc: { sv: "Potenslagar: Bas", en: "Basic Laws" }, ex: "x¬≤ √ó x¬≥ = x‚Åµ" },
                    { lvl: 6, desc: { sv: "Potenslagar: Avancerat", en: "Advanced Laws" }, ex: "(x¬≤)¬≥ = x‚Å∂" }
                ]
            },
            {
                id: "percent",
                name: { sv: "Procent", en: "Percent" },
                levels: [
                    { lvl: 1, desc: { sv: "Begrepp & Bilder", en: "Concepts & Visuals" }, ex: "10% = 1/10" },
                    { lvl: 2, desc: { sv: "Huvudr√§kning (Bas)", en: "Mental Math" }, ex: "25% av 400" },
                    { lvl: 3, desc: { sv: "Sammansatta procent", en: "Composition" }, ex: "35% av 200" },
                    { lvl: 4, desc: { sv: "Andelen i procent", en: "Finding the Percent" }, ex: "8 av 40" },
                    { lvl: 5, desc: { sv: "Hitta det hela (100%)", en: "Find the Whole" }, ex: "10% √§r 5, vad √§r 100%?" },
                    { lvl: 6, desc: { sv: "Procentuell f√∂r√§ndring", en: "Percentage Change" }, ex: "Fr√•n 200 till 250" }
                ]
            }
        ]
    },

    // ==========================================
    // 2. ALGEBRA (Indigo)
    // ==========================================
    {
        id: 'algebra',
        title: { sv: "Algebra & M√∂nster", en: "Algebra & Patterns" },
        color: "indigo",
        topics: [
            {
                id: "simplify",
                name: { sv: "Uttryck & F√∂renkling", en: "Expressions" },
                levels: [
                    { lvl: 1, desc: { sv: "Samla likadana termer", en: "Combine like terms" }, ex: "2x + 3x - x" },
                    { lvl: 2, desc: { sv: "Parenteser (Distributivitet)", en: "Parentheses" }, ex: "3(x + 2)" },
                    { lvl: 3, desc: { sv: "Expandera & F√∂renkla", en: "Expand & Simplify" }, ex: "2(x+3) + 4x" },
                    { lvl: 4, desc: { sv: "Minusparenteser", en: "Negative Parentheses" }, ex: "5 - (x - 2)" },
                    { lvl: 5, desc: { sv: "Vardagsproblem", en: "Word Problems" }, ex: "Teckna uttryck f√∂r l√∂n" },
                    { lvl: 6, desc: { sv: "Blandad f√∂renkling", en: "Mixed Simplification" }, ex: "Sammansatta uttryck" }
                ]
            },
            {
                id: "equations",
                name: { sv: "Ekvationer", en: "Equations" },
                levels: [
                    { lvl: 1, desc: { sv: "Enstegsekvationer", en: "One-step" }, ex: "x + 5 = 12" },
                    { lvl: 2, desc: { sv: "Tv√•stegsekvationer", en: "Two-step" }, ex: "2x + 3 = 11" },
                    { lvl: 3, desc: { sv: "Ekvationer med parentes", en: "Parentheses" }, ex: "2(x + 1) = 10" },
                    { lvl: 4, desc: { sv: "Variabel p√• b√•da sidor", en: "Variables both sides" }, ex: "3x + 2 = x + 8" },
                    { lvl: 5, desc: { sv: "Teckna ekvationer", en: "Formulate Equations" }, ex: "Fr√•n text till ax+b=c" },
                    { lvl: 6, desc: { sv: "Probleml√∂sning", en: "Problem Solving" }, ex: "L√∂s textuppgifter med ekvationer" }
                ]
            },
            {
                id: "patterns",
                name: { sv: "M√∂nster & Formler", en: "Patterns & Formulas" },
                levels: [
                    { lvl: 1, desc: { sv: "Talf√∂ljder & Differens", en: "Sequences" }, ex: "2, 5, 8, ..." },
                    { lvl: 2, desc: { sv: "Hitta h√∂ga figurnummer", en: "High Term Index" }, ex: "Figur nummer 100" },
                    { lvl: 3, desc: { sv: "Visuella Formler", en: "Visual Formulas" }, ex: "T√§ndsticksm√∂nster" },
                    { lvl: 4, desc: { sv: "Tabell till Formel", en: "Table to Formula" }, ex: "y = an + b" },
                    { lvl: 5, desc: { sv: "Bakl√§ngesr√§kning", en: "Reverse Engineering" }, ex: "Vilken figur har 100 delar?" }
                ]
            },
            {
                id: "linear_graph",
                name: { sv: "R√§ta Linjens Ekvation", en: "Linear Graphs" },
                levels: [
                    { lvl: 1, desc: { sv: "Identifiera m-v√§rde", en: "Find m-value" }, ex: "Sk√§rning y-axeln" },
                    { lvl: 2, desc: { sv: "Positiv lutning (k)", en: "Positive Slope" }, ex: "Trappsteg upp" },
                    { lvl: 3, desc: { sv: "Negativ lutning (k)", en: "Negative Slope" }, ex: "Trappsteg ner" },
                    { lvl: 4, desc: { sv: "Best√§m formeln", en: "Determine Formula" }, ex: "y = kx + m" },
                    { lvl: 5, desc: { sv: "Blandade grafer", en: "Mixed Graphs" }, ex: "Analysera linjer" }
                ]
            },
            {
                id: "change_factor",
                name: { sv: "F√∂r√§ndringsfaktor", en: "Change Factors" },
                levels: [
                    { lvl: 1, desc: { sv: "Begrepp & Omvandling", en: "Concepts" }, ex: "+20% -> 1,20" },
                    { lvl: 2, desc: { sv: "Ber√§kna nytt v√§rde", en: "Calculate New Value" }, ex: "Gammalt √ó Faktor" },
                    { lvl: 3, desc: { sv: "Hitta ursprungsv√§rdet", en: "Find Original" }, ex: "Nytt / Faktor" },
                    { lvl: 4, desc: { sv: "Upprepad f√∂r√§ndring", en: "Total Change" }, ex: "Faktor √ó Faktor" },
                    { lvl: 5, desc: { sv: "Vardagsproblem", en: "Word Problems" }, ex: "R√§nta & V√§rdeminskning" }
                ]
            }
        ]
    },

    // ==========================================
    // 3. GEOMETRI (Amber)
    // ==========================================
    {
        id: 'geometry',
        title: { sv: "Geometri & M√§tning", en: "Geometry & Measurement" },
        color: "amber",
        topics: [
            {
                id: "geometry",
                name: { sv: "Area & Omkrets", en: "Area & Perimeter" },
                levels: [
                    { lvl: 1, desc: { sv: "Omkrets: Rektanglar", en: "Perimeter: Rects" }, ex: "V√§gen runt om" },
                    { lvl: 2, desc: { sv: "Area: Rektangel/Parall.", en: "Area: Rects/Parall." }, ex: "Bas √ó H√∂jd" },
                    { lvl: 3, desc: { sv: "Trianglar", en: "Triangles" }, ex: "(B √ó H) / 2" },
                    { lvl: 4, desc: { sv: "Sammansatta (L-form)", en: "Composite (L-shape)" }, ex: "Dela upp ytor" },
                    { lvl: 5, desc: { sv: "Cirkeln", en: "The Circle" }, ex: "Area & Omkrets med Pi" },
                    { lvl: 6, desc: { sv: "Sammansatta (Hus/Portal)", en: "Composite (House)" }, ex: "Avancerad geometri" }
                ]
            },
            {
                id: "angles",
                name: { sv: "Vinklar", en: "Angles" },
                levels: [
                    { lvl: 1, desc: { sv: "Klassificering", en: "Classification" }, ex: "Spetsig, r√§t, trubbig" },
                    { lvl: 2, desc: { sv: "Grannvinklar (180/90)", en: "Comp/Supp" }, ex: "180 - k√§nd vinkel" },
                    { lvl: 3, desc: { sv: "Vertikalvinklar", en: "Vertical Angles" }, ex: "Mitt emot varandra" },
                    { lvl: 4, desc: { sv: "Triangelns vinkelsumma", en: "Triangle Sum" }, ex: "Svar: 180¬∞" },
                    { lvl: 5, desc: { sv: "Polygoner", en: "Polygons" }, ex: "(n-2) √ó 180" },
                    { lvl: 6, desc: { sv: "Parallella linjer", en: "Parallel Lines" }, ex: "Z, F och U-vinklar" }
                ]
            },
            {
                id: "volume",
                name: { sv: "Volym & Yta", en: "Volume & Area" },
                levels: [
                    { lvl: 1, desc: { sv: "R√§tblock & Kub", en: "Cuboids" }, ex: "B √ó D √ó H" },
                    { lvl: 2, desc: { sv: "Prisma", en: "Prism" }, ex: "Basarea √ó H√∂jd" },
                    { lvl: 3, desc: { sv: "Cylinder", en: "Cylinder" }, ex: "Pi √ó r¬≤ √ó H" },
                    { lvl: 4, desc: { sv: "Pyramid & Kon", en: "Pyramid & Cone" }, ex: "(Basarea √ó H) / 3" },
                    { lvl: 5, desc: { sv: "Klot & Sammansatta", en: "Sphere & Composite" }, ex: "4 √ó Pi √ó r¬≥ / 3" },
                    { lvl: 6, desc: { sv: "Blandade Volymer", en: "Mixed Volumes" }, ex: "Diameter-f√§llor" },
                    { lvl: 7, desc: { sv: "Enhetsomvandling", en: "Unit Conversion" }, ex: "dm¬≥ <-> Liter" },
                    { lvl: 8, desc: { sv: "Begr√§nsningsyta", en: "Surface Area" }, ex: "Arean p√• utsidan" }
                ]
            },
            {
                id: "similarity",
                name: { sv: "Likformighet", en: "Similarity" },
                levels: [
                    { lvl: 1, desc: { sv: "√Ñr de likformiga?", en: "Are they similar?" }, ex: "J√§mf√∂r sidf√∂rh√•llanden" },
                    { lvl: 2, desc: { sv: "Ber√§kna sida (Enkel)", en: "Calc Side (Simple)" }, ex: "Anv√§nd l√§ngdskala" },
                    { lvl: 3, desc: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" }, ex: "Liten vs Stor triangel" },
                    { lvl: 4, desc: { sv: "Pythagoras & Likform.", en: "Pythagoras & Sim." }, ex: "Kombinerade problem" }
                ]
            },
            {
                id: "pythagoras",
                name: { sv: "Pythagoras Sats", en: "Pythagorean Theorem" },
                levels: [
                    { lvl: 1, desc: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" }, ex: "3¬≤ = 9, ‚àö16 = 4" },
                    { lvl: 2, desc: { sv: "Hitta Hypotenusan (c)", en: "Find Hypotenuse" }, ex: "a¬≤ + b¬≤ = c¬≤" },
                    { lvl: 3, desc: { sv: "Hitta Kateten (a/b)", en: "Find Leg" }, ex: "c¬≤ - a¬≤ = b¬≤" },
                    { lvl: 4, desc: { sv: "Vardagsproblem", en: "Word Problems" }, ex: "Stegen mot v√§ggen" },
                    { lvl: 5, desc: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-angled?" }, ex: "Kontrollera satsen" },
                    { lvl: 6, desc: { sv: "Koordinatsystem", en: "Coordinate Systems" }, ex: "Avst√•nd mellan punkter" }
                ]
            }
        ]
    },

    // ==========================================
    // 4. DATA & SANNOLIKHET (Rose)
    // ==========================================
    {
        id: 'data',
        title: { sv: "Data & Sannolikhet", en: "Data & Probability" },
        color: "rose",
        topics: [
            {
                id: "statistics",
                name: { sv: "Statistik", en: "Statistics" },
                levels: [
                    { lvl: 1, desc: { sv: "Typv√§rde & Bredd", en: "Mode & Range" }, ex: "Vanligaste v√§rdet" },
                    { lvl: 2, desc: { sv: "Medelv√§rde", en: "The Mean" }, ex: "Summa / Antal" },
                    { lvl: 3, desc: { sv: "Medianen", en: "The Median" }, ex: "Mittersta talet" },
                    { lvl: 4, desc: { sv: "Bakl√§nges: Medelv√§rde", en: "Reverse Mean" }, ex: "Hitta saknat tal" },
                    { lvl: 5, desc: { sv: "Frekvenstabell", en: "Frequency Table" }, ex: "Medel fr√•n tabell" },
                    { lvl: 6, desc: { sv: "Analys & Outliers", en: "Analysis & Outliers" }, ex: "Viktat medelv√§rde" }
                ]
            },
            {
                id: "probability",
                name: { sv: "Sannolikhet", en: "Probability" },
                levels: [
                    { lvl: 1, desc: { sv: "Enkel sannolikhet", en: "Basic Probability" }, ex: "Gynsamma / M√∂jliga" },
                    { lvl: 2, desc: { sv: "F√∂rh√•llanden & Grupper", en: "Ratios & Groups" }, ex: "R√∂da vs Bl√• kulor" },
                    { lvl: 3, desc: { sv: "Begrepp & Chans", en: "Concepts & Chance" }, ex: "S√§kert, Om√∂jligt" },
                    { lvl: 4, desc: { sv: "Komplementh√§ndelse", en: "Complementary" }, ex: "Sannolikhet f√∂r 'Inte'" },
                    { lvl: 5, desc: { sv: "Sannolikhetstr√§d", en: "Probability Trees" }, ex: "Dragning utan √•terl√§ggning" },
                    { lvl: 6, desc: { sv: "H√§ndelsekedjor", en: "Event Chains" }, ex: "En av varje f√§rg" },
                    { lvl: 7, desc: { sv: "Kombinatorik", en: "Combinatorics" }, ex: "Handskakningar" },
                    { lvl: 8, desc: { sv: "Avancerade v√§gar", en: "Complex Pathways" }, ex: "A till B genom n√§tverk" }
                ]
            }
        ]
    }
];

// FILE END: src\constants\content_map.js

// =======================================================
// FILE START: src\constants\curriculum.js
// =======================================================

export const CATEGORIES = {
    ARITHMETIC: {
        id: 'ARITHMETIC',
        label: { en: 'Number Theory', sv: 'Taluppfattning' },
        color: 'pink',
        generators: [
            { id: 'BasicArithmeticGen', api: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'FractionBasicsGen', api: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, // Added
            { id: 'FractionArithGen', api: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, // Added
            { id: 'NegativeNumbersGen', api: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'TenPowersGen', api: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'PercentGen', api: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    ALGEBRA: {
        id: 'ALGEBRA',
        label: { en: 'Algebra', sv: 'Algebra' },
        color: 'indigo',
        generators: [
            { id: 'ExpressionSimplificationGen', api: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'PatternsGen', api: 'patterns', label: { sv: "Algebraiska m√∂nster", en: "Algebraic Patterns" } },
            { id: 'EquationGenerator', api: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'LinearGraphGenerator', api: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    },
    GEOMETRY: {
        id: 'GEOMETRY',
        label: { en: 'Geometry', sv: 'Geometri' },
        color: 'emerald',
        generators: [
            { id: 'GeometryGenerator', api: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'ScaleGenerator', api: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'VolumeGenerator', api: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'SimilarityGenerator', api: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'PythagorasGen', api: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } },
            { id: 'AnglesGen', api: 'angles', label: { sv: "Vinklar", en: "Angles" } }
        ]
    },
    STATISTICS: {
        id: 'STATISTICS',
        label: { en: 'Statistics', sv: 'Sannolikhet & Statistik' },
        color: 'yellow',
        generators: [
            { id: 'ProbabilityGen', api: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
            { id: 'StatisticsGen', api: 'statistics', label: { sv: "Statistik", en: "Statistics" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    BasicArithmeticGen: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    FractionBasicsGen: { // New
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Del av antal", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    FractionArithGen: { // New
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+ och -)", en: "Mixed Numbers (+ and -)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    NegativeNumbersGen: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    TenPowersGen: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    PatternsGen: { 
        1: { sv: "Hitta n√§sta tal & Skillnad", en: "Next Number & Difference" },
        2: { sv: "Ber√§kna h√∂ga figurer", en: "Calculate High Terms" },
        3: { sv: "Fr√•n bild till uttryck", en: "From Visual to Expression" },
        4: { sv: "Fr√•n tabell till formel", en: "Table to Formula" },
        5: { sv: "L√∂s ut n (bakl√§nges)", en: "Solve for n" }
    },
    PercentGen: {
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Ber√§kna det hela", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    EquationGenerator: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    ExpressionSimplificationGen: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    GeometryGenerator: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Sammansatta (Rekt+Tri)", en: "Combined (Rect+Tri)" },
        5: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        6: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    ScaleGenerator: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    VolumeGenerator: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" },
        7: { sv: "Begr√§nsningsyta", en: "Surface Area" } 
    },
    SimilarityGenerator: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    PythagorasGen: { 
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    },
    LinearGraphGenerator: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    },
    ProbabilityGen: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse", en: "Complementary Events" },
        5: { sv: "Tr√§ddiagram", en: "Probability tree" },
        6: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        7: { sv: "Kombinatorik", en: "Combinatorics" },
        8: { sv: "Kombinatorik (Sv√•r)", en: "Combinatorics (Hard)" }
    },
    StatisticsGen: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    AnglesGen: { 
        1: { sv: "Begrepp", en: "Concepts" },
        2: { sv: "Komplement/Supplementvinklar ", en: "Complementary/Supplementary angles" },
        3: { sv: "Vertikala vinklar", en: "Vertical Angles" },
        4: { sv: "Vinkelsumma (triangel)", en: "Angle sums (Triangle)" },
        5: { sv: "Vinkelsumma (m√•ngh√∂rning)", en: "Angle sums (Polygons)" },
        6: { sv: "Parallella linjer", en: "Parallel lines" }
    }
    
};

export const getColorClasses = (color, type) => {
    const c = color || 'emerald';
    switch (type) {
        case 'bg-light': return `bg-${c}-50`;
        case 'bg-dark': return `bg-${c}-500`;
        case 'border': return `border-${c}-100`;
        case 'text': return `text-${c}-700`;
        case 'ring': return `ring-${c}-500`;
        case 'border-solid': return `border-${c}-500`;
        default: return '';
    }
};

// FILE END: src\constants\curriculum.js

// =======================================================
// FILE START: src\constants\localization.js
// =======================================================

export const CATEGORIES = {
    arithmetic: {
        id: 'arithmetic', 
        label: { sv: "Taluppfattning", en: "Number Theory" },
        color: "pink",
        levels: 9,
        topics: [
            { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'order_of_operations', label: { sv: "Prioriteringsregler", en: "Order of Operations" } }, // Ny generator tillagd h√§r
            { id: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, 
            { id: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, 
            { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'exponents', label: { sv: "Potenser & R√∂tter", en: "Exponents & Roots" } },
            { id: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    
    algebra: {
        id: 'algebra',
        label: { sv: "Algebra", en: "Algebra" },
        color: "indigo",
        levels: 6,
        topics: [
            { id: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'patterns', label: { sv: "Algebraiska m√∂nster", en: "Algebraic patterns" } }
        ]
    },
    geometry: {
        id: 'geometry',
        label: { sv: "Geometri", en: "Geometry" },
        color: "emerald",
        levels: 7,
        topics: [
            { id: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } },
            { id: 'angles', label: { sv: "Vinklar", en: "Angles" } }
        ]
    },

    statistics: { 
        id: 'statistics',
        label: { sv: "Sannolikhet & Statistik", en: "Prob & Stats" },
        color: "yellow", 
        levels: 6,
        topics: [
             { id: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
             { id: 'statistics', label: { sv: "Statistik", en: "Statistics" } },
             { id: 'linear_graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } },
             { id: 'change_factor', label: { sv: "F√∂r√§ndringsfaktor", en: "Change Factor" } }
        ]
    }
};

export const CATEGORIES_ARRAY = Object.values(CATEGORIES);

export const UI_TEXT = {
    sv: {
        hero_title: "Mattest√∂d",
        hero_subtitle: "Anpassade uppgifter f√∂r h√∂gstadiet.",
        tagline: "R√§tt st√∂d. Direkt.",
        startBtn: "Starta √ñvning",
        aboutBtn: "Om Skaparen",
        contactTitle: "Kontakta mig",
        aboutTitle: "Om Skaparen",
        aboutText: "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att hitta nya s√§tt att undervisa i klassrummet.",
        contactLink: "F√∂lj mig p√• LinkedIn",
        tagCorrect: "R√§tt", tagWrong: "Fel", tagSkipped: "Hoppade √∂ver",
        streak_modal_title: "Grymt jobbat! üî•", streak_modal_msg: "Du har en streak p√• {streak}!",
        total_modal_title: "Bra jobbat! ‚úÖ", total_modal_msg: "Du har klarat {total} uppgifter! Forts√§tt s√•!",
        btn_close_streak: "K√∂r vidare!", btn_close_total: "Forts√§tt",
        timer_title: "Timer", timer_off: "Av", timer_min: "min", timer_reset: "Nollst√§ll", timer_paused: "Pausad",
        stats_title: "Statistik", stats_times_up: "Tiden √§r ute!", stats_longest_streak: "L√§ngsta streak", stats_attempted: "F√∂rs√∂k", stats_correct_no_help: "R√§tt (utan hj√§lp)", stats_correct_help: "R√§tt (med hj√§lp)", stats_incorrect: "Fel", stats_skipped: "Hoppade √∂ver", stats_close: "St√§ng",
        menu_btn: "Meny", level_breakdown: "Niv√•detaljer",
        stat_skip: "Hopp", stat_wrong: "Fel", stat_help: "Hj√§lp", stat_correct: "R√§tt", stat_total: "Totalt",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Aktivitet", donow_desc: "V√§lj upp till 3 niv√•er f√∂r att generera ett startkort.",
        donow_generate: "Generera", backBtn: "Tillbaka",
        donow_show_all: "Visa Alla Svar", donow_hide_all: "D√∂lj Alla Svar",
        donow_regenerate: "Nytt Set", 
        levels: "Niv√•er",
        clickToSelect: "Klicka f√∂r att v√§lja niv√•",
        selectLevel: "V√§lj Niv√•",
        btnCheck: "Svara", btnHint: "Ledtr√•d", btnSolution: "L√∂sning", btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        error: "N√•got gick fel. F√∂rs√∂k igen.",
        levelUpTitle: "Niv√• upp?", levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", levelUpYes: "Ja, k√∂r!", levelUpNo: "Nej, stanna h√§r"
    },
    en: {
        hero_title: "Math Support",
        hero_subtitle: "Adaptive exercises for middle school.",
        tagline: "Right support. Instantly.",
        startBtn: "Start Practice",
        aboutBtn: "About Creator",
        contactTitle: "Contact Me",
        aboutTitle: "About the Creator",
        aboutText: "Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
        contactLink: "Follow me on LinkedIn",
        tagCorrect: "Correct", tagWrong: "Wrong", tagSkipped: "Skipped",
        streak_modal_title: "Awesome! üî•", streak_modal_msg: "You hit a streak of {streak}!",
        total_modal_title: "Great work! ‚úÖ", total_modal_msg: "You answered {total} questions correctly! Great job!",
        btn_close_streak: "Great job!", btn_close_total: "Continue",
        timer_title: "Practice Timer", timer_off: "Off", timer_min: "min", timer_reset: "Reset", timer_paused: "Paused",
        stats_title: "Statistics", stats_times_up: "Time's up!", stats_longest_streak: "Longest streak", stats_attempted: "Problems attempted", stats_correct_no_help: "Correct (no help)", stats_correct_help: "Correct (with help)", stats_incorrect: "Incorrect", stats_skipped: "Skipped", stats_close: "Close",
        menu_btn: "Menu", level_breakdown: "Level Breakdown",
        stat_skip: "Skip", stat_wrong: "Wrong", stat_help: "Help", stat_correct: "Correct", stat_total: "Total",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Activity", donow_desc: "Select up to 3 levels to generate a startup card.",
        donow_generate: "Generate", backBtn: "Back",
        donow_show_all: "Show All Answers", donow_hide_all: "Hide All Answers",
        donow_regenerate: "New Set", 
        levels: "Levels",
        clickToSelect: "Click to select level",
        selectLevel: "Select Level",
        btnCheck: "Submit", btnHint: "Hint", btnSolution: "Solution", btnSkip: "Skip",
        btnNext: "Next ‚û°",
        error: "Something went wrong. Please retry.",
        levelUpTitle: "Level Up?", levelUpDesc: "You seem to know this! Do you want to skip to the next level?", levelUpYes: "Yes, let's go!", levelUpNo: "No, stay here"
    }
};

export const LEVEL_DESCRIPTIONS = {
    order_of_operations: {
        1: { sv: "Prioritering: Grund", en: "Order: Basics" },
        2: { sv: "Prioritering: Parenteser", en: "Order: Parentheses" },
        3: { sv: "Prioritering: Br√•kstreck", en: "Order: Fraction Bars" },
        4: { sv: "Prioritering: Potenser", en: "Order: Powers" }
    },
    angles: {
        1: { sv: "Vinkeltyper", en: "Types of Angles" },
        2: { sv: "Komplement & Supplement", en: "Complementary & Supplementary" },
        3: { sv: "Vertikal- & Sidovinklar", en: "Vertical & Adjacent Angles" },
        4: { sv: "Vinkelsumma (Triangel)", en: "Triangle Angle Sum" },
        5: { sv: "Likbel√§gna & Alternatvinklar", en: "Parallel Lines" },
        6: { sv: "Vinkelsumma (Polygoner)", en: "Polygon Angle Sum" }
    },
    change_factor: {
        1: { sv: "Begrepp & Definition", en: "Concepts & Definitions" },
        2: { sv: "Ber√§kna nya v√§rdet", en: "Calculate New Value" },
        3: { sv: "Ber√§kna gamla v√§rdet", en: "Find Original Value" },
        4: { sv: "Total f√∂r√§ndring", en: "Total Change" },
        5: { sv: "Textuppgifter", en: "Word Problems" }
    },
    fraction_basics: {
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Ber√§kna delen", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    fraction_arith: {
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+ och -)", en: "Mixed Numbers (+ and -)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    exponents: { 
        1: { sv: "Grunder & x^0", en: "Foundations & x^0" },
        2: { sv: "Tiopotenser", en: "Powers of 10" },
        3: { sv: "Grundpotensform", en: "Scientific Notation" },
        4: { sv: "Kvadratr√∂tter", en: "Square Roots" },
        5: { sv: "Potenslagar (Enkel)", en: "Exponent Laws (Basic)" },
        6: { sv: "Potenslagar (Avancerad)", en: "Exponent Laws (Adv)" }
    },
    arithmetic: {
        1: { sv: "Addition (Uppst√§llning)", en: "Addition (Vertical)" },
        2: { sv: "Subtraktion (Uppst√§llning)", en: "Subtraction (Vertical)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (Enkel)", en: "Multiplication (Simple)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Kort Division", en: "Short Division" },
        8: { sv: "Blandade Heltal", en: "Mixed Integers" },
        9: { sv: "Blandade Decimaltal", en: "Mixed Decimals" }
    },
    negative: {
        1: { sv: "Enkel Addition/Subtraktion", en: "Simple Add/Sub" },
        2: { sv: "Sv√•rare Addition/Subtraktion", en: "Harder Add/Sub" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandade Uppgifter", en: "Mixed Problems" }
    },
    ten_powers: {
        1: { sv: "Mult/Div med 10, 100, 1000", en: "Mult/Div by 10, 100, 1000" },
        2: { sv: "Begreppsf√∂rst√•else", en: "Conceptual Understanding" },
        3: { sv: "Blandade Faktorer (0.1, 100...)", en: "Mixed Factors" }
    },
    percent: { 
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Hitta helheten (100%)", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    probability: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse (Inte)", en: "Complementary Events" },
        5: { sv: "Tr√§ddiagram", en: "Probability Trees" },
        6: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        7: { sv: "Kombinatorik", en: "Combinatorics" },
        8: { sv: "Kombinatorik (Sv√•r)", en: "Combinatorics (Hard)" }
    },
    statistics: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    simplify: {
        1: { sv: "F√∂renkla Uttryck (Enkel)", en: "Simplify Expressions (Easy)" },
        2: { sv: "Parenteser (Addition)", en: "Parentheses (Addition)" },
        3: { sv: "Parenteser (Multiplikation)", en: "Parentheses (Multiplication)" },
        4: { sv: "Parenteser (Subtraktion)", en: "Parentheses (Subtraction)" },
        5: { sv: "Probleml√∂sning", en: "Problem Solving" },
        6: { sv: "Blandade Niv√•er", en: "Mixed Levels" }
    },
    equation: {
        1: { sv: "Enkla steg (x+a=b)", en: "One Step" },
        2: { sv: "Tv√• steg (ax+b=c)", en: "Two Steps" },
        3: { sv: "Med Parenteser", en: "With Parentheses" },
        4: { sv: "Variabel p√• b√•da sidor", en: "Variables on both sides" },
        5: { sv: "Skriv Ekvation (Problem)", en: "Write Equation (Word Problems)" },
        6: { sv: "L√∂s Problem (Ekvation)", en: "Solve Word Problems" },
        7: { sv: "Blandade Ekvationer", en: "Mixed Equations" }
    },
    linear_graph: {
        1: { sv: "Hitta m-v√§rdet", en: "Find m-value" },
        2: { sv: "Hitta k-v√§rdet (Positiv)", en: "Find k-value (Positive)" },
        3: { sv: "Hitta k-v√§rdet (Negativ)", en: "Find k-value (Negative)" },
        4: { sv: "Best√§m funktionen (y=kx+m)", en: "Determine Function" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    geometry: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Sammansatta (Rekt+Tri)", en: "Composite Shapes (Rect+Tri)" },
        5: { sv: "Cirkelns Area & Omkrets", en: "Circle Area & Perimeter" },
        6: { sv: "Sammansatta (Alla)", en: "Composite Shapes (All)" }
    },
    scale: {
        1: { sv: "F√∂rst√• Skala", en: "Understand Scale" },
        2: { sv: "Ber√§kna L√§ngd (Enkel)", en: "Calculate Length (Simple)" },
        3: { sv: "Blandade Scenarier", en: "Mixed Scenarios" }, 
        4: { sv: "Best√§m Skalan", en: "Determine Scale" },
        5: { sv: "Probleml√∂sning", en: "Word Problems" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    volume: {
        1: { sv: "R√§tblock & Kub", en: "Cuboid & Cube" },
        2: { sv: "Prisma", en: "Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot & Sammansatta", en: "Sphere & Composite" },
        6: { sv: "Blandade Volymer", en: "Mixed Volumes" },
        7: { sv: "Enhetsomvandling", en: "Unit Conversion" },
        8: { sv: "Begr√§nsningsyta", en: "Surface Area" } 
    },
    similarity: {
        1: { sv: "√Ñr de likformiga?", en: "Are they similar?" },
        2: { sv: "Ber√§kna sida (Enkel)", en: "Calc Side (Simple)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras & Likformighet", en: "Pythagoras & Similarity" }
    },
    pythagoras: {
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" },
        6: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" }
    },
    patterns: { 
        1: { sv: "Hitta n√§sta tal & Skillnad", en: "Next Number & Difference" },
        2: { sv: "Ber√§kna h√∂ga figurer", en: "Calculate High Terms" },
        3: { sv: "Fr√•n bild till uttryck", en: "From Visual to Expression" },
        4: { sv: "Fr√•n tabell till formel", en: "Table to Formula" },
        5: { sv: "L√∂s ut n (bakl√§nges)", en: "Solve for n" }
    }
};

// FILE END: src\constants\localization.js

// =======================================================
// FILE START: src\constants\skillBuckets.js
// =======================================================

/**
 * MASTER REGISTRY OF SKILL BUCKETS (VARIATION KEYS)
 * Refactored for Bilingual Support (SV/EN)
 * * STRUCTURE:
 * Category -> Topic -> Variations
 * Each variation corresponds to a specific 'case' in the generator's generateByVariation() method.
 */

export const SKILL_BUCKETS = {
  // ==========================================
  // 1. ALGEBRA & M√ñNSTER
  // ==========================================
  algebra: {
    id: 'algebra',
    name: { sv: 'Algebra & M√∂nster', en: 'Algebra & Patterns' },
    topics: {
      equations: {
        name: { sv: 'Ekvationsl√∂sning', en: 'Equation Solving' },
        variations: [
          { key: 'onestep_calc', name: { sv: 'Ensteg: Ber√§kning', en: 'One-step: Calculation' }, desc: { sv: 'L√∂s enkla x + a = b', en: 'Solve simple x + a = b' } },
          { key: 'onestep_concept_inverse', name: { sv: 'Ensteg: Invers', en: 'One-step: Inverse' }, desc: { sv: 'V√§lj r√§tt r√§knes√§tt (+/-/*/√∑)', en: 'Choose the correct operation' } },
          { key: 'onestep_spot_lie', name: { sv: 'Hitta felet: Ensteg', en: 'Find the error: One-step' }, desc: { sv: 'Identifiera felaktig l√∂sning', en: 'Identify incorrect solutions' } },
          { key: 'twostep_calc', name: { sv: 'Tv√•steg: Ber√§kning', en: 'Two-step: Calculation' }, desc: { sv: 'ax + b = c', en: 'ax + b = c' } },
          { key: 'twostep_concept_order', name: { sv: 'Tv√•steg: Ordning', en: 'Two-step: Order' }, desc: { sv: 'Vilket steg tas f√∂rst?', en: 'Which step is taken first?' } },
          { key: 'paren_calc', name: { sv: 'Parenteser: Ber√§kning', en: 'Parentheses: Calculation' }, desc: { sv: 'a(x + b) = c', en: 'a(x + b) = c' } },
          { key: 'paren_lie_distribution', name: { sv: 'Hitta felet: Parentes', en: 'Find the error: Parentheses' }, desc: { sv: 'Analysera multiplikation i parentes', en: 'Analyze distribution errors' } },
          { key: 'bothsides_calc', name: { sv: 'X p√• b√•da sidor', en: 'X on both sides' }, desc: { sv: 'Samla x-termer p√• en sida', en: 'Collect x-terms on one side' } },
          { key: 'bothsides_concept_strategy', name: { sv: 'X p√• b√•da sidor: Strategi', en: 'X on both sides: Strategy' }, desc: { sv: 'H√•ll antalet x positivt', en: 'Keep the number of x positive' } }
        ]
      },
      equations_word: {
        name: { sv: 'Ekvationer: Probleml√∂sning', en: 'Equations: Problem Solving' },
        variations: [
          { key: 'rate_fixed_add_write', name: { sv: 'Skriv: Fast + R√∂rlig', en: 'Write: Fixed + Variable' }, desc: { sv: 'Teckna uttryck y = kx + m', en: 'Formulate expression y = kx + m' } },
          { key: 'rate_fixed_add_solve', name: { sv: 'L√∂s: Fast + R√∂rlig', en: 'Solve: Fixed + Variable' }, desc: { sv: 'Ber√§kna x givet total', en: 'Calculate x given total' } },
          { key: 'rate_fixed_sub_write', name: { sv: 'Skriv: Minskning', en: 'Write: Decrease' }, desc: { sv: 'Teckna uttryck y = m - kx', en: 'Formulate expression y = m - kx' } },
          { key: 'rate_fixed_sub_solve', name: { sv: 'L√∂s: Minskning', en: 'Solve: Decrease' }, desc: { sv: 'N√§r tar v√§rdet slut?', en: 'When does the value run out?' } },
          { key: 'compare_word_sum_write', name: { sv: 'Skriv: J√§mf√∂relse (Summa)', en: 'Write: Comparison (Sum)' }, desc: { sv: 'x + (x+a) = Total', en: 'x + (x+a) = Total' } },
          { key: 'compare_word_sum_solve', name: { sv: 'L√∂s: J√§mf√∂relse (Summa)', en: 'Solve: Comparison (Sum)' }, desc: { sv: 'Hitta delarna', en: 'Find the parts' } },
          { key: 'compare_word_diff_write', name: { sv: 'Skriv: J√§mf√∂relse (Diff)', en: 'Write: Comparison (Diff)' }, desc: { sv: 'x + (x-a) = Total', en: 'x + (x-a) = Total' } },
          { key: 'compare_word_diff_solve', name: { sv: 'L√∂s: J√§mf√∂relse (Diff)', en: 'Solve: Comparison (Diff)' }, desc: { sv: 'Hitta delarna', en: 'Find the parts' } }
        ]
      },
      expressions: {
        name: { sv: 'F√∂renkling av Uttryck', en: 'Expression Simplification' },
        variations: [
          { key: 'combine_lie_exponent', name: { sv: 'Hitta felet: Potenser', en: 'Find error: Exponents' }, desc: { sv: 'x + x vs x * x', en: 'x + x vs x * x' } },
          { key: 'combine_concept_id', name: { sv: 'Begrepp: Termer', en: 'Concept: Terms' }, desc: { sv: 'Identifiera lika termer', en: 'Identify like terms' } },
          { key: 'combine_standard_mixed', name: { sv: 'F√∂renkla uttryck', en: 'Simplify expressions' }, desc: { sv: 'Samla x och tal', en: 'Combine x and constants' } },
          { key: 'distribute_lie_partial', name: { sv: 'Hitta felet: Parentes', en: 'Find error: Parentheses' }, desc: { sv: 'Partiell distribution', en: 'Partial distribution' } },
          { key: 'distribute_plus', name: { sv: 'Parentes (+)', en: 'Parentheses (+)' }, desc: { sv: '+ framf√∂r parentes', en: '+ in front of parenthesis' } },
          { key: 'distribute_double', name: { sv: 'Dubbla parenteser', en: 'Double parentheses' }, desc: { sv: 'Expandera tv√• parenteser', en: 'Expand two parentheses' } },
          { key: 'distribute_combine_std', name: { sv: 'Expandera & F√∂renkla', en: 'Expand & Simplify' }, desc: { sv: 'Multiplicera och samla termer', en: 'Multiply and combine terms' } },
          { key: 'sub_concept_plus_logic', name: { sv: 'Teckenregler', en: 'Sign rules' }, desc: { sv: 'Plus framf√∂r parentes', en: 'Plus in front of parentheses' } },
          { key: 'sub_block_plus', name: { sv: 'Minusparentes (+)', en: 'Minus parentheses (+)' }, desc: { sv: '-(ax + b)', en: '-(ax + b)' } },
          { key: 'sub_block_minus', name: { sv: 'Minusparentes (-)', en: 'Minus parentheses (-)' }, desc: { sv: '-(ax - b)', en: '-(ax - b)' } },
          { key: 'word_candy', name: { sv: 'Uttryck: Godisp√•sar', en: 'Expressions: Candy bags' }, desc: { sv: 'Teckna uttryck', en: 'Formulate expression' } },
          { key: 'word_discount', name: { sv: 'Uttryck: Rabatt', en: 'Expressions: Discount' }, desc: { sv: 'Prisrelationer', en: 'Price relations' } },
          { key: 'word_combined_age_tri', name: { sv: 'Uttryck: √Öldrar', en: 'Expressions: Ages' }, desc: { sv: 'Tre personers √•lder', en: 'Ages of three people' } },
          { key: 'word_rect_perimeter', name: { sv: 'Uttryck: Omkrets', en: 'Expressions: Perimeter' }, desc: { sv: 'Rektangel med x', en: 'Rectangle with x' } },
          { key: 'word_savings', name: { sv: 'Uttryck: Sparande', en: 'Expressions: Savings' }, desc: { sv: 'Saldo med uttag/ins√§ttning', en: 'Balance with withdrawal/deposit' } },
          { key: 'word_passengers', name: { sv: 'Uttryck: Passagerare', en: 'Expressions: Passengers' }, desc: { sv: 'F√∂r√§ndring p√• buss', en: 'Changes on a bus' } },
          { key: 'word_garden', name: { sv: 'Uttryck: Tr√§dg√•rd', en: 'Expressions: Garden' }, desc: { sv: 'Plantering och bortfall', en: 'Planting and loss' } },
          { key: 'word_sports', name: { sv: 'Uttryck: Sport', en: 'Expressions: Sports' }, desc: { sv: 'Po√§ngber√§kning', en: 'Score calculation' } },
          { key: 'word_phone_battery', name: { sv: 'Uttryck: Batteri', en: 'Expressions: Battery' }, desc: { sv: 'Laddning och f√∂rbrukning', en: 'Charging and consumption' } }
        ]
      },
      patterns: {
        name: { sv: 'M√∂nster & Formler', en: 'Patterns & Formulas' },
        variations: [
          { key: 'seq_lie', name: { sv: 'Hitta felet: Talf√∂ljd', en: 'Find error: Sequence' }, desc: { sv: 'Analysera m√∂nsterlogik', en: 'Analyze pattern logic' } },
          { key: 'seq_type', name: { sv: 'M√∂nstertyp', en: 'Pattern type' }, desc: { sv: 'Aritmetisk vs Geometrisk', en: 'Arithmetic vs Geometric' } },
          { key: 'seq_diff', name: { sv: 'Hitta differensen', en: 'Find the difference' }, desc: { sv: '√ñkning per steg', en: 'Increase per step' } },
          { key: 'seq_next', name: { sv: 'N√§sta tal', en: 'Next number' }, desc: { sv: 'Forts√§tt talf√∂ljden', en: 'Continue the sequence' } },
          { key: 'high_term', name: { sv: 'Hitta tal n', en: 'Find term n' }, desc: { sv: 'Ber√§kna v√§rdet l√•ngt fram', en: 'Calculate far-off values' } },
          { key: 'formula_missing', name: { sv: 'Hitta formeln (Bild)', en: 'Find formula (Visual)' }, desc: { sv: 'Koppla bild till uttryck', en: 'Link image to expression' } },
          { key: 'visual_calc', name: { sv: 'Ber√§kna antal (Bild)', en: 'Calculate count (Visual)' }, desc: { sv: 'Hur m√•nga t√§ndstickor?', en: 'How many matches?' } },
          { key: 'find_formula', name: { sv: 'Skriv formeln', en: 'Write the formula' }, desc: { sv: 'Skapa y = kn + m', en: 'Create y = kn + m' } },
          { key: 'table_formula', name: { sv: 'Tabell till Formel', en: 'Table to Formula' }, desc: { sv: 'Hitta m√∂nster i v√§rdetabell', en: 'Find patterns in value tables' } },
          { key: 'table_fill', name: { sv: 'Fyll i tabell', en: 'Fill in table' }, desc: { sv: 'Anv√§nd formeln', en: 'Use the formula' } },
          { key: 'reverse_calc', name: { sv: 'Hitta n (Ekvation)', en: 'Find n (Equation)' }, desc: { sv: 'Vilket figurnummer har v√§rdet X?', en: 'Which figure number has value X?' } }
        ]
      },
      graphs: {
        name: { sv: 'R√§ta Linjens Ekvation', en: 'Linear Equations & Graphs' },
        variations: [
          { key: 'intercept_id', name: { sv: 'Hitta m-v√§rde', en: 'Find m-value' }, desc: { sv: 'Var sk√§r linjen y-axeln?', en: 'Where does the line cross the y-axis?' } },
          { key: 'slope_pos_int', name: { sv: 'Positiv Lutning (Heltal)', en: 'Positive Slope (Integer)' }, desc: { sv: 'Stigande k-v√§rde', en: 'Rising k-value' } },
          { key: 'slope_pos_frac', name: { sv: 'Positiv Lutning (Br√•k)', en: 'Positive Slope (Fraction)' }, desc: { sv: 'Stigande, flack/brant', en: 'Rising, shallow/steep' } },
          { key: 'slope_neg_int', name: { sv: 'Negativ Lutning (Heltal)', en: 'Negative Slope (Integer)' }, desc: { sv: 'Sjunkande k-v√§rde', en: 'Falling k-value' } },
          { key: 'slope_neg_frac', name: { sv: 'Negativ Lutning (Br√•k)', en: 'Negative Slope (Fraction)' }, desc: { sv: 'Sjunkande, flack/brant', en: 'Falling, shallow/steep' } },
          { key: 'eq_standard', name: { sv: 'Best√§m ekvation', en: 'Determine equation' }, desc: { sv: 'y = kx + m', en: 'y = kx + m' } },
          { key: 'eq_no_m', name: { sv: 'Proportionalitet', en: 'Proportionality' }, desc: { sv: 'y = kx (G√•r genom origo)', en: 'y = kx (Passes through origin)' } },
          { key: 'eq_horizontal', name: { sv: 'Horisontell linje', en: 'Horizontal line' }, desc: { sv: 'y = m (k=0)', en: 'y = m (k=0)' } }
        ]
      }
    }
  },

  // ==========================================
  // 2. ARITMETIK
  // ==========================================
  arithmetic: {
    id: 'arithmetic',
    name: { sv: 'Aritmetik & Tal', en: 'Arithmetic & Numbers' },
    topics: {
      basic_arithmetic: {
        name: { sv: 'De 4 R√§knes√§tten', en: 'The 4 Operations' },
        variations: [
          { key: 'add_std_vertical', name: { sv: 'Addition: Uppst√§llning', en: 'Addition: Column Method' }, desc: { sv: 'Stora tal', en: 'Large numbers' } },
          { key: 'add_std_horizontal', name: { sv: 'Addition: Huvudr√§kning', en: 'Addition: Mental Math' }, desc: { sv: 'Strategier', en: 'Strategies' } },
          { key: 'add_missing_variable', name: { sv: 'Addition: Hitta termen', en: 'Addition: Find the term' }, desc: { sv: 'a + x = b', en: 'a + x = b' } },
          { key: 'add_spot_the_lie', name: { sv: 'Hitta felet: Addition', en: 'Find error: Addition' }, desc: { sv: 'Fels√∂kning', en: 'Troubleshooting' } },
          { key: 'sub_std_vertical', name: { sv: 'Subtraktion: Uppst√§llning', en: 'Subtraction: Column Method' }, desc: { sv: 'V√§xling', en: 'Borrowing' } },
          { key: 'sub_std_horizontal', name: { sv: 'Subtraktion: Huvudr√§kning', en: 'Subtraction: Mental Math' }, desc: { sv: 'Strategier', en: 'Strategies' } },
          { key: 'sub_missing_variable', name: { sv: 'Subtraktion: Hitta termen', en: 'Subtraction: Find the term' }, desc: { sv: 'a - x = b', en: 'a - x = b' } },
          { key: 'dec_add_vertical', name: { sv: 'Decimaler: Addition', en: 'Decimals: Addition' }, desc: { sv: 'Passa kommatecknet', en: 'Align decimal point' } },
          { key: 'dec_sub_vertical', name: { sv: 'Decimaler: Subtraktion', en: 'Decimals: Subtraction' }, desc: { sv: 'Passa kommatecknet', en: 'Align decimal point' } },
          { key: 'mult_table_std', name: { sv: 'Multiplikationstabellen', en: 'Multiplication Tables' }, desc: { sv: 'Grundl√§ggande tabeller', en: 'Basic tables' } },
          { key: 'mult_commutative', name: { sv: 'Kommutativa lagen', en: 'Commutative Law' }, desc: { sv: 'a * b = b * a', en: 'a * b = b * a' } },
          { key: 'mult_2x1_vertical', name: { sv: 'Mult: Uppst√§llning', en: 'Mult: Column Method' }, desc: { sv: 'Tv√• siffror * en siffra', en: 'Two digits * one digit' } },
          { key: 'mult_distributive', name: { sv: 'Distributiva lagen', en: 'Distributive Law' }, desc: { sv: 'Dela upp faktorer', en: 'Split factors' } },
          { key: 'mult_decimal_std', name: { sv: 'Decimalmultiplikation', en: 'Decimal Multiplication' }, desc: { sv: 'R√§kna decimaler', en: 'Count decimals' } },
          { key: 'mult_decimal_placement', name: { sv: 'Placera kommatecknet', en: 'Place decimal point' }, desc: { sv: 'Uppskattning', en: 'Estimation' } },
          { key: 'div_basic_std', name: { sv: 'Kort division', en: 'Short Division' }, desc: { sv: 'Standardalgoritm', en: 'Standard algorithm' } },
          { key: 'div_inverse_logic', name: { sv: 'Division via multiplikation', en: 'Division via mult' }, desc: { sv: 'Samband', en: 'Connection' } }
        ]
      },
      order_of_operations: {
        name: { sv: 'Prioriteringsregler', en: 'Order of Operations' },
        variations: [
          { key: 'order_basic', name: { sv: 'Prioritering: Grund', en: 'Order: Basic' }, desc: { sv: 'Mult/Div f√∂re Add/Sub', en: 'Mult/Div before Add/Sub' } },
          { key: 'order_paren', name: { sv: 'Prioritering: Parenteser', en: 'Order: Parentheses' }, desc: { sv: 'R√§kna ut parentesen f√∂rst', en: 'Solve parentheses first' } },
          { key: 'order_fraction', name: { sv: 'Prioritering: Br√•kstreck', en: 'Order: Fraction Bar' }, desc: { sv: 'T√§ljaren fungerar som en parentes', en: 'Numerator acts as a parenthesis' } },
          { key: 'order_powers', name: { sv: 'Prioritering: Potenser', en: 'Order: Powers' }, desc: { sv: 'Parenteser > Potenser > Mult/Div', en: 'Paren > Powers > Mult/Div' } }
        ]
      },
      negatives: {
        name: { sv: 'Negativa Tal', en: 'Negative Numbers' },
        variations: [
          { key: 'theory_number_line', name: { sv: 'Tallinjen', en: 'Number line' }, desc: { sv: 'Positionering', en: 'Positioning' } },
          { key: 'theory_sign_dominance', name: { sv: 'Teckenregler', en: 'Sign rules' }, desc: { sv: 'Blir svaret plus eller minus?', en: 'Positive or negative result?' } },
          { key: 'theory_spot_lie', name: { sv: 'Hitta felet: Negativa', en: 'Find error: Negatives' }, desc: { sv: 'Vanliga missuppfattningar', en: 'Common misconceptions' } },
          { key: 'fluency_chain_4', name: { sv: 'Add/Sub Kedja (4)', en: 'Add/Sub Chain (4)' }, desc: { sv: 'Flerstegsr√§kning', en: 'Multi-step calculation' } },
          { key: 'fluency_chain_5', name: { sv: 'Add/Sub Kedja (5)', en: 'Add/Sub Chain (5)' }, desc: { sv: 'L√•nga uttryck', en: 'Long expressions' } },
          { key: 'fluency_double_neg', name: { sv: 'Dubbla minustecken', en: 'Double negative signs' }, desc: { sv: '-(-a) = +a', en: '-(-a) = +a' } },
          { key: 'fluency_plus_neg', name: { sv: 'Plus minus', en: 'Plus minus' }, desc: { sv: '+(-a) = -a', en: '+(-a) = -a' } },
          { key: 'fluency_transform_match', name: { sv: 'Matcha uttryck', en: 'Match expressions' }, desc: { sv: 'Olika skrivs√§tt', en: 'Different notations' } },
          { key: 'mult_same_sign', name: { sv: 'Mult: Samma tecken', en: 'Mult: Same signs' }, desc: { sv: 'Minus * Minus = Plus', en: 'Minus * Minus = Plus' } },
          { key: 'mult_diff_sign', name: { sv: 'Mult: Olika tecken', en: 'Mult: Different signs' }, desc: { sv: 'Minus * Plus = Minus', en: 'Minus * Plus = Minus' } },
          { key: 'mult_chain', name: { sv: 'Mult: Kedja', en: 'Mult: Chain' }, desc: { sv: 'J√§mnt/Udda antal minus', en: 'Even/Odd number of minuses' } },
          { key: 'div_basic', name: { sv: 'Division: Grund', en: 'Division: Basic' }, desc: { sv: 'Enkel division', en: 'Simple division' } },
          { key: 'div_fraction', name: { sv: 'Division: Br√•kform', en: 'Division: Fractions' }, desc: { sv: 'Tecken i br√•k', en: 'Signs in fractions' } },
          { key: 'div_check_logic', name: { sv: 'Division: Kontroll', en: 'Division: Checking' }, desc: { sv: 'Rimlighetsbed√∂mning', en: 'Reasonableness' } }
        ]
      },
      fractions_basics: {
        name: { sv: 'Br√•k: Grunder', en: 'Fractions: Basics' },
        variations: [
          { key: 'visual_lie', name: { sv: 'Hitta felet: Bilder', en: 'Find error: Visuals' }, desc: { sv: 'Visuell tolkning', en: 'Visual interpretation' } },
          { key: 'visual_inverse', name: { sv: 'Bild: Hitta helheten', en: 'Visual: Find whole' }, desc: { sv: 'Givet del, s√∂k helhet', en: 'Given part, seek whole' } },
          { key: 'visual_calc', name: { sv: 'Bild: Ber√§kna andel', en: 'Visual: Calculate share' }, desc: { sv: 'F√§rgad del av total', en: 'Colored part of total' } },
          { key: 'part_inverse', name: { sv: 'Hitta helheten', en: 'Find the whole' }, desc: { sv: '1/n √§r x, vad √§r allt?', en: '1/n is x, what is total?' } },
          { key: 'part_compare', name: { sv: 'J√§mf√∂r andelar', en: 'Compare shares' }, desc: { sv: 'Vilken del √§r st√∂rst?', en: 'Which part is largest?' } },
          { key: 'part_calc', name: { sv: 'Ber√§kna del av antal', en: 'Calculate part of count' }, desc: { sv: '1/n av x', en: '1/n of x' } },
          { key: 'mixed_bounds', name: { sv: 'Storleksbed√∂mning', en: 'Size assessment' }, desc: { sv: 'St√∂rre/Mindre √§n heltal', en: 'Greater/Smaller than integer' } },
          { key: 'mixed_missing', name: { sv: 'Blandad form: Pussel', en: 'Mixed form: Puzzle' }, desc: { sv: 'Hitta t√§ljaren', en: 'Find the numerator' } },
          { key: 'mixed_convert_imp', name: { sv: 'Till br√•kform', en: 'To improper fraction' }, desc: { sv: 'Blandad -> Br√•k', en: 'Mixed -> Improper' } },
          { key: 'mixed_convert_mix', name: { sv: 'Till blandad form', en: 'To mixed form' }, desc: { sv: 'Br√•k -> Blandad', en: 'Improper -> Mixed' } },
          { key: 'simplify_missing', name: { sv: 'Likv√§rdiga br√•k', en: 'Equivalent fractions' }, desc: { sv: 'F√∂rl√§ngning/F√∂rkortning', en: 'Extension/Simplification' } },
          { key: 'simplify_concept', name: { sv: 'Koncept: F√∂rkortning', en: 'Concept: Simplification' }, desc: { sv: '√Ñndras v√§rdet?', en: 'Does the value change?' } },
          { key: 'simplify_calc', name: { sv: 'F√∂rkorta br√•k', en: 'Simplify fraction' }, desc: { sv: 'Enklaste form', en: 'Simplest form' } },
          { key: 'equivalence_basic_frac', name: { sv: 'Basfakta: Br√•k till %', en: 'Basic Facts: Fraction to %' }, desc: { sv: 'Ex: 1/4 = 25%', en: 'Ex: 1/4 = 25%' } },
          { key: 'equivalence_basic_dec', name: { sv: 'Basfakta: Decimal till %', en: 'Basic Facts: Decimal to %' }, desc: { sv: 'Ex: 0,2 = 20%', en: 'Ex: 0.2 = 20%' } },
          { key: 'decimal_inequality', name: { sv: 'J√§mf√∂r br√•k/decimal', en: 'Compare fraction/decimal' }, desc: { sv: 'St√∂rre, mindre, lika', en: 'Greater, smaller, equal' } },
          { key: 'decimal_to_dec', name: { sv: 'Br√•k till decimal', en: 'Fraction to decimal' }, desc: { sv: 'Ex: 1/4 = 0,25', en: 'Ex: 1/4 = 0.25' } },
          { key: 'decimal_to_frac', name: { sv: 'Decimal till br√•k', en: 'Decimal to fraction' }, desc: { sv: 'Ex: 0,5 = 1/2', en: 'Ex: 0.5 = 1/2' } }
        ]
      },
      fraction_arith: {
        name: { sv: 'Br√•k: R√§knes√§tt', en: 'Fraction Operations' },
        variations: [
          { key: 'add_concept', name: { sv: 'Addition: Regler', en: 'Addition: Rules' }, desc: { sv: 'Addera t√§ljare, ej n√§mnare', en: 'Add numerators, not denominators' } },
          { key: 'add_missing', name: { sv: 'Addition: Pussel', en: 'Addition: Puzzle' }, desc: { sv: 'Hitta saknad term', en: 'Find missing term' } },
          { key: 'add_calc', name: { sv: 'Addition: Samma n√§mnare', en: 'Addition: Same denom' }, desc: { sv: 'Enkel addition', en: 'Simple addition' } },
          { key: 'lcd_find', name: { sv: 'Hitta MGN', en: 'Find LCD' }, desc: { sv: 'Minsta gemensamma n√§mnare', en: 'Lowest common denominator' } },
          { key: 'add_error_spot', name: { sv: 'Hitta felet: Olika n√§mnare', en: 'Find error: Diff denom' }, desc: { sv: 'Vanliga misstag', en: 'Common mistakes' } },
          { key: 'add_diff_denom', name: { sv: 'Addition: Olika n√§mnare', en: 'Addition: Diff denom' }, desc: { sv: 'F√∂rl√§ngning kr√§vs', en: 'Extension required' } },
          { key: 'mixed_est', name: { sv: 'Blandad: Uppskattning', en: 'Mixed: Estimation' }, desc: { sv: 'Rimlighet', en: 'Reasonableness' } },
          { key: 'mixed_add_same', name: { sv: 'Blandad Add: Samma', en: 'Mixed Add: Same' }, desc: { sv: 'Addera heltal och br√•k', en: 'Add integers and fractions' } },
          { key: 'mixed_add_diff', name: { sv: 'Blandad Add: Olika', en: 'Mixed Add: Diff' }, desc: { sv: 'MGN med blandad form', en: 'LCD with mixed form' } },
          { key: 'mixed_sub_same', name: { sv: 'Blandad Sub: Samma', en: 'Mixed Sub: Same' }, desc: { sv: 'Subtraktion', en: 'Subtraction' } },
          { key: 'mixed_sub_diff', name: { sv: 'Blandad Sub: Olika', en: 'Mixed Sub: Diff' }, desc: { sv: 'L√•na fr√•n heltal', en: 'Borrow from integer' } },
          { key: 'mult_scaling', name: { sv: 'Multiplikation: Skalning', en: 'Mult: Scaling' }, desc: { sv: 'St√∂rre eller mindre?', en: 'Larger or smaller?' } },
          { key: 'mult_area', name: { sv: 'Multiplikation: Area', en: 'Mult: Area' }, desc: { sv: 'Visuell modell', en: 'Visual model' } },
          { key: 'mult_calc', name: { sv: 'Multiplikation', en: 'Multiplication' }, desc: { sv: 'T√§ljare*T√§ljare / N√§mnare*N√§mnare', en: 'Top*Top / Bottom*Bottom' } },
          { key: 'div_operator', name: { sv: 'Division: Koncept', en: 'Division: Concept' }, desc: { sv: 'Hur m√•nga ryms?', en: 'How many fit?' } },
          { key: 'div_reciprocal', name: { sv: 'Inverterade tal', en: 'Reciprocal numbers' }, desc: { sv: 'V√§nd p√• br√•ket', en: 'Flip the fraction' } },
          { key: 'div_calc', name: { sv: 'Division', en: 'Division' }, desc: { sv: 'Mult med invers', en: 'Mult by inverse' } }
        ]
      },
      percent: {
        name: { sv: 'Procent', en: 'Percent' },
        variations: [
          { key: 'visual_translation', name: { sv: 'Bild till Procent', en: 'Visual to Percent' }, desc: { sv: 'Tolka figurer', en: 'Interpret figures' } },
          { key: 'visual_lie', name: { sv: 'Hitta felet: Bild', en: 'Find error: Visual' }, desc: { sv: 'Visuell analys', en: 'Visual analysis' } },
          { key: 'equivalence', name: { sv: 'Br√•k-Decimal-Procent', en: 'Fraction-Decimal-Percent' }, desc: { sv: 'Samband', en: 'Relationships' } },
          { key: 'benchmark_calc', name: { sv: 'Huvudr√§kning (Bas)', en: 'Mental Math (Basic)' }, desc: { sv: '10%, 25%, 50%', en: '10%, 25%, 50%' } },
          { key: 'benchmark_inverse', name: { sv: 'Hitta 100% (Bas)', en: 'Find 100% (Basic)' }, desc: { sv: 'Om 10% √§r 5, vad √§r allt?', en: 'If 10% is 5, what is total?' } },
          { key: 'benchmark_commutative', name: { sv: 'Kommutativitet', en: 'Commutativity' }, desc: { sv: 'x% av y = y% av x', en: 'x% of y = y% of x' } },
          { key: 'composition', name: { sv: 'Sammans√§ttning', en: 'Composition' }, desc: { sv: 'Bygg 35% av 10% och 25%', en: 'Build 35% from 10% and 25%' } },
          { key: 'decomposition', name: { sv: 'Uppdelning', en: 'Decomposition' }, desc: { sv: 'Dela upp sv√•ra procent', en: 'Break down hard percents' } },
          { key: 'estimation', name: { sv: '√ñverslagsr√§kning', en: 'Estimation' }, desc: { sv: 'Ungef√§rligt v√§rde', en: 'Approximate value' } },
          { key: 'equation_calc', name: { sv: 'Procentekvationen', en: 'Percent Equation' }, desc: { sv: 'Andelen * Hela = Delen', en: 'Share * Whole = Part' } },
          { key: 'equation_missing_part', name: { sv: 'Hitta delen', en: 'Find the part' }, desc: { sv: 'x% av y', en: 'x% of y' } },
          { key: 'equation_missing_whole', name: { sv: 'Hitta det hela', en: 'Find the whole' }, desc: { sv: 'Delen / Andelen', en: 'Part / Share' } },
          { key: 'reverse_add_tax', name: { sv: 'Bakl√§nges: Moms', en: 'Backwards: VAT' }, desc: { sv: 'Hitta pris f√∂re skatt', en: 'Find price before tax' } },
          { key: 'reverse_find_original', name: { sv: 'Bakl√§nges: Ursprung', en: 'Backwards: Original' }, desc: { sv: 'Hitta startv√§rde', en: 'Find starting value' } },
          { key: 'change_calc', name: { sv: 'Ber√§kna f√∂r√§ndring', en: 'Calculate change' }, desc: { sv: 'Skillnad / Ursprung', en: 'Difference / Original' } },
          { key: 'change_diff_vs_pct', name: { sv: 'Kronor vs Procent', en: 'Currency vs Percent' }, desc: { sv: 'Enhetsf√∂rst√•else', en: 'Unit understanding' } },
          { key: 'change_sequential_trap', name: { sv: 'F√§lla: Dubbla √§ndringar', en: 'Trap: Double changes' }, desc: { sv: '+10% sen -10%', en: '+10% then -10%' } }
        ]
      },
      change_factor: {
        name: { sv: 'F√∂r√§ndringsfaktor', en: 'Change Factor' },
        variations: [
          { key: 'pct_to_factor_inc', name: { sv: '√ñkning till Faktor', en: 'Increase to Factor' }, desc: { sv: '+20% -> 1,20', en: '+20% -> 1.20' } },
          { key: 'pct_to_factor_dec', name: { sv: 'Minskning till Faktor', en: 'Decrease to Factor' }, desc: { sv: '-20% -> 0,80', en: '-20% -> 0.80' } },
          { key: 'factor_to_pct_inc', name: { sv: 'Faktor till √ñkning', en: 'Factor to Increase' }, desc: { sv: '1,20 -> +20%', en: '1.20 -> +20%' } },
          { key: 'factor_to_pct_dec', name: { sv: 'Faktor till Minskning', en: 'Factor to Decrease' }, desc: { sv: '0,80 -> -20%', en: '0.80 -> -20%' } },
          { key: 'apply_factor_inc', name: { sv: 'Ber√§kna nytt (√ñkning)', en: 'Calc new (Increase)' }, desc: { sv: 'Start * Faktor', en: 'Start * Factor' } },
          { key: 'apply_factor_dec', name: { sv: 'Ber√§kna nytt (Minskning)', en: 'Calc new (Decrease)' }, desc: { sv: 'Start * Faktor', en: 'Start * Factor' } },
          { key: 'find_original_inc', name: { sv: 'Hitta gamla (√ñkning)', en: 'Find old (Increase)' }, desc: { sv: 'Nytt / Faktor', en: 'New / Factor' } },
          { key: 'find_original_dec', name: { sv: 'Hitta gamla (Minskning)', en: 'Find old (Decrease)' }, desc: { sv: 'Nytt / Faktor', en: 'New / Factor' } },
          { key: 'sequential_factors', name: { sv: 'Total faktor', en: 'Total factor' }, desc: { sv: 'Faktor1 * Faktor2', en: 'Factor1 * Factor2' } },
          { key: 'word_population', name: { sv: 'Problem: Befolkning', en: 'Problem: Population' }, desc: { sv: 'Till√§mpning', en: 'Application' } },
          { key: 'word_interest', name: { sv: 'Problem: R√§nta', en: 'Problem: Interest' }, desc: { sv: 'Bank och l√•n', en: 'Bank and loans' } },
          { key: 'word_depreciation', name: { sv: 'Problem: V√§rdeminskning', en: 'Problem: Depreciation' }, desc: { sv: 'Bil/Maskin', en: 'Car/Machine' } },
          { key: 'word_sale', name: { sv: 'Problem: Rea', en: 'Problem: Sale' }, desc: { sv: 'Rabatter', en: 'Discounts' } },
          { key: 'word_decay', name: { sv: 'Problem: S√∂nderfall', en: 'Problem: Decay' }, desc: { sv: 'Naturvetenskap', en: 'Science' } },
          { key: 'word_salary', name: { sv: 'Problem: L√∂n', en: 'Problem: Salary' }, desc: { sv: 'L√∂nef√∂rhandling', en: 'Salary negotiation' } },
          { key: 'word_inflation', name: { sv: 'Problem: Inflation', en: 'Problem: Inflation' }, desc: { sv: 'Pris√∂kningar', en: 'Price increases' } },
          { key: 'word_stock', name: { sv: 'Problem: Aktier', en: 'Problem: Stocks' }, desc: { sv: 'B√∂rsutveckling', en: 'Market development' } }
        ]
      },
      exponents: {
        name: { sv: 'Potenser', en: 'Exponents' },
        variations: [
          { key: 'zero_rule', name: { sv: 'Noll-regeln', en: 'Zero rule' }, desc: { sv: 'x^0 = 1', en: 'x^0 = 1' } },
          { key: 'power_of_one', name: { sv: 'Upph√∂jt till 1', en: 'Power of one' }, desc: { sv: 'x^1 = x', en: 'x^1 = x' } },
          { key: 'foundations_calc', name: { sv: 'Ber√§kna potenser', en: 'Calc powers' }, desc: { sv: 'Bas * Bas...', en: 'Base * Base...' } },
          { key: 'foundations_spot_the_lie', name: { sv: 'Hitta felet: Bas/Exp', en: 'Find error: Base/Exp' }, desc: { sv: 'Vanliga misstag', en: 'Common mistakes' } },
          { key: 'ten_positive_exponent', name: { sv: 'Tiopotenser (Pos)', en: 'Powers of ten (Pos)' }, desc: { sv: 'Stora tal', en: 'Large numbers' } },
          { key: 'ten_negative_exponent', name: { sv: 'Tiopotenser (Neg)', en: 'Powers of ten (Neg)' }, desc: { sv: 'Sm√• tal', en: 'Small numbers' } },
          { key: 'ten_inverse_counting', name: { sv: 'R√§kna nollor', en: 'Count zeros' }, desc: { sv: 'Skriv som 10^n', en: 'Write as 10^n' } },
          { key: 'scientific_to_form', name: { sv: 'Till Grundpotensform', en: 'To Scientific Notation' }, desc: { sv: 'a * 10^n', en: 'a * 10^n' } },
          { key: 'scientific_missing_mantissa', name: { sv: 'Hitta mantissan', en: 'Find mantissa' }, desc: { sv: 'Talet mellan 1-10', en: 'Number between 1-10' } },
          { key: 'scientific_missing_exponent', name: { sv: 'Hitta exponenten', en: 'Find exponent' }, desc: { sv: 'Antal steg', en: 'Number of steps' } },
          { key: 'root_calc', name: { sv: 'Kvadratr√∂tter', en: 'Square roots' }, desc: { sv: 'Roten ur x', en: 'Square root of x' } },
          { key: 'root_inverse_algebra', name: { sv: 'Ekvation x^2', en: 'Equation x^2' }, desc: { sv: 'L√∂s ut x', en: 'Solve for x' } },
          { key: 'law_multiplication', name: { sv: 'Lag: Multiplikation', en: 'Law: Multiplication' }, desc: { sv: 'Addera exponenter', en: 'Add exponents' } },
          { key: 'law_division', name: { sv: 'Lag: Division', en: 'Law: Division' }, desc: { sv: 'Subtrahera exponenter', en: 'Subtract exponents' } },
          { key: 'law_addition_trap', name: { sv: 'F√§lla: Addition', en: 'Trap: Addition' }, desc: { sv: 'Ingen regel f√∂r plus', en: 'No rule for plus' } },
          { key: 'law_mult_div_combined', name: { sv: 'Lag: Mult & Div', en: 'Law: Mult & Div' }, desc: { sv: 'Blandade regler', en: 'Mixed rules' } },
          { key: 'law_power_of_power', name: { sv: 'Lag: Potens av potens', en: 'Law: Power of power' }, desc: { sv: 'Multiplicera exponenter', en: 'Multiply exponents' } },
          { key: 'law_inverse_algebra', name: { sv: 'Potensekvationer', en: 'Power equations' }, desc: { sv: 'Hitta exponenten', en: 'Find the exponent' } },
          { key: 'law_all_combined', name: { sv: 'Blandade Lagar', en: 'Mixed Laws' }, desc: { sv: 'Avancerad f√∂renkling', en: 'Advanced simplification' } }
        ]
      },
      ten_powers: {
        name: { sv: 'Tiopotenser & Prefix', en: 'Powers of Ten & Prefixes' },
        variations: [
          { key: 'big_mult_std', name: { sv: 'Mult med 10/100', en: 'Mult by 10/100' }, desc: { sv: 'Flytta komma h√∂ger', en: 'Move decimal right' } },
          { key: 'big_div_std', name: { sv: 'Div med 10/100', en: 'Div by 10/100' }, desc: { sv: 'Flytta komma v√§nster', en: 'Move decimal left' } },
          { key: 'big_missing_factor', name: { sv: 'Hitta 10-faktorn', en: 'Find 10-factor' }, desc: { sv: 'Vad multiplicerades?', en: 'What was multiplied?' } },
          { key: 'power_discovery', name: { sv: 'Potensform', en: 'Power form' }, desc: { sv: 'Skriv som 10^n', en: 'Write as 10^n' } },
          { key: 'reciprocal_equivalence', name: { sv: 'Inverser', en: 'Reciprocals' }, desc: { sv: '0,1 = 1/10', en: '0.1 = 1/10' } },
          { key: 'concept_spot_lie', name: { sv: 'Hitta felet: 10-bas', en: 'Find error: base 10' }, desc: { sv: 'Konceptuell f√∂rst√•else', en: 'Conceptual understanding' } },
          { key: 'decimal_div_std', name: { sv: 'Div med 0,1/0,01', en: 'Div by 0.1/0.01' }, desc: { sv: 'Talet blir st√∂rre', en: 'Number gets larger' } },
          { key: 'decimal_mult_std', name: { sv: 'Mult med 0,1/0,01', en: 'Mult by 0.1/0.01' }, desc: { sv: 'Talet blir mindre', en: 'Number gets smaller' } },
          { key: 'decimal_logic_trap', name: { sv: 'F√§lla: Mult/Div', en: 'Trap: Mult/Div' }, desc: { sv: 'Logiskt t√§nkande', en: 'Logical thinking' } }
        ]
      }
    }
  },

  // ==========================================
  // 3. GEOMETRI
  // ==========================================
  geometry_cat: {
    id: 'geometry_cat',
    name: { sv: 'Geometri', en: 'Geometry' },
    topics: {
      geometry: {
        name: { sv: 'Area & Omkrets', en: 'Area & Perimeter' },
        variations: [
          { key: 'perimeter_square', name: { sv: 'Omkrets: Kvadrat', en: 'Perimeter: Square' }, desc: { sv: '4 * sida', en: '4 * side' } },
          { key: 'perimeter_rect', name: { sv: 'Omkrets: Rektangel', en: 'Perimeter: Rectangle' }, desc: { sv: '2b + 2h', en: '2w + 2h' } },
          { key: 'perimeter_parallel', name: { sv: 'Omkrets: Parallellogram', en: 'Perimeter: Parallelogram' }, desc: { sv: 'Samma som rektangel', en: 'Same as rectangle' } },
          { key: 'perimeter_inverse', name: { sv: 'Omkrets: Hitta sidan', en: 'Perimeter: Find side' }, desc: { sv: 'Givet O, hitta x', en: 'Given P, find x' } },
          { key: 'perimeter_lie', name: { sv: 'Hitta felet: Omkrets', en: 'Find error: Perimeter' }, desc: { sv: 'Analysera p√•st√•ende', en: 'Analyze statement' } },
          { key: 'area_square', name: { sv: 'Area: Kvadrat', en: 'Area: Square' }, desc: { sv: 's * s', en: 's * s' } },
          { key: 'area_rect', name: { sv: 'Area: Rektangel', en: 'Area: Rectangle' }, desc: { sv: 'b * h', en: 'w * h' } },
          { key: 'area_parallel', name: { sv: 'Area: Parallellogram', en: 'Area: Parallelogram' }, desc: { sv: 'b * h (ej sida)', en: 'w * h (not side)' } },
          { key: 'area_inverse', name: { sv: 'Area: Hitta sidan', en: 'Area: Find side' }, desc: { sv: 'Givet A, hitta x', en: 'Given A, find x' } },
          { key: 'area_trap', name: { sv: 'F√§lla: Area', en: 'Trap: Area' }, desc: { sv: 'Vinkelr√§t h√∂jd!', en: 'Perpendicular height!' } },
          { key: 'area_triangle', name: { sv: 'Area: Triangel', en: 'Area: Triangle' }, desc: { sv: '(b * h) / 2', en: '(b * h) / 2' } },
          { key: 'inverse_triangle', name: { sv: 'Triangel: Hitta h√∂jd', en: 'Triangle: Find height' }, desc: { sv: 'Givet A, hitta h', en: 'Given A, find h' } },
          { key: 'perimeter_triangle_right', name: { sv: 'Omkrets: R√§tvinklig', en: 'Perimeter: Right-angled' }, desc: { sv: 'Summa av sidor', en: 'Sum of sides' } },
          { key: 'perimeter_triangle_iso', name: { sv: 'Omkrets: Likbent', en: 'Perimeter: Isosceles' }, desc: { sv: 'Tv√• lika sidor', en: 'Two equal sides' } },
          { key: 'perimeter_triangle_scalene', name: { sv: 'Omkrets: Oliksidig', en: 'Perimeter: Scalene' }, desc: { sv: 'Alla sidor olika', en: 'All sides different' } },
          { key: 'combined_rect_tri', name: { sv: 'Sammansatt: Rekt+Tri', en: 'Composite: Rect+Tri' }, desc: { sv: 'Additionsmetoden', en: 'Addition method' } },
          { key: 'combined_l_shape', name: { sv: 'Sammansatt: L-form', en: 'Composite: L-shape' }, desc: { sv: '2 Rektanglar (ihop)', en: '2 Rectangles (joined)' } },
          { key: 'combined_house', name: { sv: 'Sammansatt: Hus', en: 'Composite: House' }, desc: { sv: 'Kvadrat + Triangel', en: 'Square + Triangle' } },
          { key: 'circle_area', name: { sv: 'Cirkel: Area', en: 'Circle: Area' }, desc: { sv: 'pi * r^2', en: 'pi * r^2' } },
          { key: 'circle_perimeter', name: { sv: 'Cirkel: Omkrets', en: 'Circle: Perimeter' }, desc: { sv: 'pi * d', en: 'pi * d' } },
          { key: 'semicircle_area', name: { sv: 'Halvcirkel: Area', en: 'Semicircle: Area' }, desc: { sv: 'Halva arean', en: 'Half the area' } },
          { key: 'semicircle_perimeter', name: { sv: 'Halvcirkel: Omkrets', en: 'Semicircle: Perimeter' }, desc: { sv: 'B√•ge + Diameter', en: 'Arc + Diameter' } },
          { key: 'area_quarter', name: { sv: 'Kvartscirkel: Area', en: 'Quarter circle: Area' }, desc: { sv: 'Fj√§rdedels area', en: 'Quarter of area' } },
          { key: 'perimeter_quarter', name: { sv: 'Kvartscirkel: Omkrets', en: 'Quarter circle: Perimeter' }, desc: { sv: 'B√•ge + Radier', en: 'Arc + Radii' } },
          { key: 'perimeter_house', name: { sv: 'Omkrets: Hus', en: 'Perimeter: House' }, desc: { sv: 'Avancerad (Tak)', en: 'Advanced (Roof)' } },
          { key: 'perimeter_portal', name: { sv: 'Omkrets: Portal', en: 'Perimeter: Portal' }, desc: { sv: 'V√§ggar + B√•ge', en: 'Walls + Arc' } },
          { key: 'area_house', name: { sv: 'Area: Hus', en: 'Area: House' }, desc: { sv: 'Rektangel + Triangel', en: 'Rectangle + Triangle' } },
          { key: 'area_portal', name: { sv: 'Area: Portal', en: 'Area: Portal' }, desc: { sv: 'Rektangel + Halvcirkel', en: 'Rectangle + Semicircle' } }
        ]
      },
      angles: {
        name: { sv: 'Vinklar', en: 'Angles' },
        variations: [
          { key: 'classification_visual', name: { sv: 'Vinkeltyper', en: 'Angle types' }, desc: { sv: 'Spetsig, R√§t, Trubbig', en: 'Acute, Right, Obtuse' } },
          { key: 'classification_inverse_numeric', name: { sv: 'Klassificera tal', en: 'Classify numbers' }, desc: { sv: 'Vilken typ √§r 120¬∞?', en: 'What type is 120¬∞?' } },
          { key: 'classification_lie', name: { sv: 'Hitta felet: Typer', en: 'Find error: Types' }, desc: { sv: 'Falska p√•st√•enden', en: 'False statements' } },
          { key: 'comp_supp_visual', name: { sv: 'Grannvinklar', en: 'Neighbor angles' }, desc: { sv: 'Summa 180 eller 90', en: 'Sum 180 or 90' } },
          { key: 'comp_supp_inverse', name: { sv: 'Terminologi', en: 'Terminology' }, desc: { sv: 'Supplement/Komplement', en: 'Supp/Comp' } },
          { key: 'vertical_side_visual', name: { sv: 'Vertikalvinklar', en: 'Vertical angles' }, desc: { sv: 'Mittemot varandra', en: 'Opposite each other' } },
          { key: 'vertical_side_lie', name: { sv: 'Hitta felet: Relationer', en: 'Find error: Relations' }, desc: { sv: 'Analys', en: 'Analysis' } },
          { key: 'triangle_sum_visual', name: { sv: 'Triangelns summa', en: 'Triangle sum' }, desc: { sv: 'Alltid 180 grader', en: 'Always 180 degrees' } },
          { key: 'triangle_isosceles', name: { sv: 'Likbent triangel', en: 'Isosceles triangle' }, desc: { sv: 'Basvinklar lika', en: 'Base angles equal' } },
          { key: 'polygon_sum', name: { sv: 'Polygoners summa', en: 'Polygon sum' }, desc: { sv: '(n-2) * 180', en: '(n-2) * 180' } },
          { key: 'polygon_inverse', name: { sv: 'Hitta antalet h√∂rn', en: 'Find vertices' }, desc: { sv: 'Givet vinkelsumma', en: 'Given angle sum' } },
          { key: 'quad_missing', name: { sv: 'Fyrh√∂rning', en: 'Quadrilateral' }, desc: { sv: 'Summa 360', en: 'Sum 360' } },
          { key: 'parallel_visual', name: { sv: 'Parallella linjer', en: 'Parallel lines' }, desc: { sv: 'Z, F och U-vinklar', en: 'Z, F and U angles' } },
          { key: 'parallel_lie', name: { sv: 'Hitta felet: Parallell', en: 'Find error: Parallel' }, desc: { sv: 'Regler f√∂r linjer', en: 'Line rules' } }
        ]
      },
      pythagoras: {
        name: { sv: 'Pythagoras Sats', en: 'Pythagorean Theorem' },
        variations: [
          { key: 'sqrt_calc', name: { sv: 'Kvadratrot', en: 'Square root' }, desc: { sv: 'Ber√§kning', en: 'Calculation' } },
          { key: 'square_calc', name: { sv: 'Kvadrat', en: 'Square' }, desc: { sv: 'Tal g√•nger sig sj√§lvt', en: 'Number times itself' } },
          { key: 'missing_square', name: { sv: 'Invers kvadrat', en: 'Inverse square' }, desc: { sv: 'x^2 = a', en: 'x^2 = a' } },
          { key: 'sqrt_estimation', name: { sv: 'Uppskatta rot', en: 'Estimate root' }, desc: { sv: 'Mellan vilka heltal?', en: 'Between which integers?' } },
          { key: 'hyp_visual', name: { sv: 'Hitta Hypotenusan', en: 'Find Hypotenuse' }, desc: { sv: 'a^2 + b^2 = c^2', en: 'a^2 + b^2 = c^2' } },
          { key: 'hyp_equation', name: { sv: 'Ekvation: Hypotenusa', en: 'Equation: Hypotenuse' }, desc: { sv: 'L√∂s ut c', en: 'Solve for c' } },
          { key: 'hyp_error', name: { sv: 'Hitta felet: Hyp', en: 'Find error: Hyp' }, desc: { sv: 'Vanliga fel', en: 'Common errors' } },
          { key: 'leg_visual', name: { sv: 'Hitta Kateten', en: 'Find Leg' }, desc: { sv: 'c^2 - a^2 = b^2', en: 'c^2 - a^2 = b^2' } },
          { key: 'leg_concept', name: { sv: 'Koncept: Katet', en: 'Concept: Leg' }, desc: { sv: 'Subtraktion kr√§vs', en: 'Subtraction required' } },
          { key: 'leg_text', name: { sv: 'Textproblem: Katet', en: 'Word problem: Leg' }, desc: { sv: 'Till√§mpning', en: 'Application' } },
          { key: 'app_ladder', name: { sv: 'Problem: Stegen', en: 'Problem: The Ladder' }, desc: { sv: 'Vardagsproblem', en: 'Everyday problem' } },
          { key: 'app_displacement', name: { sv: 'Problem: F√•gelv√§gen', en: 'Problem: As the crow flies' }, desc: { sv: 'Avst√•nd', en: 'Distance' } },
          { key: 'app_diagonal', name: { sv: 'Problem: Diagonal', en: 'Problem: Diagonal' }, desc: { sv: 'Rektangelns diagonal', en: 'Rectangle diagonal' } },
          { key: 'conv_check', name: { sv: 'R√§tvinklig?', en: 'Right-angled?' }, desc: { sv: 'Kontrollera satsen', en: 'Check the theorem' } },
          { key: 'conv_trap', name: { sv: 'Triangel-f√§llan', en: 'Triangle trap' }, desc: { sv: '√Ñr den r√§t?', en: 'Is it right-angled?' } }
        ]
      },
      scale: {
        name: { sv: 'Skala', en: 'Scale' },
        variations: [
          { key: 'calc_real', name: { sv: 'Ber√§kna verklighet', en: 'Calculate reality' }, desc: { sv: 'Fr√•n bild till verklighet', en: 'From image to reality' } },
          { key: 'calc_map', name: { sv: 'Ber√§kna avbildning', en: 'Calculate image' }, desc: { sv: 'Fr√•n verklighet till bild', en: 'From reality to image' } },
          { key: 'determine_scale', name: { sv: 'Best√§m skalan', en: 'Determine scale' }, desc: { sv: 'Bild / Verklighet', en: 'Image / Reality' } },
          { key: 'compare_scales', name: { sv: 'J√§mf√∂r skalor', en: 'Compare scales' }, desc: { sv: 'Vilken √§r st√∂rst?', en: 'Which is largest?' } },
          { key: 'area_calc_large', name: { sv: 'Areaskala: F√∂rstoring', en: 'Area scale: Enlargement' }, desc: { sv: 'L√§ngdskala i kvadrat', en: 'Length scale squared' } },
          { key: 'area_calc_small', name: { sv: 'Areaskala: F√∂rminskning', en: 'Area scale: Reduction' }, desc: { sv: 'Dividera med kvadrat', en: 'Divide by square' } },
          { key: 'area_find_scale', name: { sv: 'Hitta Areaskala', en: 'Find Area scale' }, desc: { sv: 'Roten ur areakvot', en: 'Root of area ratio' } }
        ]
      },
      similarity: {
        name: { sv: 'Likformighet', en: 'Similarity' },
        variations: [
          { key: 'sim_rect_check', name: { sv: '√Ñr de likformiga?', en: 'Are they similar?' }, desc: { sv: 'Rektanglar', en: 'Rectangles' } },
          { key: 'sim_tri_angle_check', name: { sv: 'Likformighet: Vinklar', en: 'Similarity: Angles' }, desc: { sv: 'AA-kriteriet', en: 'AA criterion' } },
          { key: 'sim_tri_side_check', name: { sv: 'Likformighet: Sidor', en: 'Similarity: Sides' }, desc: { sv: 'Proportioner', en: 'Proportions' } },
          { key: 'sim_concept_lie', name: { sv: 'Hitta felet: Likformighet', en: 'Find error: Similarity' }, desc: { sv: 'Teori', en: 'Theory' } },
          { key: 'sim_calc_big', name: { sv: 'Ber√§kna stor sida', en: 'Calculate long side' }, desc: { sv: 'Multiplicera med skala', en: 'Multiply by scale' } },
          { key: 'sim_calc_small', name: { sv: 'Ber√§kna liten sida', en: 'Calculate short side' }, desc: { sv: 'Dividera med skala', en: 'Divide by scale' } },
          { key: 'sim_find_k', name: { sv: 'Hitta skalfaktor', en: 'Find scale factor' }, desc: { sv: 'Stor / Liten', en: 'Large / Small' } },
          { key: 'sim_calc_lie', name: { sv: 'Hitta felet: Ber√§kning', en: 'Find error: Calculation' }, desc: { sv: 'Kontrollera kvoter', en: 'Check ratios' } },
          { key: 'transversal_total', name: { sv: 'Topptriangelsatsen', en: 'Top triangle theorem' }, desc: { sv: 'Hela sidan', en: 'Entire side' } },
          { key: 'transversal_extension', name: { sv: 'Parallelltransversal', en: 'Parallel transversal' }, desc: { sv: 'Del av sida', en: 'Part of side' } },
          { key: 'transversal_concept_id', name: { sv: 'Identifiera fall', en: 'Identify case' }, desc: { sv: 'Topp vs Transversal', en: 'Top vs Transversal' } },
          { key: 'pythagoras_sim_hyp', name: { sv: 'Likformighet & Pythagoras', en: 'Similarity & Pythagoras' }, desc: { sv: 'Kombination (Hyp)', en: 'Combination (Hyp)' } },
          { key: 'pythagoras_sim_leg', name: { sv: 'Likformighet & Pythagoras', en: 'Similarity & Pythagoras' }, desc: { sv: 'Kombination (Kat)', en: 'Combination (Leg)' } }
        ]
      },
      volume: {
        name: { sv: 'Volym & Begr√§nsningsyta', en: 'Volume & Surface Area' },
        variations: [
          { key: 'vol_cuboid_std', name: { sv: 'Volym: R√§tblock', en: 'Volume: Cuboid' }, desc: { sv: 'b * d * h', en: 'w * d * h' } },
          { key: 'vol_cuboid_inverse', name: { sv: 'R√§tblock: Hitta sida', en: 'Cuboid: Find side' }, desc: { sv: 'Volym / Area', en: 'Volume / Area' } },
          { key: 'vol_cuboid_scaling', name: { sv: 'R√§tblock: Skalning', en: 'Cuboid: Scaling' }, desc: { sv: 'Dubbla sidor -> 8x volym', en: 'Double sides -> 8x vol' } },
          { key: 'vol_tri_prism_std', name: { sv: 'Volym: Prisma', en: 'Volume: Prism' }, desc: { sv: 'Basarea * h√∂jd', en: 'Base area * height' } },
          { key: 'vol_tri_prism_inverse', name: { sv: 'Prisma: Hitta h√∂jd', en: 'Prism: Find height' }, desc: { sv: 'Volym / Basarea', en: 'Volume / Base area' } },
          { key: 'vol_cyl_std', name: { sv: 'Volym: Cylinder', en: 'Volume: Cylinder' }, desc: { sv: 'pi * r^2 * h', en: 'pi * r^2 * h' } },
          { key: 'vol_cyl_inverse', name: { sv: 'Cylinder: Hitta h√∂jd', en: 'Cylinder: Find height' }, desc: { sv: 'Ekvationsl√∂sning', en: 'Equation solving' } },
          { key: 'vol_pyramid_sq', name: { sv: 'Volym: Pyramid', en: 'Volume: Pyramid' }, desc: { sv: '(Bas * h) / 3', en: '(Base * h) / 3' } },
          { key: 'vol_cone_std', name: { sv: 'Volym: Kon', en: 'Volume: Cone' }, desc: { sv: '(Cirkel * h) / 3', en: '(Circle * h) / 3' } },
          { key: 'vol_sphere_std', name: { sv: 'Volym: Klot', en: 'Volume: Sphere' }, desc: { sv: '4 * pi * r^3 / 3', en: '4 * pi * r^3 / 3' } },
          { key: 'vol_semi_sphere', name: { sv: 'Volym: Halvklot', en: 'Volume: Hemisphere' }, desc: { sv: 'H√§lften av klot', en: 'Half a sphere' } },
          { key: 'vol_composite_silo', name: { sv: 'Sammansatt: Silo', en: 'Composite: Silo' }, desc: { sv: 'Cylinder + Kon', en: 'Cylinder + Cone' } },
          { key: 'vol_composite_house', name: { sv: 'Sammansatt: Hus', en: 'Composite: House' }, desc: { sv: 'R√§tblock + Prisma', en: 'Cuboid + Prism' } },
          { key: 'unit_liters_basic', name: { sv: 'Enheter: Liter', en: 'Units: Liters' }, desc: { sv: 'dm3 till liter', en: 'dm3 to liters' } },
          { key: 'unit_cubic_conversion', name: { sv: 'Enheter: Kubik', en: 'Units: Cubic' }, desc: { sv: 'm3 till dm3', en: 'm3 to dm3' } },
          { key: 'sa_cuboid', name: { sv: 'Begr√§nsningsarea: R√§tblock', en: 'Surface Area: Cuboid' }, desc: { sv: 'Summa av sidor', en: 'Sum of sides' } },
          { key: 'sa_cylinder', name: { sv: 'Begr√§nsningsarea: Cylinder', en: 'Surface Area: Cylinder' }, desc: { sv: 'Mantel + 2 Cirklar', en: 'Mantle + 2 Circles' } },
          { key: 'sa_sphere', name: { sv: 'Begr√§nsningsarea: Klot', en: 'Surface Area: Sphere' }, desc: { sv: '4 * pi * r^2', en: '4 * pi * r^2' } },
          { key: 'sa_cone', name: { sv: 'Begr√§nsningsarea: Kon', en: 'Surface Area: Cone' }, desc: { sv: 'Mantel + Cirkel', en: 'Mantle + Circle' } }
        ]
      }
    }
  },

  // ==========================================
  // 4. DATA & SANNOLIKHET
  // ==========================================
  data: {
    id: 'data',
    name: { sv: 'Data & Sannolikhet', en: 'Data & Probability' },
    topics: {
      statistics: {
        name: { sv: 'Statistik', en: 'Statistics' },
        variations: [
          { key: 'find_mode', name: { sv: 'Typv√§rde', en: 'Mode' }, desc: { sv: 'Vanligaste v√§rdet', en: 'Most common value' } },
          { key: 'find_range', name: { sv: 'Variationsbredd', en: 'Range' }, desc: { sv: 'Max - Min', en: 'Max - Min' } },
          { key: 'find_min_max', name: { sv: 'Minsta/St√∂rsta tal', en: 'Min/Max number' }, desc: { sv: 'Hitta extrempunkter', en: 'Find extremes' } },
          { key: 'calc_mean', name: { sv: 'Medelv√§rde', en: 'Mean' }, desc: { sv: 'Ber√§kna genomsnitt', en: 'Calculate average' } },
          { key: 'mean_negatives', name: { sv: 'Medelv√§rde: Negativa', en: 'Mean: Negatives' }, desc: { sv: 'Temperaturer etc.', en: 'Temperatures etc.' } },
          { key: 'median_odd', name: { sv: 'Median (Udda)', en: 'Median (Odd)' }, desc: { sv: 'Mittersta v√§rdet', en: 'Middle value' } },
          { key: 'median_even', name: { sv: 'Median (J√§mnt)', en: 'Median (Even)' }, desc: { sv: 'Medel av mittentalen', en: 'Mean of middle values' } },
          { key: 'reverse_mean_calc', name: { sv: 'Hitta saknat tal', en: 'Find missing number' }, desc: { sv: 'Givet medelv√§rde', en: 'Given mean' } },
          { key: 'mean_target_score', name: { sv: 'M√•l-medelv√§rde', en: 'Target mean' }, desc: { sv: 'Vad kr√§vs f√∂r snittet?', en: 'What is required for the average?' } },
          { key: 'freq_mode', name: { sv: 'Tabell: Typv√§rde', en: 'Table: Mode' }, desc: { sv: 'H√∂gst frekvens', en: 'Highest frequency' } },
          { key: 'freq_mean', name: { sv: 'Tabell: Medelv√§rde', en: 'Table: Mean' }, desc: { sv: 'Summa(f*x) / n', en: 'Sum(f*x) / n' } },
          { key: 'freq_count', name: { sv: 'Tabell: Observationer', en: 'Table: Observations' }, desc: { sv: 'Summera antal', en: 'Sum count' } },
          { key: 'real_measure_choice', name: { sv: 'V√§lj L√§gesm√•tt', en: 'Choose measure' }, desc: { sv: 'Medel vs Median', en: 'Mean vs Median' } },
          { key: 'real_outlier_shift', name: { sv: 'Effekt av extremv√§rde', en: 'Outlier effect' }, desc: { sv: 'P√•verkan p√• medel', en: 'Impact on mean' } },
          { key: 'real_weighted_missing', name: { sv: 'Viktat medelv√§rde', en: 'Weighted average' }, desc: { sv: 'Blandade priser/m√§ngder', en: 'Mixed prices/quantities' } }
        ]
      },
      probability: {
        name: { sv: 'Sannolikhet', en: 'Probability' },
        variations: [
          { key: 'visual_calc', name: { sv: 'Enkel Sannolikhet', en: 'Basic Probability' }, desc: { sv: 'Gynsamma / M√∂jliga (Bilder)', en: 'Favorable / Possible (Visual)' } },
          { key: 'visual_not', name: { sv: 'Komplementh√§ndelse', en: 'Complementary event' }, desc: { sv: 'Sannolikheten f√∂r "Inte"', en: 'Probability of "Not"' } },
          { key: 'visual_or', name: { sv: 'Antingen Eller', en: 'Either Or' }, desc: { sv: 'Addition av sannolikheter', en: 'Addition of probabilities' } },
          { key: 'visual_spinner', name: { sv: 'Lyckohjul', en: 'Lucky wheel' }, desc: { sv: 'Sektorernas andel', en: 'Sector share' } },
          { key: 'group_ratio', name: { sv: 'F√∂rh√•llanden', en: 'Ratios' }, desc: { sv: 'Sannolikhet utifr√•n n:m', en: 'Probability from n:m' } },
          { key: 'group_ternary', name: { sv: 'Tre grupper', en: 'Three groups' }, desc: { sv: 'A, B och Resten', en: 'A, B and the rest' } },
          { key: 'concept_likelihood', name: { sv: 'Begrepp: Chans', en: 'Concept: Chance' }, desc: { sv: 'S√§kert, Om√∂jligt, Even', en: 'Certain, Impossible, Even' } },
          { key: 'concept_compare', name: { sv: 'J√§mf√∂r Chanser', en: 'Compare chances' }, desc: { sv: 'Var √§r chansen st√∂rst?', en: 'Where is the highest chance?' } },
          { key: 'comp_at_least', name: { sv: 'Minst en g√•ng', en: 'At least once' }, desc: { sv: '1 - P(Ingen)', en: '1 - P(None)' } },
          { key: 'tree_calc', name: { sv: 'Sannolikhetstr√§d', en: 'Probability tree' }, desc: { sv: 'Dragning utan √•terl√§ggning', en: 'Drawing without replacement' } },
          { key: 'tree_missing', name: { sv: 'Pussel: Tr√§d', en: 'Puzzle: Tree' }, desc: { sv: 'Hitta saknad gren', en: 'Find missing branch' } },
          { key: 'chain_any_order', name: { sv: 'Oberoende ordning', en: 'Independent order' }, desc: { sv: 'En av varje f√§rg', en: 'One of each color' } },
          { key: 'chain_fixed_order', name: { sv: 'Best√§md ordning', en: 'Fixed order' }, desc: { sv: 'Tv√• av samma i rad', en: 'Two of same in a row' } },
          { key: 'comb_constraint', name: { sv: 'Kombinatorik: Outfits', en: 'Combinatorics: Outfits' }, desc: { sv: 'Multiplikationsprincipen', en: 'Multiplication principle' } },
          { key: 'comb_handshake', name: { sv: 'Handskakningar', en: 'Handshakes' }, desc: { sv: 'n(n-1)/2', en: 'n(n-1)/2' } },
          { key: 'pathways_basic', name: { sv: 'R√§kna V√§gar', en: 'Count paths' }, desc: { sv: 'A till B genom n√§tverk', en: 'A to B via network' } },
          { key: 'pathways_prob', name: { sv: 'Sannolikhet V√§g', en: 'Path probability' }, desc: { sv: 'Chansen att en v√§g √§r √∂ppen', en: 'Chance path is open' } }
        ]
      }
    }
  }
};

// FILE END: src\constants\skillBuckets.js

// =======================================================
// FILE START: src\core\generators\AnglesGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class AnglesGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Terminology(lang);
            case 2: return this.level2_CompSupp(lang);
            case 3: return this.level3_Vertical(lang);
            case 4: return this.level4_TriangleSum(lang);
            case 5: return this.level5_Polygons(lang);
            case 6: return this.level6_Parallel(lang);
            default: return this.level1_Terminology(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'classification_visual': return this.level1_Terminology(lang, key);
            case 'classification_inverse_numeric': return this.level1_Terminology(lang, key);
            case 'classification_lie': return this.level1_Terminology(lang, key);
            case 'comp_supp_visual': return this.level2_CompSupp(lang, key);
            case 'comp_supp_inverse': return this.level2_CompSupp(lang, key);
            case 'vertical_side_visual': return this.level3_Vertical(lang, key);
            case 'vertical_side_lie': return this.level3_Vertical(lang, key);
            case 'triangle_sum_visual': return this.level4_TriangleSum(lang, key);
            case 'triangle_isosceles': return this.level4_TriangleSum(lang, key);
            case 'polygon_sum': return this.level5_Polygons(lang, key);
            case 'polygon_inverse': return this.level5_Polygons(lang, key);
            case 'quad_missing': return this.level5_Polygons(lang, key);
            case 'parallel_visual': return this.level6_Parallel(lang, key);
            case 'parallel_lie': return this.level6_Parallel(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: TERMINOLOGY & CLASSIFICATION ---
    private level1_Terminology(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['classification_visual', 'classification_inverse_numeric', 'classification_lie']);

        if (v === 'classification_visual') {
            const type = MathUtils.randomChoice(['acute', 'right', 'obtuse', 'straight']);
            let angle = 0, labelSv = "", labelEn = "";

            if (type === 'acute') { angle = MathUtils.randomInt(20, 80); labelSv = "Spetsig"; labelEn = "Acute"; }
            else if (type === 'right') { angle = 90; labelSv = "R√§t"; labelEn = "Right"; }
            else if (type === 'obtuse') { angle = MathUtils.randomInt(100, 170); labelSv = "Trubbig"; labelEn = "Obtuse"; }
            else { angle = 180; labelSv = "Rak"; labelEn = "Straight"; }

            const cx = 150, cy = 200, len = 100;
            const x2 = cx + len * Math.cos(-angle * Math.PI / 180);
            const y2 = cy + len * Math.sin(-angle * Math.PI / 180);

            const ans = lang === 'sv' ? labelSv : labelEn;

            return {
                renderData: {
                    description: lang === 'sv' ? "Vad kallas denna typ av vinkel?" : "What is this type of angle called?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(lang === 'sv' ? ["Spetsig", "R√§t", "Trubbig", "Rak"] : ["Acute", "Right", "Obtuse", "Straight"]),
                    geometry: {
                        type: 'angle',
                        lines: [{x1: cx, y1: cy, x2: cx + len, y2: cy}, {x1: cx, y1: cy, x2: x2, y2: y2}],
                        arcs: [{ center: {x: cx, y: cy}, startAngle: 0, endAngle: angle, radius: 40, label: `${angle}¬∞` }]
                    }
                },
                token: this.toBase64(ans),
                clues: [
                    { 
                        text: lang === 'sv' ? "Vi kategoriserar vinklar genom att j√§mf√∂ra dem med en r√§t vinkel ($90^\\circ$)." : "We categorize angles by comparing them to a right angle ($90^\\circ$).",
                        latex: `90^\\circ = \\text{${lang === 'sv' ? 'R√§t' : 'Right'}}` 
                    },
                    { 
                        text: lang === 'sv' ? `Eftersom ${angle}^\\circ$ √§r ${angle < 90 ? 'mindre' : angle > 90 ? 'st√∂rre' : 'lika med'} $90^\\circ$, kallas den:` : `Since ${angle}^\\circ$ is ${angle < 90 ? 'less' : angle > 90 ? 'greater' : 'equal to'} $90^\\circ$, it is called:`,
                        latex: `\\text{${ans}}` 
                    }
                ],
                metadata: { variation_key: "classification_visual", difficulty: 1 }
            };
        }

        if (v === 'classification_inverse_numeric') {
            const angle = MathUtils.randomChoice([45, 90, 135, 180]);
            let correct = "";
            if (angle < 90) correct = lang === 'sv' ? "Spetsig" : "Acute";
            else if (angle === 90) correct = lang === 'sv' ? "R√§t" : "Right";
            else if (angle < 180) correct = lang === 'sv' ? "Trubbig" : "Obtuse";
            else correct = lang === 'sv' ? "Rak" : "Straight";

            return {
                renderData: {
                    description: lang === 'sv' ? `En vinkel √§r ${angle}¬∞. Vilken kategori tillh√∂r den?` : `An angle is ${angle}¬∞. Which category does it belong to?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(lang === 'sv' ? ["Spetsig", "R√§t", "Trubbig", "Rak"] : ["Acute", "Right", "Obtuse", "Straight"])
                },
                token: this.toBase64(correct),
                clues: [
                    { 
                        text: lang === 'sv' ? "Spetsig ($<90^\\circ$), R√§t ($90^\\circ$), Trubbig ($>90^\\circ$) och Rak ($180^\\circ$)." : "Acute ($<90^\\circ$), Right ($90^\\circ$), Obtuse ($>90^\\circ$), and Straight ($180^\\circ$).",
                        latex: `${angle}^\\circ` 
                    },
                    { 
                        text: lang === 'sv' ? "R√§tt kategori √§r:" : "The correct category is:",
                        latex: `\\text{${correct}}` 
                    }
                ],
                metadata: { variation_key: "classification_inverse_numeric", difficulty: 1 }
            };
        }

        const getAngleTypePair = (isCorrect: boolean) => {
            const type = MathUtils.randomChoice(['acute', 'right', 'obtuse', 'straight']);
            let angle = 0;
            if (isCorrect) {
                if (type === 'acute') angle = MathUtils.randomInt(10, 89);
                else if (type === 'right') angle = 90;
                else if (type === 'obtuse') angle = MathUtils.randomInt(91, 179);
                else angle = 180;
            } else {
                if (type === 'acute') angle = MathUtils.randomInt(91, 180);
                else if (type === 'right') angle = MathUtils.randomChoice([45, 135]);
                else if (type === 'obtuse') angle = MathUtils.randomInt(10, 89);
                else angle = 90;
            }
            const names: any = { acute: { sv: "spetsig", en: "acute" }, right: { sv: "r√§t", en: "right" }, obtuse: { sv: "trubbig", en: "obtuse" }, straight: { sv: "rak", en: "straight" } };
            return lang === 'sv' ? `${angle}¬∞ √§r en ${names[type].sv} vinkel` : `${angle}¬∞ is an ${names[type].en} angle`;
        };

        const sFalse = getAngleTypePair(false);
        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende √§r FALSKT?" : "Which statement is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([getAngleTypePair(true), getAngleTypePair(true), sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [
                { text: lang === 'sv' ? "Kontrollera om gradtalet st√§mmer √∂verens med namnet. Trubbiga vinklar m√•ste vara st√∂rre √§n $90^\\circ$ men mindre √§n $180^\\circ$." : "Check if the degrees match the name. Obtuse angles must be larger than $90^\\circ$ but smaller than $180^\\circ$." },
                { text: lang === 'sv' ? "Detta p√•st√•ende st√§mmer inte:" : "This statement is not true:", latex: `\\text{${sFalse}}` }
            ],
            metadata: { variation_key: "classification_lie", difficulty: 1 }
        };
    }

    // --- LEVEL 2: COMPLEMENTARY & SUPPLEMENTARY ---
    private level2_CompSupp(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['comp_supp_visual', 'comp_supp_inverse']);

        if (v === 'comp_supp_visual') {
            const isSupp = Math.random() > 0.5;
            const total = isSupp ? 180 : 90;
            const known = MathUtils.randomInt(20, total - 20);
            const unknown = total - known;
            const cx = 150, cy = 200, len = 120;
            const lines = isSupp ? [{x1: cx - len, y1: cy, x2: cx + len, y2: cy}] : [{x1: cx, y1: cy, x2: cx + len, y2: cy}, {x1: cx, y1: cy, x2: cx, y2: cy - len}];
            const xCut = cx + len * Math.cos(-known * Math.PI / 180);
            const yCut = cy + len * Math.sin(-known * Math.PI / 180);
            lines.push({x1: cx, y1: cy, x2: xCut, y2: yCut});

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna vinkeln x." : "Calculate angle x.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', lines, arcs: [{ center: {x: cx, y: cy}, startAngle: 0, endAngle: known, radius: 40, label: `${known}¬∞` }, { center: {x: cx, y: cy}, startAngle: known, endAngle: total, radius: 50, label: 'x' }] }
                },
                token: this.toBase64(unknown.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? (isSupp ? "Vinklarna ligger p√• en rak linje, vilket betyder att deras summa √§r $180^\\circ$." : "Vinklarna bildar ett h√∂rn (r√§t vinkel), vilket betyder att deras summa √§r $90^\\circ$.") : (isSupp ? "The angles are on a straight line, which means their sum is $180^\\circ$." : "The angles form a corner (right angle), which means their sum is $90^\\circ$."),
                        latex: `x + ${known}^\\circ = ${total}^\\circ`
                    },
                    { 
                        text: lang === 'sv' ? `Dra bort den k√§nda vinkeln fr√•n ${total}^\\circ$ f√∂r att hitta x.` : `Subtract the known angle from ${total}^\\circ$ to find x.`,
                        latex: `x = ${total} - ${known}`
                    },
                    { 
                        text: lang === 'sv' ? "V√§rdet p√• x √§r:" : "The value of x is:",
                        latex: `x = ${unknown}`
                    }
                ],
                metadata: { variation_key: "comp_supp_visual", difficulty: 2 }
            };
        }

        const isSupp = Math.random() > 0.5;
        const known = MathUtils.randomInt(10, isSupp ? 170 : 80);
        const ans = isSupp ? 180 - known : 90 - known;
        const termSv = isSupp ? "supplementvinkel" : "komplementvinkel";
        const termEn = isSupp ? "supplementary angle" : "complementary angle";

        return {
            renderData: {
                description: lang === 'sv' ? `En vinkel √§r ${known}¬∞. Vad √§r dess ${termSv}?` : `An angle is ${known}¬∞. What is its ${termEn}?`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? (isSupp ? "Supplementvinklar blir $180^\\circ$ tillsammans." : "Komplementvinklar blir $90^\\circ$ tillsammans.") : (isSupp ? "Supplementary angles sum to $180^\\circ$." : "Complementary angles sum to $90^\\circ$.") },
                { text: lang === 'sv' ? `R√§kna ut skillnaden:` : `Calculate the difference:`, latex: `${isSupp ? 180 : 90} - ${known} = ${ans}` }
            ],
            metadata: { variation_key: "comp_supp_inverse", difficulty: 2 }
        };
    }

    // --- LEVEL 3: VERTICAL & SIDE ---
    private level3_Vertical(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vertical_side_visual', 'vertical_side_lie']);
        const angle = MathUtils.randomInt(40, 140);

        if (v === 'vertical_side_visual') {
            const isVertical = Math.random() > 0.5;
            const target = isVertical ? angle : 180 - angle;
            const cx = 150, cy = 125, len = 100, rot = 15;
            const lines = [
                {x1: cx - len * Math.cos(rot * Math.PI / 180), y1: cy + len * Math.sin(rot * Math.PI / 180), x2: cx + len * Math.cos(rot * Math.PI / 180), y2: cy - len * Math.sin(rot * Math.PI / 180)},
                {x1: cx - len * Math.cos((rot + angle) * Math.PI / 180), y1: cy + len * Math.sin((rot + angle) * Math.PI / 180), x2: cx + len * Math.cos((rot + angle) * Math.PI / 180), y2: cy - len * Math.sin((rot + angle) * Math.PI / 180)}
            ];
            const arcs = [{ center: {x: cx, y: cy}, startAngle: rot, endAngle: rot + angle, radius: 40, label: `${angle}¬∞` }];
            if (isVertical) arcs.push({ center: {x: cx, y: cy}, startAngle: rot + 180, endAngle: rot + angle + 180, radius: 40, label: 'x' });
            else arcs.push({ center: {x: cx, y: cy}, startAngle: rot + angle, endAngle: rot + 180, radius: 35, label: 'x' });

            return {
                renderData: {
                    description: lang === 'sv' ? "Best√§m vinkeln x." : "Determine angle x.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', lines, arcs }
                },
                token: this.toBase64(target.toString()),
                clues: [
                    { 
                        text: isVertical 
                            ? (lang === 'sv' ? "Vinklar som sitter mitt emot varandra i ett kors kallas vertikalvinklar. De √§r alltid lika stora." : "Angles opposite each other in a crossing are called vertical angles. They are always equal.") 
                            : (lang === 'sv' ? "Vinklar bredvid varandra p√• en rak linje kallas sidovinklar. De blir $180^\\circ$ tillsammans." : "Angles next to each other on a straight line are side angles. They sum to $180^\\circ$."),
                        latex: isVertical ? `x = ${angle}^\\circ` : `x + ${angle}^\\circ = 180^\\circ`
                    },
                    { 
                        text: lang === 'sv' ? "Detta ger oss svaret:" : "This gives us the answer:",
                        latex: `x = ${target}`
                    }
                ],
                metadata: { variation_key: "vertical_side_visual", difficulty: 3 }
            };
        }

        const a = MathUtils.randomInt(40, 140), b = 180 - a;
        const sFalse = lang === 'sv' ? `Sidovinklar till ${a}¬∞ blir totalt 90¬∞` : `Side angles to ${a}¬∞ sum to 90¬∞`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende √§r FALSKT?" : "Which statement is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([
                    lang === 'sv' ? `Vertikalvinkeln till ${a}¬∞ √§r ${a}¬∞` : `The vertical angle to ${a}¬∞ is ${a}¬∞`,
                    lang === 'sv' ? `Sidovinkeln till ${a}¬∞ √§r ${b}¬∞` : `The side angle to ${a}¬∞ is ${b}¬∞`,
                    sFalse
                ])
            },
            token: this.toBase64(sFalse),
            clues: [
                { text: lang === 'sv' ? "Sidovinklar bildar en linje ($180^\\circ$). Komplementvinklar bildar ett h√∂rn ($90^\\circ$)." : "Side angles form a line ($180^\\circ$). Complementary angles form a corner ($90^\\circ$)." },
                { text: lang === 'sv' ? "Detta p√•st√•ende √§r allts√• l√∂gnen:" : "This statement is the lie:", latex: `\\text{${sFalse}}` }
            ],
            metadata: { variation_key: "vertical_side_lie", difficulty: 2 }
        };
    }

    // --- LEVEL 4: TRIANGLE SUM ---
    private level4_TriangleSum(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['triangle_sum_visual', 'triangle_isosceles']);

        if (v === 'triangle_sum_visual') {
            const a = MathUtils.randomInt(30, 80), b = MathUtils.randomInt(30, 80);
            const ans = 180 - a - b;

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna x i triangeln." : "Calculate x in the triangle.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', polygons: [{ points: "50,220 250,220 150,50" }], labels: [{x: 65, y: 210, text: `${a}¬∞`}, {x: 235, y: 210, text: `${b}¬∞`}, {x: 150, y: 85, text: 'x'}] }
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Summan av alla tre vinklar i en triangel √§r alltid $180^\\circ$." : "The sum of all three angles in a triangle is always $180^\\circ$.",
                        latex: `x + ${a}^\\circ + ${b}^\\circ = 180^\\circ`
                    },
                    { 
                        text: lang === 'sv' ? "Vi hittar x genom att dra bort de k√§nda vinklarna fr√•n 180." : "We find x by subtracting the known angles from 180.",
                        latex: `x = 180 - ${a + b} = ${ans}` 
                    }
                ],
                metadata: { variation_key: "triangle_sum_visual", difficulty: 3 }
            };
        }

        const vertex = MathUtils.randomInt(30, 100);
        const base = (180 - vertex) / 2;
        const findVertex = Math.random() > 0.5;
        const ans = findVertex ? vertex : base;

        return {
            renderData: {
                description: lang === 'sv' ? "Triangeln √§r likbent. Ber√§kna x." : "The triangle is isosceles. Calculate x.",
                answerType: 'numeric',
                geometry: { type: 'angle', polygons: [{ points: "50,200 250,200 150,50" }], labels: findVertex ? [{x: 100, y: 190, text: `${base}¬∞`}, {x: 200, y: 190, text: `${base}¬∞`}, {x: 150, y: 80, text: 'x'}] : [{x: 100, y: 190, text: 'x'}, {x: 200, y: 190, text: `${base}¬∞`}, {x: 150, y: 80, text: `${vertex}¬∞`}] }
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "I en likbent triangel √§r de tv√• vinklarna vid basen lika stora." : "In an isosceles triangle, the two angles at the base are equal.",
                    latex: findVertex ? `${base}^\\circ = \\text{${lang === 'sv' ? 'basvinkel' : 'base angle'}}` : `x = ${base}^\\circ`
                },
                { 
                    text: lang === 'sv' ? "Anv√§nd vinkelsumman $180^\\circ$ f√∂r att hitta den saknade vinkeln." : "Use the angle sum of $180^\\circ$ to find the missing angle.",
                    latex: findVertex ? `x = 180 - (2 \\cdot ${base})` : `x = (180 - ${vertex}) / 2`
                },
                {
                    text: lang === 'sv' ? "Svaret √§r:" : "The answer is:",
                    latex: `x = ${ans}`
                }
            ],
            metadata: { variation_key: "triangle_isosceles", difficulty: 4 }
        };
    }

    // --- LEVEL 5: POLYGONS ---
    private level5_Polygons(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['polygon_sum', 'polygon_inverse', 'quad_missing']);

        if (v === 'polygon_sum') {
            const n = MathUtils.randomChoice([4, 5, 6]);
            const sum = (n - 2) * 180;
            const names = { 4: {sv:"fyrh√∂rning", en:"quadrilateral"}, 5: {sv:"femh√∂rning", en:"pentagon"}, 6: {sv:"sexh√∂rning", en:"hexagon"} };

            return {
                renderData: {
                    description: lang === 'sv' ? `Vad √§r vinkelsumman i en ${names[n as 4|5|6].sv}?` : `What is the sum of angles in a ${names[n as 4|5|6].en}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(sum.toString()),
                clues: [
                    { text: lang === 'sv' ? `En figur med ${n} h√∂rn kan delas upp i ${n-2} stycken trianglar.` : `A figure with ${n} corners can be divided into ${n-2} triangles.`, latex: `n - 2 = ${n-2}` },
                    { text: lang === 'sv' ? "Varje triangel bidrar med $180^\\circ$. Den totala vinkelsumman √§r:" : "Each triangle contributes $180^\\circ$. The total angle sum is:", latex: `(${n}-2) \\cdot 180 = ${sum}` }
                ],
                metadata: { variation_key: "polygon_sum", difficulty: 4 }
            };
        }

        if (v === 'polygon_inverse') {
            const n = MathUtils.randomChoice([3, 4, 5, 8]);
            const sum = (n - 2) * 180;
            return {
                renderData: {
                    description: lang === 'sv' ? `En polygon har en vinkelsumma p√• ${sum}¬∞. Hur m√•nga sidor har den?` : `A polygon has an angle sum of ${sum}¬∞. How many sides does it have?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(n.toString()),
                clues: [
                    { text: lang === 'sv' ? "Vi b√∂rjar med att ta reda p√• hur m√•nga trianglar som ryms i figuren genom att dela summan med 180." : "We start by finding out how many triangles fit inside the figure by dividing the sum by 180.", latex: `${sum} / 180 = ${n-2}` },
                    { text: lang === 'sv' ? "Antalet sidor (n) √§r alltid 2 fler √§n antalet trianglar." : "The number of sides (n) is always 2 more than the number of triangles.", latex: `n = ${n-2} + 2 = ${n}` }
                ],
                metadata: { variation_key: "polygon_inverse", difficulty: 4 }
            };
        }

        const a = MathUtils.randomInt(70, 110), b = MathUtils.randomInt(70, 110), c = MathUtils.randomInt(70, 110);
        const ans = 360 - a - b - c;
        return {
            renderData: {
                description: lang === 'sv' ? "Best√§m vinkeln x i fyrh√∂rningen." : "Determine angle x in the quadrilateral.",
                answerType: 'numeric',
                geometry: { type: 'angle', polygons: [{ points: "50,50 250,50 230,200 70,200" }], labels: [{x: 70, y: 70, text: `${a}¬∞`}, {x: 230, y: 70, text: `${b}¬∞`}, {x: 210, y: 185, text: `${c}¬∞`}, {x: 90, y: 185, text: 'x'}] }
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Vinkelsumman i en fyrh√∂rning √§r alltid $360^\\circ$." : "The sum of angles in a quadrilateral is always $360^\\circ$.", latex: `x + ${a} + ${b} + ${c} = 360` },
                { text: lang === 'sv' ? "R√§kna ut x genom att dra bort summan av de andra vinklarna." : "Calculate x by subtracting the sum of the other angles.", latex: `x = 360 - ${a+b+c} = ${ans}` }
            ],
            metadata: { variation_key: "quad_missing", difficulty: 4 }
        };
    }

    // --- LEVEL 6: PARALLEL LINES ---
    private level6_Parallel(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['parallel_visual', 'parallel_lie']);
        const angle = MathUtils.randomInt(50, 130);

        if (v === 'parallel_visual') {
            const type = MathUtils.randomChoice(['corr', 'alt_int', 'alt_ext', 'interior']);
            let target = (type === 'interior') ? 180 - angle : angle;
            const cy = 125, lines = [{x1: 30, y1: cy - 50, x2: 270, y2: cy - 50}, {x1: 30, y1: cy + 50, x2: 270, y2: cy + 50}, {x1: 100, y1: 50, x2: 200, y2: 200}];
            const labels = [];
            if (type === 'alt_int') { labels.push({ x: 145, y: 90, text: `${angle}¬∞` }, { x: 155, y: 160, text: 'x' }); }
            else if (type === 'interior') { labels.push({ x: 145, y: 90, text: `${angle}¬∞` }, { x: 195, y: 160, text: 'x' }); }
            else if (type === 'alt_ext') { labels.push({ x: 90, y: 60, text: `${angle}¬∞` }, { x: 230, y: 190, text: 'x' }); }
            else { labels.push({ x: 145, y: 60, text: `${angle}¬∞` }, { x: 215, y: 160, text: 'x' }); }

            let typeName = type === 'interior' ? (lang === 'sv' ? 'liksidig inre' : 'consecutive interior') : (lang === 'sv' ? 'likbel√§gen eller alternat' : 'corresponding or alternate');

            return {
                renderData: {
                    description: lang === 'sv' ? "Linjerna √§r parallella. Best√§m x." : "The lines are parallel. Determine x.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', lines, labels }
                },
                token: this.toBase64(target.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `Vinklarna bildar en ${typeName}-relation.` : `The angles form a ${typeName} relationship.`, 
                        latex: type === 'interior' ? `x + ${angle}^\\circ = 180^\\circ` : `x = ${angle}^\\circ` 
                    },
                    { text: lang === 'sv' ? "V√§rdet p√• x √§r:" : "The value of x is:", latex: `x = ${target}` }
                ],
                metadata: { variation_key: "parallel_visual", difficulty: 5 }
            };
        }

        const a = MathUtils.randomInt(50, 130);
        const sFalse = lang === 'sv' ? `Likbel√§gna vinklar blir totalt 180¬∞ (${a}¬∞ + ${a}¬∞ = 180¬∞)` : `Corresponding angles sum to 180¬∞ (${a}¬∞ + ${a}¬∞ = 180¬∞)`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende om parallella linjer √§r FALSKT?" : "Which statement about parallel lines is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([
                    lang === 'sv' ? `Alternatvinklar √§r lika stora (${a}¬∞ = ${a}¬∞)` : `Alternate angles are equal (${a}¬∞ = ${a}¬∞)`,
                    lang === 'sv' ? `Likbel√§gna vinklar √§r lika stora (${a}¬∞ = ${a}¬∞)` : `Corresponding angles are equal (${a}¬∞ = ${a}¬∞)`,
                    sFalse
                ])
            },
            token: this.toBase64(sFalse),
            clues: [
                { text: lang === 'sv' ? "Likbel√§gna och alternatvinklar √§r alltid identiska om linjerna √§r parallella." : "Corresponding and alternate angles are always identical if the lines are parallel." },
                { text: lang === 'sv' ? "Falskt p√•st√•ende:" : "False statement:", latex: `\\text{${sFalse}}` }
            ],
            metadata: { variation_key: "parallel_lie", difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\AnglesGen.ts

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class BasicArithmeticGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSimple(lang);
            case 2: return this.level2_SubSimple(lang);
            case 3: return this.level3_Decimals(lang);
            case 4: return this.level4_MultEasy(lang);
            case 5: return this.level5_MultMedium(lang);
            case 6: return this.level6_MultHard(lang);
            case 7: return this.level7_DivEasy(lang);
            case 8: return this.level8_MixedIntegers(lang);
            case 9: return this.level9_MixedDecimals(lang);
            default: return this.level1_AddSimple(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'add_std_vertical':
            case 'add_std_horizontal':
            case 'add_missing_variable':
            case 'add_spot_the_lie':
                return this.level1_AddSimple(lang, key);
            case 'sub_std_vertical':
            case 'sub_std_horizontal':
            case 'sub_missing_variable':
                return this.level2_SubSimple(lang, key);
            case 'dec_add_vertical':
            case 'dec_sub_vertical':
                return this.level3_Decimals(lang, key);
            case 'mult_table_std':
            case 'mult_commutative':
                return this.level4_MultEasy(lang, key);
            case 'mult_2x1_vertical':
            case 'mult_distributive':
                return this.level5_MultMedium(lang, key);
            case 'mult_decimal_std':
            case 'mult_decimal_placement':
                return this.level6_MultHard(lang, key);
            case 'div_basic_std':
            case 'div_inverse_logic':
                return this.level7_DivEasy(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private makeVertical(top: number | string, bottom: number | string, op: string): string {
        return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
    }

    // --- LEVEL 1: ADDITION ---
    private level1_AddSimple(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['add_std_vertical', 'add_std_horizontal', 'add_missing_variable', 'add_spot_the_lie']);

        if (v === 'add_std_vertical' || v === 'add_std_horizontal') {
            const a = MathUtils.randomInt(10, 999);
            const b = MathUtils.randomInt(10, 999);
            const isVertical = v === 'add_std_vertical';
            const res = this.createProblem(a, b, '+', lang, isVertical);
            res.metadata = { variation_key: v, difficulty: 1 };
            return res;
        }

        if (v === 'add_missing_variable') {
            const a = MathUtils.randomInt(5, 100);
            const x = MathUtils.randomInt(5, 100);
            const c = a + x;
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket tal saknas f√∂r att summan ska st√§mma?" : "What number is missing to make the sum correct?",
                    latex: `${a} + ? = ${c}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(x.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "F√∂r att hitta den saknade delen i en addition, anv√§nder vi subtraktion: hela summan minus den k√§nda delen." : "To find the missing part in an addition, we use subtraction: the whole sum minus the known part.", 
                        latex: `x = ${c} - ${a}` 
                    },
                    {
                        text: lang === 'sv' ? "Utr√§kningen ger oss det saknade talet:" : "The calculation gives us the missing number:",
                        latex: `${x}`
                    }
                ],
                metadata: { variation_key: 'add_missing_variable', difficulty: 2 }
            };
        }

        const generateEquation = (isCorrect: boolean) => {
            const n1 = MathUtils.randomInt(10, 50);
            const n2 = MathUtils.randomInt(10, 50);
            const result = isCorrect ? (n1 + n2) : (n1 + n2 + MathUtils.randomChoice([-2, -1, 1, 2]));
            return `${n1} + ${n2} = ${result}`;
        };

        const sTrue1 = generateEquation(true);
        const sTrue2 = generateEquation(true);
        const sFalse = generateEquation(false);

        return {
            renderData: {
                description: lang === 'sv' ? "Vilken av f√∂ljande utr√§kningar √§r FELAKTIG?" : "Which of the following calculations is INCORRECT?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [
                { text: lang === 'sv' ? "Kontrollera entalen och tiotalen var f√∂r sig f√∂r att se om summan st√§mmer." : "Check the ones and tens separately to see if the sum matches." },
                { text: lang === 'sv' ? "Den felaktiga utr√§kningen √§r:" : "The incorrect calculation is:", latex: sFalse }
            ],
            metadata: { variation_key: 'add_spot_the_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 2: SUBTRACTION ---
    private level2_SubSimple(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sub_std_vertical', 'sub_std_horizontal', 'sub_missing_variable']);

        if (v === 'sub_std_vertical' || v === 'sub_std_horizontal') {
            const a = MathUtils.randomInt(50, 999);
            const b = MathUtils.randomInt(10, a - 1);
            const isVertical = v === 'sub_std_vertical';
            const res = this.createProblem(a, b, '-', lang, isVertical);
            res.metadata = { variation_key: v, difficulty: 2 };
            return res;
        }

        const a = MathUtils.randomInt(100, 250);
        const x = MathUtils.randomInt(20, 80);
        const c = a - x;
        return {
            renderData: {
                description: lang === 'sv' ? "Hitta det saknade talet i subtraktionen." : "Find the missing number in the subtraction.",
                latex: `${a} - ? = ${c}`,
                answerType: 'numeric'
            },
            token: this.toBase64(x.toString()),
            clues: [
                { text: lang === 'sv' ? `F√∂r att hitta talet som tagits bort, r√§knar vi ut skillnaden mellan starttalet och resultatet.` : `To find the number that was removed, we calculate the difference between the starting number and the result.`, latex: `x = ${a} - ${c}` },
                { text: lang === 'sv' ? "Det saknade talet √§r:" : "The missing number is:", latex: `${x}` }
            ],
            metadata: { variation_key: 'sub_missing_variable', difficulty: 2 }
        };
    }

    // --- LEVEL 3: DECIMALS ---
    private level3_Decimals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['dec_add_vertical', 'dec_sub_vertical']);
        const op = v === 'dec_add_vertical' ? '+' : '-';
        const a = MathUtils.randomInt(100, 4500) / 100;
        const b = MathUtils.randomInt(100, 4500) / 100;
        
        const res = this.createProblem(
            op === '+' ? a : Math.max(a, b), 
            op === '+' ? b : Math.min(a, b), 
            op, lang, true
        );

        res.clues = [
            { text: lang === 'sv' ? "Viktigaste regeln: Decimaltecknen m√•ste st√• rakt under varandra. Fyll i med nollor om talen har olika m√•nga decimaler." : "Most important rule: The decimal points must be aligned vertically. Fill with zeros if the numbers have different numbers of decimal places." },
            { text: lang === 'sv' ? "R√§kna nu som vanligt fr√•n h√∂ger till v√§nster." : "Now calculate as usual from right to left.", latex: `${res.renderData.latex.replace('\\hline', '\\hline ' + Math.round((op === '+' ? a + b : Math.max(a, b) - Math.min(a, b)) * 100) / 100)}` },
            { text: lang === 'sv' ? "Slutresultatet √§r:" : "The final result is:", latex: `${Math.round((op === '+' ? a + b : Math.max(a, b) - Math.min(a, b)) * 100) / 100}` }
        ];
        res.metadata = { variation_key: v, difficulty: 3 };
        return res;
    }

    // --- LEVEL 4: MULT EASY ---
    private level4_MultEasy(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_table_std', 'mult_commutative']);
        const a = MathUtils.randomInt(2, 10);
        const b = MathUtils.randomInt(2, 10);

        if (v === 'mult_table_std') {
            const res = this.createProblem(a, b, '*', lang, false);
            res.clues = [
                { text: lang === 'sv' ? `Multiplikation √§r upprepad addition. ${a} √ó ${b} betyder ${a} stycken ${b}:or.` : `Multiplication is repeated addition. ${a} √ó ${b} means ${a} groups of ${b}.` },
                { text: lang === 'sv' ? "Produkten blir:" : "The product is:", latex: `${a * b}` }
            ];
            res.metadata = { variation_key: 'mult_table_std', difficulty: 2 };
            return res;
        }

        const correct = `${b} √ó ${a}`;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket uttryck ger samma produkt som ${a} √ó ${b}?` : `Which expression gives the same product as ${a} √ó ${b}?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([correct, `${a} + ${b}`, `${a} - ${b}`])
            },
            token: this.toBase64(correct),
            clues: [
                { text: lang === 'sv' ? "Den kommutativa lagen s√§ger att ordningen p√• talen inte spelar n√•gon roll vid multiplikation." : "The commutative law states that the order of numbers does not matter in multiplication.", latex: "a \\cdot b = b \\cdot a" },
                { text: lang === 'sv' ? "D√§rf√∂r √§r svaret:" : "Therefore the answer is:", latex: correct }
            ],
            metadata: { variation_key: 'mult_commutative', difficulty: 2 }
        };
    }

    // --- LEVEL 5: MULT MEDIUM ---
    private level5_MultMedium(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_2x1_vertical', 'mult_distributive']);
        const a = MathUtils.randomInt(11, 35);
        const b = MathUtils.randomInt(3, 9);

        if (v === 'mult_2x1_vertical') {
            const res = this.createProblem(a, b, '*', lang, true);
            res.clues = [
                { text: lang === 'sv' ? `Multiplicera ${b} med entalet f√∂rst, sedan med tiotalet.` : `Multiply ${b} by the ones digit first, then by the tens digit.` },
                { text: lang === 'sv' ? "Utr√§kningen blir:" : "The calculation is:", latex: `${a} \\cdot ${b} = ${a * b}` }
            ];
            res.metadata = { variation_key: 'mult_2x1_vertical', difficulty: 3 };
            return res;
        }

        const part1 = Math.floor(a / 10) * 10;
        const part2 = a % 10;
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna genom att dela upp talet i talsorter: (${part1}√ó${b})+(${part2}√ó${b})` : `Calculate by splitting the number into place values: (${part1} √ó ${b}) + (${part2} √ó ${b})`,
                answerType: 'numeric'
            },
            token: this.toBase64((a * b).toString()),
            clues: [
                { text: lang === 'sv' ? "Detta kallas den distributiva lagen. Vi r√§knar ut de tv√• parenteserna var f√∂r sig och adderar sedan resultaten." : "This is called the distributive law. We calculate the two parentheses separately and then add the results.", latex: `${part1*b} + ${part2*b}` },
                { text: lang === 'sv' ? "Summan blir:" : "The sum is:", latex: `${a * b}` }
            ],
            metadata: { variation_key: 'mult_distributive', difficulty: 3 }
        };
    }

    // --- LEVEL 6: MULT HARD ---
    private level6_MultHard(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_decimal_std', 'mult_decimal_placement']);
        const a = MathUtils.randomInt(1, 9) / 10;
        const b = MathUtils.randomInt(2, 15);
        const ans = Math.round(a * b * 100) / 100;

        if (v === 'mult_decimal_std') {
            const res = this.createProblem(a, b, '*', lang, false);
            res.clues = [
                { text: lang === 'sv' ? "Multiplicera som om det vore heltal f√∂rst. R√§kna sedan antalet decimaler i faktorerna och placera kommat i svaret." : "Multiply as if they were integers first. Then count the decimals in the factors and place the point in the answer.", latex: `${a * 10} \\cdot ${b} = ${a * 10 * b}` },
                { text: lang === 'sv' ? `Eftersom vi har en decimal totalt, flyttar vi kommat ett steg till v√§nster.` : `Since we have one decimal in total, move the decimal point one step to the left.`, latex: `${ans}` }
            ];
            res.metadata = { variation_key: 'mult_decimal_std', difficulty: 4 };
            return res;
        }

        const options = [
            `${a} √ó ${b} = ${ans}`,
            `${a} √ó ${b} = ${Math.round(ans * 10 * 10) / 10}`,
            `${a} √ó ${b} = ${Math.round(ans * 100 * 10) / 1000}`
        ];
        return {
            renderData: {
                description: lang === 'sv' ? "Vilken av utr√§kningarna har placerat decimalkommat r√§tt?" : "Which calculation has placed the decimal point correctly?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle(options)
            },
            token: this.toBase64(`${a} √ó ${b} = ${ans}`),
            clues: [
                { text: lang === 'sv' ? `R√§kna antalet decimaler i faktorerna. H√§r har ${a} en decimal och ${b} har noll. Produkten m√•ste ha totalt en decimal.` : `Count the decimals in the factors. Here ${a} has one decimal and ${b} has zero. The product must have one decimal in total.` },
                { text: lang === 'sv' ? "R√§tt svar √§r:" : "The correct answer is:", latex: `${a} \\times ${b} = ${ans}` }
            ],
            metadata: { variation_key: 'mult_decimal_placement', difficulty: 4 }
        };
    }

    // --- LEVEL 7: DIVISION ---
    private level7_DivEasy(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['div_basic_std', 'div_inverse_logic']);
        const f1 = MathUtils.randomInt(2, 12);
        const f2 = MathUtils.randomInt(2, 12);
        const prod = f1 * f2;

        if (v === 'div_basic_std') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna kvoten." : "Calculate the quotient.",
                    latex: `\\frac{${prod}}{${f1}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(f2.toString()),
                clues: [
                    { text: lang === 'sv' ? `Division √§r multiplikation bakl√§nges. Fr√•ga dig sj√§lv: Vilket tal multiplicerat med ${f1} blir ${prod}?` : `Division is multiplication in reverse. Ask yourself: What number multiplied by ${f1} equals ${prod}?`, latex: `${f1} \\cdot ? = ${prod}` },
                    { text: lang === 'sv' ? "Kvoten √§r:" : "The quotient is:", latex: `${f2}` }
                ],
                metadata: { variation_key: 'div_basic_std', difficulty: 2 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Om vi vet att ${f1} √ó ${f2} = ${prod}, vad blir d√• resultatet av ${prod} / ${f1}?` : `If we know that ${f1} √ó ${f2} = ${prod}, what is the result of ${prod} / ${f1}?`,
                answerType: 'numeric'
            },
            token: this.toBase64(f2.toString()),
            clues: [
                { text: lang === 'sv' ? "Division och multiplikation √§r motsatser. Om vi delar produkten med en av faktorerna f√•r vi den andra faktorn som svar." : "Division and multiplication are opposites. If we divide the product by one of the factors, we get the other factor as the result.", latex: `\\frac{${prod}}{${f1}} = ${f2}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${f2}` }
            ],
            metadata: { variation_key: 'div_inverse_logic', difficulty: 2 }
        };
    }

    // --- LEVEL 8 & 9: MIXED ---
    private level8_MixedIntegers(lang: string): any {
        const key = MathUtils.randomChoice(['add_std_horizontal', 'sub_std_horizontal', 'mult_table_std', 'div_basic_std']);
        const res = this.generateByVariation(key, lang);
        res.metadata.mixed = true;
        return res;
    }

    private level9_MixedDecimals(lang: string): any {
        const key = MathUtils.randomChoice(['dec_add_vertical', 'dec_sub_vertical', 'mult_decimal_std']);
        const res = this.generateByVariation(key, lang);
        res.metadata.mixed = true;
        return res;
    }

    private createProblem(a: number, b: number, op: string, lang: string, vertical: boolean = false) {
        let ans = 0;
        let latex = "";
        if (op === '+') ans = a + b;
        if (op === '-') ans = a - b;
        if (op === '*') ans = a * b;
        ans = Math.round(ans * 1000) / 1000;

        if (vertical) {
            const opSymbol = op === '*' ? '\\times' : op;
            latex = (op === '-') ? this.makeVertical(a, b, opSymbol) : this.makeVertical(Math.max(a, b), Math.min(a, b), opSymbol);
        } else {
            const opSymbol = op === '*' ? '\\cdot' : op;
            latex = `${a} ${opSymbol} ${b}`;
        }

        const description = vertical 
            ? (lang === 'sv' ? "St√§ll upp och ber√§kna. T√§nk p√• talsorterna." : "Set up and calculate. Pay attention to place values.")
            : (lang === 'sv' ? "Ber√§kna." : "Calculate.");

        const clues = [
            { 
                text: vertical 
                    ? (lang === 'sv' ? "St√§ll upp talen under varandra efter talsort (ental under ental). B√∂rja r√§kna fr√•n h√∂ger." : "Align the numbers by place value (ones under ones). Start calculating from the right.")
                    : (lang === 'sv' ? "T√§nk p√• talsorterna n√§r du r√§knar ut resultatet." : "Think about place values when calculating the result.")
            },
            { 
                text: lang === 'sv' ? "Resultatet blir:" : "The result is:", 
                latex: `${ans}` 
            }
        ];

        return {
            renderData: { latex, description, answerType: 'numeric' },
            token: this.toBase64(ans.toString()),
            clues: clues,
            metadata: { variation_key: 'generic_arithmetic', difficulty: 1 }
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ChangeFactorGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ChangeFactorGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_ApplyFactor(lang);
            case 3: return this.level3_FindOriginal(lang);
            case 4: return this.level4_TotalChange(lang);
            case 5: return this.level5_WordProblems(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'pct_to_factor_inc':
            case 'pct_to_factor_dec':
            case 'factor_to_pct_inc':
            case 'factor_to_pct_dec':
                return this.level1_Concepts(lang, key);
            
            case 'apply_factor_inc':
            case 'apply_factor_dec':
                return this.level2_ApplyFactor(lang, key);
            
            case 'find_original_inc':
            case 'find_original_dec':
                return this.level3_FindOriginal(lang, key);
            
            case 'sequential_factors':
                return this.level4_TotalChange(lang, key);
            
            case 'word_population':
            case 'word_interest':
            case 'word_depreciation':
            case 'word_sale':
            case 'word_decay':
            case 'word_salary':
            case 'word_inflation':
            case 'word_stock':
                return this.level5_WordProblems(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPTS & DEFINITION ---
    private level1_Concepts(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['pct_to_factor_inc', 'pct_to_factor_dec', 'factor_to_pct_inc', 'factor_to_pct_dec']);
        
        const isIncrease = v.endsWith('_inc');
        const isToFactor = v.startsWith('pct_to_factor');
        
        let pct = 0;
        if (Math.random() < 0.3) pct = MathUtils.randomInt(1, 9) * 10;
        else pct = MathUtils.randomInt(1, 150);
        
        let factor = 0;
        if (isIncrease) {
            factor = 1 + (pct / 100);
        } else {
            pct = Math.min(pct, 99);
            factor = 1 - (pct / 100);
        }
        factor = Math.round(factor * 100) / 100;

        if (isToFactor) {
            const desc = lang === 'sv'
                ? (isIncrease ? `Ett v√§rde √∂kar med ${pct}%. Vilken f√∂r√§ndringsfaktor motsvarar denna √∂kning?` : `Ett v√§rde minskar med ${pct}%. Vilken f√∂r√§ndringsfaktor motsvarar denna minskning?`)
                : (isIncrease ? `A value increases by ${pct}%. What is the change factor corresponding to this increase?` : `A value decreases by ${pct}%. What is the change factor corresponding to this decrease?`);
            
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Vi utg√•r fr√•n 100% (det hela), vilket motsvarar talet 1,0 i decimalform." : "We start with 100% (the whole), which corresponds to the number 1.0 in decimal form.", 
                        latex: "100\\% = 1.0" 
                    },
                    { 
                        text: lang === 'sv' 
                            ? (isIncrease ? `Addera √∂kningen (${pct}%) till basen (100%).` : `Dra bort minskningen (${pct}%) fr√•n basen (100%).`)
                            : (isIncrease ? `Add the increase (${pct}%) to the base (100%).` : `Subtract the decrease (${pct}%) from the base (100%).`),
                        latex: isIncrease ? `1.0 + ${pct/100} = ${factor}` : `1.0 - ${pct/100} = ${factor}` 
                    },
                    {
                        text: lang === 'sv' ? "Svaret √§r:" : "The answer is:",
                        latex: `${factor}`
                    }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        } else {
            const diff = Math.abs(1 - factor);
            const diffPct = Math.round(diff * 100);
            const desc = lang === 'sv'
                ? `F√∂r√§ndringsfaktorn √§r ${factor}. Hur m√•nga procents ${isIncrease ? '√∂kning' : 'minskning'} inneb√§r detta?`
                : `The change factor is ${factor}. What percentage ${isIncrease ? 'increase' : 'decrease'} does this represent?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(diffPct.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "J√§mf√∂r f√∂r√§ndringsfaktorn med 1,0 f√∂r att se hur stor skillnaden √§r." : "Compare the change factor with 1.0 to see the size of the difference.", 
                        latex: factor > 1 ? `${factor} - 1.0 = ${diff.toFixed(2)}` : `1.0 - ${factor} = ${diff.toFixed(2)}` 
                    },
                    { 
                        text: lang === 'sv' ? "G√∂r om skillnaden till procent genom att multiplicera med 100." : "Convert the difference to a percentage by multiplying by 100.", 
                        latex: `${diff.toFixed(2)} \\cdot 100 = ${diffPct}\\%` 
                    },
                    {
                        text: lang === 'sv' ? "Svaret √§r:" : "The answer is:",
                        latex: `${diffPct}`
                    }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }
    }

    // --- LEVEL 2: APPLYING FACTOR ---
    private level2_ApplyFactor(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['apply_factor_inc', 'apply_factor_dec']);
        const isIncrease = v === 'apply_factor_inc';
        
        const pct = MathUtils.randomInt(1, 95);
        let factor = isIncrease ? 1 + pct/100 : 1 - pct/100;
        factor = Math.round(factor * 100) / 100;

        let base = MathUtils.randomInt(2, 50) * 100;
        const ans = Math.round(base * factor);

        const desc = lang === 'sv'
            ? `Ett pris p√• ${base} kr ska ${isIncrease ? 'h√∂jas' : 's√§nkas'} med ${pct}%. Ber√§kna det nya priset.`
            : `A price of ${base} kr is to be ${isIncrease ? 'increased' : 'decreased'} by ${pct}%. Calculate the new price.`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(ans.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `F√∂rst r√§knar vi ut f√∂r√§ndringsfaktorn f√∂r en ${pct}% ${isIncrease ? 'h√∂jning' : 's√§nkning'}.` : `First, calculate the change factor for a ${pct}% ${isIncrease ? 'increase' : 'decrease'}.`, 
                    latex: isIncrease ? `1.0 + ${pct/100} = ${factor}` : `1.0 - ${pct/100} = ${factor}` 
                },
                { 
                    text: lang === 'sv' ? "Multiplicera sedan det gamla v√§rdet med f√∂r√§ndringsfaktorn f√∂r att f√• det nya v√§rdet." : "Then multiply the old value by the change factor to get the new value.", 
                    latex: `${base} \\cdot ${factor} = ${ans}` 
                },
                {
                    text: lang === 'sv' ? "Det nya priset blir:" : "The new price will be:",
                    latex: `${ans}`
                }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: FINDING ORIGINAL ---
    private level3_FindOriginal(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['find_original_inc', 'find_original_dec']);
        const isIncrease = v === 'find_original_inc';
        
        const pct = MathUtils.randomInt(5, 80);
        let factor = isIncrease ? 1 + pct/100 : 1 - pct/100;
        factor = Math.round(factor * 100) / 100;

        const original = MathUtils.randomInt(2, 25) * 100;
        const newPrice = Math.round(original * factor);

        const desc = lang === 'sv'
            ? `Efter en ${isIncrease ? 'h√∂jning' : 's√§nkning'} med ${pct}% kostar en vara nu ${newPrice} kr. Vad var priset fr√•n b√∂rjan?`
            : `After a ${isIncrease ? 'increase' : 'decrease'} of ${pct}%, an item now costs ${newPrice} kr. What was the price from the beginning?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(original.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `Hitta f√∂r√§ndringsfaktorn f√∂r en ${isIncrease ? '√∂kning' : 'minskning'} p√• ${pct}%.` : `Find the change factor for a ${isIncrease ? 'increase' : 'decrease'} of ${pct}%.`, 
                    latex: `f = ${factor}` 
                },
                { 
                    text: lang === 'sv' ? "F√∂r att hitta det ursprungliga v√§rdet delar (dividerar) vi det nya v√§rdet med f√∂r√§ndringsfaktorn." : "To find the original value, we divide the new value by the change factor.", 
                    latex: `\\frac{${newPrice}}{${factor}} = ${original}` 
                },
                {
                    text: lang === 'sv' ? "Det ursprungliga priset var:" : "The original price was:",
                    latex: `${original}`
                }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: TOTAL CHANGE (SEQUENTIAL) ---
    private level4_TotalChange(lang: string, variationKey?: string): any {
        const pct1 = MathUtils.randomChoice([10, 20, 25, 50]);
        const pct2 = MathUtils.randomChoice([10, 20, 25, 50]);
        const inc1 = Math.random() > 0.5;
        const inc2 = Math.random() > 0.5;

        const f1 = inc1 ? 1 + pct1/100 : 1 - pct1/100;
        const f2 = inc2 ? 1 + pct2/100 : 1 - pct2/100;
        const totalFactor = Math.round(f1 * f2 * 10000) / 10000;

        const desc = lang === 'sv'
            ? `V√§rdet p√• ett f√∂rem√•l √§ndras f√∂rst med ${inc1 ? '+' : '-'}${pct1}% och d√§refter med ${inc2 ? '+' : '-'}${pct2}%. Ber√§kna den totala f√∂r√§ndringsfaktorn.`
            : `The value of an item changes first by ${inc1 ? '+' : '-'}${pct1}% and then by ${inc2 ? '+' : '-'}${pct2}%. Calculate the total change factor.`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(totalFactor.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "N√§r flera f√∂r√§ndringar sker efter varandra multiplicerar vi de enskilda f√∂r√§ndringsfaktorerna med varandra." : "When multiple changes occur one after the other, we multiply the individual change factors with each other.", 
                    latex: `F_1 = ${f1}, \\; F_2 = ${f2}` 
                },
                { 
                    text: lang === 'sv' ? "Den totala f√∂r√§ndringsfaktorn f√•r vi genom att r√§kna ut produkten." : "The total change factor is obtained by calculating the product.", 
                    latex: `${f1} \\cdot ${f2} = ${totalFactor}` 
                },
                {
                    text: lang === 'sv' ? "Resultatet √§r:" : "The result is:",
                    latex: `${totalFactor}`
                }
            ],
            metadata: { variation_key: 'sequential_factors', difficulty: 4 }
        };
    }

    // --- LEVEL 5: WORD PROBLEMS ---
    private level5_WordProblems(lang: string, variationKey?: string): any {
        const scenarios = ['word_population', 'word_interest', 'word_depreciation', 'word_sale', 'word_decay', 'word_salary', 'word_inflation', 'word_stock'];
        const v = variationKey || MathUtils.randomChoice(scenarios);

        if (v === 'word_population' || v === 'word_salary' || v === 'word_stock') {
            const start = MathUtils.randomInt(10, 50) * 1000;
            const pct = MathUtils.randomInt(5, 40);
            const isInc = v !== 'word_stock';
            const factor = isInc ? 1 + pct/100 : 1 - pct/100;
            const end = Math.round(start * factor);

            let desc = "";
            if (v === 'word_population') {
                desc = lang === 'sv' 
                    ? `Befolkningen i en stad √§ndrades fr√•n ${start} till ${end} inv√•nare. Ber√§kna f√∂r√§ndringsfaktorn.` 
                    : `The population of a city changed from ${start} to ${end} inhabitants. Calculate the change factor.`;
            } else if (v === 'word_salary') {
                desc = lang === 'sv'
                    ? `En l√∂n h√∂jdes fr√•n ${start} kr till ${end} kr. Vilken f√∂r√§ndringsfaktor motsvarar detta?`
                    : `A salary was increased from ${start} kr to ${end} kr. Which change factor corresponds to this?`;
            } else {
                desc = lang === 'sv'
                    ? `V√§rdet p√• en aktie sj√∂nk fr√•n ${start} kr till ${end} kr. Ber√§kna f√∂r√§ndringsfaktorn.`
                    : `The value of a stock fell from ${start} kr to ${end} kr. Calculate the change factor.`;
            }

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "F√∂r√§ndringsfaktorn ber√§knas genom att dividera det nya v√§rdet med det gamla." : "The change factor is calculated by dividing the new value by the old value.", 
                        latex: `\\text{Faktor} = \\frac{\\text{Nytt}}{\\text{Gammalt}}` 
                    },
                    { 
                        text: lang === 'sv' ? "St√§ll upp divisionen med dina v√§rden." : "Set up the division with your values.", 
                        latex: `\\frac{${end}}{${start}} = ${factor}` 
                    },
                    {
                        text: lang === 'sv' ? "Svaret √§r:" : "The answer is:",
                        latex: `${factor}`
                    }
                ],
                metadata: { variation_key: v, difficulty: 3 }
            };
        }

        if (v === 'word_interest' || v === 'word_depreciation' || v === 'word_decay') {
            const money = MathUtils.randomInt(10, 50) * 1000;
            const rate = MathUtils.randomInt(2, 15);
            const isInc = v === 'word_interest';
            const factor = isInc ? 1 + rate/100 : 1 - rate/100;
            const years = 2;
            const ans = Math.round(money * Math.pow(factor, years));

            let desc = "";
            if (v === 'word_interest') {
                desc = lang === 'sv' 
                    ? `Ett sparande p√• ${money} kr har en √•rlig r√§nta p√• ${rate}%. Hur mycket finns p√• kontot efter ${years} √•r? (Avrunda till heltal).`
                    : `Savings of ${money} kr have an annual interest rate of ${rate}%. How much is in the account after ${years} years? (Round to integer).`;
            } else if (v === 'word_depreciation') {
                desc = lang === 'sv'
                    ? `En maskin kostade ${money} kr och tappar ${rate}% i v√§rde varje √•r. Vad √§r den v√§rd efter ${years} √•r? (Avrunda till heltal).`
                    : `A machine cost ${money} kr and loses ${rate}% in value every year. What is it worth after ${years} years? (Round to integer).`;
            } else {
                desc = lang === 'sv'
                    ? `Ett √§mne med massan ${money} gram minskar med ${rate}% per dygn. Hur stor massa √•terst√•r efter ${years} dygn? (Avrunda till heltal).`
                    : `A substance with a mass of ${money} grams decreases by ${rate}% per day. How much mass remains after ${years} days? (Round to integer).`;
            }

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `F√∂r√§ndringsfaktorn f√∂r ett √•r √§r ${factor}. Eftersom f√∂r√§ndringen sker under ${years} √•r anv√§nder vi potenser.` : `The change factor for one year is ${factor}. Since the change occurs over ${years} years, we use powers.`, 
                        latex: `\\text{V√§rde} = ${money} \\cdot ${factor}^{${years}}` 
                    },
                    { 
                        text: lang === 'sv' ? "Ber√§kna resultatet av potensen och multiplikationen." : "Calculate the result of the power and multiplication.", 
                        latex: `${money} \\cdot ${Math.round(Math.pow(factor, years) * 1000) / 1000} \\approx ${ans}` 
                    },
                    {
                        text: lang === 'sv' ? "Svaret √§r:" : "The answer is:",
                        latex: `${ans}`
                    }
                ],
                metadata: { variation_key: v, difficulty: 4 }
            };
        }

        if (v === 'word_sale' || v === 'word_inflation') {
            const pct = MathUtils.randomChoice([10, 20, 25, 50]);
            const isInc = v === 'word_inflation';
            const factor = isInc ? 1 + pct/100 : 1 - pct/100;
            const original = MathUtils.randomInt(5, 20) * 100;
            const current = Math.round(original * factor);

            let desc = "";
            if (v === 'word_sale') {
                desc = lang === 'sv'
                    ? `Efter ${pct}% rabatt kostar en vara ${current} kr. Vad var ordinarie pris f√∂re rean?`
                    : `After ${pct}% discount, an item costs ${current} kr. What was the regular price before the sale?`;
            } else {
                desc = lang === 'sv'
                    ? `Pga inflation har priset stigit med ${pct}% och √§r nu ${current} kr. Vad var priset innan h√∂jningen?`
                    : `Due to inflation, the price has risen by ${pct}% and is now ${current} kr. What was the price before the increase?`;
            }

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(original.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `En f√∂r√§ndring p√• ${isInc ? '+' : '-'}${pct}% motsvarar f√∂r√§ndringsfaktorn ${factor}.` : `A change of ${isInc ? '+' : '-'}${pct}% corresponds to the change factor ${factor}.`, 
                        latex: `f = ${factor}` 
                    },
                    { 
                        text: lang === 'sv' ? "F√∂r att f√• reda p√• det gamla priset dividerar vi det nya priset med f√∂r√§ndringsfaktorn." : "To find out the old price, we divide the new price by the change factor.", 
                        latex: `\\frac{${current}}{${factor}} = ${original}` 
                    },
                    {
                        text: lang === 'sv' ? "Det gamla priset var:" : "The old price was:",
                        latex: `${original}`
                    }
                ],
                metadata: { variation_key: v, difficulty: 4 }
            };
        }

        return this.level2_ApplyFactor(lang);
    }
}

// FILE END: src\core\generators\ChangeFactorGen.ts

// =======================================================
// FILE START: src\core\generators\ExponentsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExponentsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Foundations(lang);
            case 2: return this.level2_PowersOfTen(lang);
            case 3: return this.level3_ScientificNotation(lang);
            case 4: return this.level4_SquareRoots(lang);
            case 5: return this.level5_LawsBasic(lang);
            case 6: return this.level6_LawsAdvanced(lang);
            default: return this.level1_Foundations(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'zero_rule':
            case 'power_of_one':
            case 'foundations_calc':
            case 'foundations_spot_the_lie':
                return this.level1_Foundations(lang, key);
            
            case 'ten_positive_exponent':
            case 'ten_negative_exponent':
            case 'ten_inverse_counting':
                return this.level2_PowersOfTen(lang, key);
            
            case 'scientific_to_form':
            case 'scientific_missing_mantissa':
            case 'scientific_missing_exponent':
                return this.level3_ScientificNotation(lang, key);
            
            case 'root_calc':
            case 'root_inverse_algebra':
                return this.level4_SquareRoots(lang, key);
            
            case 'law_multiplication':
            case 'law_division':
            case 'law_addition_trap':
            case 'law_mult_div_combined':
                return this.level5_LawsBasic(lang, key);
            
            case 'law_power_of_power':
            case 'law_inverse_algebra':
            case 'law_all_combined':
                return this.level6_LawsAdvanced(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: FOUNDATIONS ---
    private level1_Foundations(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['zero_rule', 'power_of_one', 'foundations_calc', 'foundations_spot_the_lie']);

        if (v === 'zero_rule' || v === 'power_of_one') {
            const isZero = v === 'zero_rule';
            const base = MathUtils.randomInt(5, 500);
            const desc = lang === 'sv'
                ? `Ber√§kna v√§rdet av uttrycket nedan.`
                : `Calculate the value of the expression below.`;

            return {
                renderData: {
                    description: desc,
                    latex: isZero ? `${base}^{0}` : `${base}^{1}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(isZero ? "1" : base.toString()),
                clues: isZero ? [
                    { text: lang === 'sv' ? "Alla tal som √§r upph√∂jda till 0 (utom noll) blir alltid exakt 1." : "Any number raised to the power of 0 (except zero) is always exactly 1.", latex: "x^{0} = 1" },
                    { text: lang === 'sv' ? "Svaret √§r allts√•:" : "The answer is therefore:", latex: "1" }
                ] : [
                    { text: lang === 'sv' ? "N√§r ett tal √§r upph√∂jt till 1 betyder det att basen bara f√∂rekommer en enda g√•ng." : "When a number is raised to 1, it means the base appears only once.", latex: "x^{1} = x" },
                    { text: lang === 'sv' ? "V√§rdet f√∂rblir of√∂r√§ndrat:" : "The value remains unchanged:", latex: `${base}` }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }

        if (v === 'foundations_spot_the_lie') {
            const base = MathUtils.randomInt(2, 5);
            const exp = MathUtils.randomInt(2, 3);
            const val = Math.pow(base, exp);
            
            const true1 = `${base}^{${exp}} = ${val}`;
            const true2 = `${MathUtils.randomInt(10, 99)}^{0} = 1`;
            const lie = `${base}^{${exp}} = ${base * exp}`; 

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket p√•st√•ende √§r FALSKT?" : "Which statement is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([true1, true2, lie])
                },
                token: this.toBase64(lie),
                clues: [
                    { text: lang === 'sv' ? "En potens betyder upprepad multiplikation, inte multiplikation mellan basen och exponenten." : "A power means repeated multiplication, not multiplication between the base and the exponent.", latex: `${base}^{${exp}} = ` + Array(exp).fill(base).join(" \\cdot ") },
                    { text: lang === 'sv' ? "Denna ber√§kning √§r allts√• felaktig:" : "This calculation is therefore incorrect:", latex: `${lie}` }
                ],
                metadata: { variation_key: "foundations_spot_the_lie", difficulty: 2 }
            };
        }

        const base = MathUtils.randomInt(2, 10);
        const exp = MathUtils.randomInt(2, 4);
        if (Math.pow(base, exp) > 1000) return this.level1_Foundations(lang, v);
        const ans = Math.pow(base, exp);

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna potensen.` : `Calculate the power.`,
                latex: `${base}^{${exp}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? `Exponenten visar hur m√•nga g√•nger basen ${base} ska multipliceras med sig sj√§lv.` : `The exponent shows how many times the base ${base} should be multiplied by itself.`, latex: Array(exp).fill(base).join(' \\cdot ') },
                { text: lang === 'sv' ? "R√§kna ut produkten f√∂r att f√• det slutgiltiga svaret." : "Calculate the product to get the final answer.", latex: `${ans}` }
            ],
            metadata: { variation_key: "foundations_calc", difficulty: 1 }
        };
    }

    // --- LEVEL 2: POWERS OF 10 ---
    private level2_PowersOfTen(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['ten_positive_exponent', 'ten_negative_exponent', 'ten_inverse_counting']);
        const power = MathUtils.randomInt(1, 6);

        if (v === 'ten_negative_exponent') {
            const ansStr = (1 / Math.pow(10, power)).toString();
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv som ett decimaltal." : "Write as a decimal number.",
                    latex: `10^{-${power}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ansStr),
                clues: [
                    { text: lang === 'sv' ? "En negativ exponent inneb√§r att vi dividerar 1 med basen upph√∂jt till samma positiva tal." : "A negative exponent means we divide 1 by the base raised to the same positive power.", latex: `10^{-${power}} = \\frac{1}{10^{${power}}}` },
                    { text: lang === 'sv' ? `Detta ger en etta p√• den ${power}:e decimalplatsen.` : `This results in a one at the ${power}:th decimal place.`, latex: `${ansStr}` }
                ],
                metadata: { variation_key: "ten_negative_exponent", difficulty: 2 }
            };
        }

        if (v === 'ten_inverse_counting') {
            const zeros = MathUtils.randomInt(2, 7);
            const num = "1" + "0".repeat(zeros);
            return {
                renderData: {
                    description: lang === 'sv' ? `Skriv ${num.replace(/\B(?=(\d{3})+(?!\d))/g, " ")} som en tiopotens.` : `Write ${num.replace(/\B(?=(\d{3})+(?!\d))/g, " ")} as a power of ten.`,
                    latex: `10^{?} = ${num}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`10^${zeros}`),
                clues: [
                    { text: lang === 'sv' ? "R√§kna antalet nollor efter ettan. Antalet nollor motsvarar exponenten i tiopotensen." : "Count the number of zeros after the one. The number of zeros corresponds to the exponent in the power of ten.", latex: `\\text{Antal nollor} = ${zeros}` },
                    { text: lang === 'sv' ? "Svaret skrivs som:" : "The answer is written as:", latex: `10^{${zeros}}` }
                ],
                metadata: { variation_key: "ten_inverse_counting", difficulty: 2 }
            };
        }

        const ans = Math.pow(10, power);
        return {
            renderData: {
                description: lang === 'sv' ? "Skriv ut tiopotensen som ett heltal." : "Write the power of ten as an integer.",
                latex: `10^{${power}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? `F√∂r tiopotenser skriver man en etta f√∂ljt av lika m√•nga nollor som exponenten anger.` : `For powers of ten, write a one followed by as many zeros as the exponent indicates.`, latex: `10^{${power}} = 1\\underbrace{00...0}_{${power}}` },
                { text: lang === 'sv' ? "Detta ger oss talet:" : "This gives us the number:", latex: `${ans}` }
            ],
            metadata: { variation_key: "ten_positive_exponent", difficulty: 1 }
        };
    }

    // --- LEVEL 3: SCIENTIFIC NOTATION ---
    private level3_ScientificNotation(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['scientific_to_form', 'scientific_missing_mantissa', 'scientific_missing_exponent']);
        
        const mantissa = (MathUtils.randomInt(11, 99) / 10); 
        const exponent = MathUtils.randomInt(3, 8);
        const number = mantissa * Math.pow(10, exponent);

        if (v === 'scientific_to_form') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Skriv ${number.toLocaleString(lang)} i grundpotensform.` : `Write ${number.toLocaleString(lang)} in scientific notation.`,
                    answerType: 'structured_scientific'
                },
                token: this.toBase64(`${mantissa}*10^${exponent}`),
                clues: [
                    { text: lang === 'sv' ? "Flytta kommat s√• du f√•r ett tal mellan 1 och 10." : "Move the decimal point so you get a number between 1 and 10.", latex: `${mantissa}` },
                    { text: lang === 'sv' ? "R√§kna antalet steg kommat flyttades f√∂r att f√• exponenten." : "Count the number of steps the decimal point was moved to get the exponent.", latex: `n = ${exponent}` },
                    { text: lang === 'sv' ? "Hela talet blir d√•:" : "The whole number is then:", latex: `${mantissa} \\cdot 10^{${exponent}}` }
                ],
                metadata: { variation_key: "scientific_to_form", difficulty: 3 }
            };
        }

        const isMantissaMissing = v === 'scientific_missing_mantissa';
        const ans = isMantissaMissing ? mantissa : exponent;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket v√§rde saknas i uttrycket?` : `Which value is missing in the expression?`,
                latex: `${number.toLocaleString(lang)} = ${isMantissaMissing ? 'a' : mantissa} \\cdot 10^{${isMantissaMissing ? exponent : 'n'}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Grundpotensform ska best√• av ett tal mellan 1 och 10 multiplicerat med en tiopotens." : "Scientific notation must consist of a number between 1 and 10 multiplied by a power of ten.", latex: "a \\cdot 10^{n}" },
                { text: lang === 'sv' ? "Det saknade v√§rdet √§r:" : "The missing value is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: SQUARE ROOTS ---
    private level4_SquareRoots(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['root_calc', 'root_inverse_algebra']);
        const base = MathUtils.randomInt(2, 12);
        const square = base * base;

        if (v === 'root_inverse_algebra') {
            return {
                renderData: {
                    description: lang === 'sv' ? `L√∂s ekvationen (hitta det positiva v√§rdet p√• x).` : `Solve the equation (find the positive value of x).`,
                    latex: `x^{2} = ${square}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(base.toString()),
                clues: [
                    { text: lang === 'sv' ? "Motsatsen till 'upph√∂jt till 2' √§r kvadratroten." : "The opposite of 'squared' is the square root.", latex: "x = \\sqrt{" + square + "}" },
                    { text: lang === 'sv' ? "Vi letar efter det tal som multiplicerat med sig sj√§lvt blir resultatet." : "We are looking for the number that, when multiplied by itself, equals the result.", latex: `${base} \\cdot ${base} = ${square}` },
                    { text: lang === 'sv' ? "V√§rdet p√• x √§r:" : "The value of x is:", latex: `${base}` }
                ],
                metadata: { variation_key: "root_inverse_algebra", difficulty: 2 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna kvadratroten." : "Calculate the square root.",
                latex: `\\sqrt{${square}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(base.toString()),
            clues: [
                { text: lang === 'sv' ? `Fr√•ga dig sj√§lv: Vilket positivt tal g√•nger sig sj√§lvt blir ${square}?` : `Ask yourself: Which positive number times itself equals ${square}?`, latex: `? \\cdot ? = ${square}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${base}` }
            ],
            metadata: { variation_key: "root_calc", difficulty: 2 }
        };
    }

    // --- LEVEL 5: LAWS BASIC ---
    private level5_LawsBasic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['law_multiplication', 'law_division', 'law_addition_trap', 'law_mult_div_combined']);
        const a = MathUtils.randomInt(2, 12);
        const b = MathUtils.randomInt(2, 8);

        if (v === 'law_multiplication') {
            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla till en enda potens." : "Simplify to a single power.",
                    latex: `x^{${a}} \\cdot x^{${b}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${a + b}`),
                clues: [
                    { text: lang === 'sv' ? "Vid multiplikation av potenser med samma bas adderar vi exponenterna." : "When multiplying powers with the same base, we add the exponents.", latex: "x^{a} \\cdot x^{b} = x^{a+b}" },
                    { text: lang === 'sv' ? `R√§kna ut summan av exponenterna.` : `Calculate the sum of the exponents.`, latex: `${a} + ${b} = ${a + b}` },
                    { text: lang === 'sv' ? "Den f√∂renklade potensen blir:" : "The simplified power is:", latex: `x^{${a + b}}` }
                ],
                metadata: { variation_key: "law_multiplication", difficulty: 3 }
            };
        }

        if (v === 'law_division') {
            const big = MathUtils.randomInt(b + 1, b + 12);
            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla till en enda potens." : "Simplify to a single power.",
                    latex: `\\frac{x^{${big}}}{x^{${b}}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${big - b}`),
                clues: [
                    { text: lang === 'sv' ? "Vid division av potenser med samma bas subtraherar vi t√§ljarens exponent med n√§mnarens." : "When dividing powers with the same base, we subtract the denominator's exponent from the numerator's.", latex: "\\frac{x^{a}}{x^{b}} = x^{a-b}" },
                    { text: lang === 'sv' ? "R√§kna ut skillnaden mellan exponenterna." : "Calculate the difference between the exponents.", latex: `${big} - ${b} = ${big - b}` },
                    { text: lang === 'sv' ? "Den f√∂renklade potensen blir:" : "The simplified power is:", latex: `x^{${big - b}}` }
                ],
                metadata: { variation_key: "law_division", difficulty: 3 }
            };
        }

        if (v === 'law_mult_div_combined') {
            const n1 = MathUtils.randomInt(2, 8), n2 = MathUtils.randomInt(2, 8), d1 = MathUtils.randomInt(2, 5);
            const finalExp = n1 + n2 - d1;
            if (finalExp < 1) return this.level5_LawsBasic(lang, v);

            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla uttrycket till en enda potens." : "Simplify the expression to a single power.",
                    latex: `\\frac{x^{${n1}} \\cdot x^{${n2}}}{x^{${d1}}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${finalExp}`),
                clues: [
                    { text: lang === 'sv' ? "B√∂rja med att f√∂renkla t√§ljaren genom att addera exponenterna." : "Start by simplifying the numerator by adding the exponents.", latex: `x^{${n1} + ${n2}} = x^{${n1+n2}}` },
                    { text: lang === 'sv' ? "Subtrahera sedan n√§mnarens exponent fr√•n den nya t√§ljaren." : "Then subtract the denominator's exponent from the new numerator.", latex: `x^{${n1+n2} - ${d1}}` },
                    { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: `x^{${finalExp}}` }
                ],
                metadata: { variation_key: "law_mult_div_combined", difficulty: 4 }
            };
        }

        const options = lang === 'sv' ? ["Nej, lagarna g√§ller bara mult/div", "Ja, det blir x upph√∂jt till summan"] : ["No, laws only apply to mult/div", "Yes, it becomes x to the power of the sum"];
        return {
            renderData: { 
                description: lang === 'sv' ? `G√•r det att f√∂renkla $x^{${a}} + x^{${b}}$ med potenslagarna?` : `Can $x^{${a}} + x^{${b}}$ be simplified with the power laws?`, 
                answerType: 'multiple_choice', 
                options 
            },
            token: this.toBase64(options[0]),
            clues: [
                { text: lang === 'sv' ? "Potenslagarna f√∂r exponenter fungerar bara n√§r vi multiplicerar eller dividerar samma bas." : "The power laws for exponents only work when we multiply or divide the same base.", latex: "x^a \\cdot x^b = x^{a+b}" },
                { text: lang === 'sv' ? "D√§rf√∂r √§r svaret:" : "Therefore the answer is:", latex: `\\text{${options[0]}}` }
            ],
            metadata: { variation_key: "law_addition_trap", difficulty: 2 }
        };
    }

    // --- LEVEL 6: LAWS ADVANCED ---
    private level6_LawsAdvanced(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['law_power_of_power', 'law_inverse_algebra', 'law_all_combined']);
        const a = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(2, 6);

        if (v === 'law_power_of_power') {
            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.",
                    latex: `(x^{${a}})^{${b}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${a * b}`),
                clues: [
                    { text: lang === 'sv' ? "N√§r man har en 'potens av en potens' ska exponenterna multipliceras." : "When you have a 'power of a power', the exponents should be multiplied.", latex: "(x^{a})^{b} = x^{a \\cdot b}" },
                    { text: lang === 'sv' ? "R√§kna ut produkten av exponenterna." : "Calculate the product of the exponents.", latex: `${a} \\cdot ${b} = ${a*b}` },
                    { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `x^{${a*b}}` }
                ],
                metadata: { variation_key: "law_power_of_power", difficulty: 4 }
            };
        }

        if (v === 'law_all_combined') {
            const e1 = MathUtils.randomInt(2, 4), p1 = MathUtils.randomInt(2, 3), e2 = MathUtils.randomInt(2, 5);
            const n1 = e1 * p1;
            const finalExp = n1 + e2;

            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla till en enda potens." : "Simplify to a single power.",
                    latex: `(x^{${e1}})^{${p1}} \\cdot x^{${e2}}`,
                    answerType: 'structured_power'
                },
                token: this.toBase64(`x^${finalExp}`),
                clues: [
                    { text: lang === 'sv' ? "B√∂rja med att f√∂renkla parentesen genom att multiplicera exponenterna." : "Start by simplifying the parentheses by multiplying the exponents.", latex: `x^{${e1} \\cdot ${p1}} = x^{${n1}}` },
                    { text: lang === 'sv' ? "Addera nu den andra exponenten eftersom det √§r multiplikation mellan baserna." : "Now add the other exponent because there is multiplication between the bases.", latex: `x^{${n1} + ${e2}}` },
                    { text: lang === 'sv' ? "Den f√∂renklade potensen √§r:" : "The simplified power is:", latex: `x^{${finalExp}}` }
                ],
                metadata: { variation_key: "law_all_combined", difficulty: 5 }
            };
        }

        const target = a * b;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket v√§rde p√• y saknas?` : `Which value of y is missing?`,
                latex: `(x^{${a}})^{y} = x^{${target}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(b.toString()),
            clues: [
                { text: lang === 'sv' ? "Vid potens av en potens multipliceras exponenterna f√∂r att f√• slutresultatet." : "For a power of a power, the exponents are multiplied to get the final result.", latex: `${a} \\cdot y = ${target}` },
                { text: lang === 'sv' ? "L√∂s ut y f√∂r att f√• svaret:" : "Solve for y to get the answer:", latex: `${b}` }
            ],
            metadata: { variation_key: "law_inverse_algebra", difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\ExponentsGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExpressionSimplificationGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_CombineTerms(lang);
            case 2: return this.level2_Parentheses(lang);
            case 3: return this.level3_DistributeAndSimplify(lang);
            case 4: return this.level4_SubtractParentheses(lang);
            case 5: return this.level5_WordProblems(lang);
            case 6: return this.level6_Mixed(lang);
            default: return this.level1_CombineTerms(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'combine_lie_exponent':
            case 'combine_concept_id':
            case 'combine_standard_mixed':
                return this.level1_CombineTerms(lang, key);
            case 'distribute_lie_partial':
            case 'distribute_inverse_factor':
            case 'distribute_plus':
            case 'distribute_minus':
                return this.level2_Parentheses(lang, key);
            case 'distribute_double':
            case 'distribute_combine_std':
                return this.level3_DistributeAndSimplify(lang, key);
            case 'sub_concept_plus_logic':
            case 'sub_block_plus':
            case 'sub_block_minus':
                return this.level4_SubtractParentheses(lang, key);
            case 'word_candy':
            case 'word_discount':
            case 'word_combined_age':
            case 'word_combined_age_tri':
            case 'word_rect_perimeter':
            case 'word_savings':
            case 'word_passengers':
            case 'word_garden':
            case 'word_sports':
            case 'word_phone_battery':
                return this.level5_WordProblems(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Combine Like Terms ---
    private level1_CombineTerms(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['combine_lie_exponent', 'combine_concept_id', 'combine_standard_mixed']);

        if (v === 'combine_lie_exponent') {
            const a = MathUtils.randomInt(2, 6);
            const b = MathUtils.randomInt(2, 6);
            const sum = a + b;
            const sTrue = `${a}x + ${b}x = ${sum}x`;
            const sLie = `${a}x + ${b}x = ${sum}x^2`; 
            const options = [sTrue, sLie, `${a}x + x = ${a+1}x`];

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden √§r FALSKT?" : "Which of the following statements is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(options)
                },
                token: this.toBase64(sLie),
                clues: [
                    { 
                        text: lang === 'sv' ? "N√§r vi l√§gger ihop termer av samma sort √§ndras bara antalet (koefficienten), inte sj√§lva sorten (exponenten)." : "When we add terms of the same kind, only the count (coefficient) changes, not the kind itself (exponent).", 
                        latex: `${a}x + ${b}x = ${sum}x` 
                    },
                    {
                        text: lang === 'sv' ? "D√§rf√∂r √§r detta p√•st√•ende felaktigt:" : "Therefore, this statement is incorrect:",
                        latex: sLie
                    }
                ],
                metadata: { variation_key: 'combine_lie_exponent', difficulty: 2 }
            };
        }

        if (v === 'combine_concept_id') {
            const a = MathUtils.randomInt(2, 9);
            const correct = `${MathUtils.randomInt(2, 9)}x`;
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilken term kan f√∂renklas ihop med ${a}x?` : `Which term can be simplified with ${a}x?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, "5y", "7"])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "Man kan bara f√∂renkla termer som har exakt samma variabel." : "You can only simplify terms that have the exact same variable." },
                    { text: lang === 'sv' ? "R√§tt svar √§r:" : "The correct answer is:", latex: correct }
                ],
                metadata: { variation_key: 'combine_concept_id', difficulty: 1 }
            };
        }

        const a = MathUtils.randomInt(2, 8), b = MathUtils.randomInt(2, 12), c = MathUtils.randomInt(2, 8), d = MathUtils.randomInt(2, 12);
        const ans = `${a + c}x + ${b + d}`;

        return {
            renderData: {
                latex: `${a}x + ${b} + ${c}x + ${d}`,
                description: lang === 'sv' ? "F√∂renkla uttrycket genom att samla termer av samma slag." : "Simplify the expression by gathering like terms.",
                answerType: 'text'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "B√∂rja med att samla x-termerna f√∂r sig." : "Start by gathering the x-terms together.", latex: `${a}x + ${c}x = ${a+c}x \\\\ ${a+c}x + ${b} + ${d}` },
                { text: lang === 'sv' ? "Samla sedan siffertermerna f√∂r sig." : "Then gather the constant terms together.", latex: `${b} + ${d} = ${b+d} \\\\ ${a+c}x + ${b+d}` },
                { text: lang === 'sv' ? "Det f√§rdigf√∂renklade uttrycket √§r:" : "The fully simplified expression is:", latex: ans }
            ],
            metadata: { variation_key: 'combine_standard_mixed', difficulty: 2 }
        };
    }

    // --- LEVEL 2: Parentheses (Addition Rule) ---
    private level2_Parentheses(lang: string, variationKey?: string): any {
        const scenario = MathUtils.randomInt(1, 5);
        const a = MathUtils.randomInt(2, 9), b = MathUtils.randomInt(2, 9), c = MathUtils.randomInt(1, 12), d = MathUtils.randomInt(1, 12);
        
        let problemLatex = "", finalAnswer = "", step1Latex = "", groupingXText = "", groupingXVal = "", groupingNumText = "", groupingNumVal = "";
        let reducedAfterX = "", reducedAfterNum = "";

        const ruleText = lang === 'sv' 
            ? "Eftersom det st√•r plus (+) framf√∂r parentesen kan den tas bort utan att √§ndra tecken inuti." 
            : "Since there is a plus (+) in front of the parentheses, they can be removed without changing signs.";

        switch (scenario) {
            case 1: // ax + (bx + c)
                problemLatex = `${a}x + (${b}x + ${c})`;
                step1Latex = `${a}x + ${b}x + ${c}`;
                groupingXText = lang === 'sv' ? "Kombinera x-termerna." : "Combine the x-terms.";
                groupingXVal = `${a}x + ${b}x = ${a+b}x`;
                reducedAfterX = `${a+b}x + ${c}`;
                finalAnswer = reducedAfterX;
                break;
            case 2: // ax + (x - c)
                problemLatex = `${a}x + (x - ${c})`;
                step1Latex = `${a}x + x - ${c}`;
                groupingXText = lang === 'sv' ? "Kombinera x-termerna (x √§r samma sak som 1x)." : "Combine the x-terms (x is the same as 1x).";
                groupingXVal = `${a}x + 1x = ${a+1}x`;
                reducedAfterX = `${a+1}x - ${c}`;
                finalAnswer = reducedAfterX;
                break;
            case 3: // a + (bx + c) - d
                problemLatex = `${a} + (${b}x + ${c}) - ${d}`;
                step1Latex = `${a} + ${b}x + ${c} - ${d}`;
                groupingNumText = lang === 'sv' ? "Sl√• ihop siffertermerna." : "Combine the constant terms.";
                const res3 = a + c - d;
                groupingNumVal = `${a} + ${c} - ${d} = ${res3}`;
                reducedAfterNum = `${b}x ${res3 >= 0 ? '+' : ''} ${res3}`;
                finalAnswer = reducedAfterNum;
                break;
            case 4: // a + bx + (x - c) + d
                problemLatex = `${a} + ${b}x + (x - ${c}) + ${d}`;
                step1Latex = `${a} + ${b}x + x - ${c} + ${d}`;
                groupingXText = lang === 'sv' ? "Sl√• ihop x-termerna." : "Combine the x-terms.";
                groupingXVal = `${b}x + 1x = ${b+1}x`;
                reducedAfterX = `${a} + ${b+1}x - ${c} + ${d}`;
                const res4 = a - c + d;
                groupingNumText = lang === 'sv' ? "Sl√• ihop siffertermerna." : "Combine the constant terms.";
                groupingNumVal = `${a} - ${c} + ${d} = ${res4}`;
                reducedAfterNum = `${b+1}x ${res4 >= 0 ? '+' : ''} ${res4}`;
                finalAnswer = reducedAfterNum;
                break;
            default: // ax + (b + cx) + dx
                problemLatex = `${a}x + (${b} + ${c}x) + ${d}x`;
                step1Latex = `${a}x + ${b} + ${c}x + ${d}x`;
                groupingXText = lang === 'sv' ? "Kombinera alla x-termer." : "Combine all the x-terms.";
                groupingXVal = `${a}x + ${c}x + ${d}x = ${a+c+d}x`;
                reducedAfterX = `${a+c+d}x + ${b}`;
                finalAnswer = reducedAfterX;
                break;
        }

        const clues = [{ text: ruleText, latex: `${problemLatex} \\\\ ${step1Latex}` }];
        if (groupingXText) clues.push({ text: groupingXText, latex: `${groupingXVal} \\\\ ${reducedAfterX}` });
        if (groupingNumText) clues.push({ text: groupingNumText, latex: `${groupingNumVal} \\\\ ${reducedAfterNum}` });
        clues.push({ text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: finalAnswer });

        return {
            renderData: { latex: problemLatex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: this.toBase64(finalAnswer.replace(/\s/g, "")),
            clues,
            metadata: { variation_key: 'distribute_plus', difficulty: 2 }
        };
    }

    // --- LEVEL 3: Distribute & Combine ---
    private level3_DistributeAndSimplify(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['distribute_double', 'distribute_combine_std']);

        if (v === 'distribute_double') {
            const k1 = MathUtils.randomInt(2, 4), k2 = MathUtils.randomInt(2, 4), c1 = MathUtils.randomInt(1, 5), c2 = MathUtils.randomInt(1, 5);
            const expanded = `${k1}x + ${k1 * c1} + ${k2}x + ${k2 * c2}`;
            const final = `${k1 + k2}x + ${k1 * c1 + k2 * c2}`;

            return {
                renderData: { latex: `${k1}(x + ${c1}) + ${k2}(x + ${c2})`, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
                token: this.toBase64(final.replace(/\s/g, "")),
                clues: [
                    { 
                        text: lang === 'sv' ? "Multiplicera in talet utanf√∂r i varje term inuti parenteserna." : "Multiply the number outside into every term inside the parentheses.", 
                        latex: `${k1}(x + ${c1}) + ${k2}(x + ${c2}) \\\\ ${expanded}` 
                    },
                    { 
                        text: lang === 'sv' ? "Samla x-termer och siffertermer var f√∂r sig." : "Gather x-terms and constant terms separately.", 
                        latex: `${k1}x + ${k2}x = ${k1+k2}x, \\; ${k1*c1} + ${k2*c2} = ${k1*c1+k2*c2} \\\\ ${final}` 
                    },
                    { text: lang === 'sv' ? "Det f√∂renklade uttrycket √§r:" : "The simplified expression is:", latex: final }
                ],
                metadata: { variation_key: 'distribute_double', difficulty: 4 }
            };
        }

        const a = MathUtils.randomInt(2, 5), b = MathUtils.randomInt(2, 4), c = MathUtils.randomInt(2, 6), d = MathUtils.randomInt(2, 8);
        const final = `${a*b + d}x + ${a*c}`;
        return {
            renderData: { latex: `${a}(${b}x + ${c}) + ${d}x`, description: lang === 'sv' ? "Expandera parentesen och f√∂renkla." : "Expand the parentheses and simplify.", answerType: 'text' },
            token: this.toBase64(final.replace(/\s/g, "")),
            clues: [
                { 
                    text: lang === 'sv' ? `Anv√§nd distributiva lagen: Multiplicera in ${a} i parentesen.` : `Use the distributive law: Multiply ${a} into the parentheses.`, 
                    latex: `${a}(${b}x + ${c}) \\\\ ${a*b}x + ${a*c} \\\\ ${a*b}x + ${a*c} + ${d}x` 
                },
                { 
                    text: lang === 'sv' ? "Kombinera nu de termer som √§r av samma slag." : "Now combine the terms that are of the same kind.", 
                    latex: `${a*b}x + ${d}x = ${a*b+d}x \\\\ ${final}` 
                },
                { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: final }
            ],
            metadata: { variation_key: 'distribute_combine_std', difficulty: 3 }
        };
    }

    // --- LEVEL 4: Subtracting Parentheses ---
    private level4_SubtractParentheses(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sub_concept_plus_logic', 'sub_block_plus', 'sub_block_minus']);
        const startX = MathUtils.randomInt(8, 20), subX = MathUtils.randomInt(2, 6), subK = MathUtils.randomInt(2, 10);
        const inOp = (v === 'sub_block_minus') ? '-' : (v === 'sub_block_plus' ? '+' : Math.random() > 0.5 ? '+' : '-');
        const resOp = inOp === '+' ? '-' : '+';

        if (v === 'sub_concept_plus_logic') {
            const ans = lang === 'sv' ? "Alla tecken inuti parentesen √§ndras" : "All signs inside the parentheses change";
            return {
                renderData: {
                    description: lang === 'sv' ? "Vad h√§nder med tecknen inuti en parentes om det st√•r minus (-) framf√∂r?" : "What happens to signs inside parentheses if there is a minus (-) in front?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, lang === 'sv' ? "Inga tecken √§ndras" : "No signs change"])
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Minus framf√∂r en parentes betyder att vi subtraherar hela inneh√•llet. Det motsvarar att multiplicera med -1." : "Minus in front of a parenthesis means we subtract the whole content. It corresponds to multiplying by -1." },
                    { text: lang === 'sv' ? "Svaret √§r d√§rf√∂r:" : "The answer is therefore:", latex: `\\text{${ans}}` }
                ],
                metadata: { variation_key: 'sub_concept_plus_logic', difficulty: 2 }
            };
        }

        const final = `${startX - subX}x ${resOp} ${subK}`;
        return {
            renderData: { latex: `${startX}x - (${subX}x ${inOp} ${subK})`, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: this.toBase64(final.replace(/\s/g, "")),
            clues: [
                { 
                    text: lang === 'sv' ? `Ta bort parentesen och byt tecken p√• alla termer inuti: ${inOp} blir ${resOp}.` : `Remove the parentheses and flip the sign of all terms inside: ${inOp} becomes ${resOp}.`, 
                    latex: `${startX}x - (${subX}x ${inOp} ${subK}) \\\\ ${startX}x - ${subX}x ${resOp} ${subK}` 
                },
                { 
                    text: lang === 'sv' ? "Kombinera nu x-termerna f√∂r att slutf√∂ra f√∂renklingen." : "Now combine the x-terms to complete the simplification.", 
                    latex: `${startX}x - ${subX}x = ${startX - subX}x \\\\ ${final}` 
                },
                { text: lang === 'sv' ? "F√§rdigt uttryck:" : "Final expression:", latex: final }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }

    // --- LEVEL 5: Word Problems ---
    private level5_WordProblems(lang: string, variationKey?: string): any {
        const scenarios = ['word_candy', 'word_discount', 'word_combined_age_tri', 'word_rect_perimeter', 'word_passengers', 'word_savings', 'word_phone_battery', 'word_garden'];
        const v = variationKey || MathUtils.randomChoice(scenarios);
        const A = MathUtils.randomInt(2, 5), B = MathUtils.randomInt(10, 50), C = MathUtils.randomInt(2, 5);

        let desc = "", ans = "", steps = [];

        if (v === 'word_candy') {
            desc = lang === 'sv' ? `Du har ${A} p√•sar med x godisar. Du k√∂per ${C} likadana p√•sar till, men √§ter upp ${B} stycken. Skriv ett f√∂renklat uttryck.` : `You have ${A} bags with x candies. You buy ${C} more, but eat ${B}. Write a simplified expression.`;
            ans = `${A+C}x - ${B}`;
            steps = [
                { text: lang === 'sv' ? "St√§ll upp uttrycket baserat p√• texten." : "Set up the expression based on the text.", latex: `${A}x + ${C}x - ${B}` },
                { text: lang === 'sv' ? "Sl√• ihop p√•sarna (x-termerna)." : "Combine the bags (x-terms).", latex: `${A}x + ${C}x = ${A+C}x \\\\ ${ans}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: ans }
            ];
        } else if (v === 'word_combined_age_tri') {
            const diff = MathUtils.randomInt(2, 6);
            desc = lang === 'sv' ? `Elias √§r x √•r. Syster √§r ${diff} √•r √§ldre. Pappa √§r 3 g√•nger s√• gammal som Elias. Uttryck deras sammanlagda √•lder.` : `Elias is x. Sister is ${diff} years older. Father is 3x Elias's age. Express total age.`;
            ans = `5x + ${diff}`;
            steps = [
                { text: lang === 'sv' ? "Skapa uttryck f√∂r varje person: x, (x + ${diff}) och 3x." : "Create expressions for each person: x, (x + ${diff}), and 3x.", latex: `x + (x + ${diff}) + 3x` },
                { text: lang === 'sv' ? "Kombinera x-termerna: 1x + 1x + 3x = 5x." : "Combine the x-terms: 1x + 1x + 3x = 5x.", latex: `5x + ${diff}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: ans }
            ];
        } else {
            // Generic Fallback for other scenarios to ensure pedagogical consistency
            desc = lang === 'sv' ? `x passagerare p√• en buss. ${B} g√•r av, sedan stiger ${A}x p√•. Uttryck antalet passagerare nu.` : `x passengers. ${B} leave, then ${A}x board. Express the count.`;
            ans = `${A+1}x - ${B}`;
            steps = [
                { text: lang === 'sv' ? "Skriv uttrycket steg f√∂r steg: x - ${B} + ${A}x." : "Write the expression step by step: x - ${B} + ${A}x.", latex: `x - ${B} + ${A}x` },
                { text: lang === 'sv' ? "Samla variablerna f√∂r att f√∂renkla." : "Gather the variables to simplify.", latex: `x + ${A}x = ${A+1}x \\\\ ${ans}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: ans }
            ];
        }

        return {
            renderData: { latex: "", description: desc, answerType: 'text' },
            token: this.toBase64(ans.replace(/\s/g, "")),
            clues: steps,
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    private level6_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 5);
        const data = this.generate(lvl, lang);
        data.metadata.mixed = true;
        return data;
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\FractionArithGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionArithGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SameDenom(lang);
            case 2: return this.level2_DiffDenom(lang);
            case 3: return this.level3_MixedNumbers(lang);
            case 4: return this.level4_Multiplication(lang);
            case 5: return this.level5_Division(lang);
            default: return this.level1_SameDenom(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'add_concept':
            case 'add_missing':
            case 'add_calc':
                return this.level1_SameDenom(lang, key);
            case 'lcd_find':
            case 'add_error_spot':
            case 'add_diff_denom':
                return this.level2_DiffDenom(lang, key);
            case 'mixed_est':
            case 'mixed_add_same':
            case 'mixed_add_diff':
            case 'mixed_sub_same':
            case 'mixed_sub_diff':
                return this.level3_MixedNumbers(lang, key);
            case 'mult_scaling':
            case 'mult_area':
            case 'mult_calc':
                return this.level4_Multiplication(lang, key);
            case 'div_operator':
            case 'div_reciprocal':
            case 'div_calc':
                return this.level5_Division(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private simplify(n: number, d: number) {
        const common = MathUtils.gcd(n, d);
        return { n: n / common, d: d / common };
    }

    /**
     * Helper to calculate Least Common Multiple
     */
    private lcm(a: number, b: number): number {
        if (a === 0 || b === 0) return 0;
        return Math.abs(a * b) / MathUtils.gcd(a, b);
    }

    // --- LEVEL 1: SAME DENOMINATORS ---
    private level1_SameDenom(lang: string, variationKey?: string): any {
        const den = MathUtils.randomInt(5, 12);
        const n1 = MathUtils.randomInt(1, 3);
        const n2 = MathUtils.randomInt(1, 3);
        const sum = n1 + n2;
        const simp = this.simplify(sum, den);
        
        const tokenAnswer = `${simp.n}/${simp.d}`;
        const visualAnswer = `\\frac{${simp.n}}{${simp.d}}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna summan och svara i enklaste form." : "Calculate the sum and answer in simplest form.",
                latex: `\\frac{${n1}}{${den}} + \\frac{${n2}}{${den}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(tokenAnswer),
            clues: [
                { 
                    text: lang === 'sv' ? `Eftersom n√§mnarna √§r samma adderar vi bara t√§ljarna: ${n1} + ${n2}.` : `Since the denominators are the same, we just add the numerators: ${n1} + ${n2}.`, 
                    latex: `\\frac{${n1} + ${n2}}{${den}} = \\frac{${sum}}{${den}}` 
                },
                { 
                    text: lang === 'sv' ? "Svaret i enklaste form √§r:" : "The answer in simplest form is:", 
                    latex: visualAnswer 
                }
            ],
            metadata: { variation_key: 'add_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: DIFFERENT DENOMINATORS ---
    private level2_DiffDenom(lang: string, variationKey?: string): any {
        const d1 = MathUtils.randomInt(2, 4);
        const d2 = MathUtils.randomChoice([3, 5].filter(x => x !== d1));
        
        // Fixed: this.lcm is now defined above
        const lcd = this.lcm(d1, d2);
        const f1 = lcd / d1, f2 = lcd / d2;
        const sumN = f1 + f2;
        const simp = this.simplify(sumN, lcd);

        const tokenAnswer = `${simp.n}/${simp.d}`;
        const visualAnswer = `\\frac{${simp.n}}{${simp.d}}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna summan genom att hitta en gemensam n√§mnare." : "Calculate the sum by finding a common denominator.",
                latex: `\\frac{1}{${d1}} + \\frac{1}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(tokenAnswer),
            clues: [
                { 
                    text: lang === 'sv' ? `F√∂r att kunna addera br√•ken m√•ste de ha samma n√§mnare. Vi f√∂rl√§nger dem till ${lcd}.` : `To add the fractions, they must have the same denominator. We extend them to ${lcd}.`, 
                    latex: `\\frac{1 \\cdot ${f1}}{${d1} \\cdot ${f1}} + \\frac{1 \\cdot ${f2}}{${d2} \\cdot ${f2}} = \\frac{${f1}}{${lcd}} + \\frac{${f2}}{${lcd}}` 
                },
                { 
                    text: lang === 'sv' ? "Nu n√§r n√§mnarna √§r lika kan vi addera t√§ljarna." : "Now that the denominators are equal, we can add the numerators.", 
                    latex: `\\frac{${f1} + ${f2}}{${lcd}} = \\frac{${sumN}}{${lcd}}` 
                },
                { 
                    text: lang === 'sv' ? "Svaret i enklaste form √§r:" : "The answer in simplest form is:", 
                    latex: visualAnswer 
                }
            ],
            metadata: { variation_key: 'add_diff_denom', difficulty: 2 }
        };
    }

    // --- LEVEL 3: MIXED NUMBERS ---
    private level3_MixedNumbers(lang: string, variationKey?: string): any {
        const isSub = Math.random() > 0.5;
        const w1 = MathUtils.randomInt(3, 5), w2 = MathUtils.randomInt(1, 2);
        const d1 = 2, d2 = 3, lcd = 6;
        const n1 = 1, n2 = 1;

        const imp1N = w1 * d1 + n1, imp2N = w2 * d2 + n2;
        const ext1N = imp1N * 3, ext2N = imp2N * 2;
        const resN = isSub ? ext1N - ext2N : ext1N + ext2N;
        
        const finalW = Math.floor(resN / lcd);
        const finalN = resN % lcd;

        const tokenAnswer = finalN === 0 ? `${finalW}` : `${finalW} ${finalN}/${lcd}`;
        const visualAnswer = finalN === 0 ? `${finalW}` : `${finalW} \\frac{${finalN}}{${lcd}}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna och svara i blandad form." : "Calculate and answer in mixed form.",
                latex: `${w1}\\frac{${n1}}{${d1}} ${isSub ? '-' : '+'} ${w2}\\frac{${n2}}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(tokenAnswer),
            clues: [
                { 
                    text: lang === 'sv' ? "B√∂rja med att skriva om talen fr√•n blandad form till o√§kta br√•k." : "Start by rewriting the numbers from mixed form to improper fractions.", 
                    latex: `\\frac{${imp1N}}{${d1}} ${isSub ? '-' : '+'} \\frac{${imp2N}}{${d2}}` 
                },
                { 
                    text: lang === 'sv' ? `F√∂rl√§ng br√•ken s√• att de f√•r den gemensamma n√§mnaren ${lcd}.` : `Extend the fractions so they get the common denominator ${lcd}.`, 
                    latex: `\\frac{${ext1N}}{${lcd}} ${isSub ? '-' : '+'} \\frac{${ext2N}}{${lcd}} = \\frac{${resN}}{${lcd}}` 
                },
                { 
                    text: lang === 'sv' ? "Omvandla tillbaka till blandad form f√∂r det slutgiltiga svaret:" : "Convert back to mixed form for the final answer:", 
                    latex: visualAnswer 
                }
            ],
            metadata: { variation_key: 'mixed_calc', difficulty: 4 }
        };
    }

    // --- LEVEL 4: MULTIPLICATION ---
    private level4_Multiplication(lang: string, variationKey?: string): any {
        const n1 = MathUtils.randomInt(2, 4), d1 = MathUtils.randomInt(5, 7);
        const n2 = MathUtils.randomInt(1, 3), d2 = MathUtils.randomInt(4, 5);
        const simp = this.simplify(n1 * n2, d1 * d2);
        
        const tokenAnswer = `${simp.n}/${simp.d}`;
        const visualAnswer = `\\frac{${simp.n}}{${simp.d}}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Multiplicera br√•ken." : "Multiply the fractions.",
                latex: `\\frac{${n1}}{${d1}} \\cdot \\frac{${n2}}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(tokenAnswer),
            clues: [
                { 
                    text: lang === 'sv' ? "Vid multiplikation multiplicerar vi t√§ljarna f√∂r sig och n√§mnarna f√∂r sig." : "In multiplication, we multiply the numerators separately and the denominators separately.", 
                    latex: `\\frac{${n1} \\cdot ${n2}}{${d1} \\cdot ${d2}} = \\frac{${n1*n2}}{${d1*d2}}` 
                },
                { 
                    text: lang === 'sv' ? "Svaret i enklaste form √§r:" : "The answer in simplest form is:", 
                    latex: visualAnswer 
                }
            ],
            metadata: { variation_key: 'mult_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 5: DIVISION ---
    private level5_Division(lang: string, variationKey?: string): any {
        const d1 = MathUtils.randomInt(3, 6), d2 = MathUtils.randomInt(2, 5);
        const visualAnswer = `\\frac{${d2}}{${d1}}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna kvoten." : "Calculate the quotient.",
                latex: `\\frac{1}{${d1}} \\div \\frac{1}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${d2}/${d1}`),
            clues: [
                { 
                    text: lang === 'sv' ? "Division med ett br√•k √§r samma sak som multiplikation med det inverterade br√•ket (talet upp och ner)." : "Division by a fraction is the same as multiplication by the reciprocal (the number upside down).", 
                    latex: `\\frac{1}{${d1}} \\cdot \\frac{${d2}}{1}` 
                },
                { 
                    text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", 
                    latex: visualAnswer 
                }
            ],
            metadata: { variation_key: 'div_calc', difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\FractionArithGen.ts

// =======================================================
// FILE START: src\core\generators\FractionBasicsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionBasicsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_PartsOfQuantity(lang);
            case 3: return this.level3_MixedImproper(lang);
            case 4: return this.level4_SimplifyExtend(lang);
            case 5: return this.level5_Decimals(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'visual_lie':
            case 'visual_inverse':
            case 'visual_calc':
                return this.level1_Visuals(lang, key);
            case 'part_inverse':
            case 'part_compare':
            case 'part_calc':
                return this.level2_PartsOfQuantity(lang, key);
            case 'mixed_bounds':
            case 'mixed_missing':
            case 'mixed_convert_imp':
            case 'mixed_convert_mix':
                return this.level3_MixedImproper(lang, key);
            case 'simplify_missing':
            case 'simplify_concept':
            case 'simplify_calc':
                return this.level4_SimplifyExtend(lang, key);
            case 'decimal_inequality':
            case 'decimal_to_dec':
            case 'decimal_to_frac':
                return this.level5_Decimals(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return MathUtils.gcd(a, b);
    }

    // --- LEVEL 1: VISUAL CONCEPTS ---
    private level1_Visuals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['visual_lie', 'visual_inverse', 'visual_calc']);

        if (v === 'visual_lie') {
            const p = MathUtils.randomChoice([10, 20, 25, 40, 50, 60, 75, 80, 90]);
            const div = this.gcd(p, 100);
            const simpleN = p / div;
            const simpleD = 100 / div;

            const statementPercent = `${p}%`;
            const statementFraction = `${simpleN}/${simpleD}`;
            
            let statementFalse = "";
            if (p < 50) statementFalse = lang === 'sv' ? "Mer √§n h√§lften" : "More than half";
            else if (p === 50) statementFalse = lang === 'sv' ? "Mindre √§n 1/4" : "Less than 1/4";
            else statementFalse = lang === 'sv' ? "Mindre √§n h√§lften" : "Less than half";

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket p√•st√•ende om den f√§rgade andelen √§r FALSKT?" : "Which statement about the colored part is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([statementPercent, statementFraction, statementFalse]),
                    geometry: { type: 'percent_grid', total: 100, colored: p }
                },
                token: this.toBase64(statementFalse),
                clues: [
                    { text: lang === 'sv' ? `Det finns totalt 100 rutor och ${p} av dem √§r f√§rgade.` : `There are 100 squares total and ${p} of them are colored.`, latex: `\\frac{${p}}{100} = ${p}\\%` },
                    { text: lang === 'sv' ? "D√§rf√∂r √§r detta p√•st√•ende l√∂gnen:" : "Therefore, this statement is the lie:", latex: `\\text{${statementFalse}}` }
                ],
                metadata: { variation_key: 'visual_lie', difficulty: 1 }
            };
        }

        if (v === 'visual_inverse') {
            const fractionD = MathUtils.randomInt(3, 8);
            const countPerPart = MathUtils.randomInt(2, 6);
            const total = countPerPart * fractionD;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `Du har ${total} kulor. Om 1/${fractionD} √§r r√∂da, hur m√•nga √§r r√∂da?` : `You have ${total} marbles. If 1/${fractionD} are red, how many are red?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(countPerPart.toString()),
                clues: [
                    { text: lang === 'sv' ? `Att hitta 1/${fractionD} inneb√§r att du delar upp hela antalet i ${fractionD} lika stora delar.` : `Finding 1/${fractionD} means you divide the whole number into ${fractionD} equal parts.`, latex: `\\frac{${total}}{${fractionD}}` },
                    { text: lang === 'sv' ? "Antalet r√∂da kulor blir:" : "The number of red marbles is:", latex: `${countPerPart}` }
                ],
                metadata: { variation_key: 'visual_inverse', difficulty: 2 }
            };
        }

        const red = MathUtils.randomInt(1, 5), blue = MathUtils.randomInt(1, 5), green = MathUtils.randomInt(1, 5);
        const totalItems = red + blue + green;
        const target = MathUtils.randomChoice(['red', 'blue', 'green']);
        let count = (target === 'red') ? red : (target === 'blue' ? blue : green);
        let colorName = (target === 'red') ? (lang === 'sv' ? 'r√∂da' : 'red') : (target === 'blue' ? (lang === 'sv' ? 'bl√•a' : 'blue') : (lang === 'sv' ? 'gr√∂na' : 'green'));

        return {
            renderData: {
                description: lang === 'sv' ? `Hur stor andel av kulorna √§r ${colorName}?` : `What fraction of the marbles are ${colorName}?`,
                answerType: 'fraction',
                geometry: { type: 'probability_marbles', items: { red, blue, green } }
            },
            token: this.toBase64(`${count}/${totalItems}`),
            clues: [
                { text: lang === 'sv' ? "Ett br√•k best√•r av 'delen' dividerat med 'det hela'." : "A fraction consists of the 'part' divided by the 'whole'.", latex: `\\frac{\\text{${colorName}}}{\\text{totalt}}` },
                { text: lang === 'sv' ? `Vi har ${count} st ${colorName} kulor av totalt ${totalItems} st.` : `We have ${count} ${colorName} marbles out of ${totalItems} total.`, latex: `\\frac{${count}}{${totalItems}}` }
            ],
            metadata: { variation_key: 'visual_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: PARTS OF QUANTITY ---
    private level2_PartsOfQuantity(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['part_inverse', 'part_calc']);

        if (v === 'part_inverse') {
            const denom = MathUtils.randomChoice([4, 5, 8, 10]);
            const partValue = MathUtils.randomChoice([10, 20, 50]);
            const total = partValue * denom;

            return {
                renderData: {
                    description: lang === 'sv' ? `Om 1/${denom} av ett belopp √§r ${partValue} kr, vad √§r hela beloppet?` : `If 1/${denom} of an amount is ${partValue} kr, what is the whole amount?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { text: lang === 'sv' ? `Eftersom en del av ${denom} √§r v√§rd ${partValue} kr, multiplicerar vi delens v√§rde med antalet delar.` : `Since one part out of ${denom} is worth ${partValue} kr, we multiply the part's value by the number of parts.`, latex: `${partValue} \\cdot ${denom}` },
                    { text: lang === 'sv' ? "Det totala beloppet √§r:" : "The total amount is:", latex: `${total}` }
                ],
                metadata: { variation_key: 'part_inverse', difficulty: 2 }
            };
        }

        const denom = MathUtils.randomChoice([3, 4, 5, 10]);
        const mult = MathUtils.randomInt(2, 10);
        const total = denom * mult;

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna 1/${denom} av ${total}.` : `Calculate 1/${denom} of ${total}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(mult.toString()),
            clues: [
                { text: lang === 'sv' ? "F√∂r att hitta en del av ett tal dividerar vi talet med br√•kets n√§mnare." : "To find a part of a number, we divide the number by the fraction's denominator.", latex: `\\frac{${total}}{${denom}}` },
                { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: `${mult}` }
            ],
            metadata: { variation_key: 'part_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 3: MIXED & IMPROPER ---
    private level3_MixedImproper(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mixed_convert_imp', 'mixed_convert_mix']);
        const w = MathUtils.randomInt(1, 4), d = MathUtils.randomInt(3, 5), n = MathUtils.randomInt(1, d - 1);
        const imp = w * d + n;

        if (v === 'mixed_convert_imp') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv om fr√•n blandadform till br√•kform." : "Rewrite the mixed number as an improper fraction.",
                    latex: `${w}\\frac{${n}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${imp}/${d}`),
                clues: [
                    { text: lang === 'sv' ? `Multiplicera heltalet (${w}) med n√§mnaren (${d}) och l√§gg till t√§ljaren (${n}).` : `Multiply the whole number (${w}) by the denominator (${d}) and add the numerator (${n}).`, latex: `\\frac{(${w} \\cdot ${d}) + ${n}}{${d}}` },
                    { text: lang === 'sv' ? "I br√•kform blir det:" : "In fraction form, it is:", latex: `\\frac{${imp}}{${d}}` }
                ],
                metadata: { variation_key: 'mixed_convert_imp', difficulty: 2 }
            };
        } else {
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv om till blandad form." : "Rewrite in mixed form.",
                    latex: `\\frac{${imp}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${w} ${n}/${d}`),
                clues: [
                    { text: lang === 'sv' ? `Se hur m√•nga g√•nger ${d} f√•r plats i ${imp}. Resten blir den nya t√§ljaren.` : `See how many times ${d} fits into ${imp}. The remainder becomes the new numerator.`, latex: `${imp} / ${d} = ${w} \\text{ rest } ${n}` },
                    { text: lang === 'sv' ? "I blandad form blir det:" : "In mixed form, it is:", latex: `${w}\\frac{${n}}{${d}}` }
                ],
                metadata: { variation_key: 'mixed_convert_mix', difficulty: 2 }
            };
        }
    }

    // --- LEVEL 4: SIMPLIFY & EXTEND ---
    private level4_SimplifyExtend(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['simplify_missing', 'simplify_calc']);

        if (v === 'simplify_missing') {
            const baseN = 1, baseD = MathUtils.randomInt(2, 4), f = MathUtils.randomInt(2, 5);
            const targetD = baseD * f, targetN = baseN * f; 

            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket tal saknas f√∂r att br√•ken ska vara lika mycket v√§rda?" : "What number is missing for the fractions to be equal in value?",
                    latex: `\\frac{${baseN}}{${baseD}} = \\frac{?}{${targetD}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(targetN.toString()),
                clues: [
                    { text: lang === 'sv' ? `F√∂r att n√§mnaren ska bli ${targetD} har den multiplicerats med ${f}.` : `To make the denominator ${targetD}, it has been multiplied by ${f}.`, latex: `${baseD} \\cdot ${f} = ${targetD}` },
                    { text: lang === 'sv' ? "G√∂r exakt samma sak med t√§ljaren f√∂r att bevara br√•kets v√§rde." : "Do exactly the same to the numerator to preserve the fraction's value.", latex: `${baseN} \\cdot ${f} = ${targetN}` }
                ],
                metadata: { variation_key: 'simplify_missing', difficulty: 3 }
            };
        }

        const factor = MathUtils.randomInt(2, 4), sn = 1, sd = MathUtils.randomInt(2, 5);
        return {
            renderData: {
                description: lang === 'sv' ? "F√∂rkorta br√•ket s√• l√•ngt det g√•r." : "Simplify the fraction as much as possible.",
                latex: `\\frac{${sn * factor}}{${sd * factor}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${sn}/${sd}`),
            clues: [
                { text: lang === 'sv' ? `Hitta ett tal som b√•de t√§ljaren och n√§mnaren kan delas med. H√§r kan b√•da delas med ${factor}.` : `Find a number that both the numerator and the denominator can be divided by. Here, both can be divided by ${factor}.`, latex: `\\frac{${sn*factor} / ${factor}}{${sd*factor} / ${factor}}` },
                { text: lang === 'sv' ? "Svaret i enklaste form √§r:" : "The answer in simplest form is:", latex: `\\frac{${sn}}{${sd}}` }
            ],
            metadata: { variation_key: 'simplify_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 5: DECIMALS ---
    private level5_Decimals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['decimal_to_dec', 'decimal_to_frac']);
        const pairs = [{ f: "1/2", d: 0.5 }, { f: "1/4", d: 0.25 }, { f: "1/5", d: 0.2 }, { f: "1/10", d: 0.1 }];
        const pair = MathUtils.randomChoice(pairs);
        const isToDec = v === 'decimal_to_dec';

        return {
            renderData: {
                description: lang === 'sv' ? (isToDec ? "Skriv br√•ket som ett decimaltal." : "Skriv decimaltalet som ett br√•k.") : (isToDec ? "Write the fraction as a decimal." : "Write the decimal as a fraction."),
                latex: isToDec ? pair.f : pair.d.toString().replace('.', ','),
                answerType: isToDec ? 'numeric' : 'fraction'
            },
            token: this.toBase64(isToDec ? pair.d.toString() : pair.f),
            clues: [
                { text: lang === 'sv' ? "Br√•kstrecket betyder division. R√§kna ut t√§ljaren dividerat med n√§mnaren." : "The fraction bar means division. Calculate the numerator divided by the denominator.", latex: isToDec ? `1 / ${pair.f.split('/')[1]} = ${pair.d}` : `\\frac{${pair.d * 10}}{10} = ${pair.f}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: isToDec ? `${pair.d}` : `\\frac{${pair.f.split('/')[0]}}{${pair.f.split('/')[1]}}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\FractionBasicsGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class GeometryGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_PerimeterBasic(lang);
            case 2: return this.level2_AreaBasic(lang);
            case 3: return this.level3_Triangles(lang);
            case 4: return this.level4_CombinedFigures(lang);
            case 5: return this.level5_Circles(lang);
            case 6: return this.level6_CompositeAdvanced(lang);
            default: return this.level1_PerimeterBasic(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'perimeter_square':
            case 'perimeter_rect':
            case 'perimeter_parallel':
            case 'perimeter_inverse':
            case 'perimeter_lie':
                return this.level1_PerimeterBasic(lang, key);
            
            case 'area_square':
            case 'area_rect':
            case 'area_parallel':
            case 'area_inverse':
            case 'area_trap':
                return this.level2_AreaBasic(lang, key);
            
            case 'area_triangle':
            case 'inverse_triangle':
            case 'perimeter_triangle_right':
            case 'perimeter_triangle_iso':
            case 'perimeter_triangle_scalene':
                return this.level3_Triangles(lang, key);
            
            case 'combined_rect_tri':
            case 'combined_l_shape':
            case 'combined_house':
                return this.level4_CombinedFigures(lang, key);
            
            case 'circle_area':
            case 'circle_perimeter':
            case 'semicircle_area':
            case 'semicircle_perimeter':
            case 'area_quarter':
            case 'perimeter_quarter':
                return this.level5_Circles(lang, key);
            
            case 'perimeter_house':
            case 'perimeter_portal':
            case 'area_house':
            case 'area_portal':
                return this.level6_CompositeAdvanced(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: PERIMETER BASIC ---
    private level1_PerimeterBasic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['perimeter_square', 'perimeter_rect', 'perimeter_parallel', 'perimeter_inverse', 'perimeter_lie']);
        
        if (v === 'perimeter_square') {
            const s = MathUtils.randomInt(3, 15);
            const ans = 4 * s;
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' ? `En kvadrat har en sida som √§r ${s} cm l√•ng. Ber√§kna kvadratens omkrets.` : `A square has a side that is ${s} cm long. Calculate the perimeter of the square.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Omkretsen √§r summan av figurens alla yttersidor. En kvadrat har fyra sidor som alla √§r lika l√•nga." : "The perimeter is the sum of all the figure's outer sides. A square has four sides that are all the same length.", latex: `O = 4 \\cdot ${s}` },
                    { text: lang === 'sv' ? "Omkretsen blir:" : "The total perimeter is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'perimeter_square', difficulty: 1 }
            };
        }

        if (v === 'perimeter_rect') {
            const b = MathUtils.randomInt(5, 15), h = MathUtils.randomInt(3, 10);
            const ans = 2 * (b + h);
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: b, height: h, labels: { b: b, h: h } },
                    description: lang === 'sv' ? `En rektangel har basen ${b} cm och h√∂jden ${h} cm. Vad √§r rektangelns omkrets?` : `A rectangle has a base of ${b} cm and a height of ${h} cm. What is the perimeter of the rectangle?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Omkretsen √§r v√§gen runt hela figuren. En rektangel best√•r av tv√• baser och tv√• h√∂jder." : "Perimeter is the path around the entire figure. A rectangle consists of two bases and two heights.", latex: `O = ${b} + ${h} + ${b} + ${h}` },
                    { text: lang === 'sv' ? "Summan av alla sidor √§r:" : "The sum of all sides is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'perimeter_rect', difficulty: 1 }
            };
        }

        if (v === 'perimeter_inverse') {
            const w = MathUtils.randomInt(4, 10), h = MathUtils.randomInt(3, 8);
            const perim = 2 * (w + h);
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: w, height: h, labels: { b: w, h: '?' } },
                    description: lang === 'sv' ? `En rektangel har omkretsen ${perim} cm. Vi vet att basen √§r ${w} cm. Hur l√•ng √§r h√∂jden?` : `A rectangle has a perimeter of ${perim} cm. We know the base is ${w} cm. What is the height?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "B√∂rja med att dra bort de tv√• k√§nda baserna fr√•n den totala omkretsen." : "Step 1: Subtract the two known bases from the total perimeter.", latex: `${perim} - (2 \\cdot ${w}) = ${perim - 2*w}` },
                    { text: lang === 'sv' ? "Dela det som √§r kvar med 2 f√∂r att f√• fram h√∂jden p√• en av sidorna." : "Step 2: Divide what remains by 2 to find the height of one of the sides.", latex: `\\frac{${perim - 2*w}}{2} = ${h}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${h}` }
                ],
                metadata: { variation_key: 'perimeter_inverse', difficulty: 2 }
            };
        }

        if (v === 'perimeter_lie') {
            const s = MathUtils.randomInt(4, 10);
            const p = 4 * s;
            const sTrue1 = lang === 'sv' ? `Omkretsen √§r ${p} cm` : `The perimeter is ${p} cm`;
            const sTrue2 = lang === 'sv' ? `Sidan √§r ${s} cm` : `The side is ${s} cm`;
            const fakeP = p + MathUtils.randomChoice([-2, 2, 5]);
            const sFalse = lang === 'sv' ? `Omkretsen √§r ${fakeP} cm` : `The perimeter is ${fakeP} cm`;
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' ? "Titta p√• kvadraten nedan. Vilket av p√•st√•endena √§r FALSKT?" : "Look at the square below. Which of the statements is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse])
                },
                token: this.toBase64(sFalse),
                clues: [
                    { text: lang === 'sv' ? `Ber√§kna kvadratens omkrets genom att multiplicera sidan (${s}) med 4.` : `Calculate the square's perimeter by multiplying the side (${s}) by 4.`, latex: `4 \\cdot ${s} = ${p}` },
                    { text: lang === 'sv' ? "Den felaktiga utr√§kningen i listan √§r:" : "The incorrect calculation in the list is:", latex: `\\text{${sFalse}}` }
                ],
                metadata: { variation_key: 'perimeter_lie', difficulty: 1 }
            };
        }

        const b = MathUtils.randomInt(6, 12), s = MathUtils.randomInt(4, 9);
        const ans = 2 * (b + s);
        return {
            renderData: {
                geometry: { type: 'parallelogram', width: b, height: s-1, labels: { b: b, s: s } },
                description: lang === 'sv' ? `En parallellogram har sidorna ${b} cm och ${s} cm. Ber√§kna omkretsen.` : `A parallelogram has sides of ${b} cm and ${s} cm. Calculate its perimeter.`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Precis som en rektangel har en parallellogram tv√• par av lika l√•nga sidor. Addera alla sidor." : "Just like a rectangle, a parallelogram has two pairs of equal sides. Add all the sides together.", latex: `O = 2 \\cdot (${b} + ${s})` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'perimeter_parallel', difficulty: 1 }
        };
    }

    // --- LEVEL 2: AREA BASIC ---
    private level2_AreaBasic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['area_square', 'area_rect', 'area_parallel', 'area_inverse', 'area_trap']);

        if (v === 'area_square') {
            const s = MathUtils.randomInt(3, 12);
            const ans = s * s;
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' ? `En kvadrat har sidan ${s} cm. Ber√§kna kvadratens area.` : `A square has a side of ${s} cm. Calculate the area of the square.`,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Arean f√∂r en kvadrat ber√§knas genom att multiplicera sidan med sig sj√§lv." : "The area of a square is calculated by multiplying the side by itself.", latex: `A = ${s} \\cdot ${s}` },
                    { text: lang === 'sv' ? "Arean blir:" : "The area becomes:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'area_square', difficulty: 1 }
            };
        }

        if (v === 'area_inverse') {
            const b = MathUtils.randomInt(4, 10), h = MathUtils.randomInt(3, 8);
            const area = b * h;
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: b, height: h, labels: { b: b, h: '?' } },
                    description: lang === 'sv' ? `Rektangelns area √§r ${area} cm¬≤. Vi vet att basen √§r ${b} cm. Vad √§r rektangelns h√∂jd?` : `The area of the rectangle is ${area} cm¬≤. We know the base is ${b} cm. What is the height?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "Formeln f√∂r area √§r Bas ‚Ä¢ H√∂jd. F√∂r att hitta h√∂jden delar vi arean med basen." : "The formula for area is Base ‚Ä¢ Height. To find the height, we divide the area by the base.", latex: `h = \\frac{${area}}{${b}}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${h}` }
                ],
                metadata: { variation_key: 'area_inverse', difficulty: 2 }
            };
        }

        if (v === 'area_trap') {
            const b = MathUtils.randomInt(5, 12), h = MathUtils.randomInt(4, 9), s = h + 2;
            const ans = b * h;
            return {
                renderData: {
                    geometry: { type: 'parallelogram', width: b, height: h, labels: { b: b, h: h, s: s } },
                    description: lang === 'sv' ? "Ber√§kna parallellogrammens area." : "Calculate the area of the parallelogram.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Vid ber√§kning av area f√∂r en parallellogram anv√§nder du alltid den vinkelr√§ta h√∂jden, inte den sneda sidan." : "When calculating the area of a parallelogram, you always use the perpendicular height, not the slanted side.", latex: `A = ${b} \\cdot ${h}` },
                    { text: lang === 'sv' ? "Arean √§r:" : "The area is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'area_trap', difficulty: 2 }
            };
        }

        const b = MathUtils.randomInt(5, 12), h = MathUtils.randomInt(3, 9);
        const ans = b * h;
        const type = v === 'area_rect' ? 'rectangle' : 'parallelogram';
        return {
            renderData: {
                geometry: { type: type, width: b, height: h, labels: { b: b, h: h } },
                description: lang === 'sv' ? `Ber√§kna arean av figuren nedan.` : `Calculate the area of the figure below.`,
                answerType: 'numeric', suffix: 'cm¬≤'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Arean ber√§knas genom att multiplicera basen med den vinkelr√§ta h√∂jden." : "The area is calculated by multiplying the base by the perpendicular height.", latex: `A = ${b} \\cdot ${h}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 1 }
        };
    }

    // --- LEVEL 3: TRIANGLES ---
    private level3_Triangles(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['area_triangle', 'inverse_triangle', 'perimeter_triangle_right', 'perimeter_triangle_iso', 'perimeter_triangle_scalene']);

        if (v === 'area_triangle') {
            const b = MathUtils.randomInt(4, 12), h = MathUtils.randomInt(3, 10);
            const ans = (b * h) / 2;
            return {
                renderData: {
                    geometry: { type: 'triangle', width: b, height: h, labels: { b: b, h: h } },
                    description: lang === 'sv' ? `En triangel har basen ${b} cm och h√∂jden ${h} cm. Ber√§kna triangelns area.` : `A triangle has a base of ${b} cm and a height of ${h} cm. Calculate the area of the triangle.`,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "En triangel motsvarar halva ytan av en rektangel med samma bas och h√∂jd." : "A triangle corresponds to half the area of a rectangle with the same base and height.", latex: `A = \\frac{${b} \\cdot ${h}}{2}` },
                    { text: lang === 'sv' ? "Arean blir d√§rf√∂r:" : "The area is therefore:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'area_triangle', difficulty: 2 }
            };
        }

        if (v === 'inverse_triangle') {
            const h = MathUtils.randomInt(4, 10), b = MathUtils.randomInt(4, 10);
            const area = (b * h) / 2;
            return {
                renderData: {
                    geometry: { type: 'triangle', width: b, height: h, labels: { b: b, h: '?' } },
                    description: lang === 'sv' ? `Triangelns area √§r ${area} cm¬≤. Vi vet att basen √§r ${b} cm. Vad √§r h√∂jden?` : `The triangle's area is ${area} cm¬≤. We know the base is ${b} cm. What is the height?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "Eftersom arean √§r h√§lften av basen g√•nger h√∂jden, b√∂rjar vi med att dubbla arean." : "Since the area is half of the base times the height, we start by doubling the area.", latex: `2 \\cdot ${area} = ${b} \\cdot h` },
                    { text: lang === 'sv' ? "Dela nu det resultatet med basen f√∂r att f√• h√∂jden." : "Now divide that result by the base to find the height.", latex: `h = \\frac{${area * 2}}{${b}}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${h}` }
                ],
                metadata: { variation_key: 'inverse_triangle', difficulty: 3 }
            };
        }

        // Perimeter Variations - Randomizing values for Right, Iso, Scalene
        const type = v.replace('perimeter_triangle_', '');
        let b = 0, h = 0, s1 = 0, s2 = 0;
        
        if (type === 'right') { 
            // Use Pythagorean triples (3,4,5), (5,12,13), (8,15,17)
            const triple = MathUtils.randomChoice([[3,4,5], [6,8,10], [5,12,13]]);
            b = triple[0]; s1 = triple[1]; s2 = triple[2]; h = s1;
        } else if (type === 'iso') { 
            s1 = MathUtils.randomInt(5, 12); s2 = s1; b = MathUtils.randomInt(4, s1 + s2 - 2); 
        } else { 
            b = MathUtils.randomInt(6, 10); s1 = MathUtils.randomInt(4, 8); s2 = MathUtils.randomInt(5, 9);
        }

        const ans = b + s1 + s2;

        return {
            renderData: {
                geometry: { 
                    type: 'triangle', 
                    subtype: type === 'right' ? 'right' : undefined, 
                    width: b, 
                    height: 8, // visual scaling
                    labels: { b: b, s1: s1, s2: s2 } 
                },
                description: lang === 'sv' ? "Ber√§kna triangelns omkrets genom att addera alla sidor." : "Calculate the triangle's perimeter by adding all sides.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Omkretsen √§r den totala l√§ngden runt figurens ytterkant. Addera de tre sidorna." : "The perimeter is the total length around the outer edge of the figure. Add the three sides.", latex: `O = ${b} + ${s1} + ${s2}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 4: COMBINED FIGURES ---
    private level4_CombinedFigures(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['combined_rect_tri', 'combined_l_shape', 'combined_house']);

        if (v === 'combined_rect_tri') {
            const rw = MathUtils.randomInt(5, 10), rh = MathUtils.randomInt(4, 6), tb = MathUtils.randomInt(3, 5);
            const ans = (rw * rh + (tb * rh) / 2);
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'rect_right_tri', labels: { w: rw, h: rh, tri_b: tb } },
                    description: lang === 'sv' ? "Figuren best√•r av en rektangel och en triangel. Ber√§kna arean till figuren." : "The figure consists of a rectangle and a triangle. Calculate the total area.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Dela upp figuren i tv√• k√§nda former: en rektangel och en triangel." : "Split the figure into two known shapes: a rectangle and a triangle.", latex: "" },
                    { text: lang === 'sv' ? `Rektangel: ${rw} ‚Ä¢ ${rh}. Triangel: (${tb} ‚Ä¢ ${rh}) / 2.` : `Rectangle area: ${rw} ‚Ä¢ ${rh}. Triangle area: (${tb} ‚Ä¢ ${rh}) / 2.`, latex: `(${rw} \\cdot ${rh}) + \\frac{${tb} \\cdot ${rh}}{2} = ${ans}` },
                    { text: lang === 'sv' ? "Totalarean √§r:" : "The total area is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'combined_rect_tri', difficulty: 3 }
            };
        }

        if (v === 'combined_l_shape') {
            const vW = MathUtils.randomInt(2, 4), vH = MathUtils.randomInt(6, 9), hW = MathUtils.randomInt(4, 6), hH = MathUtils.randomInt(2, 4);
            const ans = vW * vH + hW * hH;
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'l_shape', labels: { vW, vH, hW, hH, totalW: vW + hW } },
                    description: lang === 'sv' ? "Ber√§kna arean av den L-formade figuren genom att dela upp den i tv√• rektanglar." : "Calculate the area of the L-shaped figure by splitting it into two rectangles.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Du kan dela figuren antingen vertikalt eller horisontellt f√∂r att f√• tv√• rektanglar." : "You can split the figure either vertically or horizontally to get two rectangles.", latex: `(${vW} \\cdot ${vH}) + (${hW} \\cdot ${hH})` },
                    { text: lang === 'sv' ? "Slutsvaret blir:" : "The final answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'combined_l_shape', difficulty: 3 }
            };
        }

        const s = MathUtils.randomInt(5, 8), ht = MathUtils.randomInt(3, 5);
        const ans = s * s + (s * ht) / 2;
        return {
            renderData: {
                geometry: { type: 'composite', subtype: 'house_area', labels: { s: s, h_tri: ht } },
                description: lang === 'sv' ? "Figuren best√•r av en kvadrat och en triangel. Vad √§r arean till figuren?" : "The figure consists of a square and a triangle. What is the total area?",
                answerType: 'numeric', suffix: 'cm¬≤'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Ber√§kna kvadratens yta f√∂rst och l√§gg sedan till triangelns yta." : "Calculate the square's surface first and then add the triangle's surface.", latex: `(${s} \\cdot ${s}) + \\frac{${s} \\cdot ${ht}}{2}` },
                { text: lang === 'sv' ? "Resultatet √§r:" : "The result is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'combined_house', difficulty: 3 }
        };
    }

    // --- LEVEL 5: CIRCLES ---
    private level5_Circles(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['circle_area', 'circle_perimeter', 'semicircle_area', 'semicircle_perimeter', 'area_quarter', 'perimeter_quarter']);
        const r = MathUtils.randomInt(4, 10);
        const pi = 3.14;

        if (v === 'circle_area' || v === 'circle_perimeter') {
            const isArea = v === 'circle_area';
            const ansVal = isArea ? pi * r * r : 2 * pi * r;
            const ans = (Math.round(ansVal * 100) / 100).toString();
            return {
                renderData: {
                    geometry: { type: 'circle', radius: r, labels: isArea ? { r: r } : { diameter: 2 * r }, show: isArea ? 'radius' : 'diameter' },
                    description: lang === 'sv' ? (isArea ? `Ber√§kna cirkelns area ($\pi \approx 3,14$).` : `Ber√§kna cirkelns omkrets ($\pi \approx 3,14$).`) : (isArea ? `Calculate the area of the circle ($\pi \approx 3.14$).` : `Calculate the perimeter of the circle ($\pi \approx 3.14$).`),
                    answerType: 'numeric'
                },
                token: this.toBase64(ans),
                clues: [
                    { text: isArea ? (lang === 'sv' ? "Formeln f√∂r cirkelns area √§r pi g√•nger radien i kvadrat." : "The formula for the area of a circle is pi times the radius squared.") : (lang === 'sv' ? "Formeln f√∂r cirkelns omkrets √§r pi g√•nger diametern." : "The formula for the perimeter of a circle is pi times the diameter."), latex: isArea ? `A = 3,14 \\cdot ${r}^2` : `O = 3,14 \\cdot ${2 * r}` },
                    { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: v, difficulty: 2 }
            };
        }

        if (v === 'semicircle_area' || v === 'semicircle_perimeter') {
            const isArea = v === 'semicircle_area';
            const ansVal = isArea ? (pi * r * r) / 2 : (pi * 2 * r) / 2 + (2 * r);
            const ans = (Math.round(ansVal * 100) / 100).toString();
            return {
                renderData: {
                    geometry: { type: 'semicircle', radius: r, labels: { r: r, diameter: 2*r }, show: isArea ? 'radius' : 'diameter' },
                    description: lang === 'sv' ? (isArea ? "Ber√§kna arean av halvcirkeln." : "Ber√§kna omkretsen runt hela halvcirkeln (b√•gen + basen).") : (isArea ? "Calculate the area of the semicircle." : "Calculate the perimeter around the whole semicircle (arc + base)."),
                    answerType: 'numeric'
                },
                token: this.toBase64(ans),
                clues: [
                    { text: isArea ? (lang === 'sv' ? "R√§kna ut en hel cirkels area och dela den sedan med 2." : "Calculate a full circle's area and then divide it by 2.") : (lang === 'sv' ? "Ber√§kna halva omkretsen f√∂r b√•gen och l√§gg till den raka diametern." : "Calculate half the circumference for the arc and add the straight diameter."), latex: isArea ? `\\frac{3,14 \\cdot ${r}^2}{2}` : `\\frac{3,14 \\cdot ${2 * r}}{2} + ${2 * r}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: v, difficulty: 3 }
            };
        }

        const isArea = v === 'area_quarter';
        const ansVal = isArea ? (pi * r * r) / 4 : (pi * 2 * r) / 4 + (2 * r);
        const ans = (Math.round(ansVal * 100) / 100).toString();
        return {
            renderData: {
                geometry: { type: 'quarter_circle', radius: r, labels: { r: r } },
                description: lang === 'sv' ? (isArea ? "Ber√§kna arean av kvartscirkeln." : "Ber√§kna kvartscirkelns omkrets (b√•gen + de tv√• radierna).") : (isArea ? "Calculate the area of the quarter circle." : "Calculate the quarter circle's perimeter (arc + the two radii)."),
                answerType: 'numeric'
            },
            token: this.toBase64(ans),
            clues: [
                { text: isArea ? (lang === 'sv' ? "R√§kna ut arean f√∂r en hel cirkel och dela med 4." : "Calculate the area for a full circle and divide by 4.") : (lang === 'sv' ? "Ber√§kna en fj√§rdedel av omkretsen f√∂r b√•gen och l√§gg till de tv√• raka radierna." : "Calculate one-fourth of the circumference for the arc and add the two straight radii."), latex: isArea ? `\\frac{3,14 \\cdot ${r}^2}{4}` : `\\frac{2 \\cdot 3,14 \\cdot ${r}}{4} + ${r} + ${r}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 6: COMPOSITE ADVANCED ---
    private level6_CompositeAdvanced(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['perimeter_house', 'perimeter_portal', 'area_house', 'area_portal']);
        const w = MathUtils.randomInt(40, 70), h = MathUtils.randomInt(30, 50);

        if (v === 'area_house') {
            const hr = MathUtils.randomInt(20, 40); 
            const areaSquare = w * h;
            const areaRoof = (w * hr) / 2;
            const total = areaSquare + areaRoof;
            
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'house', labels: { w, h, h_roof: hr } },
                    description: lang === 'sv' ? "Ber√§kna husets area (inklusiv taket)." : "Calculate the total area of the house (square + roof).",
                    answerType: 'numeric', suffix: 'cm¬≤' 
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { text: lang === 'sv' ? "Dela upp figuren i en rektangel och en triangel." : "Split the figure into a rectangle and a triangle.", latex: "" },
                    { text: lang === 'sv' ? `Rektangel: ${w} ‚Ä¢ ${h}. Tak (triangel): (${w} ‚Ä¢ ${hr}) / 2.` : `Rectangle: ${w} ‚Ä¢ ${h}. Roof (triangle): (${w} ‚Ä¢ ${hr}) / 2.`, latex: `${areaSquare} + ${areaRoof} = ${total}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${total}` }
                ],
                metadata: { variation_key: 'area_house', difficulty: 4 }
            };
        }

        if (v === 'area_portal') {
            const r = w / 2;
            const areaRect = w * h;
            const areaSemi = (3.14 * r * r) / 2;
            const total = Math.round((areaRect + areaSemi) * 10) / 10;

            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'portal', labels: { w, h } },
                    description: lang === 'sv' ? "Ber√§kna area till figuren." : "Calculate the total area of the portal (rectangle + semicircle).",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { text: lang === 'sv' ? "Ber√§kna rektangelns area och halvcirkelns area var f√∂r sig." : "Calculate the rectangle's area and the semicircle's area separately.", latex: "" },
                    { text: lang === 'sv' ? `Rektangel: ${w} ‚Ä¢ ${h}. Halvcirkel: (3,14 ‚Ä¢ ${r}¬≤) / 2.` : `Rectangle: ${w} ‚Ä¢ ${h}. Semicircle: (3.14 ‚Ä¢ ${r}¬≤) / 2.`, latex: `${areaRect} + ${Math.round(areaSemi * 10) / 10} = ${total}` },
                    { text: lang === 'sv' ? "Totalarean blir:" : "The total area is:", latex: `${total}` }
                ],
                metadata: { variation_key: 'area_portal', difficulty: 4 }
            };
        }

        if (v === 'perimeter_house') {
            const hr = MathUtils.randomInt(20, 35);
            const slope = Math.sqrt((w/2)**2 + hr**2);
            const ans = Math.round((w + 2*h + 2*slope) * 10) / 10;
            return {
                renderData: {
                    geometry: { type: 'composite', subtype: 'house', labels: { w, h, h_roof: hr } },
                    description: lang === 'sv' ? "Ber√§kna omkretsen runt husets ytterkant (inklusive taket)." : "Calculate the total perimeter around the outer edge of the house (including the roof).",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Identifiera alla ytterv√§ggar. Botten (${w}) och tv√• sidov√§ggar (${h} var).` : `Identify all outer walls. The bottom (${w}) and two side walls (${h} each).`, latex: "" },
                    { text: lang === 'sv' ? `Anv√§nd Pythagoras f√∂r att r√§kna ut takets sneda sidor (ca ${Math.round(slope*10)/10} var). Addera sedan allt.` : `Use Pythagoras to calculate the slanted sides of the roof (approx ${Math.round(slope*10)/10} each). Then add everything.`, latex: `${w} + ${h} + ${h} + ${Math.round(slope*10)/10} + ${Math.round(slope*10)/10}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'perimeter_house', difficulty: 4 }
            };
        }

        const r = w / 2;
        const arc = 3.14 * r;
        const ans = Math.round((w + 2*h + arc) * 10) / 10;
        return {
            renderData: {
                geometry: { type: 'composite', subtype: 'portal', labels: { w, h } },
                description: lang === 'sv' ? "Ber√§kna omkretsen runt hela portalen." : "Calculate the perimeter around the whole portal.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "B√•gen √§r en halvcirkel. R√§kna ut dess l√§ngd (pi ‚Ä¢ diametern / 2)." : "The arch is a semicircle. Calculate its length (pi ‚Ä¢ diameter / 2).", latex: `\\frac{3,14 \\cdot ${w}}{2} = ${Math.round(arc*10)/10}` },
                { text: lang === 'sv' ? "L√§gg sedan till de raka sidorna: botten och de tv√• vertikala v√§ggarna." : "Then add the straight sides: the bottom and the two vertical walls.", latex: `${Math.round(arc*10)/10} + ${w} + ${h} + ${h} = ${ans}` },
                { text: lang === 'sv' ? "Slutresultatet √§r:" : "The final result is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'perimeter_portal', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';
import { LinearEquationProblemGen } from './LinearEquationProblemGen.js';

export class LinearEquationGen {
    private problemGen: LinearEquationProblemGen;

    constructor() {
        this.problemGen = new LinearEquationProblemGen();
    }

    public generate(level: number, lang: string = 'sv'): any {
        if (level === 5 || level === 6) {
            return this.problemGen.generate(level, lang);
        }
        if (level === 7) {
            return this.level7_Mixed(lang);
        }

        switch (level) {
            case 1: return this.level1_OneStep(lang);
            case 2: return this.level2_TwoStep(lang);
            case 3: return this.level3_Parentheses(lang);
            case 4: return this.level4_BothSides(lang);
            default: return this.level1_OneStep(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        const wordProblemKeys = [
            'rate_fixed_add_write', 'rate_fixed_add_solve',
            'rate_fixed_sub_write', 'rate_fixed_sub_solve',
            'compare_word_sum_write', 'compare_word_sum_solve',
            'compare_word_diff_write', 'compare_word_diff_solve'
        ];

        if (wordProblemKeys.includes(key)) {
            const level = key.endsWith('_write') ? 5 : 6;
            return this.problemGen.generate(level, lang);
        }

        switch (key) {
            case 'onestep_concept_inverse':
            case 'onestep_spot_lie':
            case 'onestep_calc':
                return this.level1_OneStep(lang, key);
            case 'twostep_concept_order':
            case 'twostep_calc':
                return this.level2_TwoStep(lang, key);
            case 'paren_lie_distribution':
            case 'paren_calc':
                return this.level3_Parentheses(lang, key);
            case 'bothsides_concept_strategy':
            case 'bothsides_calc':
                return this.level4_BothSides(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: One-Step Equations ---
    private level1_OneStep(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['onestep_concept_inverse', 'onestep_spot_lie', 'onestep_calc']);

        if (v === 'onestep_concept_inverse') {
            const type = MathUtils.randomInt(1, 4);
            const val1 = MathUtils.randomInt(2, 12);
            const val2 = MathUtils.randomInt(2, 12);
            let q = "", correctOp = "", clueText = "", latexStep = "", ansVal = "";

            const ops = lang === 'sv' 
                ? ["Addition (+)", "Subtraktion (-)", "Multiplikation (¬∑)", "Division (/)"] 
                : ["Addition (+)", "Subtraction (-)", "Multiplication (¬∑)", "Division (/)"];

            if (type === 1) {
                q = `x + ${val1} = ${val1 + val2}`;
                ansVal = (lang === 'sv' ? "Subtraktion (-)" : "Subtraction (-)");
                clueText = lang === 'sv' ? `F√∂r att nollst√§lla $+${val1}$ anv√§nder vi den motsatta r√§kneoperationen.` : `To cancel out $+${val1}$, we use the opposite mathematical operation.`;
                latexStep = `${val1 + val2} - ${val1} = ${val2}`;
            } else if (type === 2) {
                q = `x - ${val1} = ${val2}`;
                ansVal = (lang === 'sv' ? "Addition (+)" : "Addition (+)");
                clueText = lang === 'sv' ? `Motsatsen till subtraktion √§r addition. Vi l√§gger till samma v√§rde p√• b√•da sidor.` : `The opposite of subtraction is addition. We add the same value to both sides.`;
                latexStep = `${val2} + ${val1} = ${val1 + val2}`;
            } else if (type === 3) {
                q = `${val1}x = ${val1 * val2}`;
                ansVal = (lang === 'sv' ? "Division (/)" : "Division (/)");
                clueText = lang === 'sv' ? `Eftersom x √§r multiplicerat med ${val1}, m√•ste vi dela (dividera) f√∂r att f√• x ensamt.` : `Since x is multiplied by ${val1}, we must divide to get x alone.`;
                latexStep = `\\frac{${val1 * val2}}{${val1}} = ${val2}`;
            } else {
                q = `\\frac{x}{${val1}} = ${val2}`;
                ansVal = (lang === 'sv' ? "Multiplikation (¬∑)" : "Multiplication (¬∑)");
                clueText = lang === 'sv' ? `Motsatsen till division √§r multiplikation. Multiplicera b√•da sidor med n√§mnaren.` : `The opposite of division is multiplication. Multiply both sides by the denominator.`;
                latexStep = `${val2} \\cdot ${val1} = ${val1 * val2}`;
            }

            return {
                renderData: {
                    description: lang === 'sv' ? `Vilken operation isolerar x i $${q}$?` : `Which operation isolates x in $${q}$?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(ops)
                },
                token: this.toBase64(ansVal),
                clues: [
                    { text: clueText, latex: latexStep },
                    { text: lang === 'sv' ? "R√§tt operation √§r:" : "The correct operation is:", latex: `\\text{${ansVal}}` }
                ],
                metadata: { variation_key: 'onestep_concept_inverse', difficulty: 1 }
            };
        }

        if (v === 'onestep_spot_lie') {
            const targetX = MathUtils.randomInt(2, 10);
            const a = MathUtils.randomInt(2, 6);
            const b = MathUtils.randomInt(2, 15);
            const sTrue1 = `${a}x = ${a * targetX}`;
            const sTrue2 = `x + ${b} = ${targetX + b}`;
            const lie = `x - ${b} = ${targetX + b}`; 

            return {
                renderData: {
                    description: lang === 'sv' ? `Om $x = ${targetX}$, vilket p√•st√•ende √§r FALSKT?` : `If $x = ${targetX}$, which statement is FALSE?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, lie])
                },
                token: this.toBase64(lie),
                clues: [
                    { text: lang === 'sv' ? `S√§tt in ${targetX} ist√§llet f√∂r x och kontrollera om b√•da sidor blir lika.` : `Substitute ${targetX} for x and check if both sides are equal.`, latex: `${targetX} - ${b} \\neq ${targetX + b}` },
                    { text: lang === 'sv' ? "Falskt p√•st√•ende:" : "False statement:", latex: `\\text{${lie}}` }
                ],
                metadata: { variation_key: 'onestep_spot_lie', difficulty: 1 }
            };
        }

        const type = MathUtils.randomInt(1, 3);
        const x = MathUtils.randomInt(2, 12);
        let latex = '', pedagogicalClues = [];
        
        if (type === 1) {
            const k = MathUtils.randomInt(2, 9);
            const res = k * x;
            latex = `${k}x = ${res}`;
            pedagogicalClues = [
                { text: lang === 'sv' ? `Dela b√•da sidor med ${k} f√∂r att f√• x ensamt.` : `Divide both sides by ${k} to get x alone.`, latex: `\\frac{${res}}{${k}} = ${x} \\\\ x = ${x}` }
            ];
        } else {
            const k = MathUtils.randomInt(1, 20);
            const isPlus = Math.random() > 0.5;
            const res = isPlus ? x + k : x - k;
            latex = isPlus ? `x + ${k} = ${res}` : `x - ${k} = ${res}`;
            pedagogicalClues = [
                { text: lang === 'sv' ? (isPlus ? `Ta bort ${k} fr√•n b√•da sidor.` : `L√§gg till ${k} p√• b√•da sidor.`) : (isPlus ? `Subtract ${k} from both sides.` : `Add ${k} to both sides.`), latex: isPlus ? `${res} - ${k} = ${x} \\\\ x = ${x}` : `${res} + ${k} = ${x} \\\\ x = ${x}` }
            ];
        }

        pedagogicalClues.push({ text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `x = ${x}` });

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen." : "Solve the equation.", answerType: 'text' },
            token: this.toBase64(x.toString()),
            clues: pedagogicalClues,
            metadata: { variation_key: 'onestep_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: Two-Step Equations ---
    private level2_TwoStep(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['twostep_concept_order', 'twostep_calc']);
        
        if (v === 'twostep_concept_order') {
            const a = MathUtils.randomInt(2, 5), b = MathUtils.randomInt(2, 10), c = 20;
            const correct = lang === 'sv' ? `Subtrahera ${b} f√∂rst` : `Subtract ${b} first`;
            const wrong = lang === 'sv' ? `Dividera med ${a} f√∂rst` : `Divide by ${a} first`;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `F√∂r $${a}x + ${b} = ${c}$, vilket steg √§r b√§st att b√∂rja med?` : `For $${a}x + ${b} = ${c}$, which step is best to start with?`,
                    answerType: 'multiple_choice',
                    options: [correct, wrong]
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "Det √§r l√§ttast att f√∂rst 'flytta' den term som inte inneh√•ller x." : "It is easiest to first 'move' the term that does not contain x." },
                    { text: lang === 'sv' ? "R√§tt steg √§r:" : "The correct step is:", latex: `\\text{${correct}}` }
                ],
                metadata: { variation_key: 'twostep_concept_order', difficulty: 2 }
            };
        }

        const x = MathUtils.randomInt(2, 10);
        const a = MathUtils.randomInt(2, 6);
        const b = MathUtils.randomInt(1, 15);
        const isPlus = Math.random() > 0.5;
        const c = isPlus ? a * x + b : a * x - b;
        const intermediate = isPlus ? c - b : c + b;

        return {
            renderData: { latex: `${a}x ${isPlus ? '+' : '-'} ${b} = ${c}`, description: lang === 'sv' ? "L√∂s ekvationen steg f√∂r steg." : "Solve the equation step by step.", answerType: 'text' },
            token: this.toBase64(x.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `Flytta siffran ${b} genom att utf√∂ra motsatt operation.` : `Move the number ${b} by performing the opposite operation.`,
                    latex: isPlus ? `${c} - ${b} = ${intermediate} \\\\ ${a}x = ${intermediate}` : `${c} + ${b} = ${intermediate} \\\\ ${a}x = ${intermediate}`
                },
                { 
                    text: lang === 'sv' ? `Dela nu b√•da sidor med ${a} f√∂r att isolera x.` : `Now divide both sides by ${a} to isolate x.`,
                    latex: `\\frac{${intermediate}}{${a}} = ${x} \\\\ x = ${x}`
                },
                { text: lang === 'sv' ? "V√§rdet p√• x √§r:" : "The value of x is:", latex: `x = ${x}` }
            ],
            metadata: { variation_key: 'twostep_calc', difficulty: 2 }
        };
    }

    // --- LEVEL 3: Parentheses ---
    private level3_Parentheses(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['paren_lie_distribution', 'paren_calc']);
        const a = MathUtils.randomInt(2, 5), b = MathUtils.randomInt(2, 6), x = MathUtils.randomInt(1, 8);

        if (v === 'paren_lie_distribution') {
            const correct = `${a}(x + ${b}) = ${a}x + ${a*b}`;
            const lie = `${a}(x + ${b}) = ${a}x + ${b}`; 
            const correct1 = `${a}(x + ${b}) = ${a}x + ${a*b}`;
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket p√•st√•ende √§r FELAKTIGT?" : "Which statement is INCORRECT?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct1, lie]),
                },
                token: this.toBase64(lie),
                clues: [
                    { text: lang === 'sv' ? "Siffran framf√∂r parentesen m√•ste multipliceras med ALLA termer inuti." : "The number in front of the parentheses must be multiplied by ALL terms inside.", latex: `${a} \\cdot x + ${a} \\cdot ${b}` },
                    { text: lang === 'sv' ? "L√∂gnen √§r:" : "The lie is:", latex: `\\text{${lie}}` }
                ],
                metadata: { variation_key: 'paren_lie_distribution', difficulty: 3 }
            };
        }

        const ab = a * b;
        const constantSum = a * (x + b);
        const diff = constantSum - ab;

        return {
            renderData: {
                latex: `${a}(x + ${b}) = ${constantSum}`,
                description: lang === 'sv' ? "L√∂s ut x ur ekvationen." : "Solve for x in the equation.",
                answerType: 'text'
            },
            token: this.toBase64(x.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `Multiplicera in ${a} i parentesen.` : `Distribute ${a} into the parentheses.`,
                    latex: `${a} \\cdot x + ${a} \\cdot ${b} = ${ab} \\\\ ${a}x + ${ab} = ${constantSum}`
                },
                { 
                    text: lang === 'sv' ? `Subtrahera ${ab} fr√•n b√•da sidor.` : `Subtract ${ab} from both sides.`,
                    latex: `${constantSum} - ${ab} = ${diff} \\\\ ${a}x = ${diff}`
                },
                { 
                    text: lang === 'sv' ? `Dela med ${a} f√∂r att f√• svaret.` : `Divide by ${a} to get the answer.`,
                    latex: `\\frac{${diff}}{${a}} = ${x} \\\\ x = ${x}`
                },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `x = ${x}` }
            ],
            metadata: { variation_key: 'paren_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 4: Both Sides ---
    private level4_BothSides(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['bothsides_concept_strategy', 'bothsides_calc']);
        const x = MathUtils.randomInt(2, 10), a = MathUtils.randomInt(6, 10), c = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(2, 12);
        const d = (a - c) * x + b;
        const eq = `${a}x + ${b} = ${c}x + ${d}`;

        if (v === 'bothsides_concept_strategy') {
            const correct = lang === 'sv' ? `Subtrahera ${c}x fr√•n b√•da sidor` : `Subtract ${c}x from both sides`;
            return {
                renderData: {
                    description: lang === 'sv' ? `I $${eq}$, vad √§r smartast att g√∂ra f√∂rst?` : `In $${eq}$, what is smartest to do first?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, lang === 'sv' ? `Addera ${a}x` : `Add ${a}x` ])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "Det √§r oftast enklast att ta bort den minsta x-termen f√∂rst f√∂r att slippa negativa tal." : "It's usually easiest to remove the smallest x-term first to avoid negative numbers." },
                    { text: lang === 'sv' ? "R√§tt val √§r:" : "The correct choice is:", latex: `\\text{${correct}}` }
                ],
                metadata: { variation_key: 'bothsides_concept_strategy', difficulty: 3 }
            };
        }

        const ac = a - c;
        const db = d - b;

        return {
            renderData: {
                latex: eq,
                description: lang === 'sv' ? "Samla x p√• ena sidan och talen p√• den andra." : "Gather x on one side and numbers on the other.",
                answerType: 'text'
            },
            token: this.toBase64(x.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `B√∂rja med att samla x p√• v√§nster sida genom att dra bort ${c}x.` : `Start by gathering x on the left side by subtracting ${c}x.`,
                    latex: `${a}x - ${c}x = ${ac}x \\\\ ${ac}x + ${b} = ${d}`
                },
                { 
                    text: lang === 'sv' ? `Flytta nu siffran ${b} genom att dra bort den fr√•n b√•da sidor.` : `Now move the number ${b} by subtracting it from both sides.`,
                    latex: `${d} - ${b} = ${db} \\\\ ${ac}x = ${db}`
                },
                { 
                    text: lang === 'sv' ? `Dela med ${ac} f√∂r att hitta x.` : `Divide by ${ac} to find x.`,
                    latex: `\\frac{${db}}{${ac}} = ${x} \\\\ x = ${x}`
                },
                { text: lang === 'sv' ? "Slutresultat:" : "Final result:", latex: `x = ${x}` }
            ],
            metadata: { variation_key: 'bothsides_calc', difficulty: 4 }
        };
    }

    private level7_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(1, 4);
        const data = this.generate(subLevel, lang);
        data.metadata.mixed = true;
        return data;
    }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearEquationProblemGen {
    public generate(level: number, lang: string = 'sv'): any {
        const mode = level === 5 ? 'write' : 'solve';
        const type = MathUtils.randomChoice(['A', 'B', 'C', 'D']);
        
        switch (type) {
            case 'A': return this.scenarioA_RatePlusFixed(lang, mode);
            case 'B': return this.scenarioB_RateMinusFixed(lang, mode);
            case 'C': return this.scenarioC_CompareSum(lang, mode);
            case 'D': return this.scenarioD_CompareDiff(lang, mode);
            default: return this.scenarioA_RatePlusFixed(lang, mode);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        const mode = key.endsWith('_write') ? 'write' : 'solve';
        const baseKey = key.replace('_write', '').replace('_solve', '');

        switch (baseKey) {
            case 'rate_fixed_add': return this.scenarioA_RatePlusFixed(lang, mode);
            case 'rate_fixed_sub': return this.scenarioB_RateMinusFixed(lang, mode);
            case 'compare_word_sum': return this.scenarioC_CompareSum(lang, mode);
            case 'compare_word_diff': return this.scenarioD_CompareDiff(lang, mode);
            default: return this.generate(mode === 'write' ? 5 : 6, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private getTaskText(lang: string, mode: 'write' | 'solve'): string {
        if (mode === 'write') {
            return lang === 'sv' 
                ? "Skriv en ekvation som beskriver detta problem (du beh√∂ver inte l√∂sa ut x)." 
                : "Write an equation that describes this problem (you do not need to solve for x).";
        }
        return lang === 'sv' 
            ? "L√∂s problemet och ta reda p√• vilket v√§rde variabeln x har." 
            : "Solve the problem and find the value of the variable x.";
    }

    // --- Type A: ax + b = c (Rate + Fixed Cost) ---
    private scenarioA_RatePlusFixed(lang: string, mode: 'write' | 'solve') {
        const scenarios = [
            {   
                fixedName: lang === 'sv' ? "kasse" : "bag",
                textSv: (a:number, b:number, c:number) => `Du k√∂per x stycken √§pplen f√∂r ${a} kr/st och en papperskasse f√∂r ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x apples for ${a} kr each and a paper bag for ${b} kr. In total you pay ${c} kr.`
            },
            {   
                fixedName: lang === 'sv' ? "startavgift" : "start fee",
                textSv: (a:number, b:number, c:number) => `En taxiresa kostar ${a} kr per kilometer plus en startavgift p√• ${b} kr. Hela resan kostade totalt ${c} kr. Du √•kte x km.`,
                textEn: (a:number, b:number, c:number) => `A taxi trip costs ${a} kr per kilometer plus a start fee of ${b} kr. The entire trip cost ${c} kr in total. You traveled x km.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(5, 20);
        const a = MathUtils.randomInt(5, 40);
        const b = MathUtils.randomChoice([15, 25, 45, 50]);
        const c = a * x + b;

        const equation = `${a}x+${b}=${c}`;
        const desc = (lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c)) + " " + this.getTaskText(lang, mode);

        let clues;
        if (mode === 'write') {
            clues = [
                { 
                    text: lang === 'sv' ? `F√∂rst uttrycker vi den r√∂rliga kostnaden. Om varje enhet kostar ${a} kr, s√• kostar x stycken totalt ${a}x.` : `First, express the variable cost. If each unit costs ${a} kr, then x units cost ${a}x in total.`, 
                    latex: `${a}x` 
                },
                { 
                    text: lang === 'sv' ? `Sedan l√§gger vi till den fasta kostnaden p√• ${b} kr som betalas oavsett hur m√•nga x man har.` : `Next, add the fixed cost of ${b} kr that is paid regardless of how many x units you have.`, 
                    latex: `${a}x + ${b}` 
                },
                { 
                    text: lang === 'sv' ? `Slutligen s√§tter vi uttrycket lika med det totala beloppet ${c} kr.` : `Finally, set the expression equal to the total amount of ${c} kr.`, 
                    latex: `${a}x + ${b} = ${c}` 
                }
            ];
        } else {
            clues = [
                { 
                    text: lang === 'sv' ? `F√∂r att veta vad bara sj√§lva f√∂rem√•len/kilometrarna kostade, drar vi bort den fasta avgiften (${b} kr) fr√•n totalsumman.` : `To find out the cost of just the items/kilometers, subtract the fixed fee (${b} kr) from the total sum.`, 
                    latex: `${a}x = ${c} - ${b} = ${c-b}` 
                },
                { 
                    text: lang === 'sv' ? `Eftersom vi nu vet att ${a} stycken kostar ${c-b} kr, delar vi med ${a} f√∂r att f√• fram v√§rdet p√• x.` : `Since we now know that ${a} units cost ${c-b} kr, divide by ${a} to find the value of x.`, 
                    latex: `x = \\frac{${c-b}}{${a}} = ${x}` 
                }
            ];
        }

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `rate_fixed_add_${mode}`, difficulty: mode === 'write' ? 3 : 4 }
        };
    }

    // --- Type B: ax - b = c (Rate - Discount) ---
    private scenarioB_RateMinusFixed(lang: string, mode: 'write' | 'solve') {
        const x = MathUtils.randomInt(2, 6);
        const a = MathUtils.randomInt(150, 450);
        const b = MathUtils.randomChoice([100, 200, 300]);
        const c = a * x - b;

        const desc = lang === 'sv'
            ? `Du k√∂per x stycken datorspel som kostar ${a} kr styck. Eftersom du har ett presentkort f√•r du ${b} kr rabatt p√• hela k√∂pet. Du betalar till slut ${c} kr. ${this.getTaskText(lang, mode)}`
            : `You buy x computer games that cost ${a} kr each. Since you have a gift card, you get a ${b} kr discount on the total. You end up paying ${c} kr. ${this.getTaskText(lang, mode)}`;

        const equation = `${a}x-${b}=${c}`;
        let clues;
        if (mode === 'write') {
            clues = [
                { 
                    text: lang === 'sv' ? `B√∂rja med att r√§kna ut vad spelen kostar tillsammans (${a} kr g√•nger x).` : `Start by calculating the cost of the games together (${a} kr times x).`, 
                    latex: `${a}x` 
                },
                { 
                    text: lang === 'sv' ? `Dra sedan bort rabatten p√• ${b} kr fr√•n det priset.` : `Then subtract the discount of ${b} kr from that price.`, 
                    latex: `${a}x - ${b}` 
                },
                { 
                    text: lang === 'sv' ? `S√§tt detta lika med slutpriset du betalade (${c} kr).` : `Set this equal to the final price you paid (${c} kr).`, 
                    latex: `${a}x - ${b} = ${c}` 
                }
            ];
        } else {
            clues = [
                { 
                    text: lang === 'sv' ? `F√∂r att veta vad spelen kostade innan rabatten, l√§gger vi tillbaka de ${b} kr som drogs bort.` : `To find out what the games cost before the discount, we add back the ${b} kr that were subtracted.`, 
                    latex: `${a}x = ${c} + ${b} = ${c+b}` 
                },
                { 
                    text: lang === 'sv' ? `Nu n√§r vi har priset utan rabatt, delar vi med styckpriset ${a} kr f√∂r att hitta antalet x.` : `Now that we have the price without the discount, divide by the unit price ${a} kr to find the number of x.`, 
                    latex: `x = \\frac{${c+b}}{${a}} = ${x}` 
                }
            ];
        }

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `rate_fixed_sub_${mode}`, difficulty: mode === 'write' ? 3 : 4 }
        };
    }

    // --- Type C: Compare Sum (x + (x+a) = c) ---
    private scenarioC_CompareSum(lang: string, mode: 'write' | 'solve') {
        const names = lang === 'sv' ? ["Lukas", "Maja"] : ["Lucas", "Maya"];
        const diff = MathUtils.randomInt(5, 15);
        const x = MathUtils.randomInt(10, 40);
        const total = 2 * x + diff;

        const desc = lang === 'sv'
            ? `${names[0]} har x kr. ${names[1]} har ${diff} kr mer √§n ${names[0]}. Tillsammans har de ${total} kr. ${this.getTaskText(lang, mode)}`
            : `${names[0]} has x kr. ${names[1]} has ${diff} kr more than ${names[0]}. Together they have ${total} kr. ${this.getTaskText(lang, mode)}`;

        const equation = `2x+${diff}=${total}`;
        let clues;
        if (mode === 'write') {
            clues = [
                { 
                    text: lang === 'sv' ? `${names[0]} har x kr. Eftersom ${names[1]} har ${diff} mer, skriver vi det som (x + ${diff}).` : `${names[0]} has x kr. Since ${names[1]} has ${diff} more, we write that as (x + ${diff}).`, 
                    latex: `x + (x + ${diff})` 
                },
                { 
                    text: lang === 'sv' ? `Sl√• ihop de tv√• x-termerna (x + x = 2x) och s√§tt summan lika med ${total}.` : `Combine the two x-terms (x + x = 2x) and set the sum equal to ${total}.`, 
                    latex: `2x + ${diff} = ${total}` 
                }
            ];
        } else {
            clues = [
                { 
                    text: lang === 'sv' ? `Vi b√∂rjar med att ta bort "√∂verskottet" p√• ${diff} kr f√∂r att se vad de skulle ha om de hade exakt lika mycket pengar.` : `We start by removing the "excess" of ${diff} kr to see what they would have if they had exactly the same amount of money.`, 
                    latex: `2x = ${total} - ${diff} = ${total-diff}` 
                },
                { 
                    text: lang === 'sv' ? `Eftersom resultatet motsvarar tv√• personers lika stora summor, delar vi med 2 f√∂r att hitta v√§rdet p√• x.` : `Since the result corresponds to two people's equal sums, we divide by 2 to find the value of x.`, 
                    latex: `x = \\frac{${total-diff}}{2} = ${x}` 
                }
            ];
        }

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `compare_word_sum_${mode}`, difficulty: 4 }
        };
    }

    // --- Type D: Compare Diff (x + (x-b) = c) ---
    private scenarioD_CompareDiff(lang: string, mode: 'write' | 'solve') {
        const length = MathUtils.randomInt(60, 150);
        const diff = MathUtils.randomInt(10, 30);
        const x = (length + diff) / 2;
        if (!Number.isInteger(x)) return this.scenarioD_CompareDiff(lang, mode);

        const desc = lang === 'sv'
            ? `En planka som √§r ${length} cm l√•ng kapas i tv√• bitar. Den l√•nga biten √§r x cm. Den korta biten √§r ${diff} cm kortare √§n den l√•nga. ${this.getTaskText(lang, mode)}`
            : `A plank that is ${length} cm long is cut into two pieces. The long piece is x cm. The short piece is ${diff} cm shorter than the long one. ${this.getTaskText(lang, mode)}`;

        const equation = `2x-${diff}=${length}`;
        let clues;
        if (mode === 'write') {
            clues = [
                { 
                    text: lang === 'sv' ? `Den l√•nga biten √§r x. Den korta √§r ${diff} cm kortare, vilket skrivs som (x - ${diff}).` : `The long piece is x. The short one is ${diff} cm shorter, which is written as (x - ${diff}).`, 
                    latex: `x + (x - ${diff})` 
                },
                { 
                    text: lang === 'sv' ? `F√∂renkla genom att l√§gga ihop bitarna (2x) och s√§tt det lika med den totala l√§ngden ${length} cm.` : `Simplify by adding the pieces together (2x) and set it equal to the total length ${length} cm.`, 
                    latex: `2x - ${diff} = ${length}` 
                }
            ];
        } else {
            clues = [
                { 
                    text: lang === 'sv' ? `Om vi "l√§gger till" de ${diff} cm som saknas p√• den korta biten, skulle vi ha tv√• bitar som b√•da √§r x cm l√•nga.` : `If we "add" the missing ${diff} cm to the short piece, we would have two pieces that are both x cm long.`, 
                    latex: `2x = ${length} + ${diff} = ${length+diff}` 
                },
                { 
                    text: lang === 'sv' ? `Dela nu den nya totala l√§ngden med 2 f√∂r att f√• fram l√§ngden p√• den l√•nga biten x.` : `Now divide the new total length by 2 to find the length of the long piece x.`, 
                    latex: `x = \\frac{${length+diff}}{2} = ${x}` 
                }
            ];
        }

        return {
            renderData: { description: desc, answerType: 'text', latex: "" },
            token: this.toBase64(mode === 'write' ? equation : x.toString()),
            clues,
            metadata: { variation_key: `compare_word_diff_${mode}`, difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearGraphGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_FindM(lang);
            case 2: return this.level2_FindK_Pos(lang);
            case 3: return this.level3_FindK_Neg(lang);
            case 4: return this.level4_FindFunction(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_FindM(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific "Skill Buckets".
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'intercept_id': 
                return this.level1_FindM(lang, key);
            case 'slope_pos_int':
            case 'slope_pos_frac':
                return this.level2_FindK_Pos(lang, key);
            case 'slope_neg_int':
            case 'slope_neg_frac':
                return this.level3_FindK_Neg(lang, key);
            case 'eq_standard':
            case 'eq_no_m':
            case 'eq_horizontal':
                return this.level4_FindFunction(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Intercept (m) ---
    private level1_FindM(lang: string, variationKey?: string): any {
        const m = MathUtils.randomInt(-5, 5);
        const k = MathUtils.randomChoice([1, -1, 2]); // Simple slopes for intercept focus

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#2563eb' }] },
                description: lang === 'sv' 
                    ? "Studera linjen i koordinatsystemet. Vilket √§r linjens m-v√§rde?" 
                    : "Study the line in the coordinate system. What is the m-value (y-intercept)?",
                answerType: 'numeric'
            },
            token: this.toBase64(m.toString()),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "m-v√§rdet √§r den punkt p√• den vertikala y-axeln d√§r linjen sk√§r axeln." 
                        : "The m-value is the point on the vertical y-axis where the line intersects the axis.", 
                    latex: `(0, m)` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Leta upp koordinaten d√§r x √§r 0. Siffran p√• y-axeln √§r ditt svar.` 
                        : `Locate the coordinate where x is 0. The number on the y-axis is your answer.`, 
                    latex: `m = ${m}` 
                }
            ],
            metadata: { variation_key: 'intercept_id', difficulty: 1 }
        };
    }

    // --- LEVEL 2: Positive Slope (k) ---
    private level2_FindK_Pos(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['slope_pos_int', 'slope_pos_frac']);
        let k = 1;
        let kDisplay = "1";
        
        if (v === 'slope_pos_int') {
            k = MathUtils.randomInt(1, 4);
            kDisplay = k.toString();
        } else {
            const den = MathUtils.randomChoice([2, 4]);
            k = 1 / den;
            kDisplay = `1/${den}`;
        }

        const m = MathUtils.randomInt(-2, 2);

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#16a34a' }] },
                description: lang === 'sv' 
                    ? "Ber√§kna linjens lutning (k-v√§rde). Hur mycket stiger linjen f√∂r varje steg √•t h√∂ger?" 
                    : "Calculate the slope (k-value) of the line. How much does the line rise for every step to the right?",
                answerType: 'text'
            },
            token: this.toBase64(kDisplay),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "k-v√§rdet beskriver hur brant linjen lutar. Vi m√§ter skillnaden i h√∂jd (y) delat med skillnaden i sidled (x)." 
                        : "The k-value describes how steep the line is. We measure the change in height (y) divided by the change in horizontal distance (x).", 
                    latex: "k = \\frac{\\Delta y}{\\Delta x}" 
                },
                { 
                    text: lang === 'sv' 
                        ? `Se hur m√•nga steg linjen g√•r upp√•t n√§r du g√•r √•t h√∂ger i systemet.` 
                        : `See how many steps the line moves upward as you move to the right in the system.`,
                    latex: `k = ${kDisplay}`
                }
            ],
            metadata: { variation_key: v, difficulty: v === 'slope_pos_frac' ? 3 : 2 }
        };
    }

    // --- LEVEL 3: Negative Slope (k) ---
    private level3_FindK_Neg(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['slope_neg_int', 'slope_neg_frac']);
        let k = -1;
        let kDisplay = "-1";

        if (v === 'slope_neg_int') {
            k = MathUtils.randomInt(-4, -1);
            kDisplay = k.toString();
        } else {
            const den = MathUtils.randomChoice([2, 3]);
            k = -1 / den;
            kDisplay = `-1/${den}`;
        }

        const m = MathUtils.randomInt(-2, 4);

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#dc2626' }] },
                description: lang === 'sv' 
                    ? "Best√§m linjens lutning (k-v√§rdet). T√§nk p√• om linjen stiger eller sjunker!" 
                    : "Determine the slope (k-value) of the line. Consider if the line rises or falls!",
                answerType: 'text'
            },
            token: this.toBase64(kDisplay),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "Eftersom linjen g√•r ned√•t n√§r vi l√§ser den fr√•n v√§nster till h√∂ger √§r lutningen negativ." 
                        : "Since the line goes downward when read from left to right, the slope is negative.",
                    latex: "k < 0"
                },
                { 
                    text: lang === 'sv' 
                        ? "Anv√§nd 'trappstegsmetoden' f√∂r att se hur m√•nga steg linjen sjunker per steg √•t h√∂ger." 
                        : "Use the 'staircase method' to see how many steps the line falls per step to the right.", 
                    latex: `k = ${kDisplay}` 
                }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: Full Function (y = kx + m) ---
    private level4_FindFunction(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['eq_standard', 'eq_no_m', 'eq_horizontal']);
        
        let k = MathUtils.randomInt(-2, 2);
        let m = MathUtils.randomInt(-3, 3);

        if (v === 'eq_no_m') m = 0;
        if (v === 'eq_horizontal') { k = 0; if (m === 0) m = 2; }
        if (v === 'eq_standard' && k === 0) k = 1;

        // Equation Builder
        let eq = "y=";
        if (k !== 0) {
            if (k === 1) eq += "x";
            else if (k === -1) eq += "-x";
            else eq += `${k}x`;
        }
        
        if (m !== 0) {
            if (m > 0 && k !== 0) eq += `+${m}`;
            else eq += `${m}`;
        } else if (k === 0) {
            eq += "0";
        }

        return {
            renderData: {
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#7c3aed' }] },
                description: lang === 'sv' 
                    ? "Skriv den fullst√§ndiga r√§ta linjens ekvation p√• formen y = kx + m." 
                    : "Write the complete equation of the line in the form y = kx + m.",
                answerType: 'text'
            },
            token: this.toBase64(eq),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "Hitta f√∂rst var linjen sk√§r y-axeln (m) och best√§m d√§refter lutningen (k)." 
                        : "First find where the line intersects the y-axis (m) and then determine the slope (k).", 
                    latex: `m = ${m}, \\; k = ${k}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "S√§tt in v√§rdena i mallen y = kx + m f√∂r att f√• fram ekvationen." 
                        : "Insert the values into the template y = kx + m to produce the equation.", 
                    latex: eq 
                }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }

    private level5_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(1, 4);
        const res = this.generate(subLevel, lang);
        res.metadata.mixed = true;
        return res;
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class NegativeNumbersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Foundations(lang);
            case 2: return this.level2_AddSubFluency(lang);
            case 3: return this.level3_Multiplication(lang);
            case 4: return this.level4_Division(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_Foundations(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     * Allows the Question Studio to request a specific skill bucket.
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'theory_number_line':
            case 'theory_sign_dominance':
            case 'theory_spot_lie':
                return this.level1_Foundations(lang, key);
            
            case 'fluency_chain_4':
            case 'fluency_chain_5':
            case 'fluency_double_neg':
            case 'fluency_plus_neg':
            case 'fluency_transform_match':
                return this.level2_AddSubFluency(lang, key);
            
            case 'mult_same_sign':
            case 'mult_diff_sign':
            case 'mult_inverse_missing':
            case 'mult_chain':
                return this.level3_Multiplication(lang, key);
            
            case 'div_same_sign':
            case 'div_diff_sign':
            case 'div_check_logic':
                return this.level4_Division(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    /**
     * Formats negative numbers with parentheses for LaTeX if needed
     */
    private p(n: number): string {
        return n < 0 ? `(${n})` : `${n}`;
    }

    // --- LEVEL 1: FOUNDATIONS ---
    private level1_Foundations(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['theory_number_line', 'theory_sign_dominance', 'theory_spot_lie']);

        if (v === 'theory_number_line') {
            const start = MathUtils.randomInt(-8, 5);
            const steps = MathUtils.randomInt(2, 6);
            const isRight = Math.random() > 0.5;
            const ans = isRight ? start + steps : start - steps;
            const dir = isRight 
                ? (lang === 'sv' ? "H√ñGER" : "RIGHT") 
                : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `F√∂rest√§ll dig att du st√•r p√• talet ${start} p√• tallinjen. Om du g√•r exakt ${steps} steg √•t ${dir}, p√• vilket tal hamnar du d√•?` 
                        : `Imagine you are standing at the number ${start} on the number line. If you move exactly ${steps} steps to the ${dir}, what number do you land on?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `N√§r du g√•r √•t ${dir} p√• tallinjen blir talet ${isRight ? 'st√∂rre (addition)' : 'mindre (subtraktion)'}.` : `When you move to the ${dir} on the number line, the number gets ${isRight ? 'larger (addition)' : 'smaller (subtraction)'}.`, 
                        latex: `${start} ${isRight ? '+' : '-'} ${steps}` 
                    },
                    {
                        text: lang === 'sv' ? "Du hamnar p√• talet:" : "You land on the number:",
                        latex: `${ans}`
                    }
                ],
                metadata: { variation_key: 'theory_number_line', difficulty: 1 }
            };
        }

        if (v === 'theory_sign_dominance') {
            const pos = MathUtils.randomInt(5, 15);
            const neg = MathUtils.randomInt(-15, -5);
            const isPosLarger = pos > Math.abs(neg);
            const ansLabel = isPosLarger ? (lang === 'sv' ? "Positivt" : "Positive") : (lang === 'sv' ? "Negativt" : "Negative");
            const wrongLabel = isPosLarger ? (lang === 'sv' ? "Negativt" : "Negative") : (lang === 'sv' ? "Positivt" : "Positive");

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Utan att r√§kna ut det exakta svaret, avg√∂r om resultatet av $${pos} + (${neg})$ blir positivt eller negativt.` 
                        : `Without calculating the exact answer, determine if the result of $${pos} + (${neg})$ will be positive or negative.`,
                    answerType: 'multiple_choice',
                    options: [ansLabel, wrongLabel]
                },
                token: this.toBase64(ansLabel),
                clues: [
                    { 
                        text: lang === 'sv' ? "J√§mf√∂r talens avst√•nd till noll (absolutbelopp). Det tal som √§r l√§ngst ifr√•n noll best√§mmer tecknet p√• svaret." : "Compare the numbers' distance to zero (absolute value). The number furthest from zero determines the sign of the answer.", 
                        latex: `|${pos}| \\text{ vs } |${neg}|` 
                    },
                    {
                        text: lang === 'sv' ? "Resultatet blir d√§rf√∂r:" : "The result will therefore be:",
                        latex: `\\text{${ansLabel}}`
                    }
                ],
                metadata: { variation_key: 'theory_sign_dominance', difficulty: 1 }
            };
        }

        const generateComparison = (isCorrect: boolean) => {
            const n1 = MathUtils.randomInt(-12, -1);
            const n2 = MathUtils.randomInt(-12, -1);
            if (n1 === n2) return "-2 > -5"; 
            const realCorrect = n1 > n2;
            return realCorrect === isCorrect ? `${n1} > ${n2}` : `${n1} < ${n2}`;
        };

        const sFalse = generateComparison(false);
        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende om negativa tals storleksordning √§r FALSKT?" : "Which of the following statements about the magnitude of negative numbers is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([generateComparison(true), generateComparison(true), sFalse])
            },
            token: this.toBase64(sFalse),
            clues: [
                { 
                    text: lang === 'sv' ? "Ju l√§ngre till v√§nster ett tal st√•r p√• tallinjen, desto mindre √§r det. Ett tal som √§r 'mer negativt' √§r mindre." : "The further left a number is on the number line, the smaller it is. A number that is 'more negative' is smaller.",
                    latex: "-10 < -2"
                },
                {
                    text: lang === 'sv' ? "Detta p√•st√•ende st√§mmer inte:" : "This statement is incorrect:",
                    latex: `\\text{${sFalse}}`
                }
            ],
            metadata: { variation_key: 'theory_spot_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 2: ADD/SUB FLUENCY ---
    private level2_AddSubFluency(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['fluency_chain_4', 'fluency_double_neg', 'fluency_plus_neg', 'fluency_transform_match']);

        if (v.startsWith('fluency_chain')) {
            const numTerms = v.endsWith('5') ? 5 : 4;
            const terms = Array.from({length: numTerms}, () => MathUtils.randomInt(-10, 10));
            const ops = Array.from({length: numTerms - 1}, () => MathUtils.randomChoice(['+', '-']));

            let latex = this.p(terms[0]);
            let runningTotal = terms[0];
            let simplifiedParts = [terms[0].toString()];

            for(let i=0; i < numTerms - 1; i++) {
                const next = terms[i+1];
                const op = ops[i];
                latex += ` ${op} ${this.p(next)}`;
                if (op === '+') runningTotal += next; else runningTotal -= next;
                const effectiveSign = (op === '+' && next >= 0) || (op === '-' && next < 0) ? '+' : '-';
                simplifiedParts.push(`${effectiveSign} ${Math.abs(next)}`);
            }

            return {
                renderData: {
                    latex: latex,
                    description: lang === 'sv' ? "Ber√§kna v√§rdet av uttrycket." : "Calculate the value of the expression.",
                    answerType: 'numeric'
                },
                token: this.toBase64(runningTotal.toString()),
                clues: [
                    { text: lang === 'sv' ? "B√∂rja med att f√∂renkla alla dubbeltecken s√• att varje tal bara har ett tecken framf√∂r sig." : "Start by simplifying all double signs so each number has only one sign in front of it.", latex: simplifiedParts.join(" ") },
                    { text: lang === 'sv' ? "R√§kna nu ut summan fr√•n v√§nster till h√∂ger." : "Now calculate the sum from left to right.", latex: `${runningTotal}` }
                ],
                metadata: { variation_key: v, difficulty: 4 }
            };
        }

        if (v === 'fluency_transform_match') {
            const a = MathUtils.randomInt(-5, 5);
            const b = MathUtils.randomInt(2, 9);
            const op = MathUtils.randomChoice(['+', '-']);
            const correct = op === '-' ? `${a} + ${b}` : `${a} - ${b}`;

            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket f√∂renklat uttryck betyder samma sak som: $${a} ${op} (-${b})$?` : `Which simplified expression means the same as: $${a} ${op} (-${b})$?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, `${a} ${op} ${b}`, `${a} ${op === '-' ? '-' : '+'} ${b}`])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "F√∂lj teckenregeln: Tv√• minus blir plus, medan plus och minus blir minus." : "Follow the sign rule: Two minuses become plus, while plus and minus become minus.", latex: op === '-' ? "-(-) \\rightarrow +" : "+(-) \\rightarrow -" },
                    { text: lang === 'sv' ? "Det korrekta uttrycket √§r:" : "The correct expression is:", latex: `\\text{${correct}}` }
                ],
                metadata: { variation_key: 'fluency_transform_match', difficulty: 2 }
            };
        }

        const a = MathUtils.randomInt(-10, 10);
        const b = MathUtils.randomInt(1, 10);
        const op = v === 'fluency_double_neg' ? '-' : '+';
        const ans = op === '-' ? a + b : a - b;

        return {
            renderData: {
                latex: `${a} ${op} (-${b})`,
                description: lang === 'sv' ? "F√∂renkla tecknen och ber√§kna v√§rdet." : "Simplify the signs and calculate the value.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? (op === '-' ? "Tv√• minustecken bredvid varandra f√∂rvandlas till ett plustecken." : "Ett plus och ett minus bredvid varandra f√∂rvandlas till ett minustecken.") : (op === '-' ? "Two minus signs next to each other turn into a plus sign." : "A plus and a minus next to each other turn into a minus sign."), latex: op === '-' ? `${a} + ${b}` : `${a} - ${b}` },
                { text: lang === 'sv' ? "Slutresultatet blir:" : "The final result is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: MULTIPLICATION ---
    private level3_Multiplication(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['mult_same_sign', 'mult_diff_sign', 'mult_inverse_missing', 'mult_chain']);

        if (v === 'mult_chain') {
            const numTerms = MathUtils.randomInt(3, 4);
            const factors = Array.from({length: numTerms}, () => {
                let n = MathUtils.randomInt(-4, 4);
                return n === 0 ? 1 : n;
            });
            const ans = factors.reduce((acc, cur) => acc * cur, 1);
            const negCount = factors.filter(f => f < 0).length;
            const isEven = negCount % 2 === 0;

            return {
                renderData: {
                    latex: factors.map(f => this.p(f)).join(' \\cdot '),
                    description: lang === 'sv' ? "Ber√§kna produkten av talen." : "Calculate the product of the numbers.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `R√§kna antalet negativa tecken. H√§r finns det ${negCount} stycken.` : `Count the number of negative signs. There are ${negCount} here.`, latex: `\\text{Antal minus} = ${negCount}` },
                    { text: lang === 'sv' ? (isEven ? "Eftersom antalet minus √§r j√§mnt blir svaret positivt." : "Eftersom antalet minus √§r udda blir svaret negativt.") : (isEven ? "Since the number of minuses is even, the answer is positive." : "Since the number of minuses is odd, the answer is negative."), latex: isEven ? "+" : "-" },
                    { text: lang === 'sv' ? "Multiplicera sifferv√§rdena och l√§gg till tecknet:" : "Multiply the numerical values and apply the sign:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'mult_chain', difficulty: 4 }
            };
        }

        const aVal = MathUtils.randomInt(2, 9), bVal = MathUtils.randomInt(2, 9);
        const signA = Math.random() > 0.5 ? 1 : -1;
        const signB = (v === 'mult_same_sign') ? signA : (v === 'mult_diff_sign' ? -signA : (Math.random() > 0.5 ? 1 : -1));
        const a = aVal * signA, b = bVal * signB;
        const ans = a * b;

        if (v === 'mult_inverse_missing') {
            return {
                renderData: {
                    latex: `${this.p(a)} \\cdot ? = ${ans}`,
                    description: lang === 'sv' ? "Hitta den saknade faktorn." : "Find the missing factor.",
                    answerType: 'numeric'
                },
                token: this.toBase64(b.toString()),
                clues: [
                    { text: lang === 'sv' ? `Dela produkten (${ans}) med den k√§nda faktorn (${a}) f√∂r att hitta x.` : `Divide the product (${ans}) by the known factor (${a}) to find x.`, latex: `x = \\frac{${ans}}{${this.p(a)}}` },
                    { text: lang === 'sv' ? "Den saknade faktorn √§r:" : "The missing factor is:", latex: `${b}` }
                ],
                metadata: { variation_key: 'mult_inverse_missing', difficulty: 3 }
            };
        }

        return {
            renderData: {
                latex: `${this.p(a)} \\cdot ${this.p(b)}`,
                description: lang === 'sv' ? "Multiplicera talen." : "Multiply the numbers.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Lika tecken (+/+) eller (-/-) ger ett positivt svar. Olika tecken (+/-) ger ett negativt svar." : "Like signs (+/+) or (-/-) give a positive answer. Different signs (+/-) give a negative answer.", latex: signA === signB ? "(-) \\cdot (-) = +" : "(+) \\cdot (-) = -" },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 4: DIVISION ---
    private level4_Division(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['div_same_sign', 'div_diff_sign', 'div_check_logic']);
        const bVal = MathUtils.randomInt(2, 10), resVal = MathUtils.randomInt(2, 10);
        const signB = Math.random() > 0.5 ? 1 : -1;
        const signRes = (v === 'div_same_sign') ? (signB === 1 ? 1 : -1) : (v === 'div_diff_sign' ? -signB : (Math.random() > 0.5 ? 1 : -1));
        const b = bVal * signB, res = resVal * signRes;
        const a = b * res;

        if (v === 'div_check_logic') {
            const correct = `${this.p(res)} \\cdot ${this.p(b)} = ${a}`;
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket samband bevisar att $${a} / ${this.p(b)} = ${res}$?` : `Which relationship proves that $${a} / ${this.p(b)} = ${res}$?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, `${this.p(res)} + ${this.p(b)} = ${a}`, `${this.p(a)} \\cdot ${this.p(b)} = ${res}`])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "Kontrollera divisionen genom att multiplicera svaret (kvoten) med talet d√§r nere (n√§mnaren)." : "Check the division by multiplying the answer (quotient) by the number at the bottom (denominator).", latex: "\\text{Kvoten} \\cdot \\text{N√§mnaren} = \\text{T√§ljaren}" },
                    { text: lang === 'sv' ? "R√§tt samband √§r:" : "The correct relationship is:", latex: correct }
                ],
                metadata: { variation_key: 'div_check_logic', difficulty: 2 }
            };
        }

        return {
            renderData: {
                latex: `\\frac{${a}}{${this.p(b)}}`,
                description: lang === 'sv' ? "Ber√§kna kvoten." : "Calculate the quotient.",
                answerType: 'numeric'
            },
            token: this.toBase64(res.toString()),
            clues: [
                { text: lang === 'sv' ? "Teckenreglerna f√∂r division fungerar exakt som f√∂r multiplikation." : "The sign rules for division work exactly like those for multiplication.", latex: (a > 0 && b > 0) || (a < 0 && b < 0) ? "(-) / (-) = +" : "(-) / (+) = -" },
                { text: lang === 'sv' ? "Kvoten √§r:" : "The quotient is:", latex: `${res}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    private level5_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        const data = this.generate(lvl, lang);
        data.metadata.mixed = true;
        return data;
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\OrderOperationsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class OrderOperationsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Basic(lang);
            case 2: return this.level2_Parentheses(lang);
            case 3: return this.level3_Complex(lang);
            case 4: return this.level4_Powers(lang);
            default: return this.level1_Basic(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'order_basic': return this.level1_Basic(lang);
            case 'order_paren': return this.level2_Parentheses(lang);
            case 'order_fraction': return this.level3_Complex(lang);
            case 'order_powers': return this.level4_Powers(lang);
            default: return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: 3 Terms, 2 Ops (No Parentheses) ---
    private level1_Basic(lang: string): any {
        const useMult = Math.random() > 0.5;
        const isMDFirst = Math.random() > 0.5;
        const usePlus = Math.random() > 0.5;
        const op = usePlus ? '+' : '-';

        let a, b, c, result, latex, clues = [];

        if (useMult) {
            a = MathUtils.randomInt(2, 6);
            b = MathUtils.randomInt(2, 8);
            c = MathUtils.randomInt(1, 10);
            const product = a * b;

            if (isMDFirst) {
                result = usePlus ? product + c : product - c;
                if (result <= 0) { c = product - 1; result = 1; }
                latex = `${a} \\cdot ${b} ${op} ${c}`;
                clues = [
                    { 
                        text: lang === 'sv' ? `Multiplikation g√•r f√∂re ${usePlus ? 'addition' : 'subtraktion'}. R√§kna ut produkten f√∂rst:` : `Multiplication comes before ${usePlus ? 'addition' : 'subtraction'}. Calculate the product first:`,
                        latex: `${a} \\cdot ${b} = ${product} \\\\ ${product} ${op} ${c}`
                    }
                ];
            } else {
                result = usePlus ? c + product : c - product;
                if (result <= 0) { c = product + MathUtils.randomInt(1, 5); result = c - product; }
                latex = `${c} ${op} ${a} \\cdot ${b}`;
                clues = [
                    { 
                        text: lang === 'sv' ? `Multiplikation prioriteras alltid f√∂re ${usePlus ? 'addition' : 'subtraktion'}.` : `Multiplication is always prioritized before ${usePlus ? 'addition' : 'subtraction'}.`,
                        latex: `${a} \\cdot ${b} = ${product} \\\\ ${c} ${op} ${product}`
                    }
                ];
            }
        } else {
            b = MathUtils.randomInt(2, 6);
            const quotient = MathUtils.randomInt(2, 8);
            const dividend = b * quotient; 
            c = MathUtils.randomInt(1, 15);

            if (isMDFirst) {
                latex = `\\frac{${dividend}}{${b}} ${op} ${c}`;
                result = usePlus ? quotient + c : quotient - c;
                if (result <= 0) { c = quotient + 1; result = quotient - c; }
                
                clues = [
                    { 
                        text: lang === 'sv' ? `Divisionen (br√•kstrecket) ska r√§knas ut f√∂re ${usePlus ? 'addition' : 'subtraktion'}.` : `The division (fraction bar) must be calculated before ${usePlus ? 'addition' : 'subtraction'}.`,
                        latex: `\\frac{${dividend}}{${b}} = ${quotient} \\\\ ${quotient} ${op} ${c}`
                    }
                ];
            } else {
                latex = `${c} ${op} \\frac{${dividend}}{${b}}`;
                result = usePlus ? c + quotient : c - quotient;
                if (result <= 0) { c = quotient + 2; result = c - quotient; }

                clues = [
                    { 
                        text: lang === 'sv' ? `Division har f√∂rtur √∂ver ${usePlus ? 'addition' : 'subtraktion'}.` : `Division has priority over ${usePlus ? 'addition' : 'subtraction'}.`,
                        latex: `\\frac{${dividend}}{${b}} = ${quotient} \\\\ ${c} ${op} ${quotient}`
                    }
                ];
            }
        }

        clues.push({ text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${result}` });

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna v√§rdet." : "Calculate the value.", answerType: 'numeric' },
            token: this.toBase64(result.toString()),
            clues,
            metadata: { variation_key: 'order_basic', difficulty: 1 }
        };
    }

    // --- LEVEL 2: Parentheses ---
    private level2_Parentheses(lang: string): any {
        const a = MathUtils.randomInt(2, 10), b = MathUtils.randomInt(2, 10), c = MathUtils.randomInt(2, 5), d = MathUtils.randomInt(1, 10);
        const templates = [
            {
                latex: `(${a} + ${b}) \\cdot ${c} - ${d}`,
                ans: (a + b) * c - d,
                clues: [
                    { t: lang === 'sv' ? `B√∂rja med det som st√•r i parentesen.` : `Start with what is inside the parentheses.`, l: `${a} + ${b} = ${a + b} \\\\ ${a + b} \\cdot ${c} - ${d}` },
                    { t: lang === 'sv' ? `Multiplicera d√§refter innan du subtraherar.` : `Then multiply before subtracting.`, l: `${a + b} \\cdot ${c} = ${(a + b) * c} \\\\ ${(a + b) * c} - ${d}` }
                ]
            },
            {
                latex: `${a} \\cdot (${b} + ${c}) + ${d}`,
                ans: a * (b + c) + d,
                clues: [
                    { t: lang === 'sv' ? `R√§kna ut parentesen f√∂rst.` : `Calculate the parentheses first.`, l: `${b} + ${c} = ${b + c} \\\\ ${a} \\cdot ${b + c} + ${d}` },
                    { t: lang === 'sv' ? `Genomf√∂r multiplikationen:` : `Perform the multiplication:`, l: `${a} \\cdot ${b + c} = ${a * (b + c)} \\\\ ${a * (b + c)} + ${d}` }
                ]
            },
            {
                latex: `${a} + (${b} + ${c}) \\cdot ${d}`,
                ans: a + (b + c) * d,
                clues: [
                    { t: lang === 'sv' ? `Parenteser har h√∂gsta prioritet i r√§kneordningen.` : `Parentheses have the highest priority in the order of operations.`, l: `${b} + ${c} = ${b + c} \\\\ ${a} + ${b + c} \\cdot ${d}` },
                    { t: lang === 'sv' ? `Multiplikation g√•r f√∂re addition.` : `Multiplication comes before addition.`, l: `${b + c} \\cdot ${d} = ${(b + c) * d} \\\\ ${a} + ${(b + c) * d}` }
                ]
            }
        ];

        const p = MathUtils.randomChoice(templates);
        const finalClues = p.clues.map(c => ({ text: c.t, latex: c.l }));
        finalClues.push({ text: lang === 'sv' ? "Det slutgiltiga svaret √§r:" : "The final answer is:", latex: `${p.ans}` });

        return {
            renderData: { latex: p.latex, description: lang === 'sv' ? "Ber√§kna" : "Calculate.", answerType: 'numeric' },
            token: this.toBase64(p.ans.toString()),
            clues: finalClues,
            metadata: { variation_key: 'order_paren', difficulty: 2 }
        };
    }

    // --- LEVEL 3: Complex ---
    private level3_Complex(lang: string): any {
        const div = MathUtils.randomInt(2, 4), quotient = MathUtils.randomInt(2, 5), numVal = div * quotient;
        const n1 = MathUtils.randomInt(1, numVal - 1), n2 = numVal - n1;
        const m1 = MathUtils.randomInt(2, 4), m2 = MathUtils.randomInt(2, 3), product = m1 * m2;
        const constant = MathUtils.randomInt(10, 20);
        
        const result = constant + quotient - product;
        const latex = `${constant} + \\frac{${n1} + ${n2}}{${div}} - ${m1} \\cdot ${m2}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna" : "Calculate.", answerType: 'numeric' },
            token: this.toBase64(result.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `T√§ljaren i ett br√•k fungerar som en parentes. B√∂rja d√§r:` : `The numerator of a fraction acts like parentheses. Start there:`, 
                    latex: `${n1} + ${n2} = ${numVal} \\\\ ${constant} + \\frac{${numVal}}{${div}} - ${m1} \\cdot ${m2}` 
                },
                { 
                    text: lang === 'sv' ? `Utf√∂r nu b√•de division och multiplikation:` : `Now perform both division and multiplication:`, 
                    latex: `\\frac{${numVal}}{${div}} = ${quotient}, \\; ${m1} \\cdot ${m2} = ${product} \\\\ ${constant} + ${quotient} - ${product}` 
                },
                { 
                    text: lang === 'sv' ? `Slutf√∂r med addition och subtraktion fr√•n v√§nster till h√∂ger:` : `Complete with addition and subtraction from left to right:`, 
                    latex: `${constant} + ${quotient} = ${constant + quotient} \\\\ ${constant + quotient} - ${product}` 
                },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${result}` }
            ],
            metadata: { variation_key: 'order_fraction', difficulty: 3 }
        };
    }

    // --- LEVEL 4: Powers ---
    private level4_Powers(lang: string): any {
        const base = MathUtils.randomInt(2, 4), pVal = base * base;
        const div = 2, quotient = MathUtils.randomInt(2, 4), numVal = div * quotient;
        const n1 = MathUtils.randomInt(1, numVal - 1), n2 = numVal - n1;
        const m1 = 3, m2 = 2, product = m1 * m2;

        const result = pVal + quotient - product;
        const latex = `${base}^2 + \\frac{${n1} + ${n2}}{${div}} - ${m1} \\cdot ${m2}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna" : "Calculate.", answerType: 'numeric' },
            token: this.toBase64(result.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `Steg 1: Ber√§kna t√§ljaren i br√•ket f√∂rst.` : `Step 1: Calculate the numerator in the fraction first.`, 
                    latex: `${n1} + ${n2} = ${numVal} \\\\ ${base}^2 + \\frac{${numVal}}{${div}} - ${m1} \\cdot ${m2}` 
                },
                { 
                    text: lang === 'sv' ? `Steg 2: Potenser r√§knas ut f√∂re multiplikation och division.` : `Step 2: Powers are calculated before multiplication and division.`, 
                    latex: `${base}^2 = ${pVal} \\\\ ${pVal} + \\frac{${numVal}}{${div}} - ${m1} \\cdot ${m2}` 
                },
                { 
                    text: lang === 'sv' ? `Steg 3: Utf√∂r multiplikation och division.` : `Step 3: Perform multiplication and division.`, 
                    latex: `\\frac{${numVal}}{${div}} = ${quotient}, \\; ${m1} \\cdot ${m2} = ${product} \\\\ ${pVal} + ${quotient} - ${product}` 
                },
                { 
                    text: lang === 'sv' ? `Steg 4: Slutf√∂r utr√§kningen fr√•n v√§nster till h√∂ger.` : `Step 4: Finish the calculation from left to right.`, 
                    latex: `${pVal} + ${quotient} = ${pVal + quotient} \\\\ ${pVal + quotient} - ${product}` 
                },
                { text: lang === 'sv' ? "Slutresultatet √§r:" : "The final result is:", latex: `${result}` }
            ],
            metadata: { variation_key: 'order_powers', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\OrderOperationsGen.ts

// =======================================================
// FILE START: src\core\generators\PatternsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PatternsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Sequences(lang);
            case 2: return this.level2_HighTerm(lang);
            case 3: return this.level3_VisualFormula(lang);
            case 4: return this.level4_TableToFormula(lang);
            case 5: return this.level5_ReverseEngineering(lang);
            default: return this.level1_Sequences(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'seq_lie':
            case 'seq_type':
            case 'seq_diff':
            case 'seq_next':
                return this.level1_Sequences(lang, key);
            case 'high_term':
                return this.level2_HighTerm(lang, key);
            case 'formula_missing':
            case 'visual_calc':
            case 'find_formula':
                return this.level3_VisualFormula(lang, key);
            case 'table_formula':
            case 'table_fill':
                return this.level4_TableToFormula(lang, key);
            case 'reverse_calc':
                return this.level5_ReverseEngineering(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private generateMatchstickData(type: 'squares' | 'triangles' | 'houses', count: number) {
        const sticks: { x1: number, y1: number, x2: number, y2: number }[] = [];
        const unitW = 40;
        const padding = 10;
        for (let i = 0; i < count; i++) {
            const xOffset = padding + (i * unitW);
            if (type === 'squares') {
                sticks.push({ x1: xOffset, y1: 40, x2: xOffset + unitW, y2: 40 });
                sticks.push({ x1: xOffset, y1: 80, x2: xOffset + unitW, y2: 80 });
                sticks.push({ x1: xOffset + unitW, y1: 40, x2: xOffset + unitW, y2: 80 });
                if (i === 0) sticks.push({ x1: xOffset, y1: 40, x2: xOffset, y2: 80 });
            } 
            else if (type === 'triangles') {
                sticks.push({ x1: xOffset, y1: 80, x2: xOffset + unitW, y2: 80 });
                sticks.push({ x1: xOffset + unitW / 2, y1: 40, x2: xOffset + unitW, y2: 80 });
                if (i === 0) sticks.push({ x1: xOffset, y1: 80, x2: xOffset + unitW / 2, y2: 40 });
            }
            else if (type === 'houses') {
                if (i === 0) sticks.push({ x1: xOffset, y1: 50, x2: xOffset, y2: 90 });
                sticks.push({ x1: xOffset, y1: 90, x2: xOffset + unitW, y2: 90 });
                sticks.push({ x1: xOffset + unitW, y1: 50, x2: xOffset + unitW, y2: 90 });
                sticks.push({ x1: xOffset, y1: 50, x2: xOffset + unitW / 2, y2: 20 });
                sticks.push({ x1: xOffset + unitW / 2, y1: 20, x2: xOffset + unitW, y2: 50 });
                sticks.push({ x1: xOffset, y1: 50, x2: xOffset + unitW, y2: 50 });
            }
        }
        return { width: (count * unitW) + (padding * 2), height: 100, sticks };
    }

    // --- LEVEL 1: SEQUENCES ---
    private level1_Sequences(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['seq_lie', 'seq_type', 'seq_diff', 'seq_next']);

        if (v === 'seq_lie') {
            const start = MathUtils.randomInt(2, 10);
            const diff = MathUtils.randomInt(2, 5);
            const seq = [start, start + diff, start + diff * 2, start + diff * 3];
            const sTrue1 = lang === 'sv' ? `√ñkningen √§r ${diff}` : `The increase is ${diff}`;
            const sTrue2 = lang === 'sv' ? `Starttalet √§r ${start}` : `The starting number is ${start}`;
            const sFalse = lang === 'sv' ? `N√§sta tal √§r ${seq[3] + diff + 1}` : `The next number is ${seq[3] + diff + 1}`;

            return {
                renderData: {
                    description: lang === 'sv' ? `Studera talf√∂ljden: ${seq.join(', ')}... Vilket p√•st√•ende √§r FALSKT?` : `Examine the sequence: ${seq.join(', ')}... Which statement is FALSE?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse]),
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(sFalse),
                clues: [
                    { text: lang === 'sv' ? `Kontrollera skillnaden mellan talen.` : `Check the difference between the numbers.`, latex: `${seq[1]} - ${seq[0]} = ${diff}` },
                    { text: lang === 'sv' ? `Ett av dessa p√•st√•enden st√§mmer inte med m√∂nstret:` : `One of these statements does not fit the pattern:`, latex: `\\text{${sFalse}}` }
                ],
                metadata: { variation_key: 'seq_lie', difficulty: 1 }
            };
        }

        if (v === 'seq_type') {
            const isGeo = Math.random() > 0.5;
            const start = MathUtils.randomInt(2, 5);
            const factor = MathUtils.randomInt(2, 3);
            const seq = isGeo 
                ? [start, start * factor, start * Math.pow(factor, 2), start * Math.pow(factor, 3)]
                : [start, start + factor, start + factor * 2, start + factor * 3];
            const ans = isGeo ? (lang === 'sv' ? "Geometriskt" : "Geometric") : (lang === 'sv' ? "Aritmetiskt" : "Arithmetic");

            return {
                renderData: {
                    description: lang === 'sv' ? `Titta p√• talf√∂ljden: ${seq.join(', ')}... √Ñr detta ett aritmetiskt eller geometriskt m√∂nster?` : `Look at the sequence: ${seq.join(', ')}... Is this an arithmetic or geometric pattern?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Aritmetiskt", "Geometriskt"] : ["Arithmetic", "Geometric"],
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? `√ñkar m√∂nstret med samma summa (+/-) eller med samma faktor (multiplikation)?` : `Does the pattern increase by the same sum (+/-) or by the same factor (multiplication)?`, latex: isGeo ? `${seq[0]} \\cdot ${factor} = ${seq[1]}` : `${seq[0]} + ${factor} = ${seq[1]}` },
                    { text: lang === 'sv' ? `M√∂nstret √§r:` : `The pattern is:`, latex: `\\text{${ans}}` }
                ],
                metadata: { variation_key: 'seq_type', difficulty: 2 }
            };
        }

        const diff = MathUtils.randomInt(2, 9);
        const start = MathUtils.randomInt(1, 15);
        const seq = [start, start + diff, start + diff * 2, start + diff * 3];

        if (v === 'seq_diff') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Hur stor √§r √∂kningen (differensen) i talf√∂ljden: ${seq.join(', ')}?` : `What is the increase (difference) in the sequence: ${seq.join(', ')}?`,
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(diff.toString()),
                clues: [
                    { text: lang === 'sv' ? `R√§kna ut skillnaden mellan tv√• tal som st√•r bredvid varandra.` : `Calculate the difference between two adjacent numbers.`, latex: `${seq[1]} - ${seq[0]}` },
                    { text: lang === 'sv' ? "Differensen √§r:" : "The difference is:", latex: `${diff}` }
                ],
                metadata: { variation_key: 'seq_diff', difficulty: 1 }
            };
        }

        const nextVal = seq[3] + diff;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket tal kommer h√§rn√§st: ${seq.join(', ')}?` : `What is the next number: ${seq.join(', ')}?`,
                answerType: 'numeric',
                geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '?'] }
            },
            token: this.toBase64(nextVal.toString()),
            clues: [
                { text: lang === 'sv' ? `Eftersom √∂kningen √§r ${diff}, addera ${diff} till det sista talet i f√∂ljden.` : `Since the increase is ${diff}, add ${diff} to the last number in the sequence.`, latex: `${seq[3]} + ${diff}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${nextVal}` }
            ],
            metadata: { variation_key: 'seq_next', difficulty: 1 }
        };
    }

    // --- LEVEL 2: HIGH TERM ---
    private level2_HighTerm(lang: string, variationKey?: string): any {
        const diff = MathUtils.randomInt(3, 9);
        const start = MathUtils.randomInt(2, 15); 
        const targetN = MathUtils.randomChoice([10, 20, 50, 100]);
        const ans = start + (targetN - 1) * diff;

        return {
            renderData: { 
                description: lang === 'sv' ? `I m√∂nstret ${start}, ${start + diff}, ${start + diff * 2}... vilket tal √§r nummer ${targetN}?` : `In the pattern ${start}, ${start + diff}, ${start + diff * 2}... what is number ${targetN}?`, 
                answerType: 'numeric', 
                geometry: { type: 'pattern', subtype: 'sequence', sequence: [start, start + diff, start + diff * 2, '...'] } 
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? `F√∂r att n√• tal nummer ${targetN} fr√•n starttalet m√•ste du g√∂ra ${targetN - 1} stycken hopp.` : `To reach number ${targetN} from the start, you need to make ${targetN - 1} jumps.`, latex: `n - 1 = ${targetN - 1}` },
                { text: lang === 'sv' ? `Varje hopp √§r v√§rt ${diff}. Multiplicera antalet hopp med √∂kningen och l√§gg till starttalet.` : `Each jump is worth ${diff}. Multiply the number of jumps by the increase and add the starting number.`, latex: `${start} + ${targetN - 1} \\cdot ${diff}` },
                { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'high_term', difficulty: 2 }
        };
    }

    // --- LEVEL 3: VISUAL FORMULA ---
    private level3_VisualFormula(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['formula_missing', 'visual_calc', 'find_formula']);
        const scenarios = [
            { type: 'squares', diff: 3, unitConst: 1, nameSv: "kvadrater", nameEn: "squares" },
            { type: 'triangles', diff: 2, unitConst: 1, nameSv: "trianglar", nameEn: "triangles" },
            { type: 'houses', diff: 5, unitConst: 1, nameSv: "hus", nameEn: "houses" }
        ];
        const s = MathUtils.randomChoice(scenarios);
        const offset = MathUtils.randomInt(0, 1);
        const a = s.diff;
        const b = s.diff * offset + s.unitConst;
        const objName = lang === 'sv' ? s.nameSv : s.nameEn;

        const figures = [
            this.generateMatchstickData(s.type as any, 1 + offset),
            this.generateMatchstickData(s.type as any, 2 + offset),
            this.generateMatchstickData(s.type as any, 3 + offset)
        ];
        const val1 = a * 1 + b;
        const val2 = a * 2 + b;

        if (v === 'formula_missing') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Formeln √§r $V = ?n + ${b}$. Om figur 1 har ${val1} stickor, vad √§r talet framf√∂r n?` : `The formula is $V = ?n + ${b}$. If figure 1 has ${val1} sticks, what is the number in front of n?`,
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'matchsticks', figures: [figures[0], figures[1]] }
                },
                token: this.toBase64(a.toString()),
                clues: [
                    { text: lang === 'sv' ? `Talet framf√∂r n √§r √∂kningen mellan figurerna. Ber√§kna skillnaden.` : `The number in front of n is the increase between the figures. Calculate the difference.`, latex: `${val2} - ${val1}` },
                    { text: lang === 'sv' ? "Det saknade talet √§r:" : "The missing number is:", latex: `${a}` }
                ],
                metadata: { variation_key: 'formula_missing', difficulty: 3 }
            };
        }

        if (v === 'visual_calc') {
            const target = 10;
            const ans = a * target + b;
            return {
                renderData: {
                    description: lang === 'sv' ? `Formeln √§r $V = ${a}n + ${b}$. Hur m√•nga stickor beh√∂vs till figur nummer ${target}?` : `The formula is $V = ${a}n + ${b}$. How many sticks are needed for figure number ${target}?`,
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'matchsticks', figures }
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Ers√§tt n med ${target} i formeln och r√§kna ut v√§rdet.` : `Replace n with ${target} in the formula and calculate the value.`, latex: `V = ${a} \\cdot ${target} + ${b}` },
                    { text: lang === 'sv' ? "Antalet stickor √§r:" : "The number of sticks is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'visual_calc', difficulty: 2 }
            };
        }

        const formulaAns = `${a}n+${b}`;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilken formel $an + b$ beskriver antalet stickor i m√∂nstret?` : `Which formula $an + b$ describes the number of sticks in the pattern?`,
                answerType: 'text',
                geometry: { type: 'pattern', subtype: 'matchsticks', figures } 
            },
            token: this.toBase64(formulaAns),
            clues: [
                { text: lang === 'sv' ? `Hitta f√∂rst √∂kningen (a) mellan figurerna.` : `First find the increase (a) between the figures.`, latex: `a = ${val2} - ${val1} = ${a}` },
                { text: lang === 'sv' ? `Hitta sedan startv√§rdet (b) genom att se vad som √•terst√•r n√§r n = 0.` : `Then find the starting value (b) by seeing what remains when n = 0.`, latex: `b = ${val1} - ${a} = ${b}` },
                { text: lang === 'sv' ? "Formeln √§r:" : "The formula is:", latex: `${a}n + ${b}` }
            ],
            metadata: { variation_key: 'find_formula', difficulty: 3 }
        };
    }

    // --- LEVEL 4: TABLE TO FORMULA ---
    private level4_TableToFormula(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['table_formula', 'table_fill']);
        const a = MathUtils.randomInt(2, 6);
        const b = MathUtils.randomInt(1, 5);
        const rows = [[1, a + b], [2, a * 2 + b], [3, a * 3 + b], [4, a * 4 + b]];

        if (v === 'table_formula') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilken formel p√• formen $an + b$ beskriver tabellen?" : "Which formula of the form $an + b$ describes the table?",
                    answerType: 'text',
                    geometry: { type: 'frequency_table', headers: ['n', 'V√§rde'], rows }
                },
                token: this.toBase64(`${a}n+${b}`),
                clues: [
                    { text: lang === 'sv' ? `√ñkningen f√∂r varje steg (n) ger dig v√§rdet p√• a.` : `The increase for each step (n) gives you the value of a.`, latex: `a = ${rows[1][1]} - ${rows[0][1]} = ${a}` },
                    { text: lang === 'sv' ? `V√§rdet b hittar du genom att dra bort √∂kningen fr√•n det f√∂rsta v√§rdet.` : `You find the value b by subtracting the increase from the first value.`, latex: `b = ${rows[0][1]} - ${a} = ${b}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${a}n + ${b}` }
                ],
                metadata: { variation_key: 'table_formula', difficulty: 3 }
            };
        }

        const targetN = 5;
        const targetVal = a * targetN + b;
        return {
            renderData: {
                description: lang === 'sv' ? `Vilket v√§rde h√∂r till n = ${targetN}?` : `Which value corresponds to n = ${targetN}?`,
                answerType: 'numeric',
                geometry: { type: 'frequency_table', headers: ['n', 'V√§rde'], rows }
            },
            token: this.toBase64(targetVal.toString()),
            clues: [
                { text: lang === 'sv' ? `M√∂nstret √∂kar med ${a} f√∂r varje steg. Addera ${a} till sista k√§nda v√§rdet.` : `The pattern increases by ${a} for each step. Add ${a} to the last known value.`, latex: `${rows[3][1]} + ${a}` },
                { text: lang === 'sv' ? "V√§rdet blir:" : "The value is:", latex: `${targetVal}` }
            ],
            metadata: { variation_key: 'table_fill', difficulty: 2 }
        };
    }

    // --- LEVEL 5: REVERSE ENGINEERING ---
    private level5_ReverseEngineering(lang: string, variationKey?: string): any {
        const a = MathUtils.randomInt(3, 8);
        const b = MathUtils.randomInt(2, 10);
        const n = MathUtils.randomInt(10, 30);
        const total = a * n + b;

        return {
            renderData: {
                description: lang === 'sv' ? `I m√∂nstret $V = ${a}n + ${b}$, vilket figurnummer (n) har v√§rdet ${total}?` : `In the pattern $V = ${a}n + ${b}$, which figure number (n) has the value ${total}?`,
                answerType: 'numeric'
            },
            token: this.toBase64(n.toString()),
            clues: [
                { text: lang === 'sv' ? `B√∂rja med att dra bort det fasta startv√§rdet (${b}) fr√•n totalen.` : `Start by subtracting the fixed starting value (${b}) from the total.`, latex: `${total} - ${b} = ${total - b}` },
                { text: lang === 'sv' ? `Dela nu resultatet med den konstanta √∂kningen (${a}).` : `Now divide the result by the constant increase (${a}).`, latex: `\\frac{${total - b}}{${a}}` },
                { text: lang === 'sv' ? "Figurnumret √§r:" : "The figure number is:", latex: `${n}` }
            ],
            metadata: { variation_key: 'reverse_calc', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\PatternsGen.ts

// =======================================================
// FILE START: src\core\generators\PercentGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PercentGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ConceptsAndVisuals(lang);
            case 2: return this.level2_MentalMath(lang);
            case 3: return this.level3_BuildingBlocks(lang);
            case 4: return this.level4_PercentEquation(lang);
            case 5: return this.level5_ReversePercentage(lang);
            case 6: return this.level6_PercentageChange(lang);
            default: return this.level1_ConceptsAndVisuals(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'visual_translation':
            case 'visual_lie':
            case 'equivalence':
            case 'equivalence_basic_frac': // Added new case
            case 'equivalence_basic_dec':  // Added new case
                return this.level1_ConceptsAndVisuals(lang, key);
            
            case 'benchmark_calc':
            case 'benchmark_inverse':
            case 'benchmark_commutative':
                return this.level2_MentalMath(lang, key);
            
            case 'composition':
            case 'decomposition':
            case 'estimation':
                return this.level3_BuildingBlocks(lang, key);
            
            case 'find_percent_basic':
            case 'find_percent_test':
            case 'find_percent_discount':
            case 'find_percent_group':
                return this.level4_PercentEquation(lang, key);
            
            case 'reverse_find_whole':
            case 'reverse_scaling':
            case 'reverse_concept':
                return this.level5_ReversePercentage(lang, key);
            
            case 'change_calc':
            case 'change_multiplier':
            case 'change_trap':
                return this.level6_PercentageChange(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }
    // --- LEVEL 1: CONCEPTS & VISUALS ---
    private level1_ConceptsAndVisuals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['visual_translation', 'visual_lie', 'equivalence', 'equivalence_basic_frac', 'equivalence_basic_dec']);

        // New Variation: Basic Fraction to Percent Facts
        if (v === 'equivalence_basic_frac') {
            const facts = [
                { f: "1/2", p: "50" }, { f: "1/3", p: "33" }, { f: "1/4", p: "25" }, 
                { f: "1/5", p: "20" }, { f: "1/10", p: "10" }, { f: "1/100", p: "1" }
            ];
            const item = MathUtils.randomChoice(facts);
            return {
                renderData: {
                    description: lang === 'sv' ? `Hur m√•nga procent motsvarar br√•ket $${item.f}$?` : `What percentage corresponds to the fraction $${item.f}$?`,
                    answerType: 'numeric', suffix: '%'
                },
                token: this.toBase64(item.p),
                clues: [
                    { text: lang === 'sv' ? "Procent betyder 'per hundra'. Vi vill ta reda p√• hur m√•nga hundradelar br√•ket motsvarar." : "Percent means 'per hundred'. We want to find out how many hundredths the fraction represents.", latex: `${item.f} = \\frac{?}{100}` },
                    { text: lang === 'sv' ? "Genom att dividera t√§ljaren med n√§mnaren f√•r vi andelen." : "By dividing the numerator by the denominator, we get the share.", latex: `${item.f} \\approx ${Number(item.p)/100}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${item.p}\\%` }
                ],
                metadata: { variation_key: 'equivalence_basic_frac', difficulty: 1 }
            };
        }
        if (v === 'visual_translation') {
            const colored = MathUtils.randomInt(1, 99);
            const targetType = MathUtils.randomChoice(['fraction', 'decimal', 'percent']);
            let answer = "";
            let desc = "";

            if (targetType === 'fraction') {
                desc = lang === 'sv' ? "Titta p√• rutn√§tet nedan. Hur stor andel av rutorna √§r f√§rgade? Svara i br√•kform." : "Look at the grid below. What fraction of the squares are colored? Answer as a fraction.";
                answer = `${colored}/100`;
            } else if (targetType === 'decimal') {
                desc = lang === 'sv' ? "Studera figuren och ange hur stor andel som √§r f√§rgad i decimalform." : "Study the figure and state how large a part is colored in decimal form.";
                answer = (colored / 100).toString().replace('.', ',');
            } else {
                desc = lang === 'sv' ? "Hur m√•nga procent av hela rutn√§tet √§r f√§rgat med bl√• f√§rg?" : "What percentage of the entire grid is colored in blue?";
                answer = colored.toString();
            }

            return {
                renderData: {
                    description: desc,
                    answerType: targetType === 'fraction' ? 'fraction' : 'numeric',
                    suffix: targetType === 'percent' ? '%' : '',
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(answer),
                clues: [
                    { text: lang === 'sv' ? "Hela rutn√§tet har 100 rutor. Varje f√§rgad ruta motsvarar en hundradel (1%)." : "The whole grid has 100 squares. Each colored square corresponds to one hundredth (1%).", latex: `\\frac{1}{100} = 1\\%` },
                    { text: lang === 'sv' ? `Eftersom det √§r ${colored} f√§rgade rutor blir svaret:` : `Since there are ${colored} colored squares, the answer is:`, latex: targetType === 'fraction' ? `\\frac{${colored}}{100}` : `${answer}` }
                ],
                metadata: { variation_key: 'visual_translation', difficulty: 1 }
            };
        }

        if (v === 'visual_lie') {
            const colored = MathUtils.randomInt(15, 85);
            const sTrue1 = `${colored}%`;
            const sTrue2 = (colored > 50) ? (lang === 'sv' ? "Mer √§n h√§lften" : "More than half") : (lang === 'sv' ? "Mindre √§n h√§lften" : "Less than half");
            const sFalse = (colored / 10).toString().replace('.', ',');

            return {
                renderData: {
                    description: lang === 'sv' ? "Granska figuren och p√•st√•endena. Vilket av alternativen √§r FALSKT?" : "Examine the figure and statements. Which of the options is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse]),
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(sFalse),
                clues: [
                    { text: lang === 'sv' ? `Det finns ${colored} f√§rgade rutor av 100 totalt. Det motsvarar ${colored}% eller ${colored/100} i decimalform.` : `There are ${colored} colored squares out of 100 total. That corresponds to ${colored}% or ${colored/100} in decimal form.`, latex: `\\frac{${colored}}{100} = ${colored}\\%` },
                    { text: lang === 'sv' ? "D√§rf√∂r √§r detta p√•st√•ende l√∂gnen:" : "Therefore, this statement is the lie:", latex: `\\text{${sFalse}}` }
                ],
                metadata: { variation_key: 'visual_lie', difficulty: 1 }
            };
        }

        const p = MathUtils.randomChoice([10, 20, 25, 40, 50, 75, 80]);
        const dec = (p / 100).toString().replace('.', ',');
        const wrong = (p / 10).toString().replace('.', ','); 

        return {
            renderData: {
                description: lang === 'sv' ? `Vilket alternativ representerar INTE samma v√§rde som ${p}%?` : `Which of the following options does NOT represent the same value as ${p}%?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([dec, `${p}/100`, `${p/MathUtils.gcd(p,100)}/${100/MathUtils.gcd(p,100)}`, wrong]) 
            },
            token: this.toBase64(wrong),
            clues: [
                { text: lang === 'sv' ? "Procent betyder hundradelar. F√∂r att f√• decimalform flyttar vi decimalkommat tv√• steg till v√§nster." : "Percent means hundredths. To get the decimal form, move the decimal point two places to the left.", latex: `${p}\\% = \\frac{${p}}{100} = ${p/100}` },
                { text: lang === 'sv' ? "Det felaktiga svaret √§r:" : "The incorrect answer is:", latex: `\\text{${wrong}}` }
            ],
            metadata: { variation_key: 'equivalence', difficulty: 1 }
        };
    }

    // --- LEVEL 2: MENTAL MATH ---
    private level2_MentalMath(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['benchmark_calc', 'benchmark_inverse', 'benchmark_commutative']);
        const benchmark = MathUtils.randomChoice([10, 20, 25, 50]);

        if (v === 'benchmark_calc') {
            const step = benchmark === 50 ? 2 : (benchmark === 25 ? 4 : (benchmark === 20 ? 5 : 10));
            const base = MathUtils.randomInt(3, 15) * step;
            const ans = (base * benchmark) / 100;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna ${benchmark}% av ${base}.` : `Calculate ${benchmark}% of ${base}.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `T√§nk p√• ${benchmark}% som br√•kdelen 1/${step}. Du kan d√• bara dela talet med ${step}.` : `Think of ${benchmark}% as the fraction 1/${step}. You can then just divide the number by ${step}.`, latex: `\\frac{${base}}{${step}}` },
                    { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'benchmark_calc', difficulty: 2 }
            };
        }

        if (v === 'benchmark_inverse') {
            const part = MathUtils.randomInt(4, 20);
            const step = benchmark === 50 ? 2 : (benchmark === 25 ? 4 : (benchmark === 20 ? 5 : 10));
            const total = part * step;

            return {
                renderData: {
                    description: lang === 'sv' ? `Om ${benchmark}% av ett ok√§nt tal √§r ${part}, vad √§r d√• 100%?` : `If ${benchmark}% of an unknown number is ${part}, what is 100%?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { text: lang === 'sv' ? `Det g√•r ${step} stycken delar av ${benchmark}% p√• en helhet (100%).` : `There are ${step} parts of ${benchmark}% in a whole (100%).`, latex: `${benchmark}\\% \\cdot ${step} = 100\\%` },
                    { text: lang === 'sv' ? "Multiplicera d√§rf√∂r delens v√§rde med antalet delar:" : "Therefore, multiply the part's value by the number of parts:", latex: `${part} \\cdot ${step} = ${total}` }
                ],
                metadata: { variation_key: 'benchmark_inverse', difficulty: 2 }
            };
        }

        const n1 = MathUtils.randomChoice([25, 50]);
        const n2 = MathUtils.randomInt(4, 15) * (n1 === 25 ? 4 : 2);
        const ans = (n1 * n2) / 100;

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna: ${n2}% av ${n1}.` : `Calculate: ${n2}% of ${n1}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "R√§kna smart genom att byta plats p√• talen: x% av y √§r samma som y% av x." : "Calculate smartly by swapping the numbers: x% of y is the same as y% of x.", latex: `${n1}\\% \\text{ av } ${n2}` },
                { text: lang === 'sv' ? "Detta ger oss svaret:" : "This gives us the answer:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'benchmark_commutative', difficulty: 2 }
        };
    }

    // --- LEVEL 3: BUILDING BLOCKS ---
    private level3_BuildingBlocks(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['composition', 'decomposition', 'estimation']);

        if (v === 'composition') {
            const base = MathUtils.randomInt(4, 15) * 10;
            const pct = MathUtils.randomChoice([30, 40, 60, 70, 80, 90]);
            const ans = (base * pct) / 100;

            return {
                renderData: {
                    description: lang === 'sv' ? `R√§kna ut ${pct}% av ${base} genom att f√∂rst hitta 10%.` : `Calculate ${pct}% of ${base} by first finding 10%.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Hitta f√∂rst 10% genom att dela talet med 10." : "First find 10% by dividing the number by 10.", latex: `10\\% = ${base/10}` },
                    { text: lang === 'sv' ? `Eftersom du vill ha ${pct}%, multiplicera v√§rdet f√∂r 10% med ${pct/10}.` : `Since you want ${pct}%, multiply the value for 10% by ${pct/10}.`, latex: `${base/10} \\cdot ${pct/10} = ${ans}` }
                ],
                metadata: { variation_key: 'composition', difficulty: 2 }
            };
        }

        if (v === 'decomposition') {
            const base = MathUtils.randomInt(5, 20) * 20;
            const ans = (base * 5) / 100;

            return {
                renderData: {
                    description: lang === 'sv' ? `Om 10% av ${base} √§r ${base/10}, vad √§r d√• 5%?` : `If 10% of ${base} is ${base/10}, what is 5%?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "Eftersom 5% √§r h√§lften av 10%, delar vi 10-procentsv√§rdet med 2." : "Since 5% is half of 10%, we divide the 10-percent value by 2.", latex: `\\frac{${base/10}}{2}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'decomposition', difficulty: 2 }
            };
        }

        const base = MathUtils.randomInt(10, 60) * 2;
        const testPct = MathUtils.randomInt(11, 19);
        const target = base * 0.15; 
        const isGreater = (base * testPct / 100) > target;
        const ansTxt = isGreater ? (lang === 'sv' ? "St√∂rre" : "Greater") : (lang === 'sv' ? "Mindre" : "Smaller");

        return {
            renderData: {
                description: lang === 'sv' ? `√Ñr ${testPct}% av ${base} st√∂rre eller mindre √§n ${target.toString().replace('.', ',')}?` : `Is ${testPct}% of ${base} greater or smaller than ${target}?`,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["St√∂rre", "Mindre"] : ["Greater", "Smaller"]
            },
            token: this.toBase64(ansTxt),
            clues: [
                { text: lang === 'sv' ? `Uppskatta genom att j√§mf√∂ra med 15% (h√§lften av 10% + 20%).` : `Estimate by comparing with 15% (half of 10% + 20%).`, latex: `15\\% \\text{ av } ${base} = ${target}` },
                { text: lang === 'sv' ? "D√§rf√∂r √§r svaret:" : "Therefore the answer is:", latex: `\\text{${ansTxt}}` }
            ],
            metadata: { variation_key: 'estimation', difficulty: 3 }
        };
    }

    // --- LEVEL 4: PERCENT EQUATION ---
    private level4_PercentEquation(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['find_percent_basic', 'find_percent_test', 'find_percent_discount', 'find_percent_group']);
        
        const scenarios = {
            find_percent_test: [
                { sv: (p:any, w:any) => `Du svarade r√§tt p√• ${p} fr√•gor av totalt ${w} p√• ett prov. Hur m√•nga procent r√§tt hade du?`, en: (p:any, w:any) => `You answered ${p} questions correctly out of ${w} on a test. What percentage did you get right?` }
            ],
            find_percent_discount: [
                { sv: (p:any, w:any) => `En vara s√§nktes med ${p} kr fr√•n priset ${w} kr. Hur m√•nga procent var s√§nkningen?`, en: (p:any, w:any) => `An item was reduced by ${p} kr from the price ${w} kr. What percentage was the reduction?` }
            ],
            find_percent_group: [
                { sv: (p:any, w:any) => `I en grupp p√• ${w} b√§r ${p} stycken glas√∂gon. Hur stor andel b√§r glas√∂gon i procent?`, en: (p:any, w:any) => `In a group of ${w}, ${p} wear glasses. What percentage of the group wears glasses?` }
            ],
            find_percent_basic: [
                { sv: (p:any, w:any) => `${p} √§r hur m√•nga procent av ${w}?`, en: (p:any, w:any) => `${p} is what percentage of ${w}?` }
            ]
        };

        const w = MathUtils.randomChoice([20, 25, 40, 50, 200]);
        const p = MathUtils.randomChoice([5, 10, 15, 20, 25, 40, 60]);
        const part = (p * w) / 100;

        const s: any = MathUtils.randomChoice(scenarios[v as keyof typeof scenarios]);
        const desc = lang === 'sv' ? s.sv(part, w) : s.en(part, w);

        return {
            renderData: { description: desc, answerType: 'numeric', suffix: '%' },
            token: this.toBase64(p.toString()),
            clues: [
                { text: lang === 'sv' ? "Dividera delen med det hela f√∂r att f√• fram andelen." : "Divide the part by the whole to find the share.", latex: `\\frac{${part}}{${w}}` },
                { text: lang === 'sv' ? "F√∂rl√§ng eller f√∂rkorta br√•ket s√• att n√§mnaren blir 100." : "Extend or simplify the fraction so the denominator is 100.", latex: `\\frac{${p}}{100} = ${p}\\%` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${p}\\%` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 5: REVERSE PERCENTAGE ---
    private level5_ReversePercentage(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['reverse_find_whole', 'reverse_scaling', 'reverse_concept']);

        if (v === 'reverse_find_whole') {
            const p = MathUtils.randomChoice([5, 10, 20, 25, 50]);
            const w = MathUtils.randomInt(4, 15) * 20;
            const part = (p * w) / 100;

            const scenarios = [
                { sv: `${p}% av deltagarna √§r ${part} personer. Hur m√•nga deltog totalt?`, en: `${p}% of participants is ${part} people. How many participated total?` },
                { sv: `${p}% av pengarna √§r ${part} kr. Hur mycket finns det totalt?`, en: `${p}% of the money is ${part} kr. How much is there total?` }
            ];
            const s = MathUtils.randomChoice(scenarios);

            return {
                renderData: { description: lang === 'sv' ? s.sv : s.en, answerType: 'numeric' },
                token: this.toBase64(w.toString()),
                clues: [
                    { text: lang === 'sv' ? `Hitta f√∂rst vad 1% √§r genom att dela ${part} med ${p}.` : `First find what 1% is by dividing ${part} by ${p}.`, latex: `1\\% = \\frac{${part}}{${p}} = ${part/p}` },
                    { text: lang === 'sv' ? "Multiplicera nu resultatet med 100 f√∂r att f√• fram 100%." : "Now multiply the result by 100 to find 100%.", latex: `${part/p} \\cdot 100 = ${w}` },
                    { text: lang === 'sv' ? "Hela antalet √§r:" : "The whole quantity is:", latex: `${w}` }
                ],
                metadata: { variation_key: 'reverse_find_whole', difficulty: 3 }
            };
        }

        if (v === 'reverse_scaling') {
            const val10 = MathUtils.randomInt(8, 60);
            const targetP = MathUtils.randomChoice([30, 40, 70, 80]);
            const factor = targetP / 10;
            const ans = val10 * factor;

            return {
                renderData: {
                    description: lang === 'sv' ? `10% av ett pris √§r ${val10} kr. Vad √§r d√• ${targetP}%?` : `10% of a price is ${val10} kr. What is ${targetP}%?`,
                    answerType: 'numeric', suffix: 'kr'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Eftersom ${targetP}% √§r ${factor} g√•nger s√• mycket som 10%, multiplicerar vi v√§rdet med ${factor}.` : `Since ${targetP}% is ${factor} times as much as 10%, we multiply the value by ${factor}.`, latex: `${val10} \\cdot ${factor}` },
                    { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'reverse_scaling', difficulty: 3 }
            };
        }

        const ansL = lang === 'sv' ? "Multiplicera med 4" : "Multiply by 4";
        return {
            renderData: {
                description: lang === 'sv' ? "Om man vet vad 25% √§r, hur f√•r man d√• fram 100%?" : "If you know what 25% is, how do you find 100%?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([ansL, lang === 'sv' ? "Dividera med 4" : "Divide by 4", lang === 'sv' ? "Multiplicera med 25" : "Multiply by 25"])
            },
            token: this.toBase64(ansL),
            clues: [
                { text: lang === 'sv' ? "25% motsvarar en fj√§rdedel (1/4). Fyra s√•dana delar bildar 100%." : "25% corresponds to one fourth (1/4). Four such parts form 100%.", latex: "4 \\cdot 25\\% = 100\\%" },
                { text: lang === 'sv' ? "D√§rf√∂r ska man:" : "Therefore, you should:", latex: `\\text{${ansL}}` }
            ],
            metadata: { variation_key: 'reverse_concept', difficulty: 2 }
        };
    }

    // --- LEVEL 6: PERCENTAGE CHANGE ---
    private level6_PercentageChange(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['change_calc', 'change_multiplier', 'change_trap']);

        if (v === 'change_calc') {
            const oldVal = MathUtils.randomInt(3, 12) * 100;
            const p = MathUtils.randomChoice([10, 20, 25, 40, 50]);
            const isInc = Math.random() > 0.5;
            const newVal = isInc ? oldVal * (1 + p/100) : oldVal * (1 - p/100);

            return {
                renderData: {
                    description: lang === 'sv' ? `Ett v√§rde √§ndrades fr√•n ${oldVal} till ${newVal}. Vad var f√∂r√§ndringen i procent?` : `A value changed from ${oldVal} to ${newVal}. What was the change in percent?`,
                    answerType: 'numeric', suffix: '%'
                },
                token: this.toBase64(p.toString()),
                clues: [
                    { text: lang === 'sv' ? "Ber√§kna skillnaden och dividera den med det gamla v√§rdet." : "Calculate the difference and divide it by the old value.", latex: `\\frac{|${newVal} - ${oldVal}|}{${oldVal}}` },
                    { text: lang === 'sv' ? "Svaret i procent √§r:" : "The answer in percent is:", latex: `${p}\\%` }
                ],
                metadata: { variation_key: 'change_calc', difficulty: 4 }
            };
        }

        if (v === 'change_multiplier') {
            const p = MathUtils.randomInt(5, 50);
            const isInc = Math.random() > 0.5;
            const ans = isInc ? (1 + p/100) : (1 - p/100);

            return {
                renderData: {
                    description: lang === 'sv' ? `Ange f√∂r√§ndringsfaktorn f√∂r en ${isInc ? '√∂kning' : 'minskning'} med ${p}%.` : `State the change factor for a ${isInc ? 'increase' : 'decrease'} of ${p}%.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString().replace('.', ',')),
                clues: [
                    { text: lang === 'sv' ? (isInc ? "Addera procentsatsen till 1,00." : "Subtrahera procentsatsen fr√•n 1,00.") : (isInc ? "Add the percentage to 1.00." : "Subtract the percentage from 1.00."), latex: isInc ? `1.00 + ${p/100}` : `1.00 - ${p/100}` },
                    { text: lang === 'sv' ? "Faktorn √§r:" : "The factor is:", latex: `${ans.toString().replace('.', ',')}` }
                ],
                metadata: { variation_key: 'change_multiplier', difficulty: 3 }
            };
        }

        const ansL = lang === 'sv' ? "Det √§r l√§gre √§n startpriset" : "It is lower than the starting price";
        return {
            renderData: {
                description: lang === 'sv' ? "Ett pris h√∂js f√∂rst med 10% och s√§nks sedan med 10%. Vad h√§nder med priset?" : "A price first increases by 10% and then decreases by 10%. What happens to the price?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([ansL, lang === 'sv' ? "Det √§r samma som startpriset" : "It is the same as the starting price", lang === 'sv' ? "Det √§r h√∂gre √§n startpriset" : "It is higher than the starting price"])
            },
            token: this.toBase64(ansL),
            clues: [
                { text: lang === 'sv' ? "Den sista s√§nkningen ber√§knas p√• ett h√∂gre belopp, vilket g√∂r att man tappar mer √§n man f√∂rst vann." : "The final decrease is calculated on a larger amount, meaning you lose more than you first gained.", latex: `1.10 \\cdot 0.90 = 0.99` },
                { text: lang === 'sv' ? "Svaret √§r d√§rf√∂r:" : "The answer is therefore:", latex: `\\text{${ansL}}` }
            ],
            metadata: { variation_key: 'change_trap', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\PercentGen.ts

// =======================================================
// FILE START: src\core\generators\ProbabilityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ProbabilityGen {
    // --- CONTEXT LIBRARY ---
    private static readonly SCENARIOS = {
        containers: [
            { sv: "en p√•se", en: "a bag" },
            { sv: "en ask", en: "a box" },
            { sv: "en burk", en: "a jar" },
            { sv: "en sk√•l", en: "a bowl" }
        ],
        items: [
            { sv: ["r√∂da", "bl√•a", "gr√∂na"], en: ["red", "blue", "green"], type: "marbles" },
            { sv: ["sura", "s√∂ta", "starka"], en: ["sour", "sweet", "spicy"], type: "candies" },
            { sv: ["√§pplen", "bananer", "p√§ron"], en: ["apples", "bananas", "pears"], type: "fruits" }
        ],
        lotteries: [
            { sv: "Lotteri A", en: "Lottery A" },
            { sv: "Lotteri B", en: "Lottery B" },
            { sv: "Hjul X", en: "Spinner X" },
            { sv: "Hjul Y", en: "Spinner Y" }
        ],
        likelihood: [
            { category: 'impossible', sv: ["att sl√• en 7:a med en vanlig t√§rning", "att en triangel har 4 h√∂rn"], en: ["rolling a 7 on a standard die", "a triangle having 4 corners"], val: 0 },
            { category: 'certain', sv: ["att det blir natt efter dag", "att f√• krona eller klave vid ett myntkast"], en: ["night following day", "getting heads or tails on a coin flip"], val: 1 },
            { category: 'even', sv: ["att f√• krona vid slantsingling", "att sl√• ett j√§mnt tal med en t√§rning"], en: ["getting heads on a coin toss", "rolling an even number on a die"], val: 0.5 }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_StandardGroups(lang);
            case 3: return this.level3_ConceptsAndLogic(lang);
            case 4: return this.level4_Complementary(lang);
            case 5: return this.level5_ProbabilityTree(lang);
            case 6: return this.level6_EventChains(lang);
            case 7: return this.level7_Combinatorics(lang);
            case 8: return this.level8_CombinatoricsComplex(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'visual_not':
            case 'visual_or':
            case 'visual_calc':
            case 'visual_spinner':
                return this.level1_Visuals(lang, key);
            case 'group_ratio':
            case 'group_ternary':
                return this.level2_StandardGroups(lang, key);
            case 'concept_compare':
            case 'concept_validity':
            case 'concept_likelihood':
                return this.level3_ConceptsAndLogic(lang, key);
            case 'comp_at_least':
            case 'comp_multi':
            case 'comp_lie':
                return this.level4_Complementary(lang, key);
            case 'tree_missing':
            case 'tree_calc':
                return this.level5_ProbabilityTree(lang, key);
            case 'chain_any_order':
            case 'chain_fixed_order':
                return this.level6_EventChains(lang, key);
            case 'comb_constraint':
            case 'comb_handshake':
                return this.level7_Combinatorics(lang, key);
            case 'pathways_basic':
            case 'pathways_blocked':
            case 'pathways_prob':
                return this.level8_CombinatoricsComplex(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private rawFraction(n: number, d: number): string {
        return `${n}/${d}`;
    }

    // --- LEVEL 1: VISUALS ---
    private level1_Visuals(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['visual_not', 'visual_or', 'visual_calc', 'visual_spinner']);
        const counts = [MathUtils.randomInt(2, 5), MathUtils.randomInt(2, 5), MathUtils.randomInt(1, 4)];
        const total = counts.reduce((a, b) => a + b, 0);
        const labels = lang === 'sv' ? ["R√∂d", "Bl√•", "Gr√∂n"] : ["Red", "Blue", "Green"];
        const container = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.containers);

        if (v === 'visual_spinner') {
            const sections = MathUtils.randomChoice([4, 6, 8, 10, 12]);
            const winSections = MathUtils.randomInt(1, sections - 1);
            const ans = this.rawFraction(winSections, sections);

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Ett lyckohjul har ${sections} lika stora delar. ${winSections} av dem ger vinst. Vad √§r sannolikheten att du vinner?` 
                        : `A spinner has ${sections} equal parts. ${winSections} of them are winning sections. What is the probability of winning?`,
                    answerType: 'fraction',
                    geometry: { type: 'probability_spinner', sections }
                },
                token: this.toBase64(ans),
                clues: [
                    { 
                        text: lang === 'sv' ? "Sannolikheten ber√§knas genom att dela antalet vinstf√§lt med det totala antalet f√§lt." : "Probability is calculated by dividing the winning sections by the total number of sections.", 
                        latex: `P = \\frac{\\text{Gynnsamma}}{\\text{M√∂jliga}} \\rightarrow \\frac{${winSections}}{${sections}}` 
                    },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'visual_spinner', difficulty: 1 }
            };
        }

        if (v === 'visual_not') {
            const targetIdx = MathUtils.randomInt(0, 2);
            const ansCount = total - counts[targetIdx];
            const ans = this.rawFraction(ansCount, total);

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `I ${container.sv} finns ${total} kulor. Vad √§r sannolikheten att du INTE drar en ${labels[targetIdx].toLowerCase()} kula?` 
                        : `In ${container.en} there are ${total} marbles. What is the probability that you do NOT pick a ${labels[targetIdx].toLowerCase()} marble?`,
                    answerType: 'fraction',
                    geometry: { type: 'probability_marbles', items: { red: counts[0], blue: counts[1], green: counts[2] } }
                },
                token: this.toBase64(ans),
                clues: [
                    { 
                        text: lang === 'sv' ? `R√§kna f√∂rst hur m√•nga kulor som inte √§r ${labels[targetIdx].toLowerCase()}.` : `First, count how many marbles are not ${labels[targetIdx].toLowerCase()}.`, 
                        latex: `${total} - ${counts[targetIdx]} = ${ansCount} \\rightarrow \\text{Andel} = \\frac{${ansCount}}{${total}}` 
                    },
                    { text: lang === 'sv' ? "Sannolikheten √§r:" : "The probability is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'visual_not', difficulty: 2 }
            };
        }

        if (v === 'visual_or') {
            const indices = MathUtils.shuffle([0, 1, 2]);
            const idx1 = indices[0], idx2 = indices[1];
            const ansCount = counts[idx1] + counts[idx2];
            const ans = this.rawFraction(ansCount, total);

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Vad √§r sannolikheten att du f√•r antingen en ${labels[idx1].toLowerCase()} eller en ${labels[idx2].toLowerCase()} kula?`
                        : `What is the probability that you get either a ${labels[idx1].toLowerCase()} or a ${labels[idx2].toLowerCase()} marble?`,
                    answerType: 'fraction',
                    geometry: { type: 'probability_marbles', items: { red: counts[0], blue: counts[1], green: counts[2] } }
                },
                token: this.toBase64(ans),
                clues: [
                    { 
                        text: lang === 'sv' ? `L√§gg ihop antalet f√∂r de tv√• f√§rgerna som efterfr√•gas.` : `Add the counts for the two colors requested.`, 
                        latex: `${counts[idx1]} + ${counts[idx2]} = ${ansCount} \\rightarrow \\frac{${ansCount}}{${total}}` 
                    },
                    { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'visual_or', difficulty: 2 }
            };
        }

        const target = MathUtils.randomInt(0, 2);
        const ans = this.rawFraction(counts[target], total);
        return {
            renderData: {
                description: lang === 'sv' ? `Vad √§r sannolikheten att du drar en ${labels[target].toLowerCase()} kula?` : `What is the probability that you pick a ${labels[target].toLowerCase()} marble?`,
                answerType: 'fraction',
                geometry: { type: 'probability_marbles', items: { red: counts[0], blue: counts[1], green: counts[2] } }
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Sannolikhet = (Antal gynsamma utfall) / (Totala antalet utfall)." : "Probability = (Number of desired outcomes) / (Total number of outcomes).", latex: `\\frac{${counts[target]}}{${total}}` },
                { text: lang === 'sv' ? "Resultat:" : "Result:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'visual_calc', difficulty: 1 }
        };
    }

    // --- LEVEL 2: GROUPS & RATIOS ---
    private level2_StandardGroups(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['group_ratio', 'group_ternary']);
        const ctx = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.items);
        const labels = lang === 'sv' ? ctx.sv : ctx.en;

        if (v === 'group_ratio') {
            const r1 = MathUtils.randomInt(1, 6), r2 = MathUtils.randomInt(1, 6);
            const totalParts = r1 + r2;
            const ans = this.rawFraction(r1, totalParts);

            return {
                renderData: { 
                    description: lang === 'sv' 
                        ? `F√∂rh√•llandet mellan ${labels[0]} och ${labels[1]} √§r ${r1}:${r2}. Vad √§r sannolikheten att dra en ${labels[0]}?` 
                        : `The ratio between ${labels[0]} and ${labels[1]} is ${r1}:${r2}. What is the probability of picking a ${labels[0]}?`, 
                    answerType: 'fraction' 
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Summera delarna i f√∂rh√•llandet f√∂r att f√• det totala antalet delar." : "Sum the parts in the ratio to get the total number of parts.", latex: `${r1} + ${r2} = ${totalParts} \\rightarrow P = \\frac{${r1}}{${totalParts}}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'group_ratio', difficulty: 3 }
            };
        }

        const a = MathUtils.randomInt(3, 8), b = MathUtils.randomInt(3, 8), extra = MathUtils.randomInt(2, 6);
        const total = a + b + extra;
        const ans = this.rawFraction(extra, total);

        return {
            renderData: { 
                description: lang === 'sv' 
                    ? `I en l√•da finns ${total} saker. ${a} √§r ${labels[0]} och ${b} √§r ${labels[1]}. Resten √§r ${labels[2]}. Vad √§r sannolikheten att f√• en ${labels[2]}?` 
                    : `In a box there are ${total} items. ${a} are ${labels[0]} and ${b} are ${labels[1]}. The rest are ${labels[2]}. What is the probability of picking a ${labels[2]}?`, 
                answerType: 'fraction' 
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? `R√§kna f√∂rst ut antalet ${labels[2]} genom subtraktion.` : `First, calculate the count of ${labels[2]} using subtraction.`, latex: `${total} - ${a} - ${b} = ${extra} \\rightarrow \\frac{${extra}}{${total}}` },
                { text: lang === 'sv' ? "Sannolikheten blir:" : "The probability becomes:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'group_ternary', difficulty: 2 }
        };
    }

    // --- LEVEL 3: CONCEPTS & LOGIC ---
    private level3_ConceptsAndLogic(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['concept_compare', 'concept_validity', 'concept_likelihood']);

        if (v === 'concept_likelihood') {
            const cat = MathUtils.randomChoice(['impossible', 'certain', 'even']);
            const scenarioObj = ProbabilityGen.SCENARIOS.likelihood.find(x => x.category === cat)!;
            const scenario = MathUtils.randomChoice(lang === 'sv' ? scenarioObj.sv : scenarioObj.en);
            const label = lang === 'sv' 
                ? (cat === 'impossible' ? "Om√∂jligt" : cat === 'certain' ? "S√§kert" : "H√§lften/H√§lften")
                : (cat === 'impossible' ? "Impossible" : cat === 'certain' ? "Certain" : "Even chance");

            return {
                renderData: {
                    description: lang === 'sv' ? `Hur sannolikt √§r det: "${scenario}"?` : `How likely is this: "${scenario}"?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Om√∂jligt", "S√§kert", "H√§lften/H√§lften"] : ["Impossible", "Certain", "Even chance"]
                },
                token: this.toBase64(label),
                clues: [
                    { text: lang === 'sv' ? "Bed√∂m om h√§ndelsen aldrig kan ske (0), alltid m√•ste ske (1) eller har en 50/50-chans (0,5)." : "Assess if the event can never happen (0), must always happen (1), or has a 50/50 chance (0.5)." },
                    { text: lang === 'sv' ? "R√§tt svar √§r:" : "The correct answer is:", latex: `\\text{${label}}` }
                ],
                metadata: { variation_key: 'concept_likelihood', difficulty: 1 }
            };
        }

        if (v === 'concept_compare') {
            const aD = MathUtils.randomInt(3, 5), bD = MathUtils.randomInt(6, 10);
            const aN = 1, bN = MathUtils.randomInt(2, 4);
            const valA = aN / aD, valB = bN / bD;

            const l1 = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.lotteries);
            const l2 = MathUtils.randomChoice(ProbabilityGen.SCENARIOS.lotteries.filter(x => x !== l1));
            const options = lang === 'sv' ? [l1.sv, l2.sv, "Lika stor"] : [l1.en, l2.en, "Equal"];
            const ans = valB > valA ? options[1] : (valA > valB ? options[0] : options[2]);

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Var √§r chansen st√∂rst: I ${l1.sv} (chans ${aN}/${aD}) eller i ${l2.sv} (chans ${bN}/${bD})?` 
                        : `Where is the chance greatest: In ${l1.en} (chance ${aN}/${aD}) or in ${l2.en} (chance ${bN}/${bD})?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(options)
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "G√∂r om br√•ken till decimalform f√∂r att j√§mf√∂ra v√§rdena." : "Convert the fractions to decimals to compare the values.", latex: `\\frac{${aN}}{${aD}} \\approx ${valA.toFixed(2)} \\quad \\text{vs} \\quad \\frac{${bN}}{${bD}} \\approx ${valB.toFixed(2)}` },
                    { text: lang === 'sv' ? "Det st√∂rsta v√§rdet √§r:" : "The largest value is:", latex: `\\text{${ans}}` }
                ],
                metadata: { variation_key: 'concept_compare', difficulty: 3 }
            };
        }

        const validVal = (MathUtils.randomInt(1, 99) / 100).toString();
        const invalidVals = [ (MathUtils.randomInt(11, 20) / 10).toString(), ("-" + (MathUtils.randomInt(1, 5) / 10)).toString() ];

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket v√§rde kan representera en sannolikhet?" : "Which value can represent a probability?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([validVal, ...invalidVals])
            },
            token: this.toBase64(validVal),
            clues: [
                { text: lang === 'sv' ? "En sannolikhet m√•ste ligga mellan 0 och 1. V√§rden under noll eller √∂ver ett √§r om√∂jliga." : "A probability must be between 0 and 1. Values below zero or above one are impossible." },
                { text: lang === 'sv' ? "Det giltiga v√§rdet √§r:" : "The valid value is:", latex: `${validVal}` }
            ],
            metadata: { variation_key: 'concept_validity', difficulty: 1 }
        };
    }

    // --- LEVEL 4: COMPLEMENTARY ---
    private level4_Complementary(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['comp_at_least', 'comp_multi', 'comp_lie']);

        if (v === 'comp_at_least') {
            const d = MathUtils.randomChoice([3, 4, 5]);
            const trials = 2;
            const pNoneN = Math.pow(d - 1, trials);
            const pNoneD = Math.pow(d, trials);
            const ansN = pNoneD - pNoneN;
            const ans = this.rawFraction(ansN, pNoneD);

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `Chansen att vinna √§r 1/${d}. Om du spelar ${trials} g√•nger, vad √§r sannolikheten att vinna MINST en g√•ng?` 
                        : `The chance of winning is 1/${d}. If you play ${trials} times, what is the probability of winning AT LEAST once?`,
                    answerType: 'fraction'
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "R√§kna ut risken att h√§ndelsen ALDRIG sker f√∂rst." : "First, calculate the risk of the event NEVER happening.", latex: `P(\\text{Aldrig}) = \\frac{${d-1}}{${d}} \\cdot \\frac{${d-1}}{${d}} = \\frac{${pNoneN}}{${pNoneD}} \\rightarrow P(\\text{Minst en}) = 1 - \\frac{${pNoneN}}{${pNoneD}}` },
                    { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'comp_at_least', difficulty: 4 }
            };
        }

        if (v === 'comp_lie') {
            const lieVal = "1.5";
            const lie = lang === 'sv' ? `Summan av alla utfall kan bli ${lieVal}` : `The sum of all outcomes can be ${lieVal}`;
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket p√•st√•ende √§r FELAKTIGT?" : "Which statement is INCORRECT?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([lie, lang === 'sv' ? "Summan av alla utfall √§r alltid 1" : "The sum of all outcomes is always 1", "P(A) + P(not A) = 1"])
                },
                token: this.toBase64(lie),
                clues: [
                    { text: lang === 'sv' ? "Summan av alla m√∂jliga h√§ndelser i ett experiment m√•ste alltid bli exakt 100% eller 1." : "The sum of all possible events in an experiment must always equal exactly 100% or 1." },
                    { text: lang === 'sv' ? "Felaktigt p√•st√•ende:" : "Incorrect statement:", latex: `\\text{${lie}}` }
                ],
                metadata: { variation_key: 'comp_lie', difficulty: 2 }
            };
        }

        const pA = 20, pB = 30;
        const pRest = 100 - pA - pB;
        return {
            renderData: {
                description: lang === 'sv' ? `Chans f√∂r vinst A: ${pA}%, vinst B: ${pB}%. Vad √§r chansen att INTE vinna n√•got?` : `Chance for prize A: ${pA}%, prize B: ${pB}%. What is the chance of NOT winning anything?`,
                answerType: 'numeric', suffix: '%'
            },
            token: this.toBase64(pRest.toString()),
            clues: [
                { text: lang === 'sv' ? "Dra bort alla k√§nda vinstchanser fr√•n helheten (100%)." : "Subtract all known winning chances from the whole (100%).", latex: `100\\% - (${pA}\\% + ${pB}\\%) = ${pRest}\\%` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${pRest}\\%` }
            ],
            metadata: { variation_key: 'comp_multi', difficulty: 2 }
        };
    }

    // --- LEVEL 5: PROBABILITY TREES ---
    private level5_ProbabilityTree(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['tree_missing', 'tree_calc']);

        if (v === 'tree_missing') {
            const d1 = 2, d2 = 3, dTot = 6;
            return {
                renderData: {
                    description: lang === 'sv' ? `En gren slutar p√• 1/${dTot}. F√∂rsta steget var 1/${d1}. Vad var andra steget?` : `A branch ends at 1/${dTot}. The first step was 1/${d1}. What was the second step?`,
                    answerType: 'fraction'
                },
                token: this.toBase64(this.rawFraction(1, d2)),
                clues: [
                    { text: lang === 'sv' ? "Sannolikheter l√§ngs en gren multipliceras. F√∂r att hitta en saknad del dividerar vi resultatet med den k√§nda delen." : "Probabilities along a branch are multiplied. To find a missing part, divide the result by the known part.", latex: `\\frac{1}{${dTot}} \\div \\frac{1}{${d1}} = \\frac{1}{${d2}}` },
                    { text: lang === 'sv' ? "Det saknade steget √§r:" : "The missing step is:", latex: `\\frac{1}{${d2}}` }
                ],
                metadata: { variation_key: 'tree_missing', difficulty: 3 }
            };
        }

        const c1 = 3, c2 = 2;
        const tot = 5;
        const ansN = c1 * c2, ansD = tot * (tot - 1);
        const ans = this.rawFraction(ansN, ansD);

        return {
            renderData: {
                description: lang === 'sv' ? `Dra tv√• kulor utan √•terl√§ggning. ${c1} R√∂da, ${c2} Bl√•. Sannolikhet f√∂r R√∂d sen Bl√•?` : `Pick two marbles without replacement. ${c1} Red, ${c2} Blue. Probability of Red then Blue?`,
                answerType: 'fraction',
                geometry: { type: 'probability_tree', groups: ["R", "B"], initialCounts: [c1, c2], targetBranch: 's2_1' }
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Multiplicera chansen f√∂r det f√∂rsta draget med chansen f√∂r det andra. Gl√∂m inte att totalen minskar." : "Multiply the chance of the first pick by the chance of the second. Don't forget that the total decreases.", latex: `\\frac{${c1}}{${tot}} \\cdot \\frac{${c2}}{${tot-1}} = \\frac{${ansN}}{${ansD}}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'tree_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 6: EVENT CHAINS ---
    private level6_EventChains(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['chain_any_order', 'chain_fixed_order']);
        const a = 3, b = 3;
        const total = 6;

        if (v === 'chain_any_order') {
            const ansN = (a * b) * 2;
            const ansD = total * (total - 1);
            const ans = this.rawFraction(ansN, ansD);

            return {
                renderData: {
                    description: lang === 'sv' ? `Dra tv√• frukter utan √•terl√§ggning (${a} R√∂da, ${b} Bl√•). Chans f√∂r en av varje f√§rg?` : `Pick two fruits without replacement (${a} Red, ${b} Blue). Chance for one of each color?`,
                    answerType: 'fraction'
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Det finns tv√• m√∂jliga ordningar: (R√∂d, Bl√•) eller (Bl√•, R√∂d). Ber√§kna en gren och dubblera resultatet." : "There are two possible orders: (Red, Blue) or (Blue, Red). Calculate one branch and double the result.", latex: `2 \\cdot (\\frac{${a}}{${total}} \\cdot \\frac{${b}}{${total-1}}) = \\frac{${ansN}}{${ansD}}` },
                    { text: lang === 'sv' ? "Total chans:" : "Total chance:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'chain_any_order', difficulty: 4 }
            };
        }

        const ansN = b * (b - 1);
        const ansD = total * (total - 1);
        const ans = this.rawFraction(ansN, ansD);

        return {
            renderData: {
                description: lang === 'sv' ? `Vad √§r sannolikheten att dra tv√• bl√•a i rad? (Totalt ${a} r√∂da, ${b} bl√•a).` : `What is the probability of picking two blue in a row? (Total ${a} red, ${b} blue).`,
                answerType: 'fraction'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Minska b√•de antalet bl√•a och det totala antalet inf√∂r det andra draget." : "Decrease both the count of blue and the total count before the second pick.", latex: `\\frac{${b}}{${total}} \\cdot \\frac{${b-1}}{${total-1}} = \\frac{${ansN}}{${ansD}}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'chain_fixed_order', difficulty: 3 }
        };
    }

    // --- LEVEL 7: COMBINATORICS ---
    private level7_Combinatorics(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['comb_constraint', 'comb_handshake']);

        if (v === 'comb_constraint') {
            const c1 = 4, c2 = 3;
            const ans = (c1 * c2).toString();
            return {
                renderData: {
                    description: lang === 'sv' ? `Du har ${c1} tr√∂jor och ${c2} byxor. P√• hur m√•nga s√§tt kan du kombinera dem?` : `You have ${c1} shirts and ${c2} pants. In how many ways can you combine them?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Anv√§nd multiplikationsprincipen: multiplicera antalet val i det f√∂rsta steget med antalet val i det andra." : "Use the multiplication principle: multiply the choices in the first step by the choices in the second.", latex: `${c1} \\cdot ${c2} = ${ans}` },
                    { text: lang === 'sv' ? "Antal kombinationer:" : "Number of combinations:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'comb_constraint', difficulty: 3 }
            };
        }

        const n = 6;
        const ans = ((n * (n - 1)) / 2).toString();
        return {
            renderData: {
                description: lang === 'sv' ? `${n} personer skakar hand med alla p√• en fest. Hur m√•nga handskakningar sker?` : `${n} people shake hands with everyone at a party. How many handshakes occur?`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Varje person skakar hand med n-1 andra. Dela med 2 eftersom varje handskakning sker mellan tv√• personer." : "Each person shakes hands with n-1 others. Divide by 2 because each handshake happens between two people.", latex: `\\frac{${n} \\cdot ${n-1}}{2} = ${ans}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'comb_handshake', difficulty: 3 }
        };
    }

    // --- LEVEL 8: COMPLEX PATHWAYS ---
    private level8_CombinatoricsComplex(lang: string, variationKey?: string): any {
        const v = variationKey || 'pathways_basic';
        const layers = [1, 2, 3, 1];
        const totalPaths = 6;
        const ans = v === 'pathways_prob' ? this.rawFraction(totalPaths, totalPaths) : totalPaths.toString();

        return {
            renderData: {
                description: lang === 'sv' ? "Hur m√•nga v√§gar finns fr√•n A till B?" : "How many paths are there from A to B?",
                answerType: v === 'pathways_prob' ? 'fraction' : 'numeric',
                geometry: { type: 'probability_tree', subtype: 'pathway', layers, obstacles: [] }
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "R√§kna valen i varje lager och multiplicera dem." : "Count the choices in each layer and multiply them.", latex: `${layers[1]} \\cdot ${layers[2]} = ${totalPaths}` },
                { text: lang === 'sv' ? "Antalet v√§gar √§r:" : "The number of paths is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 5 }
        };
    }
}

// FILE END: src\core\generators\ProbabilityGen.ts

// =======================================================
// FILE START: src\core\generators\PythagorasGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PythagorasGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SquaresRoots(lang);
            case 2: return this.level2_Hypotenuse(lang);
            case 3: return this.level3_Leg(lang);
            case 4: return this.level4_Applications(lang);
            case 5: return this.level5_Converse(lang);
            case 6: return this.level6_AdvancedMixed(lang);
            default: return this.level1_SquaresRoots(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'sqrt_calc':
            case 'square_calc':
            case 'missing_square':
            case 'sqrt_estimation':
                return this.level1_SquaresRoots(lang, key);
            case 'hyp_visual':
            case 'hyp_equation':
            case 'hyp_error':
                return this.level2_Hypotenuse(lang, key);
            case 'leg_visual':
            case 'leg_concept':
            case 'leg_text':
                return this.level3_Leg(lang, key);
            case 'app_ladder':
            case 'app_diagonal':
            case 'app_displacement':
            case 'app_guy_wire':
            case 'app_coords':
                return this.level4_Applications(lang, key);
            case 'conv_check':
            case 'conv_missing':
            case 'conv_trap':
                return this.level5_Converse(lang, key);
            case 'advanced_mixed':
                return this.level6_AdvancedMixed(lang);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    /**
     * Converts standard numbers into Unicode superscript strings for clear button display.
     */
    private toSup(num: number | string): string {
        const map: any = {
            '0': '‚Å∞', '1': '¬π', '2': '¬≤', '3': '¬≥', '4': '‚Å¥',
            '5': '‚Åµ', '6': '‚Å∂', '7': '‚Å∑', '8': '‚Å∏', '9': '‚Åπ', '-': '‚Åª'
        };
        return num.toString().split('').map(char => map[char] || char).join('');
    }

    private getTriple(): { a: number, b: number, c: number, k: number } {
        const primitives = [
            [3, 4, 5], [5, 12, 13], [8, 15, 17], [7, 24, 25], [20, 21, 29],
            [12, 35, 37], [9, 40, 41], [28, 45, 53], [11, 60, 61], [16, 63, 65]
        ];
        const base = MathUtils.randomChoice(primitives);
        const k = MathUtils.randomChoice([1, 1, 2, 2, 3]); 
        return { a: base[0] * k, b: base[1] * k, c: base[2] * k, k: k };
    }

    // --- LEVEL 1: SQUARES & ROOTS ---
    private level1_SquaresRoots(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sqrt_calc', 'square_calc', 'missing_square', 'sqrt_estimation']);

        if (v === 'sqrt_calc' || v === 'square_calc') {
            const isRoot = v === 'sqrt_calc';
            const base = MathUtils.randomInt(2, 15);
            const square = base * base;
            const desc = lang === 'sv' 
                ? (isRoot ? "Ber√§kna kvadratroten ur talet nedan." : "Ber√§kna kvadraten av talet nedan.")
                : (isRoot ? "Calculate the square root of the number below." : "Calculate the square of the number below.");

            const ans = isRoot ? base.toString() : square.toString();

            return {
                renderData: {
                    description: desc,
                    latex: isRoot ? `\\sqrt{${square}}` : `${base}^2`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? (isRoot ? `Vi s√∂ker ett tal som multiplicerat med sig sj√§lvt blir ${square}.` : `Kvadrering inneb√§r att man multiplicerar talet med sig sj√§lvt en g√•ng.`) 
                            : (isRoot ? `We are looking for a number that, when multiplied by itself, equals ${square}.` : `Squaring means multiplying the number by itself once.`), 
                        latex: isRoot ? `? \\cdot ? = ${square}` : `${base} \\cdot ${base} = ${square}` 
                    },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }

        if (v === 'missing_square') {
            const base = MathUtils.randomInt(2, 12);
            const square = base * base;
            return {
                renderData: {
                    description: lang === 'sv' ? "Hitta v√§rdet p√• x i ekvationen." : "Find the value of x in the equation.",
                    latex: `x^2 = ${square}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(base.toString()),
                clues: [
                    { text: lang === 'sv' ? "F√∂r att l√∂sa ut x n√§r det √§r upph√∂jt till tv√• anv√§nder vi kvadratroten." : "To solve for x when it is squared, we use the square root.", latex: `x = \\sqrt{${square}}` },
                    { text: lang === 'sv' ? "Detta ger oss svaret:" : "This gives us the answer:", latex: `${base}` }
                ],
                metadata: { variation_key: 'missing_square', difficulty: 2 }
            };
        }

        const base = MathUtils.randomInt(4, 10);
        const square = base * base; 
        const offset = MathUtils.randomChoice([-5, 5]);
        const testVal = square + offset; 
        const isGreater = offset > 0;
        const ans = isGreater ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");

        return {
            renderData: {
                description: lang === 'sv' ? `√Ñr $\\sqrt{${testVal}}$ st√∂rre √§n ${base}?` : `Is $\\sqrt{${testVal}}$ greater than ${base}?`,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"]
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? `Vi vet att kvadraten av ${base} √§r ${square}.` : `We know the square of ${base} is ${square}.`, latex: `${base}^2 = ${square}` },
                { text: lang === 'sv' ? `Eftersom ${testVal} √§r ${isGreater ? 'st√∂rre' : 'mindre'} √§n ${square}, s√• √§r dess kvadratrot ${isGreater ? 'st√∂rre' : 'mindre'} √§n ${base}.` : `Since ${testVal} is ${isGreater ? 'greater' : 'less'} than ${square}, its square root is ${isGreater ? 'greater' : 'less'} than ${base}.`, latex: `\\sqrt{${testVal}} \\text{ vs } \\sqrt{${square}}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `\\text{${ans}}` }
            ],
            metadata: { variation_key: 'sqrt_estimation', difficulty: 2 }
        };
    }

    // --- LEVEL 2: HYPOTENUSE ---
    private level2_Hypotenuse(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['hyp_visual', 'hyp_equation', 'hyp_error']);
        const t = this.getTriple();

        if (v === 'hyp_equation') {
            const correct = `${t.a}¬≤ + ${t.b}¬≤ = x¬≤`;
            const wrong1 = `${t.a}¬≤ + x¬≤ = ${t.c}¬≤`;
            const wrong2 = `x¬≤ - ${t.a}¬≤ = ${t.b}¬≤`;
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilken ekvation ber√§knar hypotenusan x i en triangel med kateterna ${t.a} och ${t.b}?` : `Which equation calculates the hypotenuse x in a triangle with legs ${t.a} and ${t.b}?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, wrong1, wrong2])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "Pythagoras sats s√§ger att summan av kateternas kvadrater √§r lika med hypotenusans kvadrat." : "Pythagoras' theorem states that the sum of the squares of the legs is equal to the square of the hypotenuse.", latex: "a^2 + b^2 = c^2" },
                    { text: lang === 'sv' ? "R√§tt uppst√§llning √§r:" : "The correct setup is:", latex: `\\text{${correct}}` }
                ],
                metadata: { variation_key: 'hyp_equation', difficulty: 2 }
            };
        }

        if (v === 'hyp_error') {
            const ans = lang === 'sv' ? "Man m√•ste kvadrera sidorna f√∂rst" : "You must square the sides first";
            return {
                renderData: {
                    description: lang === 'sv' ? `Varf√∂r kan man inte bara addera sidorna ${t.a} + ${t.b} f√∂r att hitta hypotenusan?` : `Why can't you just add the sides ${t.a} + ${t.b} to find the hypotenuse?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, lang === 'sv' ? "Man ska anv√§nda division" : "One should use division", lang === 'sv' ? "Det √§r faktiskt r√§tt" : "It is actually correct"])
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Satsen g√§ller arean av de kvadrater man kan rita p√• sidorna, inte l√§ngden p√• sidorna direkt." : "The theorem applies to the area of the squares that can be drawn on the sides, not the length of the sides directly.", latex: "a^2 + b^2 = c^2" },
                    { text: lang === 'sv' ? "R√§tt svar √§r:" : "The correct answer is:", latex: `\\text{${ans}}` }
                ],
                metadata: { variation_key: 'hyp_error', difficulty: 1 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna l√§ngden p√• hypotenusan x." : "Calculate the length of the hypotenuse x.",
                answerType: 'numeric',
                geometry: { type: 'triangle', subtype: 'right', width: t.a, height: t.b, labels: { b: t.a, h: t.b, hyp: 'x' } }
            },
            token: this.toBase64(t.c.toString()),
            clues: [
                { text: lang === 'sv' ? "St√§ll upp satsen och ber√§kna kvadraterna f√∂rst." : "Set up the theorem and calculate the squares first.", latex: `${t.a}^2 + ${t.b}^2 = x^2 \\\\ ${t.a*t.a} + ${t.b*t.b} = x^2` },
                { text: lang === 'sv' ? "Addera areorna och dra sedan kvadratroten ur summan f√∂r att hitta x." : "Add the areas and then take the square root of the sum to find x.", latex: `${t.a*t.a + t.b*t.b} = x^2 \\\\ x = \\sqrt{${t.c*t.c}}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${t.c}` }
            ],
            metadata: { variation_key: 'hyp_visual', difficulty: 2 }
        };
    }

    // --- LEVEL 3: LEG ---
    private level3_Leg(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['leg_visual', 'leg_concept', 'leg_text']);
        const t = this.getTriple();

        if (v === 'leg_concept') {
            const ans = lang === 'sv' ? "Subtrahera" : "Subtract";
            return {
                renderData: {
                    description: lang === 'sv' ? "Ska man addera eller subtrahera om man s√∂ker en katet och redan har hypotenusan?" : "Should you add or subtract if you are looking for a leg and already have the hypotenuse?",
                    answerType: 'multiple_choice',
                    options: [ans, lang === 'sv' ? "Addera" : "Add"]
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Hypotenusan √§r den l√§ngsta sidan. F√∂r att hitta en av de kortare kateterna m√•ste vi dra bort den k√§nda sidans kvadrat." : "The hypotenuse is the longest side. To find one of the shorter legs, we must subtract the square of the known side.", latex: "b^2 = c^2 - a^2" },
                    { text: lang === 'sv' ? "Man ska allts√•:" : "So one should:", latex: `\\text{${ans}}` }
                ],
                metadata: { variation_key: 'leg_concept', difficulty: 2 }
            };
        }

        const isText = v === 'leg_text';
        return {
            renderData: {
                description: lang === 'sv' ? `Hypotenusan √§r ${t.c} och en katet √§r ${t.a}. Ber√§kna den andra kateten x.` : `The hypotenuse is ${t.c} and one leg is ${t.a}. Calculate the other leg x.`,
                answerType: 'numeric',
                geometry: isText ? null : { type: 'triangle', subtype: 'right', width: t.b, height: t.a, labels: { b: 'x', h: t.a, hyp: t.c } }
            },
            token: this.toBase64(t.b.toString()),
            clues: [
                { text: lang === 'sv' ? "N√§r vi s√∂ker en katet drar vi bort den k√§nda katetens kvadrat fr√•n hypotenusans kvadrat." : "When seeking a leg, we subtract the square of the known leg from the square of the hypotenuse.", latex: `x^2 = ${t.c}^2 - ${t.a}^2 \\\\ x^2 = ${t.c*t.c} - ${t.a*t.a}` },
                { text: lang === 'sv' ? "Ber√§kna skillnaden och dra sedan kvadratroten ur svaret." : "Calculate the difference and then take the square root of the result.", latex: `x^2 = ${t.b*t.b} \\\\ x = \\sqrt{${t.b*t.b}}` },
                { text: lang === 'sv' ? "L√§ngden p√• kateten √§r:" : "The length of the leg is:", latex: `${t.b}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: APPLICATIONS ---
    private level4_Applications(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['app_ladder', 'app_diagonal', 'app_displacement', 'app_guy_wire', 'app_coords']);
        const t = this.getTriple();

        if (v === 'app_diagonal') {
            return {
                renderData: {
                    description: lang === 'sv' ? `En rektangel har sidorna ${t.a} cm och ${t.b} cm. Hur l√•ng √§r diagonalen?` : `A rectangle has sides of ${t.a} cm and ${t.b} cm. How long is the diagonal?`,
                    answerType: 'numeric',
                    geometry: { type: 'rectangle', width: t.a, height: t.b, labels: { b: t.a, h: t.b } }
                },
                token: this.toBase64(t.c.toString()),
                clues: [
                    { text: lang === 'sv' ? "Diagonalen delar rektangeln i tv√• r√§tvinkliga trianglar och fungerar som hypotenusa." : "The diagonal divides the rectangle into two right-angled triangles and acts as the hypotenuse.", latex: `d^2 = ${t.a}^2 + ${t.b}^2` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${t.c}` }
                ],
                metadata: { variation_key: 'app_diagonal', difficulty: 3 }
            };
        }

        if (v === 'app_coords') {
            const x1 = MathUtils.randomInt(1, 5), y1 = MathUtils.randomInt(1, 5);
            const x2 = x1 + t.a, y2 = y1 + t.b;
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna avst√•ndet mellan punkterna (${x1}, ${y1}) och (${x2}, ${y2}).` : `Calculate the distance between points (${x1}, ${y1}) and (${x2}, ${y2}).`,
                    answerType: 'numeric'
                },
                token: this.toBase64(t.c.toString()),
                clues: [
                    { text: lang === 'sv' ? "Skillnaden i x- och y-led mellan punkterna bildar kateterna i en r√§tvinklig triangel." : "The difference in x and y between the points forms the legs of a right-angled triangle.", latex: `\\Delta x = ${t.a}, \\Delta y = ${t.b}` },
                    { text: lang === 'sv' ? "Avst√•ndet d √§r d√• hypotenusan i triangeln." : "The distance d is then the hypotenuse of the triangle.", latex: `d = \\sqrt{${t.a}^2 + ${t.b}^2} = ${t.c}` },
                    { text: lang === 'sv' ? "Avst√•ndet √§r:" : "The distance is:", latex: `${t.c}` }
                ],
                metadata: { variation_key: 'app_coords', difficulty: 4 }
            };
        }

        const app_ladder = lang === 'sv' ? `En stege som √§r ${t.c} m l√•ng lutar mot en v√§gg och n√•r ${t.b} m upp. Hur l√•ngt fr√•n v√§ggen st√•r stegen?` : `A ladder ${t.c} m long leans against a wall and reaches ${t.b} m up. How far from the wall is the base?`;
        const ansVal = v === 'app_ladder' ? t.a : t.c;

        return {
            renderData: {
                description: lang === 'sv' ? app_ladder : `A wire is attached to the top of a ${t.b} m pole and anchored ${t.a} m away. How long is the wire?`,
                answerType: 'numeric'
            },
            token: this.toBase64(ansVal.toString()),
            clues: [
                { text: lang === 'sv' ? "Anv√§nd Pythagoras sats f√∂r att hitta den saknade sidan." : "Use Pythagoras' theorem to find the missing side.", latex: v === 'app_ladder' ? `x = \\sqrt{${t.c}^2 - ${t.b}^2}` : `x = \\sqrt{${t.a}^2 + ${t.b}^2}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ansVal}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 5: CONVERSE ---
    private level5_Converse(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['conv_check', 'conv_missing', 'conv_trap']);
        
        if (v === 'conv_trap') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Kan sidorna 2, 2 och 5 bilda en r√§tvinklig triangel?" : "Can the sides 2, 2 and 5 form a right-angled triangle?",
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"]
                },
                token: this.toBase64(lang === 'sv' ? "Nej" : "No"),
                clues: [
                    { text: lang === 'sv' ? "F√∂r att bilda en triangel m√•ste summan av de kortare sidorna vara st√∂rre √§n den l√§ngsta sidan. $2 + 2 < 5$, s√• detta √§r inte ens en triangel." : "To form a triangle, the sum of the shorter sides must be greater than the longest side. $2 + 2 < 5$, so this isn't even a triangle." },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `\\text{${lang === 'sv' ? 'Nej' : 'No'}}` }
                ],
                metadata: { variation_key: 'conv_trap', difficulty: 2 }
            };
        }

        const t = this.getTriple();
        const isRight = Math.random() > 0.5 || v === 'conv_missing';
        const c = isRight ? t.c : t.c + 1;
        const ans = v === 'conv_missing' ? t.c.toString() : (isRight ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No"));

        return {
            renderData: {
                description: lang === 'sv' 
                    ? (v === 'conv_missing' ? `Sidorna √§r ${t.a} och ${t.b}. Vad m√•ste den tredje sidan vara f√∂r r√§t vinkel?` : `√Ñr en triangel med sidorna ${t.a}, ${t.b} och ${c} r√§tvinklig?`)
                    : (v === 'conv_missing' ? `The sides are ${t.a} and ${t.b}. What must the third side be for a right angle?` : `Is a triangle with sides ${t.a}, ${t.b} and ${c} right-angled?`),
                answerType: v === 'conv_missing' ? 'numeric' : 'multiple_choice',
                options: v === 'conv_missing' ? undefined : (lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"])
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Kontrollera Pythagoras sats: st√§mmer $a^2 + b^2 = c^2$?" : "Check Pythagoras' theorem: does $a^2 + b^2 = c^2$ hold?", latex: `${t.a}^2 + ${t.b}^2 = ${t.a*t.a + t.b*t.b} \\text{ vs } ${c}^2 = ${c*c}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: v === 'conv_missing' ? `${t.c}` : `\\text{${ans}}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 6: ADVANCED MIXED ---
    private level6_AdvancedMixed(lang: string): any {
        const t = this.getTriple();
        const x1 = MathUtils.randomInt(-5, 0), y1 = MathUtils.randomInt(-5, 0);
        const x2 = x1 + t.a, y2 = y1 + t.b;

        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna avst√•ndet mellan punkterna (${x1}, ${y1}) och (${x2}, ${y2}).` : `Calculate the distance between points (${x1}, ${y1}) and (${x2}, ${y2}).`,
                answerType: 'numeric'
            },
            token: this.toBase64(t.c.toString()),
            clues: [
                { text: lang === 'sv' ? "Skillnaden i x- och y-led ger oss de tv√• kateterna." : "The difference in x and y gives us the two legs.", latex: `\\Delta x = ${t.a}, \\Delta y = ${t.b}` },
                { text: lang === 'sv' ? "Svaret √§r hypotenusan:" : "The answer is the hypotenuse:", latex: `\\sqrt{${t.a}^2 + ${t.b}^2} = ${t.c}` },
                { text: lang === 'sv' ? "Avst√•ndet √§r:" : "The distance is:", latex: `${t.c}` }
            ],
            metadata: { variation_key: 'advanced_mixed', difficulty: 5 }
        };
    }
}

// FILE END: src\core\generators\PythagorasGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ScaleGen {
    // Standard shapes for visuals
    private static readonly SHAPES = ['arrow', 'star', 'lightning', 'key', 'heart', 'cloud', 'moon', 'sun'];

    // --- CONTEXT LIBRARY ---
    private static readonly SCENARIOS = {
        map: [
            { sv: "en karta", en: "a map", contextSv: "avst√•ndet", contextEn: "the distance", unit: "km" },
            { sv: "en vandringskarta", en: "a hiking map", contextSv: "stigen", contextEn: "the trail", unit: "m" },
            { sv: "ett sj√∂kort", en: "a nautical chart", contextSv: "rutten", contextEn: "the route", unit: "km" }
        ],
        blueprint: [
            { sv: "en ritning", en: "a blueprint", contextSv: "v√§ggen", contextEn: "the wall", unit: "m" },
            { sv: "en planl√∂sning", en: "a floor plan", contextSv: "rummet", contextEn: "the room", unit: "m" },
            { sv: "en konstruktionsritning", en: "a construction drawing", contextSv: "balken", contextEn: "the beam", unit: "m" }
        ],
        model: [
            { sv: "en modell", en: "a model", contextSv: "bilen", contextEn: "the car", unit: "m" },
            { sv: "en leksaksbil", en: "a toy car", contextSv: "bilen", contextEn: "the car", unit: "m" },
            { sv: "ett modellflygplan", en: "a model airplane", contextSv: "vingbredden", contextEn: "the wingspan", unit: "m" }
        ],
        microscope: [
            { sv: "en bild i ett mikroskop", en: "a microscope image", contextSv: "cellen", contextEn: "the cell", unit: "mm" },
            { sv: "en f√∂rstoring", en: "a magnification", contextSv: "insekten", contextEn: "the insect", unit: "mm" },
            { sv: "en detaljbild", en: "a detailed image", contextSv: "chipet", contextEn: "the chip", unit: "mm" }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_LinearFluency(lang);
            case 3: return this.level3_MixedScenarios(lang);
            case 4: return this.level4_DetermineScale(lang);
            case 5: return this.level5_NoPictures(lang);
            case 6: return this.level6_AreaScaleDeep(lang);
            case 7: return this.level7_Mixed(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'concept_lie':
            case 'concept_match':
                return this.level1_Concepts(lang, key);
            case 'calc_real':
            case 'calc_image':
            case 'find_scale':
            case 'calc_magnification':
                return this.level2_LinearFluency(lang, key);
            case 'map_real':
            case 'blueprint_draw':
            case 'microscope_calc':
            case 'model_real':
                return this.level3_MixedScenarios(lang, key);
            case 'determine_reduction':
            case 'determine_magnification':
                return this.level4_DetermineScale(lang, key);
            case 'word_problem':
                return this.level5_NoPictures(lang);
            case 'area_concept':
            case 'area_reverse':
            case 'area_calc_small':
            case 'area_calc_large':
                return this.level6_AreaScaleDeep(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private formatNum(n: number): string {
        return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPTS ---
    private level1_Concepts(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['concept_lie', 'concept_match']);

        if (v === 'concept_lie') {
             const scale = MathUtils.randomChoice([2, 5, 10, 100]);
             const falseStatement = lang === 'sv' ? `Bilden √§r ritad i naturlig storlek (skala 1:1).` : `The image is drawn in natural size (scale 1:1).`;
             const correctStatement = lang === 'sv' ? `Verkligheten √§r ${scale} g√•nger st√∂rre √§n vad bilden visar.` : `Reality is ${scale} times larger than what the image shows.`;

             return {
                renderData: {
                    description: lang === 'sv' ? `Studera skalan 1:${scale}. Vilket p√•st√•ende √§r FALSKT?` : `Study the scale 1:${scale}. Which statement is FALSE?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correctStatement, falseStatement, lang === 'sv' ? `Skalan 1:${scale} √§r en f√∂rminskning.` : `The scale 1:${scale} is a reduction.`]),
                    geometry: { type: 'scale_single', label: `1:${scale}`, shape: 'map' }
                },
                token: this.toBase64(falseStatement),
                clues: [
                    { text: lang === 'sv' ? `En skala p√• 1:${scale} betyder att 1 cm p√• bilden motsvarar ${scale} cm i verkligheten.` : `A scale of 1:${scale} means 1 cm in the image corresponds to ${scale} cm in reality.`, latex: `1 \\text{ cm (bild)} = ${scale} \\text{ cm (verklighet)}` },
                    { text: lang === 'sv' ? "Detta p√•st√•ende st√§mmer inte:" : "This statement is not correct:", latex: `\\text{${falseStatement}}` }
                ],
                metadata: { variation_key: 'concept_lie', difficulty: 1 }
             };
        }

        const isReduction = Math.random() > 0.5;
        const ratio = MathUtils.randomChoice([5, 10, 20, 50]);
        const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
        const correct = isReduction 
            ? (lang === 'sv' ? `Verkligheten √§r ${ratio} g√•nger st√∂rre √§n bilden.` : `Reality is ${ratio} times larger than the image.`)
            : (lang === 'sv' ? `Bilden √§r ${ratio} g√•nger st√∂rre √§n verkligheten.` : `The image is ${ratio} times larger than reality.`);

        return {
            renderData: {
                description: lang === 'sv' ? `Vad inneb√§r skalan ${scaleStr}?` : `What does the scale ${scaleStr} mean?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([correct, lang === 'sv' ? "Bilden och verkligheten √§r lika stora." : "The image and reality are the same size."]),
                geometry: { type: 'scale_compare', leftLabel: 'Bild', rightLabel: 'Verklighet', leftValue: isReduction ? 1 : ratio, rightValue: isReduction ? ratio : 1, shape: 'arrow' }
            },
            token: this.toBase64(correct),
            clues: [
                { text: lang === 'sv' ? "Siffran 1 i skalan representerar alltid bilden eller ritningen." : "The number 1 in the scale always represents the image or drawing." },
                { text: lang === 'sv' ? "D√§rf√∂r betyder skalan:" : "Therefore, the scale means:", latex: `\\text{${correct}}` }
            ],
            metadata: { variation_key: 'concept_match', difficulty: 1 }
        };
    }

    // --- LEVEL 2: LINEAR FLUENCY ---
    private level2_LinearFluency(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['calc_real', 'calc_image', 'find_scale', 'calc_magnification']);
        const shape = MathUtils.randomChoice(ScaleGen.SHAPES);

        if (v === 'calc_real') {
            const scale = MathUtils.randomChoice([5, 10, 20, 50]);
            const imgCm = MathUtils.randomInt(2, 12);
            const ans = imgCm * scale;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `Skala 1:${scale}. Bilden √§r ${imgCm} cm. Ber√§kna verkligheten.` : `Scale 1:${scale}. The image is ${imgCm} cm. Calculate reality.`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Eftersom det √§r en f√∂rminskning √§r verkligheten ${scale} g√•nger st√∂rre √§n bilden.` : `Since it's a reduction, reality is ${scale} times larger than the image.`, latex: `${imgCm} \\cdot ${scale} = ${ans} \\rightarrow \\text{Verklighet} = ${ans}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'calc_real', difficulty: 2 }
            };
        }

        if (v === 'calc_image') {
            const scale = MathUtils.randomChoice([10, 20, 50, 100]);
            const imgCm = MathUtils.randomInt(3, 10);
            const realCm = imgCm * scale;

            return {
                renderData: {
                    description: lang === 'sv' ? `Ett f√∂rem√•l √§r ${realCm} cm i verkligheten. Hur l√•ng blir den p√• en ritning i skala 1:${scale}?` : `An object is ${realCm} cm in reality. How long will it be on a drawing in scale 1:${scale}?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(imgCm.toString()),
                clues: [
                    { text: lang === 'sv' ? `P√• ritningen blir f√∂rem√•let ${scale} g√•nger mindre √§n i verkligheten.` : `On the drawing, the object becomes ${scale} times smaller than in reality.`, latex: `\\frac{${realCm}}{${scale}} = ${imgCm} \\rightarrow \\text{Ritning} = ${imgCm}` },
                    { text: lang === 'sv' ? "L√§ngden p√• ritningen blir:" : "The length on the drawing will be:", latex: `${imgCm}` }
                ],
                metadata: { variation_key: 'calc_image', difficulty: 2 }
            };
        }

        if (v === 'find_scale') {
            const scale = MathUtils.randomChoice([2, 5, 10, 20, 50]);
            const imgCm = MathUtils.randomInt(2, 10);
            const realCm = imgCm * scale;

            return {
                renderData: {
                    description: lang === 'sv' ? `Bilden √§r ${imgCm} cm. Verkligheten √§r ${realCm} cm. Ange skalan.` : `The image is ${imgCm} cm. Reality is ${realCm} cm. State the scale.`,
                    answerType: 'text', placeholder: '1:X'
                },
                token: this.toBase64(`1:${scale}`),
                clues: [
                    { text: lang === 'sv' ? "Dividera verklighetens l√§ngd med bildens l√§ngd f√∂r att f√• reda p√• f√∂rminskningen." : "Divide the real length by the image length to find the reduction.", latex: `\\frac{${realCm}}{${imgCm}} = ${scale} \\rightarrow 1:${scale}` },
                    { text: lang === 'sv' ? "Skalan √§r:" : "The scale is:", latex: `1:${scale}` }
                ],
                metadata: { variation_key: 'find_scale', difficulty: 2 }
            };
        }

        const scale = MathUtils.randomChoice([5, 10, 20]);
        const realMm = MathUtils.randomInt(2, 8);
        const imgMm = realMm * scale;
        
        return {
            renderData: {
                description: lang === 'sv' ? `F√∂rstoring ${scale}:1. Bilden √§r ${imgMm} mm. Hur l√•ng √§r den i verkligheten?` : `Magnification ${scale}:1. The image is ${imgMm} mm. How long is it in reality?`,
                answerType: 'numeric', suffix: 'mm'
            },
            token: this.toBase64(realMm.toString()),
            clues: [
                { text: lang === 'sv' ? `Skalan ${scale}:1 betyder att bilden √§r ${scale} g√•nger st√∂rre √§n verkligheten.` : `The scale ${scale}:1 means the image is ${scale} times larger than reality.`, latex: `\\frac{${imgMm}}{${scale}} = ${realMm} \\rightarrow \\text{Verklighet} = ${realMm}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${realMm}` }
            ],
            metadata: { variation_key: 'calc_magnification', difficulty: 2 }
        };
    }

    // --- LEVEL 3: MIXED SCENARIOS ---
    private level3_MixedScenarios(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['map_real', 'blueprint_draw', 'microscope_calc', 'model_real']);
        
        if (v === 'map_real') {
            const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.map);
            const scale = MathUtils.randomChoice([10000, 50000, 100000]);
            const mapCm = MathUtils.randomInt(2, 10);
            const realCm = mapCm * scale;
            const useKm = realCm >= 100000;
            const ans = useKm ? realCm / 100000 : realCm / 100;
            const unit = useKm ? 'km' : 'm';

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `P√• ${scenario.sv} i skala 1:${this.formatNum(scale)} m√§ts ${scenario.contextSv} till ${mapCm} cm. Hur l√•ngt √§r detta i verkligheten?`
                        : `On ${scenario.en} in scale 1:${this.formatNum(scale)}, ${scenario.contextEn} measures ${mapCm} cm. How long is this in reality?`,
                    answerType: 'numeric', suffix: unit
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `R√§kna f√∂rst ut avst√•ndet i cm.` : `First calculate the distance in cm.`, latex: `${mapCm} \\cdot ${scale} = ${this.formatNum(realCm)} \\text{ cm}` },
                    { text: lang === 'sv' ? `Omvandla sedan fr√•n cm till ${unit}.` : `Then convert from cm to ${unit}.`, latex: useKm ? `\\frac{${realCm}}{100\\,000} = ${ans} \\text{ km}` : `\\frac{${realCm}}{100} = ${ans} \\text{ m}` },
                    { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'map_real', difficulty: 3 }
            };
        }

        if (v === 'blueprint_draw') {
            const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.blueprint);
            const scale = 50;
            const realM = MathUtils.randomInt(2, 8);
            const ans = (realM * 100) / scale;

            return {
                renderData: {
                    description: lang === 'sv' ? `${scenario.sv} √§r i skala 1:${scale}. Verkligheten √§r ${realM} m. Hur l√•ngt blir det p√• ritningen?` : `${scenario.en} is in scale 1:${scale}. Reality is ${realM} m. How long will it be on the drawing?`,
                    answerType: 'numeric', suffix: 'cm'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "G√∂r om meter till centimeter f√∂rst." : "Convert meters to centimeters first.", latex: `${realM} \\cdot 100 = ${realM * 100} \\text{ cm}` },
                    { text: lang === 'sv' ? `Dividera med skalan ${scale} f√∂r att f√• ritningens m√•tt.` : `Divide by the scale ${scale} to get the drawing measure.`, latex: `\\frac{${realM * 100}}{${scale}} = ${ans} \\text{ cm}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'blueprint_draw', difficulty: 3 }
            };
        }

        if (v === 'microscope_calc') {
            const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.microscope);
            const scale = MathUtils.randomChoice([10, 50, 100]);
            const realMm = MathUtils.randomChoice([0.1, 0.2, 0.5]);
            const ansMm = realMm * scale;
            const ans = ansMm >= 10 ? ansMm / 10 : ansMm;
            const unit = ansMm >= 10 ? 'cm' : 'mm';

            return {
                renderData: {
                    description: lang === 'sv' ? `I ${scenario.sv} (skala ${scale}:1) √§r verkligheten ${realMm.toString().replace('.', ',')} mm. Hur l√•ng √§r den p√• bilden?` : `In ${scenario.en} (scale ${scale}:1), reality is ${realMm} mm. How long is it in the image?`,
                    answerType: 'numeric', suffix: unit
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Multiplicera verklighetens l√§ngd med ${scale}.` : `Multiply the real length by ${scale}.`, latex: `${realMm} \\cdot ${scale} = ${ansMm} \\text{ mm}` },
                    { text: lang === 'sv' ? (ansMm >= 10 ? "Omvandla till cm." : "Svaret i mm:") : (ansMm >= 10 ? "Convert to cm." : "The answer in mm:"), latex: `${ans}` }
                ],
                metadata: { variation_key: 'microscope_calc', difficulty: 3 }
            };
        }

        const scenario = MathUtils.randomChoice(ScaleGen.SCENARIOS.model);
        const scale = MathUtils.randomChoice([10, 20, 50]);
        const imgCm = MathUtils.randomInt(5, 20);
        const ans = (imgCm * scale) / 100;

        return {
            renderData: {
                description: lang === 'sv' ? `${scenario.sv} i skala 1:${scale}. Modellen √§r ${imgCm} cm. Ber√§kna verkligheten i meter.` : `${scenario.en} in scale 1:${scale}. The model is ${imgCm} cm. Calculate reality in meters.`,
                answerType: 'numeric', suffix: 'm'
            },
            token: this.toBase64(ans.toString().replace('.', ',')),
            clues: [
                { text: lang === 'sv' ? `Multiplicera modellens l√§ngd med ${scale}.` : `Multiply the model length by ${scale}.`, latex: `${imgCm} \\cdot ${scale} = ${imgCm * scale} \\text{ cm}` },
                { text: lang === 'sv' ? "Dela med 100 f√∂r att f√• meter." : "Divide by 100 to get meters.", latex: `\\frac{${imgCm * scale}}{100} = ${ans} \\text{ m}` },
                { text: lang === 'sv' ? "Slutresultat:" : "Final result:", latex: `${ans}` }
            ],
            metadata: { variation_key: 'model_real', difficulty: 3 }
        };
    }

    // --- LEVEL 4: DETERMINE SCALE ---
    private level4_DetermineScale(lang: string, variationKey?: string): any {
        const v = variationKey || (Math.random() < 0.5 ? 'determine_reduction' : 'determine_magnification');
        
        if (v === 'determine_reduction') {
            const scale = MathUtils.randomChoice([20, 50, 100, 200]);
            const imgCm = MathUtils.randomInt(2, 5);
            const realM = (imgCm * scale) / 100;

            return {
                renderData: {
                    description: lang === 'sv' ? `Verkligheten √§r ${realM.toString().replace('.', ',')} m. P√• en ritning √§r den ${imgCm} cm. Ange skalan.` : `Reality is ${realM} m. On a drawing it is ${imgCm} cm. State the scale.`,
                    answerType: 'text', placeholder: '1:X'
                },
                token: this.toBase64(`1:${scale}`),
                clues: [
                    { text: lang === 'sv' ? `G√∂r f√∂rst om meter till cm: ${realM} m = ${realM * 100} cm.` : `Convert meters to cm first: ${realM} m = ${realM * 100} cm.` },
                    { text: lang === 'sv' ? "Dela det verkliga m√•ttet med ritningens m√•tt." : "Divide the real measure by the drawing measure.", latex: `\\frac{${realM * 100}}{${imgCm}} = ${scale} \\rightarrow 1:${scale}` },
                    { text: lang === 'sv' ? "Skalan √§r:" : "The scale is:", latex: `1:${scale}` }
                ],
                metadata: { variation_key: 'determine_reduction', difficulty: 3 }
            };
        }

        const scale = MathUtils.randomChoice([5, 10, 50]);
        const realMm = MathUtils.randomInt(2, 5);
        const imgCm = (realMm * scale) / 10;

        return {
            renderData: {
                description: lang === 'sv' ? `Ett fr√∂ √§r ${realMm} mm. P√• en bild √§r det ${imgCm.toString().replace('.', ',')} cm. Ange skalan.` : `A seed is ${realMm} mm. In an image it is ${imgCm} cm. State the scale.`,
                answerType: 'text', placeholder: 'X:1'
            },
            token: this.toBase64(`${scale}:1`),
            clues: [
                { text: lang === 'sv' ? `G√∂r f√∂rst om cm till mm: ${imgCm} cm = ${imgCm * 10} mm.` : `Convert cm to mm first: ${imgCm} cm = ${imgCm * 10} mm.` },
                { text: lang === 'sv' ? "Dela bildens m√•tt med verklighetens m√•tt." : "Divide the image measure by the real measure.", latex: `\\frac{${imgCm * 10}}{${realMm}} = ${scale} \\rightarrow ${scale}:1` },
                { text: lang === 'sv' ? "Skalan √§r:" : "The scale is:", latex: `${scale}:1` }
            ],
            metadata: { variation_key: 'determine_magnification', difficulty: 3 }
        };
    }

    // --- LEVEL 5: NO PICTURES ---
    private level5_NoPictures(lang: string): any {
        const data = this.level3_MixedScenarios(lang);
        data.renderData.geometry = null;
        data.metadata.variation_key = 'word_problem';
        return data;
    }

    // --- LEVEL 6: AREA SCALE DEEP ---
    private level6_AreaScaleDeep(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['area_concept', 'area_reverse', 'area_calc_large']);

        if (v === 'area_concept') {
            const L = MathUtils.randomChoice([2, 5, 10]);
            const sq = L * L;
            const correct = lang === 'sv' ? `${sq} g√•nger st√∂rre` : `${sq} times larger`;
            
            return {
                renderData: {
                    description: lang === 'sv' ? `L√§ngdskalan √§r 1:${L}. Hur m√•nga g√•nger st√∂rre blir arean?` : `The length scale is 1:${L}. How many times larger does the area become?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([correct, lang === 'sv' ? `${L} g√•nger st√∂rre` : `${L} times larger`])
                },
                token: this.toBase64(correct),
                clues: [
                    { text: lang === 'sv' ? "Regel: Areaskalan √§r l√§ngdskalan i kvadrat." : "Rule: Area scale is the length scale squared.", latex: `\\text{Areaskala} = ${L}^2 = ${sq}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${sq}` }
                ],
                metadata: { variation_key: 'area_concept', difficulty: 4 }
            };
        }

        const L = MathUtils.randomChoice([2, 3, 4]);
        const smallA = MathUtils.randomInt(5, 10);
        const largeA = smallA * (L * L);

        if (v === 'area_reverse') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Liten area: ${smallA} cm¬≤. Stor area: ${largeA} cm¬≤. Ange l√§ngdskalan.` : `Small area: ${smallA} cm¬≤. Large area: ${largeA} cm¬≤. State the length scale.`,
                    answerType: 'text', placeholder: '1:X'
                },
                token: this.toBase64(`1:${L}`),
                clues: [
                    { text: lang === 'sv' ? `Ber√§kna areaskalan f√∂rst: ${largeA} / ${smallA} = ${L*L}.` : `Calculate area scale first: ${largeA} / ${smallA} = ${L*L}.`, latex: `\\text{Areaskala} = ${L*L}` },
                    { text: lang === 'sv' ? "L√§ngdskalan √§r roten ur areaskalan." : "Length scale is the root of area scale.", latex: `\\sqrt{${L*L}} = ${L} \\rightarrow 1:${L}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `1:${L}` }
                ],
                metadata: { variation_key: 'area_reverse', difficulty: 4 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `L√§ngdskala 1:${L}. Liten area √§r ${smallA} cm¬≤. Ber√§kna stora arean.` : `Length scale 1:${L}. Small area is ${smallA} cm¬≤. Calculate large area.`,
                answerType: 'numeric', suffix: 'cm¬≤'
            },
            token: this.toBase64(largeA.toString()),
            clues: [
                { text: lang === 'sv' ? `Areaskalan √§r ${L} i kvadrat: ${L*L}.` : `The area scale is ${L} squared: ${L*L}.`, latex: `${L}^2 = ${L*L}` },
                { text: lang === 'sv' ? `Multiplicera lilla arean med ${L*L}.` : `Multiply the small area by ${L*L}.`, latex: `${smallA} \\cdot ${L*L} = ${largeA}` },
                { text: lang === 'sv' ? "Stora arean √§r:" : "The large area is:", latex: `${largeA}` }
            ],
            metadata: { variation_key: 'area_calc_large', difficulty: 4 }
        };
    }

    // --- LEVEL 7: MIXED ---
    private level7_Mixed(lang: string): any {
        const subLevel = MathUtils.randomInt(2, 6);
        const res = this.generate(subLevel, lang);
        res.metadata.mixed = true;
        return res;
    }
}

// FILE END: src\core\generators\ScaleGen.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class SimilarityGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concept(lang);
            case 2: return this.level2_CalcSide(lang);
            case 3: return this.level3_TopTriangle(lang);
            case 4: return this.level4_Pythagoras(lang);
            default: return this.level1_Concept(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'sim_rect_check':
            case 'sim_tri_angle_check':
            case 'sim_tri_side_check':
            case 'sim_concept_lie':
                return this.level1_Concept(lang, key);
            
            case 'sim_calc_big':
            case 'sim_calc_small':
            case 'sim_find_k':
            case 'sim_calc_lie':
                return this.level2_CalcSide(lang, key);
            
            case 'transversal_total':
            case 'transversal_extension':
            case 'transversal_concept_id':
                return this.level3_TopTriangle(lang, key);
            
            case 'pythagoras_sim_hyp':
            case 'pythagoras_sim_leg':
                return this.level4_Pythagoras(lang, key);

            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CONCEPT (Identifying Similarity) ---
    private level1_Concept(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sim_rect_check', 'sim_tri_angle_check', 'sim_tri_side_check', 'sim_concept_lie']);
        const isSimilar = Math.random() > 0.5;

        if (v === 'sim_concept_lie') {
            const sTrue1 = lang === 'sv' ? "Alla liksidiga trianglar √§r likformiga." : "All equilateral triangles are similar.";
            const sTrue2 = lang === 'sv' ? "Alla cirklar √§r likformiga med varandra." : "All circles are similar to each other.";
            const sLie = lang === 'sv' ? "Alla rektanglar √§r likformiga." : "All rectangles are similar.";
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Vilket av f√∂ljande p√•st√•enden om likformighet √§r FALSKT?" : "Which of the following statements about similarity is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sLie])
                },
                token: this.toBase64(sLie),
                clues: [
                    { text: lang === 'sv' ? "F√∂r att figurer ska vara likformiga m√•ste alla vinklar vara lika och f√∂rh√•llandet mellan sidorna vara detsamma. Alla rektanglar har 90 graders vinklar, men deras sidf√∂rh√•llanden kan variera kraftigt." : "For shapes to be similar, all angles must be equal and the ratio between sides must be the same. All rectangles have 90-degree angles, but their side ratios can vary greatly." },
                    { text: lang === 'sv' ? "D√§rf√∂r √§r detta p√•st√•ende l√∂gnen:" : "Therefore, this statement is the lie:", latex: `\\text{${sLie}}` }
                ],
                metadata: { variation_key: 'sim_concept_lie', difficulty: 1 }
            };
        }

        let geom: any = { type: 'similarity_compare' };
        let desc = "";
        let clues = [];

        if (v === 'sim_rect_check') {
            geom.shapeType = 'rectangle';
            const w1 = 4, h1 = 2;
            const w2 = 8;
            const h2 = isSimilar ? h1 * 2 : h1 * 1.2;

            geom.left = { labels: { b: w1, h: h1 } };
            geom.right = { labels: { b: w2, h: h2 } };
            desc = lang === 'sv' ? "Avg√∂r om rektanglarna nedan √§r likformiga." : "Determine if the rectangles below are similar.";
            clues.push({ text: lang === 'sv' ? "Dela de motsvarande sidorna med varandra. Om kvoten (skalan) blir exakt densamma √§r figurerna likformiga." : "Divide the corresponding sides by each other. If the quotient (scale) is exactly the same, the figures are similar.", latex: `\\frac{${w2}}{${w1}} = ${w2/w1} \\quad \\text{vs} \\quad \\frac{${h2}}{${h1}} = ${h2/h1}` });
        } 
        else if (v === 'sim_tri_angle_check') {
            geom.shapeType = 'triangle';
            const a1 = 60, a2 = 70;
            const b1 = isSimilar ? a1 : a1 + 10;
            geom.left = { labels: { a1: `${a1}¬∞`, a2: `${a2}¬∞` } };
            geom.right = { labels: { a1: `${b1}¬∞`, a2: `${a2}¬∞` } };
            desc = lang === 'sv' ? "√Ñr trianglarna likformiga baserat p√• deras vinklar?" : "Are the triangles similar based on their angles?";
            clues.push({ text: lang === 'sv' ? "Tv√• trianglar √§r likformiga om de har exakt samma upps√§ttning vinklar." : "Two triangles are similar if they have the exact same set of angles." });
        }
        else {
            geom.shapeType = 'triangle';
            const s1 = 3, s2 = 5;
            const r1 = s1 * 3;
            const r2 = isSimilar ? s2 * 3 : s2 * 2.5;
            geom.left = { labels: { s1: s1, s2: s2 } };
            geom.right = { labels: { s1: r1, s2: r2 } };
            desc = lang === 'sv' ? "Unders√∂k sidorna i figurerna. √Ñr trianglarna likformiga?" : "Examine the sides of the figures. Are the triangles similar?";
            clues.push({ text: lang === 'sv' ? "Kontrollera om f√∂rh√•llandet mellan de korta sidorna √§r detsamma som f√∂rh√•llandet mellan de l√•nga sidorna." : "Check if the ratio between the short sides is the same as the ratio between the long sides.", latex: `\\frac{${r1}}{${s1}} = ${r1/s1} \\quad \\text{vs} \\quad \\frac{${r2}}{${s2}} = ${r2/s2}` });
        }

        const correct = isSimilar ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");
        clues.push({ text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `\\text{${correct}}` });

        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Ja", "Nej"] : ["Yes", "No"],
                geometry: geom
            },
            token: this.toBase64(correct),
            clues,
            metadata: { variation_key: v, difficulty: 1 }
        };
    }

    // --- LEVEL 2: CALCULATE SIDE ---
    private level2_CalcSide(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sim_calc_big', 'sim_calc_small', 'sim_find_k']);
        const k = MathUtils.randomChoice([1.5, 2, 3, 5]);
        const s1 = 4, s2 = 6;
        const bigS1 = s1 * k, bigS2 = s2 * k;

        if (v === 'sim_find_k') {
            return {
                renderData: {
                    geometry: { type: 'similarity_compare', shapeType: 'rectangle', left: { labels: { b: s1, h: s2 } }, right: { labels: { b: bigS1, h: bigS2 } } },
                    description: lang === 'sv' ? "Figurerna √§r likformiga. Vilken √§r l√§ngdskalan fr√•n den lilla till den stora figuren?" : "The shapes are similar. What is the length scale from the small to the large shape?",
                    answerType: 'numeric'
                },
                token: this.toBase64(k.toString()),
                clues: [
                    { text: lang === 'sv' ? "Skalan hittas genom att dividera ett m√•tt i den nya figuren med motsvarande m√•tt i den ursprungliga figuren." : "The scale is found by dividing a dimension in the new figure by the corresponding dimension in the original figure.", latex: `\\frac{\\text{ny}}{\\text{gammal}}` },
                    { text: lang === 'sv' ? "Utr√§kningen blir:" : "The calculation is:", latex: `\\frac{${bigS1}}{${s1}} = ${k}` }
                ],
                metadata: { variation_key: 'sim_find_k', difficulty: 2 }
            };
        }

        const findBig = v === 'sim_calc_big';
        const ans = findBig ? bigS1 : s1;

        return {
            renderData: {
                geometry: { 
                    type: 'similarity_compare', 
                    shapeType: 'triangle', 
                    left: { labels: findBig ? { s1: s1, s2: s2 } : { s1: 'x', s2: s2 } }, 
                    right: { labels: findBig ? { s1: 'x', s2: bigS2 } : { s1: bigS1, s2: bigS2 } } 
                },
                description: lang === 'sv' ? "Ber√§kna l√§ngden p√• sidan x i de likformiga figurerna." : "Calculate the length of side x in the similar shapes.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Hitta f√∂rst skalan genom att j√§mf√∂ra de sidor som vi k√§nner till i b√•da trianglarna." : "First find the scale by comparing the sides we know in both triangles.", latex: `frac{${bigS2}}{${s2}} = ${k}` },
                { text: lang === 'sv' ? (findBig ? `Multiplicera nu den lilla sidan med skalan ${k} f√∂r att f√• den stora sidan.` : `Dela nu den stora sidan med skalan ${k} f√∂r att f√• den lilla sidan.`) : (findBig ? `Multiply the small side by the scale ${k} to get the large side.` : `Divide the large side by the scale ${k} to get the small side.`), latex: findBig ? `${s1} \\cdot ${k} = ${ans} \\\\ x = ${ans}` : `${bigS1} / ${k} = ${ans} \\\\ x = ${ans}` },
                { text: lang === 'sv' ? "V√§rdet p√• x √§r:" : "The value of x is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 3: TOP TRIANGLE ---
    private level3_TopTriangle(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['transversal_total', 'transversal_extension', 'transversal_concept_id']);
        const top = 5, add = 3, smallBase = 4;
        const tot = top + add;
        const scale = tot / top; 
        const ans = smallBase * scale;

        if (v === 'transversal_concept_id') {
            const ansLabel = lang === 'sv' ? "Topptriangeln och hela triangeln" : "The top triangle and the whole triangle";
            return {
                renderData: {
                    description: lang === 'sv' ? "I en triangel med en parallelltransversal, vilka tv√• figurer √§r likformiga?" : "In a triangle with a parallel transversal, which two shapes are similar?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ansLabel, lang === 'sv' ? "Topptriangeln och den nedre fyrh√∂rningen" : "The top triangle and the bottom quadrilateral", lang === 'sv' ? "Inga figurer √§r likformiga" : "No shapes are similar"])
                },
                token: this.toBase64(ansLabel),
                clues: [
                    { text: lang === 'sv' ? "Eftersom toppens baslinje √§r parallell med den stora triangelns baslinje, f√•r den lilla triangeln l√§ngst upp exakt samma vinklar som den stora triangeln." : "Since the top's baseline is parallel to the large triangle's baseline, the small triangle at the top gets exactly the same angles as the large triangle." },
                    { text: lang === 'sv' ? "D√§rf√∂r √§r dessa likformiga:" : "Therefore, these are similar:", latex: `\\text{${ansLabel}}` }
                ],
                metadata: { variation_key: 'transversal_concept_id', difficulty: 2 }
            };
        }

        const isExt = v === 'transversal_extension';
        const visualLabels = isExt 
            ? { left_top: top, left_bot: add, base_top: smallBase, base_bot: 'x' }
            : { left_top: top, left_tot: tot, base_top: smallBase, base_bot: 'x' };

        return {
            renderData: {
                geometry: { type: 'transversal', labels: visualLabels },
                description: lang === 'sv' ? "Anv√§nd likformighet f√∂r att ber√§kna basen x i figuren." : "Use similarity to calculate the base x in the figure.",
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Identifiera den lilla topptriangeln och den stora hela triangeln som de tv√• likformiga figurerna." : "Identify the small top triangle and the large whole triangle as the two similar shapes." },
                { text: lang === 'sv' ? (isExt ? `Hitta l√§ngden p√• den stora triangelns sida genom att l√§gga ihop delarna.` : `Hitta skalan genom att dela den stora sidans l√§ngd med den lilla sidans l√§ngd.`) : (isExt ? `Find the length of the large triangle's side by adding the parts together.` : `Find the scale by dividing the large side length by the small side length.`), latex: isExt ? `${top} + ${add} = ${tot} \\\\ \\frac{${tot}}{${top}} = ${scale}` : `\\frac{${tot}}{${top}} = ${scale}` },
                { text: lang === 'sv' ? `Multiplicera den lilla basen med skalan f√∂r att f√• x.` : `Multiply the small base by the scale to get x.`, latex: `${smallBase} \\cdot ${scale} = ${ans} \\\\ x = ${ans}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
            ],
            metadata: { variation_key: v, difficulty: 3 }
        };
    }

    // --- LEVEL 4: PYTHAGORAS & SIMILARITY ---
    private level4_Pythagoras(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['pythagoras_sim_hyp', 'pythagoras_sim_leg']);
        const a = 3, b = 4, c = 5;
        const k = 2;
        const bigA = a*k, bigB = b*k, bigC = c*k;

        const isHyp = v === 'pythagoras_sim_hyp';
        const ansValue = isHyp ? bigC : bigA;

        return {
            renderData: {
                geometry: { 
                    type: 'similarity_compare', shapeType: 'triangle', 
                    left: { labels: { b: a, h: b, hyp: c } }, 
                    right: { labels: isHyp ? { b: bigA, h: bigB, hyp: 'x' } : { b: 'x', h: bigB, hyp: bigC } } 
                },
                description: lang === 'sv' ? "Trianglarna √§r likformiga. Ber√§kna l√§ngden p√• sidan x." : "The triangles are similar. Calculate the length of side x.",
                answerType: 'numeric'
            },
            token: this.toBase64(ansValue.toString()),
            clues: [
                { text: lang === 'sv' ? "Hitta f√∂rst skalan genom att j√§mf√∂ra de sidor som √§r k√§nda i b√•da figurerna." : "First find the scale by comparing the sides that are known in both figures.", latex: `\\frac{${bigB}}{${b}} = ${k}` },
                { text: lang === 'sv' ? `Anv√§nd skalan ${k} f√∂r att r√§kna ut den ok√§nda sidan x.` : `Use the scale ${k} to calculate the unknown side x.`, latex: isHyp ? `${c} \\cdot ${k} = ${bigC} \\\\ x = ${bigC}` : `${a} \\cdot ${k} = ${bigA} \\\\ x = ${bigA}` },
                { text: lang === 'sv' ? "V√§rdet p√• x √§r:" : "The value of x is:", latex: `${ansValue}` }
            ],
            metadata: { variation_key: v, difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\SimilarityGen.ts

// =======================================================
// FILE START: src\core\generators\StatisticsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class StatisticsGen {
    // --- CONTEXT LIBRARY ---
    private static readonly SCENARIOS = {
        lists: [
            { id: 'shoe', sv: "skostorlekar", en: "shoe sizes", unit: "", min: 35, max: 45 },
            { id: 'goals', sv: "gjorda m√•l", en: "goals scored", unit: "m√•l", min: 0, max: 6 },
            { id: 'temp', sv: "temperaturer", en: "temperatures", unit: "¬∞C", min: 15, max: 25 },
            { id: 'age', sv: "√•ldrar", en: "ages", unit: "√•r", min: 10, max: 16 },
            { id: 'points', sv: "po√§ng", en: "points", unit: "p", min: 5, max: 20 },
            { id: 'height', sv: "l√§ngder", en: "heights", unit: "cm", min: 150, max: 170 },
            { id: 'sleep', sv: "s√∂mntimmar", en: "hours of sleep", unit: "h", min: 6, max: 10 }
        ],
        real_world: [
            { sv: "l√∂ner", en: "salaries", unit: "kr", min: 25, max: 45, suffix: 'k' },
            { sv: "huspriser", en: "house prices", unit: "kr", min: 2, max: 8, suffix: ' milj.' },
            { sv: "t√§vlingsresultat", en: "competition scores", unit: "p", min: 50, max: 100, suffix: '' }
        ],
        shopping: [
            { sv: "√§pplen", en: "apples", unit: "kr/kg", min: 15, max: 35 },
            { sv: "godis", en: "candy", unit: "kr/hg", min: 8, max: 15 },
            { sv: "potatis", en: "potatoes", unit: "kr/kg", min: 10, max: 20 },
            { sv: "oxfil√©", en: "beef fillet", unit: "kr/kg", min: 300, max: 600 },
            { sv: "lax", en: "salmon", unit: "kr/kg", min: 200, max: 400 }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ModeRange(lang);
            case 2: return this.level2_Mean(lang);
            case 3: return this.level3_Median(lang);
            case 4: return this.level4_ReverseMean(lang);
            case 5: return this.level5_FrequencyTable(lang);
            case 6: return this.level6_RealWorldMixed(lang);
            default: return this.level1_ModeRange(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'find_mode':
            case 'find_range':
            case 'stats_lie':
            case 'find_min_max':
                return this.level1_ModeRange(lang, key);
            case 'calc_mean':
            case 'mean_concept_balance':
            case 'mean_negatives':
                return this.level2_Mean(lang, key);
            case 'median_odd':
            case 'median_even':
            case 'median_lie':
                return this.level3_Median(lang, key);
            case 'reverse_mean_calc':
            case 'mean_target_score':
                return this.level4_ReverseMean(lang, key);
            case 'freq_mean':
            case 'freq_count':
            case 'freq_mode':
            case 'freq_range':
                return this.level5_FrequencyTable(lang, key);
            case 'real_outlier_shift':
            case 'real_measure_choice':
            case 'real_weighted_avg':
            case 'real_weighted_missing':
                return this.level6_RealWorldMixed(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: MODE & RANGE ---
    private level1_ModeRange(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['find_mode', 'find_range', 'stats_lie', 'find_min_max']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);
        const len = MathUtils.randomInt(6, 9);
        const list: number[] = [];
        
        const modeVal = MathUtils.randomInt(s.min, s.max);
        if (v !== 'find_min_max') {
            for(let i=0; i<3; i++) list.push(modeVal); 
            for(let i=0; i<len-3; i++) list.push(MathUtils.randomInt(s.min, s.max));
        } else {
            for(let i=0; i<len; i++) list.push(MathUtils.randomInt(s.min, s.max));
        }
        
        const shuffled = [...list].sort(() => Math.random() - 0.5);
        const setStr = shuffled.join(', ');

        if (v === 'find_mode') {
            return {
                renderData: { 
                    description: lang === 'sv' ? `Vilket √§r typv√§rdet f√∂r f√∂ljande ${s.sv}: ${setStr}?` : `What is the mode for the following ${s.en}: ${setStr}?`,
                    answerType: 'numeric' 
                },
                token: this.toBase64(modeVal.toString()),
                clues: [
                    { text: lang === 'sv' ? "Typv√§rdet √§r det v√§rde som f√∂rekommer flest g√•nger i datam√§ngden." : "The mode is the value that appears most frequently in the data set." },
                    { text: lang === 'sv' ? `V√§rdet som upprepas mest √§r:` : `The value repeated the most is:`, latex: `${modeVal}` }
                ],
                metadata: { variation_key: 'find_mode', difficulty: 1 }
            };
        }

        if (v === 'find_range') {
            const min = Math.min(...list);
            const max = Math.max(...list);
            const range = max - min;
            return {
                renderData: { 
                    description: lang === 'sv' ? `Ber√§kna variationsbredden f√∂r dessa ${s.sv}: ${setStr}.` : `Calculate the range for these ${s.en}: ${setStr}.`,
                    answerType: 'numeric' 
                },
                token: this.toBase64(range.toString()),
                clues: [
                    { text: lang === 'sv' ? "Variationsbredden √§r skillnaden mellan det st√∂rsta och det minsta v√§rdet." : "The range is the difference between the largest and the smallest value." },
                    { text: lang === 'sv' ? "Hitta max och min och ber√§kna differensen:" : "Find the max and min and calculate the difference:", latex: `${max} - ${min} = ${range}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${range}` }
                ],
                metadata: { variation_key: 'find_range', difficulty: 1 }
            };
        }

        if (v === 'find_min_max') {
            const min = Math.min(...list);
            const max = Math.max(...list);
            const isMin = Math.random() > 0.5;
            const ans = isMin ? min : max;
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket √§r det ${isMin ? 'minsta' : 'st√∂rsta'} v√§rdet i listan: ${setStr}?` : `What is the ${isMin ? 'minimum' : 'maximum'} value in the list: ${setStr}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Leta igenom listan metodiskt efter det ${isMin ? 'l√§gsta' : 'h√∂gsta'} talet.` : `Search the list methodically for the ${isMin ? 'lowest' : 'highest'} number.` },
                    { text: lang === 'sv' ? "V√§rdet √§r:" : "The value is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'find_min_max', difficulty: 1 }
            };
        }

        const minVal = Math.min(...list);
        const maxVal = Math.max(...list);
        const rangeVal = maxVal - minVal;
        const sFalse = lang === 'sv' ? `Minsta v√§rdet √§r ${minVal - 2}` : `Min value is ${minVal - 2}`;

        return {
            renderData: {
                description: lang === 'sv' ? `Granska listan: ${setStr}. Vilket p√•st√•ende √§r FALSKT?` : `Review the list: ${setStr}. Which statement is FALSE?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([
                    lang === 'sv' ? `Typv√§rdet √§r ${modeVal}` : `Mode is ${modeVal}`,
                    lang === 'sv' ? `Variationsbredden √§r ${rangeVal}` : `Range is ${rangeVal}`,
                    sFalse
                ])
            },
            token: this.toBase64(sFalse),
            clues: [
                { text: lang === 'sv' ? "Kontrollera p√•st√•endena genom att identifiera min, max och typv√§rde i listan." : "Verify the statements by identifying min, max, and mode in the list." },
                { text: lang === 'sv' ? "Detta p√•st√•ende st√§mmer inte:" : "This statement is not correct:", latex: `\\text{${sFalse}}` }
            ],
            metadata: { variation_key: 'stats_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 2: MEAN ---
    private level2_Mean(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['calc_mean', 'mean_concept_balance', 'mean_negatives']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);

        if (v === 'mean_negatives' || s.id === 'temp') {
            const list = Array.from({length: 4}, () => MathUtils.randomInt(-5, 5));
            const sum = list.reduce((a, b) => a + b, 0);
            const mean = Math.round((sum / 4) * 10) / 10;
            return {
                renderData: {
                    description: lang === 'sv' ? `Ber√§kna medeltemperaturen f√∂r: ${list.join('¬∞C, ')}¬∞C.` : `Calculate the mean temperature for: ${list.join('¬∞C, ')}¬∞C.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(mean.toString()),
                clues: [
                    { text: lang === 'sv' ? "Summan av v√§rdena delat med antalet v√§rden ger medelv√§rdet." : "The sum of the values divided by the count of values gives the mean." },
                    { text: lang === 'sv' ? "Ber√§kna summan f√∂rst (t√§nk p√• tecknen):" : "Calculate the sum first (watch the signs):", latex: `${list.join(' + ')} = ${sum}` },
                    { text: lang === 'sv' ? "Dela summan med 4:" : "Divide the sum by 4:", latex: `\\frac{${sum}}{4} = ${mean}` },
                    { text: lang === 'sv' ? "Medelv√§rdet √§r:" : "The mean is:", latex: `${mean}` }
                ],
                metadata: { variation_key: 'mean_negatives', difficulty: 3 }
            };
        }

        if (v === 'mean_concept_balance') {
            const oldMean = 20;
            const newVal = MathUtils.randomChoice([10, 30]);
            const isLower = newVal < oldMean;
            const ans = isLower ? (lang === 'sv' ? "Det minskar" : "It decreases") : (lang === 'sv' ? "Det √∂kar" : "It increases");
            return {
                renderData: {
                    description: lang === 'sv' ? `Om medelv√§rdet √§r ${oldMean} och ett nytt v√§rde p√• ${newVal} l√§ggs till, vad h√§nder med medelv√§rdet?` : `If the mean is ${oldMean} and a new value of ${newVal} is added, what happens to the mean?`,
                    answerType: 'multiple_choice',
                    options: lang === 'sv' ? ["Det √∂kar", "Det minskar", "Det √§r of√∂r√§ndrat"] : ["It increases", "It decreases", "It stays unchanged"]
                },
                token: this.toBase64(ans),
                clues: [
                    { text: lang === 'sv' ? "Om ett v√§rde som √§r l√§gre √§n det nuvarande snittet l√§ggs till s√• sjunker medelv√§rdet. Om det √§r h√∂gre s√• stiger det." : "If a value lower than the current average is added, the mean drops. If it is higher, it rises." },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `\\text{${ans}}` }
                ],
                metadata: { variation_key: 'mean_concept_balance', difficulty: 2 }
            };
        }

        const count = MathUtils.randomInt(4, 5);
        const list = Array.from({length: count}, () => MathUtils.randomInt(s.min, s.max));
        const sum = list.reduce((a, b) => a + b, 0);
        const mean = Math.round((sum / count) * 10) / 10;

        return {
            renderData: {
                description: lang === 'sv' ? `R√§kna ut medelv√§rdet f√∂r: ${list.join(', ')}.` : `Calculate the mean for: ${list.join(', ')}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(mean.toString()),
            clues: [
                { text: lang === 'sv' ? "Addera alla tal f√∂r att f√• totalsumman." : "Add all numbers to get the total sum.", latex: `${list.join(' + ')} = ${sum}` },
                { text: lang === 'sv' ? `Dividera summan med antalet tal (${count}).` : `Divide the sum by the number of values (${count}).`, latex: `\\frac{${sum}}{${count}} = ${mean}` },
                { text: lang === 'sv' ? "Medelv√§rdet blir:" : "The mean becomes:", latex: `${mean}` }
            ],
            metadata: { variation_key: 'calc_mean', difficulty: 2 }
        };
    }

    // --- LEVEL 3: MEDIAN ---
    private level3_Median(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['median_odd', 'median_even', 'median_lie']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);
        const count = v === 'median_even' ? 6 : 5;
        const list = Array.from({length: count}, () => MathUtils.randomInt(s.min, s.max));
        const sorted = [...list].sort((a, b) => a - b);
        
        let median = 0;
        if (count % 2 !== 0) {
            median = sorted[Math.floor(count / 2)];
        } else {
            median = (sorted[count/2 - 1] + sorted[count/2]) / 2;
        }

        if (v === 'median_lie') {
            const sTrue = lang === 'sv' ? `Medianen √§r ${median}` : `Median is ${median}`;
            const sLie = lang === 'sv' ? `Medianen √§r ${sorted[0]}` : `Median is ${sorted[0]}`;
            return {
                renderData: {
                    description: lang === 'sv' ? `Givet listan ${list.join(', ')}, vilket p√•st√•ende st√§mmer?` : `Given the list ${list.join(', ')}, which statement is true?`,
                    answerType: 'multiple_choice',
                    options: [sTrue, sLie]
                },
                token: this.toBase64(sTrue),
                clues: [
                    { text: lang === 'sv' ? "Sortera talen och hitta det mittersta v√§rdet f√∂r att best√§mma medianen." : "Sort the numbers and find the middle value to determine the median.", latex: sorted.join(', ') },
                    { text: lang === 'sv' ? "R√§tt svar √§r:" : "The correct answer is:", latex: `\\text{${sTrue}}` }
                ],
                metadata: { variation_key: 'median_lie', difficulty: 2 }
            };
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Best√§m medianen f√∂r: ${list.sort(() => Math.random() - 0.5).join(', ')}.` : `Determine the median for: ${list.sort(() => Math.random() - 0.5).join(', ')}.`,
                answerType: 'numeric'
            },
            token: this.toBase64(median.toString()),
            clues: [
                { text: lang === 'sv' ? "Sortera f√∂rst talen i storleksordning." : "First, sort the numbers in size order.", latex: sorted.join(', ') },
                { text: lang === 'sv' ? (count % 2 !== 0 ? "Eftersom det √§r ett udda antal tal √§r medianen talet i mitten." : "Vid ett j√§mnt antal tal √§r medianen snittet av de tv√• talen i mitten.") : (count % 2 !== 0 ? "Since there is an odd number of values, the median is the number in the middle." : "With an even number of values, the median is the average of the two numbers in the middle."), latex: count % 2 !== 0 ? `${median}` : `\\frac{${sorted[count/2 - 1]} + ${sorted[count/2]}}{2} = ${median}` },
                { text: lang === 'sv' ? "Medianen √§r:" : "The median is:", latex: `${median}` }
            ],
            metadata: { variation_key: v, difficulty: 2 }
        };
    }

    // --- LEVEL 4: REVERSE MEAN ---
    private level4_ReverseMean(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['reverse_mean_calc', 'mean_target_score']);
        
        if (v === 'mean_target_score') {
            const score1 = MathUtils.randomInt(10, 15), score2 = MathUtils.randomInt(12, 18);
            const targetMean = 16;
            const required = (targetMean * 3) - score1 - score2;
            return {
                renderData: {
                    description: lang === 'sv' ? `Du har ${score1} och ${score2} po√§ng p√• tv√• prov. Vad kr√§vs p√• det tredje provet f√∂r att snittet ska bli ${targetMean}?` : `You have ${score1} and ${score2} points on two tests. What is required on the third test for the average to be ${targetMean}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(required.toString()),
                clues: [
                    { text: lang === 'sv' ? `R√§kna ut vad den totala summan av 3 prov m√•ste vara.` : `Calculate what the total sum of 3 tests must be.`, latex: `3 \\cdot ${targetMean} = ${targetMean * 3}` },
                    { text: lang === 'sv' ? `Dra bort de po√§ng du redan har fr√•n m√•let.` : `Subtract the points you already have from the target.`, latex: `${targetMean * 3} - ${score1} - ${score2} = ${required}` },
                    { text: lang === 'sv' ? "Du beh√∂ver:" : "You need:", latex: `${required}` }
                ],
                metadata: { variation_key: 'mean_target_score', difficulty: 4 }
            };
        }

        const count = 4, mean = 15;
        const total = mean * count;
        const v1 = 12, v2 = 18, v3 = 14;
        const missing = total - (v1 + v2 + v3);

        return {
            renderData: {
                description: lang === 'sv' ? `Medelv√§rdet av fyra tal √§r ${mean}. Tre av talen √§r ${v1}, ${v2} och ${v3}. Vad √§r det fj√§rde?` : `The mean of four numbers is ${mean}. Three of the numbers are ${v1}, ${v2}, and ${v3}. What is the fourth?`,
                answerType: 'numeric'
            },
            token: this.toBase64(missing.toString()),
            clues: [
                { text: lang === 'sv' ? "Ber√§kna den totala summan utifr√•n medelv√§rdet." : "Calculate the total sum based on the mean.", latex: `${mean} \\cdot 4 = ${total}` },
                { text: lang === 'sv' ? "Dra bort summan av de k√§nda talen fr√•n totalsumman." : "Subtract the sum of the known numbers from the total sum.", latex: `${total} - (${v1} + ${v2} + ${v3}) = ${missing}` },
                { text: lang === 'sv' ? "Det fj√§rde talet √§r:" : "The fourth number is:", latex: `${missing}` }
            ],
            metadata: { variation_key: 'reverse_mean_calc', difficulty: 3 }
        };
    }

    // --- LEVEL 5: FREQUENCY TABLES ---
    private level5_FrequencyTable(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['freq_mean', 'freq_count', 'freq_mode']);
        const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.lists);
        const rows = [[1, 2], [2, 5], [3, 3], [4, 1]];
        const totalCount = 11;
        const totalSum = 25; 
        
        if (v === 'freq_mode') {
            return {
                renderData: {
                    description: lang === 'sv' ? `Vilket √§r typv√§rdet enligt tabellen?` : `What is the mode according to the table?`,
                    answerType: 'numeric',
                    geometry: { type: 'frequency_table', headers: lang === 'sv' ? ['V√§rde', 'Antal'] : ['Value', 'Count'], rows }
                },
                token: this.toBase64("2"),
                clues: [
                    { text: lang === 'sv' ? "Typv√§rdet √§r det v√§rde som har h√∂gst frekvens (st√∂rst antal)." : "The mode is the value that has the highest frequency (largest count)." },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: "2" }
                ],
                metadata: { variation_key: 'freq_mode', difficulty: 2 }
            };
        }

        if (v === 'freq_count') {
            return {
                renderData: {
                    description: lang === 'sv' ? "Hur m√•nga observationer gjordes totalt?" : "How many observations were made in total?",
                    answerType: 'numeric',
                    geometry: { type: 'frequency_table', headers: lang === 'sv' ? ['V√§rde', 'Antal'] : ['Value', 'Count'], rows }
                },
                token: this.toBase64(totalCount.toString()),
                clues: [
                    { text: lang === 'sv' ? "Addera alla siffror i kolumnen f√∂r 'Antal'." : "Add all the numbers in the 'Count' column.", latex: `2 + 5 + 3 + 1 = ${totalCount}` },
                    { text: lang === 'sv' ? "Totalt antal:" : "Total count:", latex: `${totalCount}` }
                ],
                metadata: { variation_key: 'freq_count', difficulty: 2 }
            };
        }

        const mean = Math.round((totalSum / totalCount) * 10) / 10;
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna medelv√§rdet f√∂r tabellen (en decimal).` : `Calculate the mean for the table (one decimal).`,
                answerType: 'numeric',
                geometry: { type: 'frequency_table', headers: lang === 'sv' ? ['V√§rde', 'Antal'] : ['Value', 'Count'], rows }
            },
            token: this.toBase64(mean.toString()),
            clues: [
                { text: lang === 'sv' ? "Ber√§kna totala summan genom att multiplicera v√§rdena med deras antal." : "Calculate the total sum by multiplying the values by their counts.", latex: `(1 \\cdot 2) + (2 \\cdot 5) + (3 \\cdot 3) + (4 \\cdot 1) = ${totalSum}` },
                { text: lang === 'sv' ? "Dividera totalsumman med det totala antalet observationer." : "Divide the total sum by the total number of observations.", latex: `\\frac{${totalSum}}{${totalCount}} = ${mean}` },
                { text: lang === 'sv' ? "Medelv√§rdet √§r:" : "The mean is:", latex: `${mean}` }
            ],
            metadata: { variation_key: 'freq_mean', difficulty: 3 }
        };
    }

    // --- LEVEL 6: REAL WORLD ---
    private level6_RealWorldMixed(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['real_weighted_missing', 'real_outlier_shift', 'real_measure_choice']);

        if (v === 'real_weighted_missing') {
            const s = MathUtils.randomChoice(StatisticsGen.SCENARIOS.shopping);
            const ans = 30;
            return {
                renderData: {
                    description: lang === 'sv' ? `Du k√∂per 2 kg ${s.sv} f√∂r 20 kr/kg och 3 kg till. Medelpriset blev 26 kr/kg. Vad kostade den andra sorten?` : `You buy 2 kg of ${s.en} for 20 kr/kg and 3 kg more. The mean price was 26 kr/kg. What was the price of the second kind?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? "R√§kna ut totalsumman f√∂r alla 5 kg." : "Calculate the total cost for all 5 kg.", latex: `5 \\cdot 26 = 130` },
                    { text: lang === 'sv' ? "Ta bort kostnaden f√∂r de f√∂rsta 2 kilona." : "Subtract the cost of the first 2 kg.", latex: `130 - (2 \\cdot 20) = 90` },
                    { text: lang === 'sv' ? "Dela resten p√• de √•terst√•ende 3 kilona." : "Divide the remainder by the remaining 3 kg.", latex: `\\frac{90}{3} = ${ans}` },
                    { text: lang === 'sv' ? "Priset per kg var:" : "The price per kg was:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'real_weighted_missing', difficulty: 4 }
            };
        }

        if (v === 'real_outlier_shift') {
            const diff = 13;
            return {
                renderData: {
                    description: lang === 'sv' ? "L√∂nerna √§r 25k, 27k, 28k och 80k. Hur mycket √§ndras snittet om chefen (80k) tas bort?" : "Salaries are 25k, 27k, 28k, and 80k. How much does the mean change if the boss (80k) is removed?",
                    answerType: 'numeric'
                },
                token: this.toBase64(diff.toString()),
                clues: [
                    { text: lang === 'sv' ? "J√§mf√∂r snittet f√∂r alla fyra anst√§llda med snittet f√∂r de tre som tj√§nar minst." : "Compare the mean of all four employees with the mean of the three lowest earners." },
                    { text: lang === 'sv' ? "Utr√§kning:" : "Calculation:", latex: `\\frac{160}{4} - \\frac{80}{3} \\approx ${diff}` },
                    { text: lang === 'sv' ? "Skillnaden √§r:" : "The difference is:", latex: `${diff}` }
                ],
                metadata: { variation_key: 'real_outlier_shift', difficulty: 4 }
            };
        }

        const ans = lang === 'sv' ? "Median" : "Median";
        return {
            renderData: {
                description: lang === 'sv' ? "Vid extremv√§rden (som ett lyxhus bland vanliga hus), vilket m√•tt √§r mest r√§ttvist?" : "With extreme values (like a luxury house among normal houses), which measure is fairest?",
                answerType: 'multiple_choice',
                options: lang === 'sv' ? ["Medelv√§rde", "Median", "Variationsbredd"] : ["Mean", "Median", "Range"]
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang === 'sv' ? "Medelv√§rdet dras upp kraftigt av extremv√§rden, medan medianen f√∂rblir stabil." : "The mean is pulled up significantly by extreme values, while the median remains stable." },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `\\text{${ans}}` }
            ],
            metadata: { variation_key: 'real_measure_choice', difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\StatisticsGen.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class TenPowersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_MultDivBig(lang);
            case 2: return this.level2_Concepts(lang);
            case 3: return this.level3_DecimalPowers(lang);
            default: return this.level1_MultDivBig(lang);
        }
    }

    /**
     * Phase 2: Targeted Generation
     */
    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'big_mult_std':
            case 'big_div_std':
            case 'big_missing_factor':
            case 'power_discovery':
                return this.level1_MultDivBig(lang, key);
            case 'reciprocal_equivalence':
            case 'concept_spot_lie':
                return this.level2_Concepts(lang, key);
            case 'decimal_div_std':
            case 'decimal_mult_std':
            case 'decimal_logic_trap':
                return this.level3_DecimalPowers(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private fixFloat(n: number) { 
        return parseFloat(n.toFixed(8)); 
    }

    /**
     * Converts numbers/signs into Unicode superscripts for clear button display.
     */
    private toSup(num: number | string): string {
        const map: any = {
            '0': '‚Å∞', '1': '¬π', '2': '¬≤', '3': '¬≥', '4': '‚Å¥',
            '5': '‚Åµ', '6': '‚Å∂', '7': '‚Å∑', '8': '‚Å∏', '9': '‚Åπ', '-': '‚Åª'
        };
        return num.toString().split('').map(char => map[char] || char).join('');
    }

    // --- LEVEL 1: MULT/DIV BY 10, 100, 1000 & POWERS ---
    private level1_MultDivBig(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['big_mult_std', 'big_div_std', 'big_missing_factor', 'power_discovery']);

        if (v === 'big_mult_std' || v === 'big_div_std') {
            const power = MathUtils.randomChoice([10, 100, 1000, 10000]);
            const isMult = v === 'big_mult_std';
            const num = MathUtils.randomInt(5, 95) / (Math.random() > 0.5 ? 1 : 10);
            const ans = isMult ? num * power : this.fixFloat(num / power);
            const zeros = Math.round(Math.log10(power));

            return {
                renderData: {
                    latex: isMult ? `${num} \\cdot ${power}` : `${num} / ${power}`,
                    description: lang === 'sv' ? "Ber√§kna uttryckets v√§rde." : "Calculate the value of the expression.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `R√§kna antalet nollor i talet ${power}. Det avg√∂r hur m√•nga steg kommat ska flyttas.` : `Count the number of zeros in ${power}. This determines how many places the decimal moves.`, 
                        latex: `10^{${zeros}} = ${power}` 
                    },
                    { 
                        text: lang === 'sv' ? `Flytta kommat ${zeros} steg √•t ${isMult ? 'h√∂ger (talet blir st√∂rre).' : 'v√§nster (talet blir mindre).'}` : `Move the decimal ${zeros} places to the ${isMult ? 'right (making the number larger).' : 'left (making the number smaller).'}`, 
                        latex: `${num} \\rightarrow ${ans}`
                    },
                    { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: v, difficulty: 1 }
            };
        }

        if (v === 'big_missing_factor') {
            const power = MathUtils.randomChoice([10, 100, 1000]);
            const num = MathUtils.randomInt(5, 50);
            const isMult = Math.random() > 0.5;
            const res = isMult ? num * power : this.fixFloat(num / power);

            return {
                renderData: {
                    latex: isMult ? `${num} \\cdot ? = ${res}` : `${num} / ? = ${res}`,
                    description: lang === 'sv' ? "Vilken tiopotens saknas?" : "Which power of ten is missing?",
                    answerType: 'numeric'
                },
                token: this.toBase64(power.toString()),
                clues: [
                    { text: lang === 'sv' ? `J√§mf√∂r ${num} med ${res}. Hur m√•nga steg har kommatecknet flyttats?` : `Compare ${num} with ${res}. How many places has the decimal point moved?` },
                    { text: lang === 'sv' ? `Varje steg motsvarar en nolla efter ettan.` : `Each step corresponds to a zero after the one.`, latex: `10^{${Math.round(Math.log10(power))}} = ${power}` },
                    { text: lang === 'sv' ? "Den saknade tiopotensen √§r:" : "The missing power of ten is:", latex: `${power}` }
                ],
                metadata: { variation_key: 'big_missing_factor', difficulty: 2 }
            };
        }

        const pVal = MathUtils.randomInt(2, 6);
        const num = Math.pow(10, pVal);
        return {
            renderData: {
                description: lang === 'sv' ? `Skriv talet ${this.formatNum(num)} som en potens med basen 10.` : `Write ${num} as a power with base 10.`,
                latex: `${num} = 10^{?}`,
                answerType: 'structured_power'
            },
            token: this.toBase64(`10^${pVal}`),
            clues: [
                { text: lang === 'sv' ? `Antalet nollor efter siffran 1 motsvarar exponenten i tiopotensen.` : `The number of zeros after the digit 1 corresponds to the exponent in the power of ten.`, latex: `10^{${pVal}} = ${num}` },
                { text: lang === 'sv' ? "Svaret i potensform √§r:" : "The answer in power form is:", latex: `10^{${pVal}}` }
            ],
            metadata: { variation_key: 'power_discovery', difficulty: 2 }
        };
    }

    private formatNum(n: number): string {
        return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    }

    // --- LEVEL 2: CONCEPTUAL RECIPROCALS ---
    private level2_Concepts(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['reciprocal_equivalence', 'concept_spot_lie']);

        if (v === 'reciprocal_equivalence') {
            const scenarios = [
                { op: 'mul', val: 0.1, equiv: 10, equivOp: 'div' },
                { op: 'mul', val: 0.01, equiv: 100, equivOp: 'div' },
                { op: 'div', val: 0.1, equiv: 10, equivOp: 'mul' },
                { op: 'div', val: 0.01, equiv: 100, equivOp: 'mul' }
            ];
            const s = MathUtils.randomChoice(scenarios);
            const opText = lang === 'sv' ? (s.op === 'mul' ? "multiplicera med" : "dividera med") : (s.op === 'mul' ? "multiplying by" : "dividing by");
            const targetText = lang === 'sv' ? (s.equivOp === 'mul' ? "multiplicera med..." : "dividera med...") : (s.equivOp === 'mul' ? "multiplying by..." : "dividing by...");

            return {
                renderData: {
                    description: lang === 'sv' ? `Att ${opText} ${s.val.toString().replace('.', ',')} ger samma resultat som att ${targetText}` : `To ${opText} ${s.val} gives the same result as ${targetText}`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(["10", "100", "0,1", "0,01", "1000"])
                },
                token: this.toBase64(s.equiv.toString()),
                clues: [
                    { text: lang === 'sv' ? `Kom ih√•g att ${s.val.toString().replace('.', ',')} √§r en ${s.equiv === 10 ? 'tiondel' : 'hundradel'}.` : `Remember that ${s.val} is one ${s.equiv === 10 ? 'tenth' : 'hundredth'}.`, latex: `${s.val.toString().replace('.', ',')} = \\frac{1}{${s.equiv}}` },
                    { text: lang === 'sv' ? "R√§tt tal att anv√§nda √§r:" : "The correct number to use is:", latex: `${s.equiv}` }
                ],
                metadata: { variation_key: 'reciprocal_equivalence', difficulty: 2 }
            };
        }

        const num = MathUtils.randomInt(3, 9) * 10;
        const sTrue = `${num} ¬∑ 0,1 = ${num/10}`;
        const sLie = `${num} ¬∑ 0,1 = ${num * 10}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende √§r FALSKT?" : "Which statement is FALSE?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([sTrue, sLie, `${num} / 0,1 = ${num * 10}`])
            },
            token: this.toBase64(sLie),
            clues: [
                { text: lang === 'sv' ? "Multiplikation med ett tal mindre √§n 1 (som 0,1) g√∂r talet mindre, inte st√∂rre." : "Multiplication with a number less than 1 (like 0.1) makes the number smaller, not larger.", latex: `${num} \\cdot 0,1 = ${num/10}` },
                { text: lang === 'sv' ? "Denna ber√§kning st√§mmer allts√• inte:" : "This calculation is therefore incorrect:", latex: `\\text{${sLie}}` }
            ],
            metadata: { variation_key: 'concept_spot_lie', difficulty: 2 }
        };
    }

    // --- LEVEL 3: DECIMAL POWERS ---
    private level3_DecimalPowers(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['decimal_div_std', 'decimal_mult_std', 'decimal_logic_trap']);
        const factor = MathUtils.randomChoice([0.1, 0.01]);
        const num = MathUtils.randomInt(5, 50);

        if (v === 'decimal_div_std') {
            const ans = this.fixFloat(num / factor);
            const equivMult = Math.round(1 / factor);
            return {
                renderData: {
                    latex: `${num} / ${factor.toString().replace('.', ',')}`,
                    description: lang === 'sv' ? "Ber√§kna resultatet." : "Calculate the result.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Division med ${factor.toString().replace('.', ',')} √§r samma sak som multiplikation med ${equivMult}.` : `Division by ${factor} is the same as multiplication by ${equivMult}.`, latex: `\\frac{${num}}{${factor.toString().replace('.', ',')}} = ${num} \\cdot ${equivMult}` },
                    { text: lang === 'sv' ? "Resultatet blir:" : "The result is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'decimal_div_std', difficulty: 3 }
            };
        }

        if (v === 'decimal_mult_std') {
            const ans = this.fixFloat(num * factor);
            const equivDiv = Math.round(1 / factor);
            return {
                renderData: {
                    latex: `${num} \\cdot ${factor.toString().replace('.', ',')}`,
                    description: lang === 'sv' ? "Ber√§kna resultatet." : "Calculate the result.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Multiplikation med ${factor.toString().replace('.', ',')} √§r detsamma som division med ${equivDiv}.` : `Multiplication by ${factor} is the same as division by ${equivDiv}.`, latex: `${num} \\cdot ${factor.toString().replace('.', ',')} = \\frac{${num}}{${equivDiv}}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${ans}` }
                ],
                metadata: { variation_key: 'decimal_mult_std', difficulty: 3 }
            };
        }

        const isMult = Math.random() > 0.5;
        const result = isMult ? this.fixFloat(num * factor) : this.fixFloat(num / factor);
        const correctStmt = `${num} ${isMult ? '¬∑' : '/'} ${factor.toString().replace('.', ',')} = ${result.toString().replace('.', ',')}`;

        return {
            renderData: {
                description: lang === 'sv' ? "Vilket p√•st√•ende √§r korrekt?" : "Which statement is correct?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([
                    correctStmt,
                    `${num} ${isMult ? '¬∑' : '/'} ${1/factor} = ${result.toString().replace('.', ',')}`,
                    `${num} ${isMult ? '¬∑' : '/'} 1 = ${result.toString().replace('.', ',')}`
                ])
            },
            token: this.toBase64(correctStmt),
            clues: [
                { text: lang === 'sv' ? `Kontrollera om resultatet (${result.toString().replace('.', ',')}) √§r rimligt f√∂r r√§knes√§ttet.` : `Check if the result (${result}) is reasonable for the operation.` },
                { text: lang === 'sv' ? "Det korrekta p√•st√•endet √§r:" : "The correct statement is:", latex: `\\text{${correctStmt}}` }
            ],
            metadata: { variation_key: 'decimal_logic_trap', difficulty: 3 }
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class VolumeGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Cuboid(lang);
            case 2: return this.level2_TriPrism(lang);
            case 3: return this.level3_Cylinder(lang);
            case 4: return this.level4_PyramidCone(lang);
            case 5: return this.level5_SphereComposite(lang);
            case 6: return this.level6_Mixed(lang);
            case 7: return this.level7_Units(lang);
            case 8: return this.level8_SurfaceArea(lang);
            default: return this.level1_Cuboid(lang);
        }
    }

    public generateByVariation(key: string, lang: string = 'sv'): any {
        switch (key) {
            case 'vol_cuboid_std':
            case 'vol_cuboid_inverse':
            case 'vol_cuboid_scaling':
                return this.level1_Cuboid(lang, key);
            case 'vol_tri_prism_std':
            case 'vol_tri_prism_inverse':
                return this.level2_TriPrism(lang, key);
            case 'vol_cyl_std':
            case 'vol_cyl_est':
            case 'vol_cyl_inverse':
                return this.level3_Cylinder(lang, key);
            case 'vol_pyramid_std':
            case 'vol_cone_rule3':
            case 'vol_cone_std':
                return this.level4_PyramidCone(lang, key);
            case 'vol_sphere_std':
            case 'vol_silo_std':
            case 'vol_icecream_std':
                return this.level5_SphereComposite(lang, key);
            case 'vol_sphere_diameter':
            case 'vol_icecream_diameter':
                return this.level6_Mixed(lang, key);
            case 'vol_units_liter':
            case 'vol_units_m3':
                return this.level7_Units(lang, key);
            case 'sa_cuboid':
            case 'sa_cylinder':
            case 'sa_cone':
            case 'sa_sphere':
                return this.level8_SurfaceArea(lang, key);
            default:
                return this.generate(1, lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: CUBOID ---
    private level1_Cuboid(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_cuboid_std', 'vol_cuboid_inverse', 'vol_cuboid_scaling']);
        const w = MathUtils.randomInt(3, 7), d = MathUtils.randomInt(4, 8), h = MathUtils.randomInt(3, 6);
        const baseArea = w * d;
        const vol = baseArea * h;

        if (v === 'vol_cuboid_inverse') {
            const desc = lang === 'sv' 
                ? `Ett r√§tblock har volymen ${vol} cm¬≥ och en bottenarea p√• ${baseArea} cm¬≤. Ber√§kna r√§tblockets h√∂jd.` 
                : `A rectangular prism has a volume of ${vol} cm¬≥ and a base area of ${baseArea} cm¬≤. Calculate the height.`;
            
            return {
                renderData: { geometry: { type: 'cuboid', labels: { w, d, h: '?' } }, description: desc, answerType: 'numeric', suffix: 'cm' },
                token: this.toBase64(h.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = B \\cdot h$." : "Step 1: Use the formula $V = B \\cdot h$.", latex: "V = B \\cdot h" },
                    { text: lang === 'sv' ? "Dela volymen med bottenarean f√∂r att f√• fram h√∂jden." : "Divide the volume by the base area to find the height.", latex: `\\frac{${vol}}{${baseArea}} = ${h} \\\\ h = ${h}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${h}` }
                ],
                metadata: { variation_key: 'vol_cuboid_inverse', difficulty: 2 }
            };
        }

        if (v === 'vol_cuboid_scaling') {
            const factor = MathUtils.randomInt(2, 4);
            const ansText = lang === 'sv' ? `Den blir ${factor} g√•nger st√∂rre` : `It becomes ${factor} times larger`;
            const wrongText = lang === 'sv' ? "Den √§ndras inte" : "It stays the same";
            
            return {
                renderData: {
                    description: lang === 'sv' ? `Om du g√∂r ett r√§tblock ${factor} g√•nger h√∂gre, vad h√§nder d√• med volymen?` : `If you make a cuboid ${factor} times taller, what happens to the volume?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ansText, wrongText, lang === 'sv' ? "Den blir h√§lften s√• stor" : "It becomes half the size"])
                },
                token: this.toBase64(ansText),
                clues: [
                    { text: lang === 'sv' ? "Volymen ber√§knas som $B \\cdot h$. Om h√∂jden √∂kar med en faktor s√• √∂kar volymen med samma faktor." : "The volume is calculated as $B \\cdot h$. If the height increases by a factor, the volume increases by that same factor.", latex: `V_{ny} = B \\cdot (${factor} \\cdot h) \\\\ ${factor} \\cdot V` },
                    { text: lang === 'sv' ? "R√§tt svar √§r:" : "The correct answer is:", latex: `\\text{${ansText}}` }
                ],
                metadata: { variation_key: 'vol_cuboid_scaling', difficulty: 2 }
            };
        }

        return {
            renderData: { geometry: { type: 'cuboid', labels: { w, d, h } }, description: lang === 'sv' ? "Ber√§kna r√§tblockets volym." : "Calculate the volume of the cuboid.", answerType: 'numeric', suffix: 'cm¬≥' },
            token: this.toBase64(vol.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = l \\cdot b \\cdot h$." : "Step 1: Use the formula $V = l \\cdot b \\cdot h$.", latex: "V = l \\cdot b \\cdot h" },
                { text: lang === 'sv' ? "Multiplicera bredden, djupet och h√∂jden." : "Multiply the width, depth, and height.", latex: `${w} \\cdot ${d} \\cdot ${h} = ${vol} \\\\ V = ${vol}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${vol}` }
            ],
            metadata: { variation_key: 'vol_cuboid_std', difficulty: 1 }
        };
    }

    // --- LEVEL 2: TRIANGULAR PRISM ---
    private level2_TriPrism(lang: string, variationKey?: string): any {
        const b = MathUtils.randomInt(4, 10), hTri = MathUtils.randomInt(4, 8), length = MathUtils.randomInt(10, 20);
        const baseArea = (b * hTri) / 2;
        const vol = baseArea * length;

        return {
            renderData: {
                geometry: { type: 'triangular_prism', labels: { b, h: hTri, l: length } },
                description: lang === 'sv' ? "Ber√§kna volymen f√∂r det triangul√§ra prismat." : "Calculate the volume of the triangular prism.",
                answerType: 'numeric', suffix: 'cm¬≥'
            },
            token: this.toBase64(vol.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = B \\cdot l$ d√§r $B$ √§r triangelns area." : "Step 1: Use the formula $V = B \\cdot l$ where $B$ is the area of the triangle.", latex: "V = B \\cdot l" },
                { text: lang === 'sv' ? "R√§kna ut triangelns area f√∂rst." : "Calculate the triangle's area first.", latex: `\\frac{${b} \\cdot ${hTri}}{2} = ${baseArea} \\\\ B = ${baseArea}` },
                { text: lang === 'sv' ? "Multiplicera basytan med prismats l√§ngd." : "Multiply the base area by the length of the prism.", latex: `${baseArea} \\cdot ${length} = ${vol} \\\\ V = ${vol}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${vol}` }
            ],
            metadata: { variation_key: 'vol_tri_prism_std', difficulty: 2 }
        };
    }

    // --- LEVEL 3: CYLINDER ---
    private level3_Cylinder(lang: string, variationKey?: string): any {
        const r = MathUtils.randomInt(2, 5), h = MathUtils.randomInt(6, 12);
        const useDiameter = Math.random() > 0.5;
        const displayVal = useDiameter ? r * 2 : r;
        const show = useDiameter ? 'diameter' : 'radius';
        const labels = useDiameter ? { d: displayVal, h } : { r: displayVal, h };
        const vol = Math.round(3.14 * r * r * h);

        const clues = [{ text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = \\pi \\cdot r^2 \\cdot h$." : "Step 1: Use the formula $V = \\pi \\cdot r^2 \\cdot h$.", latex: "V = \\pi \\cdot r^2 \\cdot h" }];
        if (useDiameter) {
            clues.push({ text: lang === 'sv' ? `Eftersom diametern √§r ${displayVal} cm, ber√§kna radien genom att dela med 2.` : `Since the diameter is ${displayVal} cm, calculate the radius by dividing by 2.`, latex: `r = \\frac{${displayVal}}{2} = ${r}` });
        }
        clues.push({ text: lang === 'sv' ? "Ber√§kna nu volymen med radien." : "Now calculate the volume using the radius.", latex: `3,14 \\cdot ${r}^2 \\cdot ${h} = ${vol} \\\\ V = ${vol}` });
        clues.push({ text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${vol}` });

        return {
            renderData: { description: lang === 'sv' ? "Ber√§kna cylinderns volym ($\\pi \\approx 3,14$)." : "Calculate the cylinder's volume ($\\pi \\approx 3.14$).", answerType: 'numeric', suffix: 'cm¬≥', geometry: { type: 'cylinder', show, labels } },
            token: this.toBase64(vol.toString()),
            clues,
            metadata: { variation_key: 'vol_cyl_std', difficulty: 2 }
        };
    }

    // --- LEVEL 4: PYRAMID & CONE ---
    private level4_PyramidCone(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_pyramid_std', 'vol_cone_std']);
        const r = MathUtils.randomInt(3, 5), h = MathUtils.randomChoice([9, 12]);

        if (v === 'vol_pyramid_std') {
            const s = MathUtils.randomInt(4, 7);
            const vol = (s * s * h) / 3;
            return {
                renderData: { geometry: { type: 'pyramid', labels: { s, h } }, description: lang === 'sv' ? "Ber√§kna pyramidens volym." : "Calculate the volume of the pyramid.", answerType: 'numeric', suffix: 'cm¬≥' },
                token: this.toBase64(vol.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = \\frac{B \\cdot h}{3}$." : "Step 1: Use the formula $V = \\frac{B \\cdot h}{3}$.", latex: "V = \\frac{B \\cdot h}{3}" },
                    { text: lang === 'sv' ? "R√§kna ut basytan ($s \\cdot s$) och multiplicera med h√∂jden, dela sedan med 3." : "Calculate the base area ($s \\cdot s$) and multiply by the height, then divide by 3.", latex: `\\frac{${s} \\cdot ${s} \\cdot ${h}}{3} = ${vol} \\\\ V = ${vol}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${vol}` }
                ],
                metadata: { variation_key: 'vol_pyramid_std', difficulty: 3 }
            };
        }

        const vol = Math.round((3.14 * r * r * h) / 3);
        return {
            renderData: { geometry: { type: 'cone', labels: { r, h } }, description: lang === 'sv' ? "Ber√§kna konens volym ($\\pi \\approx 3,14$)." : "Calculate the cone's volume ($\\pi \\approx 3.14$).", answerType: 'numeric', suffix: 'cm¬≥' },
            token: this.toBase64(vol.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = \\frac{\\pi \\cdot r^2 \\cdot h}{3}$." : "Step 1: Use the formula $V = \\frac{\\pi \\cdot r^2 \\cdot h}{3}$.", latex: "V = \\frac{\\pi \\cdot r^2 \\cdot h}{3}" },
                { text: lang === 'sv' ? "Ber√§kna volymen." : "Calculate the volume.", latex: `\\frac{3,14 \\cdot ${r}^2 \\cdot ${h}}{3} \\approx ${vol} \\\\ V = ${vol}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${vol}` }
            ],
            metadata: { variation_key: 'vol_cone_std', difficulty: 3 }
        };
    }

    // --- LEVEL 5: SPHERE & COMPOSITE ---
    private level5_SphereComposite(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_sphere_std', 'vol_silo_std', 'vol_icecream_std']);
        const r = MathUtils.randomInt(3, 6);
        const pi = 3.14;

        if (v === 'vol_sphere_std') {
            const vol = Math.round((4 * pi * Math.pow(r, 3)) / 3);
            return {
                renderData: { description: lang === 'sv' ? `Ber√§kna volymen f√∂r ett klot med radien ${r} cm.` : `Calculate the volume of a sphere with radius ${r} cm.`, answerType: 'numeric', suffix: 'cm¬≥', geometry: { type: 'sphere', labels: { r } } },
                token: this.toBase64(vol.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = \\frac{4 \\pi r^3}{3}$." : "Step 1: Use the formula $V = \\frac{4 \\pi r^3}{3}$.", latex: "V = \\frac{4 \\pi r^3}{3}" },
                    { text: lang === 'sv' ? "S√§tt in radien i formeln." : "Insert the radius into the formula.", latex: `\\frac{4 \\cdot 3,14 \\cdot ${r}^3}{3} \\approx ${vol} \\\\ V = ${vol}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${vol}` }
                ],
                metadata: { variation_key: 'vol_sphere_std', difficulty: 3 }
            };
        }

        if (v === 'vol_silo_std') {
            const hCyl = MathUtils.randomInt(10, 18);
            const vCyl = Math.round(pi * r * r * hCyl);
            const vHemi = Math.round((2 * pi * Math.pow(r, 3)) / 3);
            const total = vCyl + vHemi;

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna den totala volymen f√∂r silon (cylinder + halvklot)." : "Calculate the total volume of the silo (cylinder + hemisphere).",
                    answerType: 'numeric', suffix: 'cm¬≥',
                    geometry: { type: 'silo', labels: { r, h: hCyl } }
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Dela upp figuren i en cylinder ($V = \\pi r^2 h$) och ett halvklot ($V = \\frac{2 \\pi r^3}{3}$)." : "Step 1: Split the shape into a cylinder ($V = \\pi r^2 h$) and a hemisphere ($V = \\frac{2 \\pi r^3}{3}$)." },
                    { text: lang === 'sv' ? "Ber√§kna f√∂rst cylinderns volym." : "First calculate the cylinder's volume.", latex: `3,14 \\cdot ${r}^2 \\cdot ${hCyl} = ${vCyl} \\\\ V_{cyl} = ${vCyl}` },
                    { text: lang === 'sv' ? "Ber√§kna sedan halvklotets volym." : "Then calculate the hemisphere's volume.", latex: `\\frac{2 \\cdot 3,14 \\cdot ${r}^3}{3} = ${vHemi} \\\\ V_{hemi} = ${vHemi}` },
                    { text: lang === 'sv' ? "Addera de tv√• delarna f√∂r att f√• hela volymen." : "Add the two parts together to get the total volume.", latex: `${vCyl} + ${vHemi} = ${total} \\\\ V_{tot} = ${total}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${total}` }
                ],
                metadata: { variation_key: 'vol_silo_std', difficulty: 4 }
            };
        }

        // Ice Cream Cone
        const hCone = MathUtils.randomInt(8, 14);
        const vCone = Math.round((pi * r * r * hCone) / 3);
        const vHemi = Math.round((2 * pi * Math.pow(r, 3)) / 3);
        const total = vCone + vHemi;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna den totala volymen f√∂r glasstruten (kon + halvklot)." : "Calculate the total volume of the ice cream cone (cone + hemisphere).",
                answerType: 'numeric', suffix: 'cm¬≥',
                geometry: { type: 'ice_cream', labels: { r, h: hCone } }
            },
            token: this.toBase64(total.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Ber√§kna volymen f√∂r konen ($V = \\frac{\\pi r^2 h}{3}$) och halvklotet ($V = \\frac{2 \\pi r^3}{3}$)." : "Step 1: Calculate the volume for the cone ($V = \\frac{\\pi r^2 h}{3}$) and the hemisphere ($V = \\frac{2 \\pi r^3}{3}$)." },
                { text: lang === 'sv' ? "Konens volym:" : "Cone volume:", latex: `\\frac{3,14 \\cdot ${r}^2 \\cdot ${hCone}}{3} = ${vCone} \\\\ V_{kon} = ${vCone}` },
                { text: lang === 'sv' ? "Halvklotets volym:" : "Hemisphere volume:", latex: `\\frac{2 \\cdot 3,14 \\cdot ${r}^3}{3} = ${vHemi} \\\\ V_{glass} = ${vHemi}` },
                { text: lang === 'sv' ? "Summa:" : "Total:", latex: `${vCone} + ${vHemi} = ${total} \\\\ V_{tot} = ${total}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${total}` }
            ],
            metadata: { variation_key: 'vol_icecream_std', difficulty: 4 }
        };
    }

    // --- LEVEL 6: MIXED DIAMETER ---
    private level6_Mixed(lang: string, variationKey?: string): any {
        const r = MathUtils.randomInt(3, 7);
        const d = r * 2;
        const vol = Math.round((4 * 3.14 * Math.pow(r, 3)) / 3);

        return {
            renderData: {
                description: lang === 'sv' ? `Ett klot har diametern ${d} cm. Ber√§kna klotets volym ($\\pi \\approx 3,14$).` : `A sphere has a diameter of ${d} cm. Calculate the sphere's volume ($\\pi \\approx 3.14$).`,
                answerType: 'numeric', suffix: 'cm¬≥',
                geometry: { type: 'sphere', show: 'diameter', labels: { d } }
            },
            token: this.toBase64(vol.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $V = \\frac{4 \\pi r^3}{3}$." : "Step 1: Use the formula $V = \\frac{4 \\pi r^3}{3}$." },
                { text: lang === 'sv' ? "Hitta radien f√∂rst genom att dela diametern med 2." : "Find the radius first by dividing the diameter by 2.", latex: `r = \\frac{${d}}{2} = ${r} \\\\ r = ${r}` },
                { text: lang === 'sv' ? "Ber√§kna volymen." : "Calculate the volume.", latex: `\\frac{4 \\cdot 3,14 \\cdot ${r}^3}{3} \\approx ${vol} \\\\ V = ${vol}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${vol}` }
            ],
            metadata: { variation_key: 'vol_sphere_diameter', difficulty: 3 }
        };
    }

    // --- LEVEL 7: UNITS ---
    private level7_Units(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['vol_units_liter', 'vol_units_m3']);

        if (v === 'vol_units_m3') {
            const w = MathUtils.randomInt(3, 5), d = MathUtils.randomInt(5, 8), h = 2;
            const m3 = w * d * h;
            const liters = m3 * 1000;
            return {
                renderData: {
                    description: lang === 'sv' ? `En pool har m√•tten ${w} m, ${d} m och ${h} m. Hur m√•nga liter rymmer den?` : `A pool has the dimensions ${w} m, ${d} m, and ${h} m. How many liters does it hold?`,
                    answerType: 'numeric', suffix: 'liter'
                },
                token: this.toBase64(liters.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Ber√§kna volymen i kubikmeter ($l \\cdot b \\cdot h$)." : "Step 1: Calculate the volume in cubic meters ($l \\cdot b \\cdot h$).", latex: `${w} \\cdot ${d} \\cdot ${h} = ${m3} \\\\ V = ${m3} \\text{ m}^3` },
                    { text: lang === 'sv' ? "Omvandla till liter genom att multiplicera med 1000 ($1 \\text{ m}^3 = 1000 \\text{ liter}$)." : "Convert to liters by multiplying by 1000 ($1 \\text{ m}^3 = 1000 \\text{ liters}$).", latex: `${m3} \\cdot 1000 = ${liters} \\\\ L = ${liters}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${liters}` }
                ],
                metadata: { variation_key: 'vol_units_m3', difficulty: 4 }
            };
        }

        const w = 50, d = 20, h = 30;
        const liters = (w * d * h) / 1000;
        return {
            renderData: {
                description: lang === 'sv' ? `Ett akvarium har m√•tten ${w} cm, ${d} cm och ${h} cm. Hur m√•nga liter vatten rymmer det?` : `An aquarium has the dimensions ${w} cm, ${d} cm, and ${h} cm. How many liters does it hold?`,
                answerType: 'numeric', suffix: 'liter'
            },
            token: this.toBase64(liters.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Omvandla m√•tten till decimeter f√∂r att f√• liter direkt ($1 \\text{ dm}^3 = 1 \\text{ liter}$)." : "Step 1: Convert dimensions to decimeters to get liters directly ($1 \\text{ dm}^3 = 1 \\text{ liter}$).", latex: `5, 2, 3 \\text{ dm} \\\\ 5 \\cdot 2 \\cdot 3 = ${liters} \\text{ liter}` },
                { text: lang === 'sv' ? "Svaret blir:" : "The answer is:", latex: `${liters}` }
            ],
            metadata: { variation_key: 'vol_units_liter', difficulty: 3 }
        };
    }

    // --- LEVEL 8: SURFACE AREA ---
    private level8_SurfaceArea(lang: string, variationKey?: string): any {
        const v = variationKey || MathUtils.randomChoice(['sa_cuboid', 'sa_sphere']);

        if (v === 'sa_cuboid') {
            const w = MathUtils.randomInt(2, 5), d = MathUtils.randomInt(3, 6), h = MathUtils.randomInt(4, 7);
            const area = 2 * (w*d + w*h + d*h);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna r√§tblockets begr√§nsningsarea (ytarea)." : "Calculate the surface area of the rectangular prism.",
                    answerType: 'numeric', suffix: 'cm¬≤',
                    geometry: { type: 'cuboid', labels: { w, d, h } }
                },
                token: this.toBase64(area.toString()),
                clues: [
                    { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $A = 2(lw + lh + wh)$." : "Step 1: Use the formula $A = 2(lw + lh + wh)$.", latex: "A = 2(lw + lh + wh)" },
                    { text: lang === 'sv' ? "Addera arean f√∂r de sex sidorna (tre par)." : "Add the areas of the six sides (three pairs).", latex: `2(${w} \\cdot ${d} + ${w} \\cdot ${h} + ${d} \\cdot ${h}) = ${area} \\\\ A = ${area}` },
                    { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${area}` }
                ],
                metadata: { variation_key: 'sa_cuboid', difficulty: 4 }
            };
        }

        const r = MathUtils.randomInt(3, 8);
        const area = Math.round(4 * 3.14 * r * r);
        return {
            renderData: {
                description: lang === 'sv' ? `Ber√§kna ytarean f√∂r ett klot med radien ${r} cm.` : `Calculate the surface area for a sphere with radius ${r} cm.`,
                answerType: 'numeric', suffix: 'cm¬≤',
                geometry: { type: 'sphere', labels: { r } }
            },
            token: this.toBase64(area.toString()),
            clues: [
                { text: lang === 'sv' ? "Steg 1: Anv√§nd formeln $A = 4 \\pi r^2$." : "Step 1: Use the formula $A = 4 \\pi r^2$.", latex: "A = 4 \\pi r^2" },
                { text: lang === 'sv' ? "Ber√§kna arean." : "Calculate the area.", latex: `4 \\cdot 3,14 \\cdot ${r}^2 \\approx ${area} \\\\ A = ${area}` },
                { text: lang === 'sv' ? "Svaret √§r:" : "The answer is:", latex: `${area}` }
            ],
            metadata: { variation_key: 'sa_sphere', difficulty: 4 }
        };
    }
}

// FILE END: src\core\generators\VolumeGen.ts

// =======================================================
// FILE START: src\core\interfaces\Generator.ts
// =======================================================

export interface QuestionData {
    text?: string;
    renderData?: any; // Preferred
    visual?: any;     // Legacy
    answer: string | number;
    clues: string[];
}

export interface Generator {
    /**
     * Generates a new question.
     * @param level Difficulty level (1-9)
     * @param lang Language code ('sv' | 'en')
     */
    generate(level: number, lang: string): QuestionData;

    /**
     * Optional: Custom validation logic for answers.
     * @param userAnswer The user's input
     * @param systemAnswer The generated correct answer
     */
    validate?(userAnswer: string, systemAnswer: string): boolean;
}

// FILE END: src\core\interfaces\Generator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        exponents: 6,
        fraction_basics: 5,
        fraction_arith: 5,
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 6,
        volume: 8,
        graph: 5,
        similarity: 4,
        percent: 6,
        probability: 8,
        statistics: 6,
        pythagoras: 6,
        change_factor: 5,
        angles: 6,
        patterns: 5
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        // Fallback to 5 if topic not found, but we aim to list all
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export const UI_STRINGS = {
    sv: {
        // --- General UI ---
        submit: "Svara",
        next: "N√§sta fr√•ga",
        correct: "R√§tt!",
        incorrect: "Inte riktigt, f√∂rs√∂k igen",
        try_again: "F√∂rs√∂k igen",
        score: "Po√§ng",
        streak: "Svit",
        level: "Niv√•",
        loading: "Laddar...",
        error: "Fel vid laddning",
        dashboard_title: "V√§lj omr√•de att √∂va p√•",
        backBtn: "Meny",
        history: "Historik",
        noHistory: "Inga svar √§n.",
        btnHint: "Ledtr√•d",
        btnSolution: "Visa l√∂sning",
        btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        placeholder: "Skriv ditt svar...",
        hintsTitle: "Ledtr√•dar",
        clueUsed: "Hj√§lp",
        donow: "Startuppgift",
        donow_title: "Uppstart (Do Now)",
        donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
        donow_gen: "Generera",
        donow_show_all: "Visa alla",
        donow_hide_all: "D√∂lj alla",
        donow_regenerate: "Nytt Set",
        aboutBtn: "Om skaparen",
        levelUpTitle: "Niv√• upp?", 
        levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", 
        levelUpYes: "Ja, k√∂r!", 
        levelUpNo: "Nej, stanna h√§r",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Aritmetik",
            negative: "Negativa Tal",
            simplification: "F√∂renkling",
            linear_eq: "Ekvationer",
            linear_eq_prob: "Probleml√∂sning",
            geometry: "Geometri",
            volume: "Volym & Area",
            similarity: "Likformighet",
            scale: "Skala",
            linear_graph: "R√§ta Linjen",
            ten_powers: "Tiopotenser",
            percent: "Procent",           // NEW
            exponents: "Potenser",        // NEW
            probability: "Sannolikhet",   // NEW
            statistics: "Statistik",      // NEW
            pythagoras: "Pythagoras Sats" // NEW
        },

        // --- Math Vocabulary (Common) ---
        common: {
            calculate: "Ber√§kna",
            equation: "Ekvation",
            simplify: "F√∂renkla",
            solve: "L√∂s ut x",
            evaluate: "Ber√§kna",
            find_k: "Best√§m k-v√§rdet",
            find_m: "Best√§m m-v√§rdet",
            find_equation: "Best√§m linjens ekvation",
            match_graph: "Vilken ekvation h√∂r till grafen?",
            determine_equation: "Best√§m ekvationen f√∂r linjen som g√•r genom:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Ber√§kna summan",
            sub: "Ber√§kna differensen",
            mul: "Ber√§kna produkten",
            div: "Ber√§kna kvoten",
            mixed: "Ber√§kna",
            missing_term: "Hitta det saknade talet"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Vi har ekvationen: $${eq}$`,
            multiply: (k: any) => `Multiplicera b√•da sidor med $${k}$ f√∂r att bli av med divisionen.`,
            divide: (k: any) => `Dividera b√•da sidor med $${k}$ f√∂r att f√• $x$ ensamt.`,
            add: (k: any) => `Addera $${k}$ p√• b√•da sidor.`,
            subtract: (k: any) => `Subtrahera $${k}$ p√• b√•da sidor.`,
            distribute: (k: any) => `Multiplicera in $${k}$ i parentesen.`,
            sub_var: (term: string) => `Subtrahera $${term}$ fr√•n b√•da sidor f√∂r att samla $x$ p√• en sida.`,
            collect: "Samla lika termer",
            expand: "Utveckla parentesen",
            factorise: "Faktorisera uttrycket",
            substitute: "Ers√§tt och ber√§kna"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Att addera ett negativt tal √§r samma som subtraktion.",
            sub_neg: "Tv√• minus blir plus (‚Äì ‚Äì blir +).",
            mul_neg_neg: "Minus g√•nger minus blir plus.",
            mul_pos_neg: "Plus g√•nger minus blir minus.",
            div_sign_same: "Lika tecken ger positivt svar.",
            div_sign_diff: "Olika tecken ger negativt svar.",
            simple_calc: "Ber√§kna:", 
            step_calc: "Ber√§kna:",
            plus_plus: "Positivt + Positivt",
            plus_minus: "Positivt + Negativt",
            minus_plus: "Negativt + Positivt",
            minus_minus: "Negativt - Negativt",
            mixed: "Blandat",
            multiplication: "Multiplikation",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "Best√§m m-v√§rdet (d√§r linjen sk√§r y-axeln).", en: "Find the intercept (m)." },
            q_slope: { sv: "Best√§m k-v√§rdet (lutningen).", en: "Find the slope (k)." },
            q_func: { sv: "Best√§m linjens ekvation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Titta p√• grafen: Var sk√§r linjen y-axeln (d√§r $x=0$)?",
            step_intercept: (m:any) => `Linjen sk√§r y-axeln vid $y = ${m}$.`,
            step_delta: "Lutningen $k$ √§r skillnaden i $y$ delat med skillnaden i $x$.",
            step_slope_calc: "R√§kna rutor: Hur mycket √§ndras $y$ n√§r vi g√•r 1 steg √•t h√∂ger?",
            find_m: "Hitta m-v√§rdet (sk√§rning med y-axeln).",
            find_k: "Hitta k-v√§rdet (lutningen).",
            parallel: "Best√§m lutningen f√∂r en linje som √§r parallell med:",
            perpendicular: "Best√§m lutningen f√∂r en linje som √§r vinkelr√§t mot:",
            find_gradient: "Ber√§kna lutningen (k)",
            find_intercept: "Hitta y-axelsk√§rningen (m)"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Skala",
            real: "Verklig str√§cka",
            map_dist: "Avst√•nd p√• kartan",
            ratio: "Skala",
            problem_map_to_real: "Ber√§kna det verkliga avst√•ndet.",
            problem_real_to_map: "Ber√§kna avst√•ndet p√• kartan.",
            problem_find_scale: "Best√§m kartans skala.",
            reduction: "F√∂rminskning",
            enlargement: "F√∂rstoring",
            reality: "Verkligheten",
            drawing: "Bilden",
            rule_reduction: "N√§r skalan √§r 1:X √§r bilden mindre √§n verkligheten.",
            rule_enlargement: "N√§r skalan √§r X:1 √§r bilden st√∂rre √§n verkligheten.",
            step_plug_in: "S√§tt in v√§rdena i formeln: $\\frac{\\text{Bild}}{\\text{Verklighet}}$",
            calc_cm: "R√§kna f√∂rst ut det i cm.",
            conv_m: "Omvandla till meter (1 m = 100 cm).",
            conv_same: "Se till att b√•da m√•tten har samma enhet.",
            setup_ratio: "St√§ll upp f√∂rh√•llandet Bild : Verklighet.",
            step_simplify: "F√∂renkla br√•ket.",
            calc_area_img: "Ber√§kna bildens area.",
            calc_area_real: "Ber√§kna verklighetens area.",
            calc_area_scale: "Areaskalan √§r l√§ngdskalan i kvadrat."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "L√∂s ekvationen och ber√§kna $x$.",
            task_write: "Skriv en ekvation som beskriver situationen (du beh√∂ver inte l√∂sa den).",
            clue_var: "L√•t $x$ vara det vi s√∂ker.",
            clue_total: "S√§tt uttrycket lika med totalen.",
            expl_rate_val: "Pris per styck g√•nger antal.",
            expl_fixed_val: "L√§gg till den fasta avgiften.",
            expl_item_cost: "Kostnaden f√∂r varorna innan rabatt.",
            expl_discount_sub: "Subtrahera rabatten.",
            expl_person1: "Person 1 har $x$.",
            expl_person2_more: "Person 2 har mer.",
            expl_person2_less: "Person 2 har mindre.",
            expl_compare_sum: "Summan av b√•da √§r totalen.",
            a_buy: { sv: "Du k√∂per $a$ st {item} f√∂r $x$ kr/st och en p√•se f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $a$ {item} for $x$ kr each and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "En taxiresa kostar $b$ kr i startavgift och $a$ kr per km. Resan kostar totalt $c$ kr. Hur m√•nga km ($x$) √•kte du?", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "Du k√∂per $a$ st {item} som kostar $x$ kr/st. Du har en rabattkupong p√• $b$ kr. Du betalar totalt $c$ kr.", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "{name1} och {name2} samlar p√• {item}. {name2} har $a$ fler √§n {name1}. Tillsammans har de $c$ st. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "{name1} och {name2} har $c$ {item} tillsammans. {name2} har $b$ f√§rre √§n {name1}. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Ber√§kna arean",
            perimeter: "Ber√§kna omkretsen",
            circumference: "Ber√§kna omkretsen",
            volume: "Ber√§kna volymen",
            surface_area: "Ber√§kna begr√§nsningsarean",
            similarity: "Likformighet",
            scale_factor: "Hitta skalfaktorn (k)",
            missing_side: "Ber√§kna den saknade sidan",
            shape: "Figur",
            cube: "Kub",
            cuboid: "R√§tblock",
            cylinder: "Cylinder",
            sphere: "Klot",
            cone: "Kon",
            triangle: "Triangel",
            rectangle: "Rektangel",
            circle: "Cirkel",
            parallelogram: "Parallellogram",
            trapezium: "Trapets"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplikation med tiopotenser",
            div: "Division med tiopotenser",
            standard_form: "Grundpotensform",
            prefix: "Prefix"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Ber√§kna delen",
            find_whole: "Hitta det hela",
            change: "F√∂r√§ndring",
            visual: "Andel (Bild)"
        },
        statistics: {
            mean: "Medelv√§rde",
            median: "Median",
            mode: "Typv√§rde",
            range: "Variationsbredd",
            table: "Frekvenstabell"
        },
        probability: {
            chance: "Sannolikhet",
            complement: "Komplementh√§ndelse",
            compound: "Sammansatt h√§ndelse",
            marbles: "Kulor",
            spinner: "Snurrhjul"
        },
        pythagoras: {
            theorem: "Pythagoras sats",
            hypotenuse: "Hypotenusa",
            leg: "Katet",
            distance: "Avst√•nd"
        },
        exponents: {
            power: "Potens",
            base: "Bas",
            exponent: "Exponent",
            root: "Kvadratrot",
            sci_not: "Grundpotensform",
            zero_rule: "Nollregeln"
        },

        // --- Shapes ---
        shapes: {
            square: "kvadrat",
            rectangle: "rektangel",
            circle: "cirkel",
            triangle: "triangel",
            rhombus: "romb",
            parallelogram: "parallellogram",
            pentagon: "femh√∂rning",
            hexagon: "sexh√∂rning",
            octagon: "√•ttah√∂rning",
            star: "stj√§rna",
            arrow: "pil",
            heart: "hj√§rta",
            cross: "kors",
            lightning: "blixt",
            kite: "drake",
            cube: "kub",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "kon",
            sphere: "klot"
        },
        shapes_plural: {
            rectangle: "rektanglar",
            triangle: "trianglar",
            circle: "cirklar",
            semicircle: "halvcirklar",
            parallelogram: "parallellogram"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    },

    en: {
        // --- General UI ---
        submit: "Submit Answer",
        next: "Next Question",
        correct: "Correct!",
        incorrect: "Incorrect.",
        try_again: "Try Again",
        score: "Score",
        streak: "Streak",
        level: "Level",
        loading: "Loading...",
        error: "Error loading question",
        dashboard_title: "Choose a topic to practice",
        backBtn: "Menu",
        history: "History",
        noHistory: "No answers yet.",
        btnHint: "Hint",
        btnSolution: "Show Solution",
        btnSkip: "Skip",
        btnNext: "Next ‚û°",
        placeholder: "Enter your answer...",
        hintsTitle: "Hints",
        clueUsed: "Clue",
        donow: "Do Now",
        donow_title: "Do Now Activity",
        donow_desc: "Select up to 3 levels. System generates 6 questions total.",
        donow_gen: "Generate",
        donow_show_all: "Show All",
        donow_hide_all: "Hide All",
        donow_regenerate: "New Set",
        aboutBtn: "About",
        levelUpTitle: "Level Up?", 
        levelUpDesc: "You seem to know this! Do you want to skip to the next level?", 
        levelUpYes: "Yes, let's go!", 
        levelUpNo: "No, stay here",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Arithmetic",
            negative: "Negative Numbers",
            simplification: "Simplification",
            linear_eq: "Linear Equations",
            linear_eq_prob: "Equation Problems",
            geometry: "Geometry",
            volume: "Volume & Surface Area",
            similarity: "Similarity",
            scale: "Scale & Maps",
            linear_graph: "Linear Graphs",
            ten_powers: "Powers of 10",
            percent: "Percentage",
            exponents: "Exponents & Roots",
            probability: "Probability",
            statistics: "Statistics",
            pythagoras: "Pythagoras"
        },

        // --- Math Vocabulary ---
        common: {
            calculate: "Calculate",
            equation: "Equation",
            simplify: "Simplify",
            solve: "Solve for x",
            evaluate: "Evaluate",
            find_k: "Find the gradient (k)",
            find_m: "Find the y-intercept (m)",
            find_equation: "Find the equation of the line",
            match_graph: "Which equation matches the graph?",
            determine_equation: "Determine the equation of the line passing through:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Calculate the sum",
            sub: "Calculate the difference",
            mul: "Calculate the product",
            div: "Calculate the quotient",
            mixed: "Evaluate the expression",
            missing_term: "Find the missing number"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Equation: $${eq}$`,
            multiply: (k: any) => `Multiply both sides by $${k}$ to remove the division.`,
            divide: (k: any) => `Divide both sides by $${k}$ to isolate $x$.`,
            add: (k: any) => `Add $${k}$ to both sides.`,
            subtract: (k: any) => `Subtract $${k}$ from both sides.`,
            distribute: (k: any) => `Distribute $${k}$ into the parentheses.`,
            sub_var: (term: string) => `Subtract $${term}$ from both sides to collect $x$ on one side.`,
            collect: "Collect like terms",
            expand: "Expand the brackets",
            factorise: "Factorise the expression",
            substitute: "Substitute and evaluate"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Adding a negative number is the same as subtraction.",
            sub_neg: "Subtracting a negative number is the same as addition (‚Äì ‚Äì becomes +).",
            mul_neg_neg: "Negative times negative becomes positive.",
            mul_pos_neg: "Positive times negative becomes negative.",
            div_sign_same: "Same signs give a positive result.",
            div_sign_diff: "Different signs give a negative result.",
            simple_calc: "Calculate:",
            step_calc: "Calculate:",
            plus_plus: "Positive + Positive",
            plus_minus: "Positive + Negative",
            minus_plus: "Negative + Positive",
            minus_minus: "Negative - Negative",
            mixed: "Mixed",
            multiplication: "Multiplication",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "", en: "Find the intercept (m)." },
            q_slope: { sv: "", en: "Find the slope (k)." },
            q_func: { sv: "", en: "Find the line equation ($y = kx + m$)."},
            look_x0: "Look at the graph: Where does the line cross the y-axis (where $x=0$)?",
            step_intercept: (m:any) => `The line crosses the y-axis at $y = ${m}$.`,
            step_delta: "The slope $k$ is the change in $y$ divided by the change in $x$.",
            step_slope_calc: "Count squares: How much does $y$ change when we go 1 step to the right?",
            find_m: "Find the m-value (y-intercept).",
            find_k: "Find the k-value (slope).",
            parallel: "Find the slope of a line parallel to:",
            perpendicular: "Find the slope of a line perpendicular to:",
            find_gradient: "Calculate the gradient",
            find_intercept: "Find the intercept"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Map Scale",
            real: "Real Distance",
            map_dist: "Map Distance",
            ratio: "Ratio",
            problem_map_to_real: "Calculate the real world distance.",
            problem_real_to_map: "Calculate the distance on the map.",
            problem_find_scale: "Determine the scale of the map.",
            reduction: "Reduction",
            enlargement: "Enlargement",
            reality: "Reality",
            drawing: "Drawing",
            rule_reduction: "When the scale is 1:X, the image is smaller than reality.",
            rule_enlargement: "When the scale is X:1, the image is larger than reality.",
            step_plug_in: "Insert the values into the formula: $\\frac{\\text{Image}}{\\text{Reality}}$",
            calc_cm: "Calculate it in cm first.",
            conv_m: "Convert to meters (1 m = 100 cm).",
            conv_same: "Ensure both measurements have the same unit.",
            setup_ratio: "Set up the ratio Image : Reality.",
            step_simplify: "Simplify the fraction.",
            calc_area_img: "Calculate the area of the image.",
            calc_area_real: "Calculate the area of reality.",
            calc_area_scale: "The area scale is the length scale squared."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "Solve the equation and calculate $x$.",
            task_write: "Write an equation that describes the situation (you don't need to solve it).",
            clue_var: "Let $x$ be what we are looking for.",
            clue_total: "Set the expression equal to the total.",
            expl_rate_val: "Price per item times quantity.",
            expl_fixed_val: "Add the fixed fee.",
            expl_item_cost: "The cost of items before discount.",
            expl_discount_sub: "Subtract the discount.",
            expl_person1: "Person 1 has $x$.",
            expl_person2_more: "Person 2 has more.",
            expl_person2_less: "Person 2 has less.",
            expl_compare_sum: "The sum of both is the total.",
            a_buy: { sv: "", en: "You buy $a$ {item} for $x$ kr/st and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Calculate the Area",
            perimeter: "Calculate the Perimeter",
            circumference: "Calculate the Circumference",
            volume: "Calculate the Volume",
            surface_area: "Calculate the Surface Area",
            similarity: "Similarity",
            scale_factor: "Find the Scale Factor",
            missing_side: "Find the missing side length",
            shape: "Shape",
            cube: "Cube",
            cuboid: "Rectangular Prism",
            cylinder: "Cylinder",
            sphere: "Sphere",
            cone: "Cone",
            triangle: "Triangle",
            rectangle: "Rectangle",
            circle: "Circle",
            parallelogram: "Parallelogram",
            trapezium: "Trapezium"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplication by powers of 10",
            div: "Division by powers of 10",
            standard_form: "Standard Form (Scientific Notation)",
            prefix: "Unit Prefixes"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Calculate Part",
            find_whole: "Find Whole",
            change: "Change",
            visual: "Proportion (Visual)"
        },
        statistics: {
            mean: "Mean",
            median: "Median",
            mode: "Mode",
            range: "Range",
            table: "Frequency Table"
        },
        probability: {
            chance: "Probability",
            complement: "Complementary Event",
            compound: "Compound Event",
            marbles: "Marbles",
            spinner: "Spinner"
        },
        pythagoras: {
            theorem: "Pythagorean Theorem",
            hypotenuse: "Hypotenuse",
            leg: "Leg",
            distance: "Distance"
        },
        exponents: {
            power: "Power",
            base: "Base",
            exponent: "Exponent",
            root: "Square Root",
            sci_not: "Scientific Notation",
            zero_rule: "Zero Rule"
        },

        // --- Shapes ---
        shapes: {
            square: "square",
            rectangle: "rectangle",
            circle: "circle",
            triangle: "triangle",
            rhombus: "rhombus",
            parallelogram: "parallelogram",
            pentagon: "pentagon",
            hexagon: "hexagon",
            octagon: "octagon",
            star: "star",
            arrow: "arrow",
            heart: "heart",
            cross: "cross",
            lightning: "lightning",
            kite: "kite",
            cube: "cube",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "cone",
            sphere: "sphere"
        },
        shapes_plural: {
            rectangle: "rectangles",
            triangle: "triangles",
            circle: "circles",
            semicircle: "semicircles",
            parallelogram: "parallelograms"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    }
};

export const TERMS = UI_STRINGS;

// Helper to handle both string and object keys safely
export function t(lang: Language, keyOrObj: string | { sv: string, en: string }): string {
    const l = (lang === 'en') ? 'en' : 'sv';
    
    // Check if input is a localized object {sv:..., en:...}
    if (typeof keyOrObj === 'object' && keyOrObj !== null) {
        // @ts-ignore
        return keyOrObj[l] || keyOrObj['sv'] || "";
    }
    
    // Check if input is a dot-notation string "geometry.area"
    if (typeof keyOrObj === 'string') {
        if (keyOrObj.includes('.')) {
            const keys = keyOrObj.split('.');
            let value: any = UI_STRINGS[l];
            for (const k of keys) {
                if (value && value[k]) {
                    value = value[k];
                } else {
                    return keyOrObj; // Return key if missing
                }
            }
            return typeof value === 'string' ? value : keyOrObj;
        }
        
        // Direct key lookup in UI root
        // @ts-ignore
        return UI_STRINGS[l][keyOrObj] || keyOrObj;
    }
    
    return String(keyOrObj);
}

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\MathUtils.ts
// =======================================================

export class MathUtils {
    static randomInt(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static randomFloat(min: number, max: number, decimals: number = 1): number {
        const val = Math.random() * (max - min) + min;
        return Number(val.toFixed(decimals));
    }

    static randomChoice<T>(arr: T[]): T {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    static gcd(a: number, b: number): number {
        return b === 0 ? a : MathUtils.gcd(b, a % b);
    }

    // FIX: This method is required by PythagorasGen and others
    static shuffle<T>(array: T[]): T[] {
        const arr = [...array]; // Create a copy to avoid mutating original
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }
}

// FILE END: src\core\utils\MathUtils.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: src\index.css
// =======================================================

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
  -webkit-font-smoothing: antialiased;
  @apply bg-gray-50 text-gray-800;
}

/* Legacy Animations */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Custom Scrollbar from Legacy Code */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Print Styles for Do Now Grid */
.print-break-inside-avoid {
  break-inside: avoid;
}

/* Katex Adjustments */
.katex {
  font-size: 1.1em;
}

// FILE END: src\index.css

// =======================================================
// FILE START: src\lib\supabaseClient.js
// =======================================================

import { createClient } from '@supabase/supabase-js';

// Vite uses import.meta.env to access .env variables
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Create a single instance of the Supabase client to use across your app
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// FILE END: src\lib\supabaseClient.js

// =======================================================
// FILE START: src\main.jsx
// =======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// FILE END: src\main.jsx

// =======================================================
// FILE START: tailwind.config.js
// =======================================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Legacy Color Palette
        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
      },
      fontFamily: { 
        sans: ['Inter', 'sans-serif'] 
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      }
    },
  },
  plugins: [],
}

// FILE END: tailwind.config.js

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    
    "strict": false,               
    "noImplicitAny": false,        
    "strictNullChecks": false,     
    "suppressImplicitAnyIndexErrors": true, 
    
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["src", "api"],
  "references": []
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/$1" },
    { "source": "/(.*)", "destination": "/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json

// =======================================================
// FILE START: vite.config.js
// =======================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@core': path.resolve(__dirname, './src/core'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  }
})

// FILE END: vite.config.js
