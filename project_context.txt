PROJECT EXPORT GENERATED AT 2026-01-27T19:47:19.138Z

--- FILE STRUCTURE ---
api\answer.ts
api\batch.ts
api\curriculum.ts
api\question.ts
backup_UI.html
bundle_project.ts
dev-server.ts
index.html
package-lock.json
package.json
postcss.config.js
src\App.jsx
src\components\modals\AboutModal.jsx
src\components\modals\LgrModal.jsx
src\components\modals\StatsModal.jsx
src\components\practice\CluePanel.jsx
src\components\practice\HistoryList.jsx
src\components\practice\MobileDrawer.jsx
src\components\ui\Button.jsx
src\components\ui\MathText.jsx
src\components\views\Dashboard.jsx
src\components\views\DoNowConfig.jsx
src\components\views\DoNowGrid.jsx
src\components\views\PracticeView.jsx
src\components\visuals\GeometryVisual.jsx
src\components\visuals\GraphCanvas.jsx
src\components\visuals\VolumeVisualization.jsx
src\constants\curriculum.js
src\constants\localization.js
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\ScaleGenerator.ts
src\core\generators\SimilarityGenerator.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGenerator.ts
src\core\interfaces\Generator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
src\index.css
src\main.jsx
tailwind.config.js
tsconfig.json
vercel.json
vite.config.js

==================================================


// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

// --- Generators (STRICTLY Existing Files Only) ---
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen';

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    const { token, answer, topic, level } = req.body;

    if (!token || answer === undefined) {
        return res.status(400).json({ error: 'Missing token or answer' });
    }

    // Decode Token
    const decoded = JSON.parse(Buffer.from(token, 'base64').toString('utf-8'));
    const correctAnswer = decoded.a;

    // --- Validation Logic ---
    // 1. Basic String Match (Case insensitive, trimmed)
    const normalize = (s: any) => String(s).toLowerCase().replace(/\s+/g, '').replace(',', '.');
    
    let isCorrect = normalize(answer) === normalize(correctAnswer);

    // 2. Generator-Specific Validation (if needed)
    // Used for equivalent expressions (e.g. "x + 1" == "1 + x")
    if (!isCorrect && topic) {
        let generator: any = null;
        switch (topic) {
            case 'simplify': generator = new ExpressionSimplificationGen(); break;
            case 'equation': generator = new LinearEquationGen(); break;
        }

        if (generator && typeof generator.validate === 'function') {
            isCorrect = generator.validate(answer, correctAnswer);
        }
    }

    return res.status(200).json({
        correct: isCorrect,
        correctAnswer: correctAnswer
    });

  } catch (error: any) {
    console.error("Answer API Error:", error);
    return res.status(500).json({ error: "Validation Failed", details: error.message });
  }
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';

// Helper to format answers for display in the grid
function formatAnswer(answer: any): string {
    try {
        if (typeof answer === 'object' && answer !== null) {
            if ('k' in answer && 'm' in answer) {
                const { k, m } = answer;
                const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
                return `y = ${k}x ${mStr}`; 
            }
            if ('left' in answer && 'right' in answer) {
                return `${answer.left}:${answer.right}`; 
            }
            return JSON.stringify(answer);
        }
        return String(answer);
    } catch (e) {
        return String(answer);
    }
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  try {
      const { config, lang = 'sv' } = req.body;
      const generatedQuestions: any[] = [];
      const timestamp = Date.now();

      if (Array.isArray(config)) {
          // Iterate through the array. 
          // The frontend now ensures this array has 6 items to fill the grid.
          for (let i = 0; i < config.length; i++) {
              const item = config[i];
              const { topic, level } = item;
              
              // Seed includes index 'i' to guarantee uniqueness even if same topic/level is requested multiple times
              const seed = `batch-${timestamp}-${topic}-${level}-${i}`;
              const lvl = Number(level);

              try {
                  let qData: any = null;

                  switch (topic) {
                      case 'arithmetic': qData = BasicArithmeticGen.generate(lvl, seed, lang as any); break;
                      case 'negative': qData = NegativeNumbersGen.generate(lvl, seed, lang as any); break;
                      case 'equation': 
                          // FIXED: Route BOTH Level 5 and 6 (Word Problems) to the correct generator
                          if (lvl === 5 || lvl === 6) {
                              qData = LinearEquationProblemGen.generate(lvl, seed, lang as any);
                          } else {
                              qData = LinearEquationGenerator.generate(lvl, seed, lang as any); 
                          }
                          break;
                      case 'geometry': qData = GeometryGenerator.generate(lvl, seed, lang as any); break;
                      case 'volume': qData = VolumeGenerator.generate(lvl, seed, lang as any); break;
                      case 'graph': qData = LinearGraphGenerator.generate(lvl, seed, lang as any); break;
                      case 'simplify': 
                          // Simplification generator check
                          qData = ExpressionSimplificationGen.generate(lvl, seed, lang as any); 
                          break;
                      default: qData = ScaleGenerator.generate(lvl, seed, lang as any); break;
                  }

                  if (qData) {
                      // NORMALIZE DESCRIPTION:
                      // Some generators return {sv, en}, others return string.
                      // We resolve it to a single string here to simplify frontend.
                      let desc = qData.renderData.description;
                      if (typeof desc === 'object' && desc !== null) {
                          desc = desc[lang] || desc['sv'] || "";
                      }

                      generatedQuestions.push({
                          renderData: {
                              ...qData.renderData,
                              description: desc // Ensure this is always a string
                          },
                          displayAnswer: formatAnswer(qData.serverData.answer),
                          topic: topic,
                          level: lvl
                      });
                  }
              } catch (genError) {
                  console.error(`Error generating question for ${topic} level ${lvl}:`, genError);
                  generatedQuestions.push({
                      renderData: { description: "Error generating question", latex: "" },
                      displayAnswer: "Error",
                      topic: topic,
                      level: lvl
                  });
              }
          }
      }

      return res.status(200).json({ questions: generatedQuestions });

  } catch (e) {
      console.error("Batch generation fatal error:", e);
      return res.status(500).json({ error: "Generation failed" });
  }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang."
    ],

    // Mapping modules to "Centralt Inneh√•ll" (Core Content)
    mapping: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        modules: ["arithmetic", "negative"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.",
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform vid √∂verslagsr√§kning, huvudr√§kning samt vid ber√§kningar med skriftliga metoder.",
          "Tal i potensform. Grundpotensform."
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["equation", "simplify"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.",
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Metoder f√∂r ekvationsl√∂sning."
        ]
      },
      geometri: {
        category: "Geometri",
        modules: ["geometry", "scale", "volume"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt, s√•v√§l med som utan digitala verktyg. Skala och dess anv√§ndning i vardagliga situationer.",
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta."
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"],
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"], // Specifically word problems in equations
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  return res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { TenPowersGen } from '../src/core/generators/TenPowersGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
// Ensure these exist in the file system before importing, 
// otherwise this file will fail to build. 
// Assuming ScaleGenerator and VolumeGenerator exist based on project context.
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';

// --- Generator Registry ---
// Maps topic IDs (from dashboard) to their respective classes.
// These keys MUST match the 'topics' object in src/core/utils/i18n.ts
const GENERATORS: Record<string, any> = {
  'arithmetic': BasicArithmeticGen,
  'linear_eq': LinearEquationGen,
  'linear_eq_prob': LinearEquationProblemGen,
  'geometry': GeometryGenerator,
  'similarity': SimilarityGenerator,
  'simplification': ExpressionSimplificationGen,
  'ten_powers': TenPowersGen,
  'negative': NegativeNumbersGen,
  'linear_graph': LinearGraphGenerator,
  'scale': ScaleGenerator,
  'volume': VolumeGenerator
};

export default function handler(req: VercelRequest, res: VercelResponse) {
  // --- CORS Configuration ---
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader(
    'Access-Control-Allow-Headers',
    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
  );

  // Handle preflight requests
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // --- Request Validation ---
  const { topic, difficulty } = req.query;

  if (!topic) {
    return res.status(400).json({ error: 'Missing required parameter: topic' });
  }

  const topicKey = topic as string;

  if (!GENERATORS[topicKey]) {
    // Return available topics to help with debugging frontend configuration
    return res.status(404).json({ 
      error: `Topic '${topicKey}' not found.`,
      availableTopics: Object.keys(GENERATORS) 
    });
  }

  // --- Question Generation ---
  try {
    // Default to difficulty 1 if not provided or invalid
    const diffLevel = difficulty ? Math.max(1, Math.min(3, parseInt(difficulty as string))) : 1;
    
    const GeneratorClass = GENERATORS[topicKey];
    
    // Support both static methods (preferred) and class instances (legacy)
    let question;
    
    if (typeof GeneratorClass.getQuestion === 'function') {
        question = GeneratorClass.getQuestion(diffLevel);
    } else {
        const instance = new GeneratorClass();
        question = instance.getQuestion(diffLevel);
    }

    // --- Response ---
    return res.status(200).json(question);

  } catch (error: any) {
    console.error(`[API Error] Failed to generate question for topic: ${topicKey}`, error);
    
    return res.status(500).json({ 
        error: 'Internal Server Error during question generation.', 
        message: error.message,
        topic: topicKey
    });
  }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: dev-server.ts
// =======================================================

import express, { Request, Response } from 'express';
import cors from 'cors';
import { register } from 'tsconfig-paths';
import path from 'path';

// 1. Register Path Aliases (@core/*) from tsconfig
// This ensures the backend logic can find files in src/core
import tsConfig from './tsconfig.json' assert { type: "json" };

const baseUrl = path.resolve(process.cwd(), tsConfig.compilerOptions.baseUrl || '.');
const cleanup = register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths,
});

// 2. Import API Handlers
// We import these AFTER registering paths so they resolve correctly
import questionHandler from './api/question';
import answerHandler from './api/answer';
import curriculumHandler from './api/curriculum';

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// 3. Vercel -> Express Adapter
// Vercel functions are (req, res) => void, which matches Express,
// but we wrap them to ensure errors are caught.
const adapter = (handler: any) => async (req: Request, res: Response) => {
    try {
        await handler(req, res);
    } catch (err) {
        console.error("API Error:", err);
        res.status(500).json({ error: 'Internal Server Error', details: String(err) });
    }
};

// 4. Define Routes
// These must match the filenames in your /api folder
app.get('/api/question', adapter(questionHandler));
app.post('/api/answer', adapter(answerHandler));
app.get('/api/curriculum', adapter(curriculumHandler));

// 5. Start Server
app.listen(PORT, () => {
    console.log(`\nüöÄ Backend Simulation running at http://localhost:${PORT}`);
    console.log(`   - /api/question`);
    console.log(`   - /api/answer`);
    console.log(`   - /api/curriculum`);
    console.log(`\nüé® Frontend running at http://localhost:5173 (Proxy active)\n`);
});

// FILE END: dev-server.ts

// =======================================================
// FILE START: index.html
// =======================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <title>Anpassa | Adaptive Math</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// FILE END: index.html

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"vite\"",
    "dev:frontend": "vite",
    "dev:server": "tsx watch dev-server.ts",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "katex": "^0.16.9",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.7.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.6"
  }
}

// FILE END: package.json

// =======================================================
// FILE START: postcss.config.js
// =======================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// FILE END: postcss.config.js

// =======================================================
// FILE START: src\App.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import Dashboard from './components/views/Dashboard';
import PracticeView from './components/views/PracticeView';
import DoNowConfig from './components/views/DoNowConfig';
import DoNowGrid from './components/views/DoNowGrid';
import StatsModal from './components/modals/StatsModal';
import AboutModal from './components/modals/AboutModal';
import LgrModal from './components/modals/LgrModal';
import { UI_STRINGS } from './core/utils/i18n'; 

// Counters Component for the Header
const StatsCounter = ({ icon, value, colorClass, title, onClick }) => (
  <div 
    onClick={onClick}
    className={`flex items-center gap-1.5 px-3 py-1 rounded-full border ${colorClass} transition-all duration-200 cursor-pointer hover:bg-opacity-80 active:scale-95`}
    title={title}
  >
    <span className="text-lg select-none">{icon}</span>
    <span className={`font-bold text-sm sm:text-base ${colorClass.split(' ')[1]}`.replace('border-', 'text-')}>
      {value}
    </span>
  </div>
);

const App = () => {
  // --- Global State ---
  const [currentView, setCurrentView] = useState('dashboard');
  const [selectedTopic, setSelectedTopic] = useState(null);
  const [doNowConfig, setDoNowConfig] = useState(null);
  const [lang, setLang] = useState('sv'); // Default language
  
  // Modal State
  const [showStats, setShowStats] = useState(false);
  const [showAbout, setShowAbout] = useState(false);
  const [showLgr, setShowLgr] = useState(false);
  
  // Persisted User Stats
  const [stats, setStats] = useState({
    totalCorrect: 0,
    streak: 0,
    history: []
  });

  // Load stats on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem('anpassa_stats');
      if (saved) {
        setStats(JSON.parse(saved));
      }
    } catch (e) {
      console.error("Failed to load stats", e);
    }
  }, []);

  // Save stats on change
  useEffect(() => {
    localStorage.setItem('anpassa_stats', JSON.stringify(stats));
  }, [stats]);

  // --- Handlers ---
  const handleStartPractice = (topic) => {
    if (!topic) return;
    setSelectedTopic(topic);
    setCurrentView('practice');
    window.scrollTo(0, 0);
  };

  const handleStartDoNow = (config) => {
    setDoNowConfig(config);
    setCurrentView('donow_grid');
    window.scrollTo(0, 0);
  };

  const handleCorrectAnswer = (topicId) => {
    setStats(prev => ({
      ...prev,
      totalCorrect: prev.totalCorrect + 1,
      streak: prev.streak + 1,
      history: [...prev.history, { date: new Date().toISOString(), result: 'correct', topic: topicId }]
    }));
  };

  const handleIncorrectAnswer = () => {
    setStats(prev => ({
      ...prev,
      streak: 0
    }));
  };

  const handleHome = () => {
    setCurrentView('dashboard');
    setSelectedTopic(null);
  };

  const UI = UI_STRINGS[lang];

  // --- Render ---
  return (
    <div className="min-h-screen bg-slate-50 text-slate-900 font-sans flex flex-col pb-20"> {/* pb-20 for fixed footer */}
      {/* Sticky Header */}
      <header className="sticky top-0 z-50 bg-white/95 backdrop-blur-sm border-b border-slate-200 shadow-sm px-4 py-3">
        <div className="max-w-5xl mx-auto flex justify-between items-center">
          
          {/* Logo / Home */}
          <div 
            className="flex items-center gap-2 cursor-pointer group" 
            onClick={handleHome}
          >
            <div className="w-9 h-9 bg-indigo-600 rounded-lg flex items-center justify-center text-white font-bold text-xl shadow-md group-hover:bg-indigo-700 transition-colors">
              A
            </div>
            <h1 className="text-xl font-bold text-slate-800 tracking-tight hidden sm:block group-hover:text-indigo-700 transition-colors">
              Anpassa
            </h1>
          </div>

          {/* Stats Counters */}
          <div className="flex items-center gap-3 sm:gap-4">
            <StatsCounter 
              icon="üî•" 
              value={stats.streak} 
              colorClass="bg-orange-50 border-orange-100 text-orange-600"
              title={UI.streak}
              onClick={() => setShowStats(true)}
            />
            
            <StatsCounter 
              icon="‚úÖ" 
              value={stats.totalCorrect} 
              colorClass="bg-emerald-50 border-emerald-100 text-emerald-600"
              title={UI.score}
              onClick={() => setShowStats(true)}
            />
          </div>
        </div>
      </header>

      {/* Main Content Area */}
      <main className="flex-1 w-full max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
        {currentView === 'dashboard' && (
          <Dashboard 
            onStart={handleStartPractice}
            lang={lang}
          />
        )}

        {currentView === 'practice' && selectedTopic && (
          <PracticeView 
            topic={selectedTopic}
            onCorrect={handleCorrectAnswer}
            onIncorrect={handleIncorrectAnswer}
            onBack={handleHome}
            lang={lang}
          />
        )}

        {currentView === 'donow_config' && (
          <DoNowConfig 
            onStart={handleStartDoNow} 
            onBack={handleHome}
            lang={lang}
          />
        )}

        {currentView === 'donow_grid' && doNowConfig && (
          <DoNowGrid 
            config={doNowConfig}
            onComplete={handleHome}
            lang={lang}
          />
        )}
      </main>

      {/* FIXED FOOTER NAVIGATION (Restored from Project Context) */}
      <footer className="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 shadow-lg z-40 px-4 py-3">
        <div className="max-w-xl mx-auto flex justify-between items-center text-xs font-medium text-slate-500">
          
          {/* 1. Do Now Button */}
          <button 
            onClick={() => {
                setCurrentView('donow_config');
                window.scrollTo(0,0);
            }}
            className="flex flex-col items-center gap-1 hover:text-indigo-600 transition-colors w-16"
          >
            <span className="text-xl">‚ö°</span>
            <span>{UI.donow}</span>
          </button>

          {/* 2. LGR22 Modal Button */}
          <button 
            onClick={() => setShowLgr(true)}
            className="flex flex-col items-center gap-1 hover:text-indigo-600 transition-colors w-16"
          >
            <span className="text-xl">üìö</span>
            <span>LGR22</span>
          </button>

          {/* 3. Language Toggle */}
          <button 
            onClick={() => setLang(l => l === 'sv' ? 'en' : 'sv')}
            className="flex flex-col items-center gap-1 hover:text-indigo-600 transition-colors w-16"
          >
            <span className="text-xl">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span>
            <span>{lang.toUpperCase()}</span>
          </button>

          {/* 4. About Modal Button */}
          <button 
            onClick={() => setShowAbout(true)}
            className="flex flex-col items-center gap-1 hover:text-indigo-600 transition-colors w-16"
          >
            <span className="text-xl">‚ÑπÔ∏è</span>
            <span>{UI.aboutBtn}</span>
          </button>

        </div>
      </footer>

      {/* --- Modals --- */}
      {showStats && (
        <StatsModal 
          isOpen={showStats}
          onClose={() => setShowStats(false)} 
          stats={stats}
          lang={lang}
        />
      )}
      
      {showAbout && (
        <AboutModal 
          isOpen={showAbout}
          onClose={() => setShowAbout(false)}
          lang={lang}
        />
      )}
      
      {showLgr && (
        <LgrModal 
          isOpen={showLgr}
          onClose={() => setShowLgr(false)}
          lang={lang}
        />
      )}

    </div>
  );
};

export default App;

// FILE END: src\App.jsx

// =======================================================
// FILE START: src\components\modals\AboutModal.jsx
// =======================================================

import React from 'react';
import { UI_TEXT } from '../../constants/localization';

export const AboutModal = ({ visible, onClose, lang = 'sv' }) => {
  if (!visible) return null;

  const aboutTitle = "Om skaparen";
  const aboutText = "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.";
  
  return (
    <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm animate-fade-in">
      <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
        <button 
          onClick={onClose} 
          className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1"
        >
          ‚úï
        </button>

        <div className="mb-4 flex justify-center">
            <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100 bg-gray-200">
                 <img 
                    src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                    alt="Creator"
                    className="w-full h-full object-cover"
                 />
            </div>
        </div>

        <div className="text-center mb-6">
            <h3 className="text-2xl font-bold text-gray-800 mb-2">{aboutTitle}</h3>
            <p className="text-gray-600 text-sm leading-relaxed mb-6">{aboutText}</p>
            <hr className="my-4 border-gray-200" />
            <a 
              href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" 
              target="_blank" 
              rel="noopener noreferrer" 
              className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors"
            >
               F√∂lj mig p√• LinkedIn
            </a>
        </div>
      </div>
    </div>
  );
};

// FILE END: src\components\modals\AboutModal.jsx

// =======================================================
// FILE START: src\components\modals\LgrModal.jsx
// =======================================================

import React, { useState, useEffect } from 'react';

export const LgrModal = ({ visible, onClose }) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (visible && !data) {
            setLoading(true);
            fetch('/api/curriculum')
                .then(res => res.json())
                .then(d => { setData(d); setLoading(false); })
                .catch(err => { console.error(err); setLoading(false); });
        }
    }, [visible, data]);

    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm animate-fade-in">
            <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden">
                <div className="flex justify-between items-start mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                    <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600">‚úï</button>
                </div>

                <div className="overflow-y-auto flex-1 pr-2">
                    {loading ? (
                        <div className="py-10 text-center text-slate-400">Laddar l√§roplan...</div>
                    ) : data ? (
                        <div className="space-y-8">
                            <p className="text-slate-600 italic">{data.description}</p>
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700">
                                    {data.syfte && data.syfte.map((s, i) => <li key={i}>{s}</li>)}
                                </ul>
                            </div>
                        </div>
                    ) : (
                        <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                    )}
                </div>
            </div>
        </div>
    );
};

// FILE END: src\components\modals\LgrModal.jsx

// =======================================================
// FILE START: src\components\modals\StatsModal.jsx
// =======================================================

import React from 'react';
import { UI_TEXT } from '../../constants/localization';

export const StatsModal = ({ visible, stats, onClose, lang = 'sv', title }) => {
  if (!visible) return null;

  const ui = UI_TEXT;
  const attemptCount = stats.attempted || 0;
  
  // Helper to calculate percentage safely
  const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

  return (
    <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm animate-fade-in">
      <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
        
        <h3 className="text-2xl font-bold text-gray-900 mb-6">
            {title || ui.stats_title[lang]}
        </h3>

        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-8">
            {/* Streak */}
            <div className="text-gray-500 font-medium">{ui.stats_longest_streak[lang]}</div>
            <div className="font-bold text-right text-lg">{stats.maxStreak} üî•</div>

            {/* Attempted */}
            <div className="text-gray-500 font-medium">{ui.stats_attempted[lang]}</div>
            <div className="font-bold text-right text-lg">{stats.attempted}</div>

            <div className="col-span-2 h-px bg-gray-100 my-1"></div>

            {/* Correct (No Help) */}
            <div className="text-gray-500">{ui.stats_correct_no_help[lang]}</div>
            <div className="font-bold text-right text-green-600">
                {stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)
            </div>

            {/* Correct (With Help) */}
            <div className="text-gray-500">{ui.stats_correct_help[lang]}</div>
            <div className="font-bold text-right text-yellow-600">
                {stats.correctHelp} ({getPct(stats.correctHelp)}%)
            </div>

            {/* Incorrect */}
            <div className="text-gray-500">{ui.stats_incorrect[lang]}</div>
            <div className="font-bold text-right text-red-600">
                {stats.incorrect} ({getPct(stats.incorrect)}%)
            </div>

            {/* Skipped */}
            <div className="text-gray-500">{ui.stats_skipped[lang]}</div>
            <div className="font-bold text-right text-gray-400">
                {stats.skipped}
            </div>
        </div>

        <button 
            onClick={onClose} 
            className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
        >
            {ui.stats_close[lang]}
        </button>
      </div>
    </div>
  );
};

// FILE END: src\components\modals\StatsModal.jsx

// =======================================================
// FILE START: src\components\practice\CluePanel.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';
import { UI_TEXT } from '../../constants/localization';

export const CluePanel = ({ revealedClues, totalClues, ui, lang = 'sv', isSolutionRevealed }) => {
  if (!revealedClues || revealedClues.length === 0) return null;

  return (
    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
      <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
        <span>üí° {ui.hintsTitle[lang]} ({revealedClues.length}/{totalClues})</span>
      </div>
      
      <div className="space-y-6">
        {revealedClues.map((clue, i) => {
          // Logic: Only show the big LaTeX box for the *current* clue, unless solution is fully revealed
          const isLast = i === totalClues - 1; 
          // const showLatex = !isLast || isSolutionRevealed; // Legacy logic variation
          
          return (
            <div key={i} className="group animate-slide-down">
              <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                <MathText text={clue.text} />
              </div>
              {clue.latex && (
                <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                  <MathText text={`$${clue.latex}$`} className="text-lg" />
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};

// FILE END: src\components\practice\CluePanel.jsx

// =======================================================
// FILE START: src\components\practice\HistoryList.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';
import { UI_TEXT } from '../../constants/localization';

export const HistoryList = ({ history, lang = 'sv' }) => {
  const ui = UI_TEXT;

  return (
    <div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
      <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
        <h2 className="font-bold text-gray-700">{ui.history[lang]}</h2>
        <span className="text-xs text-gray-400">{history.length}</span>
      </div>
      
      <div className="flex-1 overflow-y-auto p-4 space-y-3 custom-scrollbar">
        {history.length === 0 ? (
          <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory[lang]}</p>
        ) : (
          history.map((entry, i) => (
            <div 
              key={i} 
              className={`p-3 rounded-lg border-l-4 text-sm ${
                entry.correct 
                  ? 'border-primary-500 bg-primary-50' 
                  : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')
              }`}
            >
              <div className="flex justify-between items-start mb-1">
                <span className="font-semibold capitalize text-gray-700">
                   {entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span>
                </span>
                <span className="text-xs text-gray-400">
                  {new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </span>
              </div>
              
              <div className="text-gray-600 mb-1 line-clamp-2">
                <MathText text={entry.text} />
              </div>
              
              {/* Show correct answer if wrong/skipped */}
              {!entry.correct && !entry.skipped && entry.correctAnswer && (
                <div className="text-xs text-red-600 mt-1 font-medium">
                   <MathText text={`Correct: ${entry.correctAnswer}`} />
                </div>
              )}
              
              <div className="mt-2 flex items-center gap-2">
                {entry.clueUsed && (
                  <span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider">
                    {ui.clueUsed[lang]}
                  </span>
                )}
                <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${
                  entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')
                }`}>
                  {entry.correct ? ui.correct[lang].split('!')[0] : (entry.skipped ? ui.stat_skip[lang] : ui.incorrect[lang].split(',')[0])}
                </span>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};

// FILE END: src\components\practice\HistoryList.jsx

// =======================================================
// FILE START: src\components\practice\MobileDrawer.jsx
// =======================================================

import React from 'react';
import { HistoryList } from './HistoryList';
import { UI_TEXT } from '../../constants/localization';

export const MobileDrawer = ({ open, onClose, history, lang }) => {
  return (
    <>
      {/* Backdrop */}
      {open && (
        <div 
          className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" 
          onClick={onClose}
        ></div>
      )}
      
      {/* Drawer */}
      <div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}>
        <div className="p-4 border-b flex justify-between items-center bg-gray-50">
          <h2 className="font-bold text-gray-700">{UI_TEXT.history[lang]}</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600">‚úï</button>
        </div>
        <div className="flex-1 overflow-y-auto p-4">
          <HistoryList history={history} lang={lang} />
        </div>
      </div>
    </>
  );
};

// FILE END: src\components\practice\MobileDrawer.jsx

// =======================================================
// FILE START: src\components\ui\Button.jsx
// =======================================================

import React from 'react';

export const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  className = '', 
  disabled = false,
  fullWidth = false 
}) => {
  const baseStyles = "px-4 py-2 rounded-lg font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-math-blue text-white hover:bg-blue-600 focus:ring-math-blue shadow-sm",
    secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500",
    success: "bg-math-green text-white hover:bg-green-600 focus:ring-math-green shadow-sm",
    danger: "bg-math-red text-white hover:bg-red-600 focus:ring-math-red shadow-sm",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
    >
      {children}
    </button>
  );
};

// FILE END: src\components\ui\Button.jsx

// =======================================================
// FILE START: src\components\ui\MathText.jsx
// =======================================================

import React from 'react';
import 'katex/dist/katex.min.css';

const MathText = ({ text, className = "" }) => {
  if (!text) return null;

  return (
    <span 
      className={`math-text-content ${className}`}
      dangerouslySetInnerHTML={{ __html: text }} 
    />
  );
};

export default MathText;

// FILE END: src\components\ui\MathText.jsx

// =======================================================
// FILE START: src\components\views\Dashboard.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/curriculum';
import { UI_TEXT } from '../../constants/localization';

// --- Local Helper for Tailwind Classes (Safe Fallback) ---
const getLocalColorClasses = (color, type) => {
  const c = color || 'emerald';
  const validColors = ['pink', 'indigo', 'emerald', 'purple', 'primary'];
  const safeColor = validColors.includes(c) ? c : 'emerald';

  switch (type) {
      case 'bg-light': return `bg-${safeColor}-50`;
      case 'bg-dark': return `bg-${safeColor}-500`;
      case 'border': return `border-${safeColor}-100`;
      case 'text': return `text-${safeColor}-700`;
      case 'ring': return `ring-${safeColor}-500`;
      case 'border-solid': return `border-${safeColor}-500`;
      default: return '';
  }
};

export const Dashboard = ({ 
  onStartPractice, 
  lang = 'sv', 
  timerSettings, 
  toggleTimer, 
  resetTimer, 
  onLgrOpen, 
  onDoNowOpen, 
  toggleLang 
}) => {
  const [selectedGenId, setSelectedGenId] = useState(null);
  const [selectedLevel, setSelectedLevel] = useState(0);

  // Safety Check: Ensure CRITICAL Data exists before rendering
  // If UI_TEXT is missing, it likely means the localization file wasn't saved correctly.
  if (!UI_TEXT || !CATEGORIES) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="p-8 bg-white rounded-xl shadow text-center max-w-md">
          <h2 className="text-red-500 font-bold text-xl mb-2">Configuration Error</h2>
          <p className="text-gray-600 mb-4">Core data files (UI_TEXT or CATEGORIES) failed to load.</p>
        </div>
      </div>
    );
  }

  const handleSelection = (genId, level) => {
    setSelectedGenId(genId);
    setSelectedLevel(level);
  };

  const handleStartClick = () => {
    if (selectedGenId && selectedLevel > 0) {
      onStartPractice(selectedGenId, selectedLevel);
    }
  };

  const titleText = UI_TEXT.dashboard_title ? UI_TEXT.dashboard_title[lang] : "Anpassa Math";

  return (
    <div className="max-w-6xl mx-auto w-full p-4 fade-in flex flex-col min-h-[85vh]">
      
      {/* --- HERO HEADER --- */}
      <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4 relative overflow-hidden">
        <h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight relative z-10">
            Anpassa
        </h1>
        <p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide relative z-10">
            {titleText}
        </p>

        {/* Timer Selector */}
        <div className="mt-8 flex justify-center relative z-10">
           <div className="bg-white/80 backdrop-blur-sm rounded-xl p-2 px-4 shadow-sm border border-gray-100 flex items-center gap-3">
              <span className="font-bold text-gray-700 text-xs uppercase tracking-wider">
                  {lang === 'sv' ? 'Tid' : 'Timer'}
              </span>
              <div className="relative group">
                 <select 
                    value={timerSettings?.duration / 60 || 0}
                    onChange={(e) => toggleTimer && toggleTimer(Number(e.target.value))}
                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                 >
                    <option value="0">{lang === 'sv' ? 'Av' : 'Off'}</option>
                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} min</option>)}
                 </select>
              </div>
           </div>
        </div>
      </div>

      {/* --- CATEGORY CARDS --- */}
      <div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-2 gap-8 mb-20">
        {Object.values(CATEGORIES).map((cat) => {
          // Use local helper to prevent import crashes
          const bgLight = getLocalColorClasses(cat.color, 'bg-light');
          const border = getLocalColorClasses(cat.color, 'border');
          const text = getLocalColorClasses(cat.color, 'text');
          const bgDark = getLocalColorClasses(cat.color, 'bg-dark');
          const ring = getLocalColorClasses(cat.color, 'ring');
          const borderSolid = getLocalColorClasses(cat.color, 'border-solid');

          return (
            <div key={cat.id} className="bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full">
               <div className={`${bgLight} p-4 border-b ${border}`}>
                  <h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}>
                      <span className={`w-3 h-3 rounded-full ${bgDark}`}></span>
                      {cat.label[lang]}
                  </h3>
               </div>

               <div className="p-4 space-y-4 flex-1">
                 {/* Generator List Loop */}
                 {cat.generators.map(gen => {
                    // ROBUST DATA HANDLING:
                    // Check if 'gen' is an object (new format) or string (old format)
                    const genId = typeof gen === 'string' ? gen : gen.id;
                    const genLabel = typeof gen === 'string' ? gen : (gen.label ? gen.label[lang] : genId);
                    
                    const isSelected = selectedGenId === genId;
                    
                    // Safe Level Access
                    const levels = (LEVEL_DESCRIPTIONS && LEVEL_DESCRIPTIONS[genId]) || {};
                    const levelKeys = Object.keys(levels).map(Number).sort((a,b) => a - b);

                    return (
                        <div key={genId} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                           <div className="font-semibold text-gray-700 mb-3 ml-1">
                               {genLabel}
                           </div>
                           <div className="relative">
                              <select 
                                value={isSelected ? selectedLevel : 0}
                                onChange={(e) => handleSelection(genId, Number(e.target.value))}
                                className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${isSelected ? `ring-2 ${ring} ${borderSolid}` : `focus:${ring}`}`}
                              >
                                 <option value={0} disabled>{lang === 'sv' ? "V√§lj niv√•:" : "Select Level:"}</option>
                                 {levelKeys.length > 0 ? levelKeys.map(lvl => (
                                     <option key={lvl} value={lvl}>
                                        {lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {levels[lvl] ? levels[lvl][lang] : ''}
                                     </option>
                                 )) : <option disabled>No levels available</option>}
                              </select>
                           </div>
                        </div>
                    );
                 })}
               </div>
            </div>
          );
        })}
      </div>

      {/* --- START BUTTON --- */}
      <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20">
         <button 
           onClick={handleStartClick}
           className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedGenId && selectedLevel > 0 ? 'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600' : 'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}
         >
            {lang === 'sv' ? 'B√∂rja √∂va' : 'Start Practice'} <span>üöÄ</span>
         </button>
      </div>

      {/* --- FOOTER --- */}
      <footer className="mt-auto py-6 border-t border-gray-200 flex flex-col md:flex-row justify-between items-center px-4 gap-4">
          <button 
            onClick={onDoNowOpen} 
            className="w-full md:w-auto bg-slate-800 hover:bg-slate-900 text-white font-bold py-2 px-6 rounded-full text-sm transition-colors shadow-sm order-2 md:order-1"
          >
              {UI_TEXT?.donow ? (UI_TEXT.donow[lang] || "Do Now") : "Do Now"}
          </button>

          <div className="flex items-center gap-3 order-1 md:order-2 w-full md:w-auto justify-center md:justify-end">
             <button onClick={toggleLang} className="px-4 py-2 rounded-full text-sm font-bold border border-slate-200 bg-white text-slate-600 hover:bg-slate-50 transition-all shadow-sm flex items-center gap-2">
                <span className="text-lg">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span>
                <span>{lang === 'sv' ? 'SE' : 'ENG'}</span>
             </button>
             <button onClick={onLgrOpen} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-sky-200 shadow-sm">
                LGR22
             </button>
          </div>
      </footer>

    </div>
  );
};

// FILE END: src\components\views\Dashboard.jsx

// =======================================================
// FILE START: src\components\views\DoNowConfig.jsx
// =======================================================

import React, { useState } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/curriculum';
import { UI_TEXT } from '../../constants/localization';

export const DoNowConfig = ({ onBack, onGenerate, lang = 'sv' }) => {
  const [selected, setSelected] = useState([]);
  const ui = UI_TEXT;

  // Legacy Toggle Logic
  const handleToggle = (topicId, level) => {
    setSelected(prev => {
      const exists = prev.find(p => p.topic === topicId && p.level === level);
      if (exists) {
        return prev.filter(p => !(p.topic === topicId && p.level === level));
      } else {
        if (prev.length >= 3) return prev; // Max 3
        return [...prev, { topic: topicId, level }];
      }
    });
  };

  // Helper to resolve topic label from curriculum constants
  const getTopicLabel = (topicId) => {
      for (const cat of Object.values(CATEGORIES)) {
          const topic = cat.generators.find(g => g.id === topicId);
          if (topic) return typeof topic.label === 'object' ? topic.label[lang] : topic.label;
      }
      return topicId;
  };

  return (
    <div className="max-w-5xl mx-auto p-6 h-full flex flex-col min-h-screen bg-gray-50 fade-in">
      {/* Header */}
      <div className="flex justify-between items-center mb-6">
        <button 
          onClick={onBack} 
          className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2 transition-colors"
        >
          <span>‚Üê</span> {ui.backBtn[lang]}
        </button>
        <h2 className="text-2xl font-bold text-slate-800">
          {ui.donow_title ? ui.donow_title[lang] : "Do Now"}
        </h2>
        <button
          onClick={() => onGenerate(selected)}
          disabled={selected.length === 0}
          className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
        >
          {ui.donow_gen ? ui.donow_gen[lang] : "Generate"} ({selected.length}/3)
        </button>
      </div>

      <p className="text-slate-500 mb-6 text-center">
        {ui.donow_desc ? ui.donow_desc[lang] : "Select up to 3 levels."}
      </p>

      {/* Legacy Grid Layout */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 pb-10">
        {Object.entries(CATEGORIES).map(([catKey, category]) => (
          <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm h-full">
            <h3 className="font-bold text-slate-700 mb-3 border-b border-slate-100 pb-2">
              {category.label[lang]}
            </h3>
            
            <div className="space-y-4">
              {category.generators.map(topic => (
                <div key={topic.id}>
                  <div className="text-xs font-bold text-slate-400 uppercase mb-2">
                    {typeof topic.label === 'object' ? topic.label[lang] : topic.label}
                  </div>
                  
                  <div className="flex flex-col gap-2">
                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                      const descObj = LEVEL_DESCRIPTIONS[topic.id];
                      if (!descObj || !descObj[lvl]) return null;
                      
                      const description = descObj[lvl][lang];
                      const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);

                      return (
                        <button
                          key={lvl}
                          onClick={() => handleToggle(topic.id, lvl)}
                          className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${
                            isSelected 
                              ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' 
                              : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'
                          }`}
                        >
                          <span className="font-mono font-bold w-6 text-center bg-white/50 rounded text-xs">
                            {lvl}
                          </span>
                          <span className="truncate text-xs leading-tight">
                            {description}
                          </span>
                        </button>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

// FILE END: src\components\views\DoNowConfig.jsx

// =======================================================
// FILE START: src\components\views\DoNowGrid.jsx
// =======================================================

import React, { useState } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas } from '../visuals/GraphCanvas';
import { VolumeVisualization } from '../visuals/VolumeVisualization';
import { GeometryVisual } from '../visuals/GeometryVisual';
import { UI_TEXT } from '../../constants/localization';

// Helper for static visual fallback
const StaticGeometryVisual = ({ description }) => { 
    if (!description) return null; 
    const d = description.toLowerCase(); 
    if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; 
    return null; 
};

const DoNowCard = ({ q, index, showAnswer, onToggle, lang }) => {
    // Determine description text
    const desc = q.renderData && q.renderData.description 
        ? (typeof q.renderData.description === 'object' ? q.renderData.description[lang] : q.renderData.description)
        : "";

    const renderVisual = () => {
        if (!q.renderData) return null;
        if (q.renderData.graph) return <GraphCanvas visual={q.renderData.graph} />; // Changed prop name 'data' to 'visual' to match new components if needed, or stick to legacy 'data' if wrapper handles it. 
        // Note: New components use 'visual' prop usually. 
        // Legacy used 'data'. We will map 'visual'={q.renderData.graph} assuming new components.
        
        if (q.renderData.geometry) {
             const type = q.renderData.geometry.type;
             if (['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(type)) {
                 return <VolumeVisualization visual={q.renderData.geometry} />;
             }
             return <GeometryVisual visual={q.renderData.geometry} />;
        }
        
        // Fallback
        if (q.topic === 'geometry') return <StaticGeometryVisual description={desc} />;
        return <div className="text-4xl text-slate-200 font-bold select-none opacity-20">#</div>;
    };

    return (
        <div className="bg-white rounded-xl shadow-sm border border-slate-200 flex flex-col h-full overflow-hidden print-break-inside-avoid relative">
            {/* Card Header */}
            <div className="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center shrink-0">
                <span className="text-xs font-bold text-slate-400 uppercase">
                    Q{index + 1} ‚Ä¢ {q.topic.replace('Gen', '')} L{q.level}
                </span>
            </div>

            <div className="p-4 flex-1 flex flex-col gap-4 relative">
                {/* 1. VISUALIZATION ZONE */}
                <div className="flex-1 bg-slate-50/50 rounded-lg border border-slate-100 flex items-center justify-center min-h-[150px] p-2 relative overflow-hidden">
                    <div className="scale-90 origin-center w-full flex justify-center">
                        {renderVisual()}
                    </div>
                </div>

                {/* 2. TEXT ZONE */}
                <div className="shrink-0 text-center space-y-3 min-h-[6rem] flex flex-col justify-center py-2">
                    {q.renderData && q.renderData.latex && (
                        <div className="text-3xl md:text-5xl font-mono text-slate-900 font-bold tracking-wider">
                            <MathText text={`$${q.renderData.latex}$`} />
                        </div>
                    )}
                    {desc && (
                        <div className="text-lg md:text-2xl font-medium text-slate-700 leading-snug max-w-prose mx-auto">
                            <MathText text={desc} />
                        </div>
                    )}
                </div>

                {/* ANSWER OVERLAY */}
                <div className={`absolute inset-0 bg-white/95 backdrop-blur-sm z-10 flex items-center justify-center transition-opacity duration-300 ${showAnswer ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                    <div className="text-center transform scale-110">
                        <div className="text-sm text-slate-400 uppercase font-bold mb-2">Facit</div>
                        <div className="text-4xl font-bold text-emerald-600 font-mono px-4">
                            {q.displayAnswer}
                        </div>
                    </div>
                </div>
            </div>

            <button
                onClick={onToggle}
                className="w-full py-4 bg-slate-50 hover:bg-slate-100 border-t border-slate-100 text-sm font-bold text-slate-500 transition-colors shrink-0 z-20"
            >
                {showAnswer 
                    ? (lang === 'sv' ? "D√∂lj" : "Hide") 
                    : (lang === 'sv' ? "Visa svar" : "Show Answer")}
            </button>
        </div>
    );
};

export const DoNowGrid = ({ questions, onBack, lang = 'sv' }) => {
    const [revealed, setRevealed] = useState({});
    const [showAll, setShowAll] = useState(false);
    const ui = UI_TEXT;

    const toggleOne = (idx) => {
        setRevealed(prev => ({ ...prev, [idx]: !prev[idx] }));
    };

    const toggleAll = () => {
        if (showAll) {
            setRevealed({});
            setShowAll(false);
        } else {
            const all = {};
            questions.forEach((_, i) => all[i] = true);
            setRevealed(all);
            setShowAll(true);
        }
    };

    return (
        <div className="h-screen flex flex-col bg-slate-100 fade-in">
            {/* Header */}
            <header className="bg-white border-b border-slate-200 px-6 py-3 flex justify-between items-center shadow-sm z-20 shrink-0">
                <button 
                    onClick={onBack} 
                    className="flex items-center gap-2 text-slate-600 font-bold hover:text-slate-900"
                >
                    <span>‚Üê</span> {ui.donow_title ? ui.donow_title[lang] : "Do Now Activity"}
                </button>
                <div className="flex gap-4">
                    <button 
                        onClick={toggleAll} 
                        className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg font-bold text-sm transition-colors"
                    >
                        {showAll 
                            ? (ui.donow_hide_all ? ui.donow_hide_all[lang] : "Hide All") 
                            : (ui.donow_show_all ? ui.donow_show_all[lang] : "Show All")}
                    </button>
                </div>
            </header>

            {/* Scrollable Grid Area */}
            <div className="flex-1 p-6 overflow-y-auto">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 h-full auto-rows-fr">
                    {questions.map((q, i) => (
                        <DoNowCard
                            key={i}
                            index={i}
                            q={q}
                            showAnswer={!!revealed[i]}
                            onToggle={() => toggleOne(i)}
                            lang={lang}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
};

// FILE END: src\components\views\DoNowGrid.jsx

// =======================================================
// FILE START: src\components\views\PracticeView.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import { UI_TEXT } from '../../constants/localization';
import { CATEGORIES } from '../../constants/curriculum';
import MathText from '../ui/MathText';
import { GeometryVisual } from '../visuals/GeometryVisual';
import { VolumeVisualization } from '../visuals/VolumeVisualization';
import { GraphCanvas } from '../visuals/GraphCanvas';
import { CluePanel } from '../practice/CluePanel';
import { HistoryList } from '../practice/HistoryList';
import { MobileDrawer } from '../practice/MobileDrawer';

export const PracticeView = ({ 
  generatorId, 
  initialLevel = 1, 
  onBack, 
  lang = 'sv',
  streak,
  setStreak,
  setTotalCorrect,
  updateStats
}) => {
  // --- State ---
  const [loading, setLoading] = useState(true);
  const [question, setQuestion] = useState(null);
  
  // Progression State
  const [currentLevel, setCurrentLevel] = useState(initialLevel);
  const [history, setHistory] = useState([]);
  
  // Interaction State
  const [input, setInput] = useState('');
  const [scaleLeft, setScaleLeft] = useState('');
  const [scaleRight, setScaleRight] = useState('');
  const [feedback, setFeedback] = useState(null); // 'correct' | 'incorrect' | null
  
  // Clue State
  const [revealedClues, setRevealedClues] = useState([]);
  const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);
  
  // UI State
  const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);
  const inputRef = useRef(null);

  const ui = UI_TEXT;

  // --- Helper: Get API Topic from Generator ID ---
  const getApiTopic = (genId) => {
    for (const cat of Object.values(CATEGORIES)) {
        const gen = cat.generators.find(g => g.id === genId);
        if (gen && gen.api) return gen.api;
    }
    // Fallback: simple stripping (Legacy support)
    return genId.replace('Gen', '').replace('Generator', '').toLowerCase();
  };

  // --- Actions ---

  const fetchQuestion = async (lvl = currentLevel) => {
    setLoading(true);
    setFeedback(null);
    setInput('');
    setScaleLeft('');
    setScaleRight('');
    setRevealedClues([]);
    setIsSolutionRevealed(false);
    
    try {
      const topic = getApiTopic(generatorId);
      const res = await fetch(`/api/question?topic=${topic}&lang=${lang}&level=${lvl}`);
      
      if (!res.ok) {
          throw new Error(`API Error: ${res.status}`);
      }

      const data = await res.json();
      
      if (data.error) {
          throw new Error(data.error);
      }

      setQuestion(data);
    } catch (err) {
      console.error("Failed to fetch question:", err);
      // We don't setQuestion(null) here to potentially keep old question visible if refresh failed
      // But for a fresh load, we need to handle the null case in render
    } finally {
      setLoading(false);
      // Auto-focus logic
      setTimeout(() => {
          if(window.innerWidth > 768) inputRef.current?.focus();
      }, 100);
    }
  };

  // Initial Load
  useEffect(() => {
    fetchQuestion(initialLevel);
  }, []); 

  const handleChangeLevel = (delta) => {
    const newLvl = currentLevel + delta;
    const maxLevel = 9; 
    if (newLvl >= 1 && newLvl <= maxLevel) {
        setCurrentLevel(newLvl);
        setStreak(0); // Reset streak on manual level change
        fetchQuestion(newLvl);
    }
  };

  const handleHint = () => {
    if (question && question.clues) {
        const nextIndex = revealedClues.length;
        if (nextIndex < question.clues.length) {
            setRevealedClues([...revealedClues, question.clues[nextIndex]]);
        }
    }
  };

  const handleSolution = () => {
    if (question && question.clues) {
        setRevealedClues(question.clues);
        setIsSolutionRevealed(true);
        setStreak(0); // Forfeit streak
        if (updateStats) updateStats('incorrect'); // Viewing solution counts as wrong/give up
    }
  };

  const handleSkip = () => {
    if (!question) return;
    
    // Add skipped entry to history
    const entry = {
        topic: generatorId.replace('Gen', '').replace('Generator', ''),
        level: currentLevel,
        correct: false,
        skipped: true,
        text: question.text || (question.renderData && question.renderData.description),
        clueUsed: revealedClues.length > 0,
        time: Date.now(),
        correctAnswer: question.displayAnswer || "Skipped"
    };
    setHistory(prev => [entry, ...prev]);
    setStreak(0);
    if (updateStats) updateStats('skipped');
    fetchQuestion();
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (feedback === 'correct' || !question) return;

    // Combine input for scale type
    let answerToSubmit = input;
    if (question.renderData?.answerType === 'scale') {
        if (!scaleLeft || !scaleRight) return;
        answerToSubmit = `${scaleLeft}:${scaleRight}`;
    } else {
        if (!input) return;
    }

    try {
        const topic = getApiTopic(generatorId);
        
        // Use token verification
        const res = await fetch('/api/answer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                token: question.token, 
                answer: answerToSubmit,
                topic: topic,
                level: currentLevel
            })
        });
        const result = await res.json();

        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        if (result.correct) {
            setFeedback('correct');
            setStreak(s => s + 1);
            setTotalCorrect(t => t + 1);
            
            // Stats
            if (updateStats) {
                if (helpUsed) updateStats('correctHelp');
                else updateStats('correctNoHelp');
            }

            // Add to history
            const entry = {
                topic: generatorId.replace('Gen', '').replace('Generator', ''),
                level: currentLevel,
                correct: true,
                skipped: false,
                text: question.text || (question.renderData && question.renderData.description),
                clueUsed: helpUsed,
                time: Date.now()
            };
            setHistory(prev => [entry, ...prev]);

            // Delay for "Correct!" message then next
            setTimeout(() => {
                fetchQuestion();
            }, 1500);

        } else {
            setFeedback('incorrect');
            setStreak(0);
            if (updateStats) updateStats('incorrect');
        }

    } catch (err) {
        console.error("Submission Error", err);
    }
  };

  // --- Rendering Helpers ---

  const renderVisual = () => {
    if (!question || !question.renderData) return null;
    
    // Legacy support: check both question.visual and question.renderData.geometry
    const v = question.renderData.graph || question.renderData.geometry || question.visual;
    
    if (!v) return null;

    if (v.lines || v.type === 'graph_linear') { // Graph Check
        return <GraphCanvas visual={v} />;
    }
    
    // Dispatch to specific visual components
    if (v.type === 'cube' || v.type === 'cylinder' || v.type === 'cuboid' || v.type === 'pyramid' || v.type === 'cone' || v.type === 'sphere' || v.type === 'hemisphere' || v.type === 'ice_cream' || v.type === 'silo') {
        return <VolumeVisualization visual={v} />;
    }
    
    // Default 2D geometry
    return <GeometryVisual visual={v} />;
  };

  const getDescription = () => {
      if (!question?.renderData?.description) return null;
      const d = question.renderData.description;
      return typeof d === 'object' ? d[lang] : d;
  };

  // Render Loading Spinner
  if (loading && !question) {
      return (
        <div className="flex-1 flex items-center justify-center p-20">
            <div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div>
        </div>
      );
  }

  // Render Error State if loading finished but no question
  if (!loading && !question) {
      return (
          <div className="flex-1 flex flex-col items-center justify-center p-10 text-center">
              <div className="text-red-400 mb-4 text-5xl">‚ö†Ô∏è</div>
              <h3 className="text-xl font-bold text-gray-700 mb-2">{ui.error[lang]}</h3>
              <button 
                onClick={() => fetchQuestion(currentLevel)}
                className="px-6 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors"
              >
                  {ui.retry[lang]}
              </button>
          </div>
      );
  }

  return (
    <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
        <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} lang={lang} />

        {/* --- LEFT COLUMN: Main Interaction --- */}
        <div className="flex-1 w-full min-w-0">
            
            {/* Header: Back & Level Controls */}
            <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                <button onClick={onBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95">
                    <span>‚Üê</span> {ui.backBtn[lang]}
                </button>

                <div className="flex items-center gap-3">
                    {/* Level Navigator */}
                    <div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200">
                        <button 
                            onClick={() => handleChangeLevel(-1)} 
                            disabled={currentLevel <= 1}
                            className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold"
                        >
                            &lt;
                        </button>
                        <span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">
                            {generatorId.replace('Gen', '').replace('Generator', '')} ‚Ä¢ Lvl {currentLevel}
                        </span>
                        <button 
                            onClick={() => handleChangeLevel(1)} 
                            disabled={currentLevel >= 9}
                            className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold"
                        >
                            &gt;
                        </button>
                    </div>

                    {/* Mobile History Toggle */}
                    <button onClick={() => setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500 hover:bg-gray-200 transition-colors">
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    </button>
                </div>
            </div>

            {/* Question Card */}
            <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                <div className="p-4 sm:p-6">
                    
                    {/* Visualization Area */}
                    <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative overflow-hidden">
                        {renderVisual()}
                        
                        {/* LaTeX Fallback if no visual */}
                        {question.renderData?.latex && (
                             <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center">
                                 <MathText text={`$${question.renderData.latex}$`} />
                             </div>
                        )}
                    </div>

                    {/* Description Text */}
                    {getDescription() && (
                        <div className="mb-4 text-center">
                            <h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed">
                                <MathText text={getDescription()} />
                            </h2>
                        </div>
                    )}

                    {/* Answer Input Form */}
                    {question.renderData?.answerType === 'multiple_choice' ? (
                       <div className="grid grid-cols-2 gap-4 max-w-md mx-auto mt-8">
                          {question.renderData.choices.map((choice, i) => (
                             <button
                               key={i}
                               onClick={() => {
                                  if (feedback === 'correct') return;
                                  setInput(choice);
                                  // Hack to auto submit for MC
                                  // We can't call handleSubmit directly without event, so we construct synthetic one
                                  // But state 'input' won't be updated yet. 
                                  // Better pattern:
                                  const ans = choice;
                                  // Call submit logic directly with 'ans'
                                  // We'll duplicate the submit fetch logic or wrap it. 
                                  // For now, let's just let user click the button to see selection effect
                                  // OR use a timeout.
                                }}
                               className={`py-4 rounded-xl font-bold text-lg border-2 transition-all ${
                                  input === choice 
                                    ? 'bg-blue-100 border-blue-500 text-blue-700' 
                                    : 'bg-white border-gray-200 hover:border-blue-300'
                               }`}
                             >
                                {choice}
                             </button>
                          ))}
                       </div>
                    ) : (
                        <form onSubmit={handleSubmit} className="max-w-md mx-auto space-y-4 mt-8">
                            {question.renderData?.answerType === 'scale' ? (
                                <div className="flex items-center justify-center gap-2">
                                    <input 
                                        type="text" 
                                        value={scaleLeft} 
                                        onChange={(e) => setScaleLeft(e.target.value)} 
                                        className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} 
                                        placeholder="X" 
                                        disabled={feedback === 'correct'} 
                                    />
                                    <span className="text-2xl font-bold text-gray-400">:</span>
                                    <input 
                                        type="text" 
                                        value={scaleRight} 
                                        onChange={(e) => setScaleRight(e.target.value)} 
                                        className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} 
                                        placeholder="Y" 
                                        disabled={feedback === 'correct'} 
                                    />
                                </div>
                            ) : (
                                <div className="relative">
                                    <input 
                                        ref={inputRef}
                                        type="text" 
                                        value={input} 
                                        onChange={(e) => setInput(e.target.value)} 
                                        className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} 
                                        placeholder={ui.placeholder[lang]} 
                                        autoComplete="off"
                                        disabled={feedback === 'correct'} 
                                    />
                                </div>
                            )}

                            <button 
                                type="submit" 
                                className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback === 'correct' ? 'bg-primary-500 shadow-green-200 cursor-default' : 'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}
                            >
                                {feedback === 'correct' ? ui.correct[lang].split('!')[0] + '!' : (feedback === 'incorrect' ? ui.incorrect[lang].split(',')[0] : ui.submit[lang])}
                            </button>
                        </form>
                    )}

                    {/* Action Buttons (Hint, Skip, Solve) */}
                    <div className="mt-6 flex gap-3 justify-center flex-wrap">
                        <button 
                            type="button" 
                            onClick={handleHint} 
                            disabled={!question.clues || revealedClues.length >= question.clues.length} 
                            className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"
                        >
                            <span>üí°</span> {ui.btnHint[lang]}
                        </button>
                        
                        <button 
                            type="button" 
                            onClick={handleSolution} 
                            disabled={!question.clues || isSolutionRevealed} 
                            className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                        >
                            {ui.btnSolution[lang]}
                        </button>
                        
                        <button 
                            type="button" 
                            onClick={handleSkip} 
                            className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"
                        >
                            <span>‚è≠Ô∏è</span> {ui.btnSkip[lang]}
                        </button>
                    </div>
                </div>
            </main>
        </div>

        {/* --- RIGHT COLUMN: Sidebar (Desktop) --- */}
        <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex self-start sticky top-24">
            <CluePanel 
                revealedClues={revealedClues} 
                totalClues={question?.clues?.length || 0} 
                ui={ui} 
                lang={lang}
                isSolutionRevealed={isSolutionRevealed}
            />
            <div className="flex-1 min-h-0 max-h-[calc(100vh-200px)]">
                <HistoryList history={history} lang={lang} />
            </div>
        </div>

    </div>
  );
};

// FILE END: src\components\views\PracticeView.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryVisual.jsx
// =======================================================

import React from 'react';

/**
 * Renders SVG geometry. Handles 'similarity' by rendering multiple shapes.
 * Updated to use named export to match PracticeView imports.
 */
export const GeometryVisual = ({ data }) => {
  if (!data) return null;

  // --- Helper: Render a Single Polygon ---
  const renderShape = (points, offsetX = 0, offsetY = 0, color = 'black', key) => {
    if (!points || points.length < 2) return null;
    
    // SVG Coordinate System: Y increases downwards.
    // Math Coordinate System: Y increases upwards.
    // We flip Y (-p.y) so math coordinates (0,10) render above (0,0).
    const pathData = points.map((p, i) => 
      `${i === 0 ? 'M' : 'L'} ${p.x + offsetX} ${-p.y + offsetY}`
    ).join(' ') + ' Z';

    return (
      <path 
        key={key}
        d={pathData} 
        fill={color} 
        fillOpacity="0.2" 
        stroke={color} 
        strokeWidth="2"
        vectorEffect="non-scaling-stroke" // Keeps stroke width constant on zoom
        strokeLinejoin="round"
      />
    );
  };

  // --- Helper: Render Labels ---
  const renderLabels = (labels, shapes) => {
    if (!labels) return null;
    
    return labels.map((lbl, i) => {
      let x = lbl.x;
      let y = -lbl.y; // Flip Y to match shape coordinate system
      
      // Determine offset based on shapeIndex
      // If shapeIndex is 1 (the second shape), we shift it right
      if (lbl.shapeIndex === 1 && shapes && shapes.length > 0) {
        // Find max width of shape 0 to calculate the gap offset
        const shape0Width = shapes[0].points.reduce((max, p) => Math.max(max, p.x), 0);
        const gap = 4; // Must match the gap used in ViewBox calculation
        x += (shape0Width + gap); 
      }

      return (
        <text 
          key={`lbl-${i}`} 
          x={x} 
          y={y} 
          className="text-[0.6px] fill-gray-800 font-medium font-sans select-none"
          textAnchor="middle" 
          dominantBaseline="middle"
        >
          {lbl.text}
        </text>
      );
    });
  };

  // --- ViewBox Calculation ---
  // We need to determine the bounding box of ALL shapes to zoom the SVG correctly.
  let allPoints = [];
  const gap = 4; // Space between similarity shapes

  if (data.type === 'similarity' && data.shapes) {
    // Shape 1 points (no offset)
    const s0Points = data.shapes[0].points;
    
    // Shape 2 points (offset by Shape 1 width + gap)
    const s0Width = s0Points.reduce((max, p) => Math.max(max, p.x), 0);
    const s1Points = data.shapes[1].points.map(p => ({
        x: p.x + s0Width + gap,
        y: p.y
    }));

    allPoints = [...s0Points, ...s1Points];
  } else if (data.points) {
    // Standard single shape
    allPoints = data.points;
  }

  // Safety check
  if (allPoints.length === 0) {
      return <div className="p-4 text-gray-400 italic text-sm text-center">Visual unavailable</div>;
  }

  const minX = Math.min(...allPoints.map(p => p.x));
  const maxX = Math.max(...allPoints.map(p => p.x));
  const minY = Math.min(...allPoints.map(p => -p.y)); // SVG Y
  const maxY = Math.max(...allPoints.map(p => -p.y));

  const padding = 2; // Breathing room around shapes
  const width = maxX - minX + (padding * 2);
  const height = maxY - minY + (padding * 2);
  
  // Construct ViewBox
  const viewBox = `${minX - padding} ${minY - padding} ${width} ${height}`;

  return (
    <div className="w-full flex justify-center items-center p-6 bg-white rounded-xl shadow-sm border border-gray-100 my-4">
      <svg 
        viewBox={viewBox} 
        className="w-full max-w-[500px] h-auto overflow-visible"
        preserveAspectRatio="xMidYMid meet"
      >
        {/* Debug Grid/Axes if requested */}
        {data.showAxes && (
           <g stroke="#e5e7eb" strokeWidth="0.1">
             <line x1="-100" y1="0" x2="100" y2="0" stroke="#9ca3af" />
             <line x1="0" y1="-100" x2="0" y2="100" stroke="#9ca3af" />
           </g>
        )}

        {/* --- Render Logic for Similarity --- */}
        {data.type === 'similarity' && data.shapes && (
          <>
            {/* Shape 1 */}
            {renderShape(data.shapes[0].points, 0, 0, data.shapes[0].color, 's1')}
            
            {/* Shape 2 (Offset) */}
            {(() => {
              const s1Offset = data.shapes[0].points.reduce((max, p) => Math.max(max, p.x), 0) + gap;
              return renderShape(data.shapes[1].points, s1Offset, 0, data.shapes[1].color, 's2');
            })()}
            
            {/* Labels */}
            {renderLabels(data.labels, data.shapes)}
          </>
        )}

        {/* --- Render Logic for Standard Single Shape --- */}
        {(!data.type || data.type !== 'similarity') && (
           <g>
             {renderShape(data.points, 0, 0, '#3B82F6', 'single')}
             {/* If standard shapes have labels, render them here. Currently assumes custom labels array is for similarity */}
           </g>
        )}
      </svg>
    </div>
  );
};

// FILE END: src\components\visuals\GeometryVisual.jsx

// =======================================================
// FILE START: src\components\visuals\GraphCanvas.jsx
// =======================================================

import React, { useEffect, useRef } from 'react';

/**
 * GraphCanvas
 * Renders a coordinate system and linear functions (y = kx + m).
 * Supports drawing two lines for system of equations if needed.
 */
export const GraphCanvas = ({ visual }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !visual) return;

    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    // Config
    const scale = 20; // pixels per unit
    const centerX = w / 2;
    const centerY = h / 2;

    // Reset
    ctx.clearRect(0, 0, w, h);
    
    // Draw Grid
    ctx.strokeStyle = '#e5e7eb'; // light gray
    ctx.lineWidth = 1;
    
    // Vertical grid lines
    for (let x = 0; x <= w; x += scale) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
    }
    // Horizontal grid lines
    for (let y = 0; y <= h; y += scale) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    // Draw Axes
    ctx.strokeStyle = '#374151'; // dark gray
    ctx.lineWidth = 2;
    
    // X-Axis
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(w, centerY);
    ctx.stroke();

    // Y-Axis
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, h);
    ctx.stroke();

    // Helper: Plot a line given slope (k) and intercept (m)
    const drawLine = (k, m, color = '#2563eb') => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        // Calculate start and end points
        // x = -10 (far left in units), x = 10 (far right)
        // Canvas coords: cx = centerX + x*scale, cy = centerY - y*scale
        
        const x1 = -15;
        const y1 = k * x1 + m;
        
        const x2 = 15;
        const y2 = k * x2 + m;

        ctx.moveTo(centerX + x1 * scale, centerY - y1 * scale);
        ctx.lineTo(centerX + x2 * scale, centerY - y2 * scale);
        ctx.stroke();
    };

    // Draw Lines from visual data
    if (visual.lines) {
        visual.lines.forEach((line, index) => {
            // Alternate colors for systems
            const color = index === 0 ? '#3b82f6' : '#ef4444'; 
            drawLine(line.k, line.m, color);
        });
    }

  }, [visual]);

  return (
    <div className="flex justify-center my-4 overflow-hidden rounded-lg border border-gray-200">
      <canvas 
        ref={canvasRef} 
        width={300} 
        height={300} 
        className="bg-white"
      />
    </div>
  );
};

// FILE END: src\components\visuals\GraphCanvas.jsx

// =======================================================
// FILE START: src\components\visuals\VolumeVisualization.jsx
// =======================================================

import React, { useEffect, useRef } from 'react';

/**
 * VolumeVisualization
 * Renders 3D shapes (Cubes, Rectangular Prisms, Cylinders) on HTML5 Canvas.
 * * MIGRATION NOTE:
 * - Uses TARGET_SIZE = 160.
 * - Implements dynamic scaling: scale = TARGET_SIZE / Math.max(w, h, d).
 */
export const VolumeVisualization = ({ visual }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !visual) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    ctx.lineJoin = 'round';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#374151'; // gray-700
    ctx.fillStyle = '#E5E7EB';   // gray-200

    const centerX = width / 2;
    const centerY = height / 2;

    // SCALING LOGIC
    const TARGET_SIZE = 160;
    // Determine max dimension to scale appropriately
    const maxDim = Math.max(
      visual.width || 0,
      visual.height || 0,
      visual.depth || 0,
      (visual.radius || 0) * 2
    );
    
    // Avoid division by zero
    const scale = maxDim > 0 ? TARGET_SIZE / maxDim : 1;

    // Drawing functions
    const drawCubeOrPrism = () => {
        const w = (visual.width || 0) * scale;
        const h = (visual.height || 0) * scale;
        const d = (visual.depth || 0) * scale * 0.5; // Foreshortening depth
        
        const x = centerX - w / 2;
        const y = centerY - h / 2;

        // Front Face
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.stroke();
        ctx.fill();

        // Top Face
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + d, y - d);
        ctx.lineTo(x + w + d, y - d);
        ctx.lineTo(x + w, y);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#D1D5DB'; // slightly darker
        ctx.fill();

        // Side Face
        ctx.beginPath();
        ctx.moveTo(x + w, y);
        ctx.lineTo(x + w + d, y - d);
        ctx.lineTo(x + w + d, y + h - d);
        ctx.lineTo(x + w, y + h);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#9CA3AF'; // darkest
        ctx.fill();
        
        // Labels
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        if (visual.labels) {
            // Simple label placement approximation
            if (visual.labels.w) ctx.fillText(visual.labels.w, x + w/2, y + h + 15);
            if (visual.labels.h) ctx.fillText(visual.labels.h, x - 20, y + h/2);
            if (visual.labels.d) ctx.fillText(visual.labels.d, x + w + d/2, y - d/2);
        }
    };

    const drawCylinder = () => {
        const r = (visual.radius || 0) * scale;
        const h = (visual.height || 0) * scale;
        
        // Ellipse squash factor
        const squash = 0.3; 
        const ry = r * squash;

        const x = centerX;
        const yTop = centerY - h/2;
        const yBottom = centerY + h/2;

        // Top Ellipse
        ctx.beginPath();
        ctx.ellipse(x, yTop, r, ry, 0, 0, 2 * Math.PI);
        ctx.fillStyle = '#D1D5DB';
        ctx.fill();
        ctx.stroke();

        // Body
        ctx.beginPath();
        ctx.moveTo(x - r, yTop);
        ctx.lineTo(x - r, yBottom);
        // Bottom curve (half ellipse)
        ctx.ellipse(x, yBottom, r, ry, 0, 0, Math.PI, false);
        ctx.lineTo(x + r, yTop);
        ctx.fillStyle = '#E5E7EB';
        ctx.fill();
        
        // Re-stroke sides to cover fill overlap
        ctx.beginPath();
        ctx.moveTo(x - r, yTop);
        ctx.lineTo(x - r, yBottom);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + r, yTop);
        ctx.lineTo(x + r, yBottom);
        ctx.stroke();

        // Bottom full ellipse stroke (optional, but helps depth)
        ctx.beginPath();
        ctx.ellipse(x, yBottom, r, ry, 0, 0, Math.PI, false);
        ctx.stroke();
        
        // Labels
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        if (visual.labels) {
            if (visual.labels.r) ctx.fillText(visual.labels.r, x + r/2, yTop - 5);
            if (visual.labels.h) ctx.fillText(visual.labels.h, x + r + 10, centerY);
        }
    };

    // Render based on type
    if (visual.type === 'cube' || visual.type === 'cuboid') {
        drawCubeOrPrism();
    } else if (visual.type === 'cylinder') {
        drawCylinder();
    }

  }, [visual]);

  return (
    <div className="flex justify-center my-4">
      <canvas 
        ref={canvasRef} 
        width={300} 
        height={250} 
        className="bg-white rounded-lg"
      />
    </div>
  );
};

// FILE END: src\components\visuals\VolumeVisualization.jsx

// =======================================================
// FILE START: src\constants\curriculum.js
// =======================================================

export const CATEGORIES = {
    ARITHMETIC: {
        id: 'ARITHMETIC',
        label: { en: 'Number Theory', sv: 'Taluppfattning' },
        color: 'pink',
        generators: [
            { id: 'BasicArithmeticGen', api: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'NegativeNumbersGen', api: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'TenPowersGen', api: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } }
        ]
    },
    ALGEBRA: {
        id: 'ALGEBRA',
        label: { en: 'Algebra', sv: 'Algebra' },
        color: 'indigo',
        generators: [
            { id: 'ExpressionSimplificationGen', api: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'EquationGenerator', api: 'equation', label: { sv: "Ekvationer", en: "Equations" } }
        ]
    },
    GEOMETRY: {
        id: 'GEOMETRY',
        label: { en: 'Geometry', sv: 'Geometri' },
        color: 'emerald',
        generators: [
            { id: 'GeometryGenerator', api: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'ScaleGenerator', api: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'VolumeGenerator', api: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'SimilarityGenerator', api: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } }
        ]
    },
    FUNCTIONS: {
        id: 'FUNCTIONS',
        label: { en: 'Functions', sv: 'Samband' },
        color: 'purple',
        generators: [
            { id: 'LinearGraphGenerator', api: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    BasicArithmeticGen: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    NegativeNumbersGen: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    TenPowersGen: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    EquationGenerator: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    ExpressionSimplificationGen: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    GeometryGenerator: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        5: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    ScaleGenerator: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    VolumeGenerator: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
    },
    SimilarityGenerator: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    LinearGraphGenerator: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    }
};

export const getColorClasses = (color, type) => {
    const c = color || 'emerald';
    switch (type) {
        case 'bg-light': return `bg-${c}-50`;
        case 'bg-dark': return `bg-${c}-500`;
        case 'border': return `border-${c}-100`;
        case 'text': return `text-${c}-700`;
        case 'ring': return `ring-${c}-500`;
        case 'border-solid': return `border-${c}-500`;
        default: return '';
    }
};

// FILE END: src\constants\curriculum.js

// =======================================================
// FILE START: src\constants\localization.js
// =======================================================

export const UI_TEXT = {
    // --- Navigation & Headers ---
    dashboard_title: { en: "Choose a topic to practice", sv: "V√§lj omr√•de att √∂va p√•" },
    backBtn: { en: "Menu", sv: "Meny" },
    history: { en: "History", sv: "Historik" },
    noHistory: { en: "No answers yet.", sv: "Inga svar √§n." },
    level: { en: "Level", sv: "Niv√•" },
    streak: { en: "Streak", sv: "Svit" },
    
    // --- Practice View Actions ---
    btnHint: { en: "Hint", sv: "Ledtr√•d" },
    btnSolution: { en: "Show Solution", sv: "Visa l√∂sning" },
    btnSkip: { en: "Skip", sv: "Hoppa √∂ver" },
    submit: { en: "Submit", sv: "Svara" },
    placeholder: { en: "Enter your answer...", sv: "Skriv ditt svar..." },
    loading: { en: "Loading question...", sv: "Laddar fr√•ga..." },
    error: { en: "Error loading question", sv: "Kunde inte ladda fr√•gan." },
    
    // --- Feedback & Tags ---
    correct: { en: "Correct! Next...", sv: "R√§tt! N√§sta..." },
    incorrect: { en: "Not quite, try again", sv: "Inte riktigt, f√∂rs√∂k igen" },
    clueUsed: { en: "Clue", sv: "Hj√§lp" },
    hintsTitle: { en: "Hints", sv: "Ledtr√•dar" },
    
    // --- Stats / Tags ---
    stat_skip: { en: "Skipped", sv: "Hoppad" },
    stat_wrong: { en: "Wrong", sv: "Fel" },
    stat_help: { en: "Help", sv: "Hj√§lp" },
    stat_correct: { en: "Correct", sv: "R√§tt" },
    stat_total: { en: "Total", sv: "Totalt" },
    
    // --- Modals ---
    streak_modal_title: { en: "Awesome! üî•", sv: "Fantastiskt! üî•" },
    streak_modal_msg: { en: "You hit a streak of {streak}!", sv: "Du har n√•tt en streak p√• {streak}!" },
    total_modal_title: { en: "Great work! ‚úÖ", sv: "Snyggt jobbat! ‚úÖ" },
    total_modal_msg: { en: "You answered {total} questions correctly! Great job!", sv: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!" },
    btn_close_streak: { en: "Great job!", sv: "Bra jobbat!" },
    btn_close_total: { en: "Continue", sv: "Forts√§tt" },
    
    levelUpTitle: { en: "Great Job! üî•", sv: "Bra jobbat! üî•" },
    levelUpDesc: { en: "You've answered 8 in a row! Do you want to try the next level?", sv: "Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?" },
    levelUpYes: { en: "Next Level", sv: "N√§sta niv√•" },
    levelUpNo: { en: "Stay Here", sv: "Stanna p√• samma niv√•" },
    levelUpHint: { en: "Remember, you can always change difficulty manually at the top.", sv: "Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan." },

    // --- Stats Modal ---
    stats_title: { en: "Statistics", sv: "Statistik" },
    stats_times_up: { en: "Time's up!", sv: "Tiden √§r ute!" },
    stats_longest_streak: { en: "Longest streak", sv: "L√§ngsta streak" },
    stats_attempted: { en: "Problems attempted", sv: "F√∂rs√∂kta fr√•gor" },
    stats_correct_no_help: { en: "Correct (no help)", sv: "R√§tt (utan hj√§lp)" },
    stats_correct_help: { en: "Correct (with help)", sv: "R√§tt (med hj√§lp)" },
    stats_incorrect: { en: "Incorrect", sv: "Fel" },
    stats_skipped: { en: "Skipped", sv: "Hoppade √∂ver" },
    stats_close: { en: "Close", sv: "St√§ng" },
    level_breakdown: { en: "Level Breakdown", sv: "Niv√•detaljer" },

    // --- Footer & Misc ---
    mastery: { en: "Mastery", sv: "Bem√§strande" },
    donow: { en: "Do Now", sv: "Startuppgift" },
    donow_title: { en: "Do Now Activity", sv: "Uppstart (Do Now)" },
    donow_desc: { en: "Select up to 3 levels. System generates 6 questions total.", sv: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt." },
    donow_gen: { en: "Generate", sv: "Generera" },
    donow_show_all: { en: "Show All", sv: "Visa alla" },
    donow_hide_all: { en: "Hide All", sv: "D√∂lj alla" },
    lgr_btn: { en: "LGR22", sv: "LGR22" },
    aboutBtn: { en: "About", sv: "Om" },
    check: { en: "Check Answer", sv: "Kontrollera svar" },
    next: { en: "Next Question", sv: "N√§sta fr√•ga" },
    retry: { en: "Try Again", sv: "F√∂rs√∂k igen" }
};

// FILE END: src\constants\localization.js

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class BasicArithmeticGen {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let mode = level;

        // --- LEVEL 8: Mixed Integers (1, 2, 4, 7) ---
        if (level === 8) {
            mode = rng.pick([1, 2, 4, 7]);
        }
        
        // --- LEVEL 9: Mixed All (1-7) ---
        if (level === 9) {
            mode = rng.intBetween(1, 7);
        }

        let steps: Clue[] = [];
        let answer: number = 0;
        let latex = "";
        
        // Description defaults
        let description = { sv: "Ber√§kna", en: "Calculate" };

        // Helper for vertical layout
        const makeVertical = (top: number | string, bottom: number | string, op: string) => {
            return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
        };

        // --- LEVEL 1: Addition (1-3 digits) ---
        if (mode === 1) {
            const a = rng.intBetween(1, 999);
            const b = rng.intBetween(1, 999);
            answer = a + b;
            
            if (rng.intBetween(0, 1) === 1) {
                latex = makeVertical(a, b, '+');
                description = { sv: "St√§ll upp och addera.", en: "Set up and add." };
            } else {
                latex = `${a} + ${b} =`;
                description = { sv: "Addera.", en: "Add." };
            }

            steps = [
                { text: t(lang, TERMS.common.calculate), latex: `${a} + ${b} = ${formatColor(answer)}` }
            ];
        }

        // --- LEVEL 2: Subtraction (1-3 digits, a > b) ---
        else if (mode === 2) {
            const a = rng.intBetween(2, 999);
            const b = rng.intBetween(1, a - 1); 
            answer = a - b;

            if (rng.intBetween(0, 1) === 1) {
                latex = makeVertical(a, b, '-');
                description = { sv: "St√§ll upp och subtrahera.", en: "Set up and subtract." };
            } else {
                latex = `${a} - ${b} =`;
                description = { sv: "Subtrahera.", en: "Subtract." };
            }

            steps = [
                { text: t(lang, TERMS.common.calculate), latex: `${a} - ${b} = ${formatColor(answer)}` }
            ];
        }

        // --- LEVEL 3: Decimal (+/-) ---
        else if (mode === 3) {
            const isAdd = rng.intBetween(0, 1) === 1;
            
            const getDec = () => {
                const num = rng.intBetween(1, 4900); 
                return num / 100; 
            };

            let a = getDec();
            let b = getDec();
            
            if (isAdd) {
                while (Math.floor(a + b) > 50) { a = getDec(); b = getDec(); }
                answer = Math.round((a + b) * 100) / 100;
                latex = `${a} + ${b} =`;
            } else {
                if (b > a) [a, b] = [b, a];
                while (Math.floor(a - b) > 50) { a = getDec(); b = getDec(); if (b>a) [a,b]=[b,a];}
                answer = Math.round((a - b) * 100) / 100;
                latex = `${a} - ${b} =`;
            }

            description = { sv: "Ber√§kna decimaltalen.", en: "Calculate the decimals." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${latex} ${formatColor(answer)}` }];
        }

        // --- LEVEL 4: Multiplication Easy (<= 10) ---
        else if (mode === 4) {
            const a = rng.intBetween(1, 10);
            const b = rng.intBetween(1, 10);
            answer = a * b;

            if (rng.intBetween(0, 1) === 1) {
                const top = Math.max(a, b);
                const bot = Math.min(a, b);
                latex = makeVertical(top, bot, '\\times');
            } else {
                latex = `${a} \\cdot ${b} =`;
            }

            description = { sv: "Multiplicera.", en: "Multiply." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${a} \\cdot ${b} = ${formatColor(answer)}` }];
        }

        // --- LEVEL 5: Multiplication Medium (<= 20) ---
        else if (mode === 5) {
            const a = rng.intBetween(2, 20);
            const b = rng.intBetween(2, 20);
            answer = a * b;

            if (rng.intBetween(0, 1) === 1) {
                const top = Math.max(a, b);
                const bot = Math.min(a, b);
                latex = makeVertical(top, bot, '\\times');
            } else {
                latex = `${a} \\cdot ${b} =`;
            }

            description = { sv: "Multiplicera.", en: "Multiply." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${a} \\cdot ${b} = ${formatColor(answer)}` }];
        }

        // --- LEVEL 6: Multiplication Hard (Decimals) ---
        else if (mode === 6) {
            const type = rng.intBetween(1, 4);
            let a = 0, b = 0;

            if (type === 1) { // 0.x * 0.y
                a = rng.intBetween(1, 9) / 10;
                b = rng.intBetween(1, 9) / 10;
            } else if (type === 2) { // Int * 0.x
                a = rng.intBetween(2, 20);
                b = rng.intBetween(1, 9) / 10;
            } else if (type === 3) { // 0.x * 0.yz
                a = rng.intBetween(1, 9) / 10;
                b = rng.intBetween(1, 99) / 100;
            } else { // Int * 0.yz
                a = rng.intBetween(2, 20);
                b = rng.intBetween(1, 99) / 100;
            }

            answer = Math.round((a * b) * 1000) / 1000;
            latex = `${a} \\cdot ${b} =`;
            description = { sv: "Multiplicera decimaltalen.", en: "Multiply the decimals." };
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `${a} \\cdot ${b} = ${formatColor(answer)}` }];
        }

        // --- LEVEL 7: Division (Tables) ---
        else if (mode === 7) {
            const f1 = rng.intBetween(1, 10);
            const f2 = rng.intBetween(1, 10);
            const product = f1 * f2;
            
            const divisor = rng.intBetween(0, 1) === 1 ? f1 : f2;
            answer = product / divisor; 

            latex = `\\frac{${product}}{${divisor}} =`;
            description = { sv: "Dividera.", en: "Divide." };
            
            steps = [{ text: t(lang, TERMS.common.calculate), latex: `\\frac{${product}}{${divisor}} = ${formatColor(answer)}` }];
        }

        return {
            questionId: `arith-l${level}-${seed}`,
            renderData: {
                text_key: "arithmetic",
                description: description,
                latex: latex,
                answerType: "numeric",
                variables: {}
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language } from "../utils/i18n";

export class ExpressionSimplificationGen {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let mode = level;
        if (level === 6) mode = rng.intBetween(1, 5); // Mixed level

        let expr = "";
        let steps: Clue[] = [];
        let answer = "";
        let description: string | { sv: string, en: string } = { sv: "", en: "" };

        // --- LEVEL 1: Combine like terms (addition) ---
        // 3x + 5x
        if (mode === 1) {
            const v = rng.pick(['x', 'y', 'a', 'b']);
            const c1 = rng.intBetween(2, 9);
            const c2 = rng.intBetween(2, 9);
            
            expr = `${c1}${v} + ${c2}${v}`;
            answer = `${c1+c2}${v}`;
            
            steps.push({
                text: t(lang, { sv: "Addera koefficienterna (siffrorna framf√∂r variabeln).", en: "Add the coefficients (numbers in front of the variable)." }),
                latex: `${c1} + ${c2} = ${c1+c2}`
            });
            steps.push({
                text: t(lang, { sv: "Svaret beh√•ller variabeln.", en: "The answer keeps the variable." }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 2: Parentheses (Distribution) ---
        // 3(2x + 4)
        else if (mode === 2) {
            const v = 'x';
            const outer = rng.intBetween(2, 5);
            const innerC = rng.intBetween(2, 5);
            const innerK = rng.intBetween(1, 5);
            
            expr = `${outer}(${innerC}${v} + ${innerK})`;
            const resC = outer * innerC;
            const resK = outer * innerK;
            answer = `${resC}${v} + ${resK}`; // e.g. 6x + 12

            steps.push({
                text: t(lang, { sv: "Multiplicera in talet utanf√∂r parentesen med b√•da termerna inuti.", en: "Multiply the number outside the parentheses with both terms inside." }),
                latex: `${outer} \\cdot ${innerC}${v} + ${outer} \\cdot ${innerK}`
            });
            steps.push({
                text: t(lang, { sv: "Ber√§kna produkterna.", en: "Calculate the products." }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 3: Distribute & Combine ---
        // 2(3x + 1) + 4x
        else if (mode === 3) {
            const outer = rng.intBetween(2, 4);
            const inC = rng.intBetween(2, 4);
            const inK = rng.intBetween(1, 5);
            const extraX = rng.intBetween(2, 6);
            
            expr = `${outer}(${inC}x + ${inK}) + ${extraX}x`;
            
            const distX = outer * inC;
            const distK = outer * inK;
            const totalX = distX + extraX;
            
            answer = `${totalX}x + ${distK}`;
            
            steps.push({
                text: t(lang, { sv: "B√∂rja med att multiplicera in i parentesen.", en: "Start by distributing into the parentheses." }),
                latex: `${distX}x + ${distK} + ${extraX}x`
            });
            steps.push({
                text: t(lang, { sv: "L√§gg ihop x-termerna.", en: "Combine the x-terms." }),
                latex: `${distX}x + ${extraX}x = ${totalX}x`
            });
            steps.push({
                text: t(lang, { sv: "S√§tt ihop allt.", en: "Put it all together." }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 4: Subtracting Parentheses ---
        // 5x - (2x + 3)
        else if (mode === 4) {
            const startX = rng.intBetween(5, 10);
            const subX = rng.intBetween(1, startX - 1);
            const subK = rng.intBetween(1, 5);
            
            expr = `${startX}x - (${subX}x + ${subK})`;
            const resX = startX - subX;
            const resK = -subK; // Minus becomes negative
            
            answer = `${resX}x - ${Math.abs(resK)}`;
            
            steps.push({
                text: t(lang, { sv: "Minus framf√∂r en parentes √§ndrar tecken p√• allt inuti n√§r vi tar bort parentesen.", en: "A minus in front of parentheses changes the sign of everything inside when removed." }),
                latex: `${startX}x - ${subX}x - ${subK}`
            });
            steps.push({
                text: t(lang, { sv: "F√∂renkla x-termerna.", en: "Simplify the x-terms." }),
                latex: `${startX}x - ${subX}x = ${resX}x`
            });
            steps.push({
                text: t(lang, { sv: "Resultat", en: "Result" }),
                latex: formatColor(answer)
            });
        }

        // --- LEVEL 5: Word Problems (Text) ---
        else if (mode === 5) {
            
            // Constants for the logic: Ax + Cx +/- B
            const A = rng.intBetween(2, 6);  // Variable group 1
            const B = rng.intBetween(5, 30); // Constant
            const C = rng.intBetween(2, 6);  // Variable group 2
            
            const totalX = A + C;

            // Define Scenarios with Subtraction (Loss/Cost) and Addition (Gain/Total)
            const scenarios = [
                // --- ADDITION SCENARIOS (ax + b) ---
                {
                    type: 'add',
                    sv: `Du har ${A} p√•sar med godis (x) och k√∂per ${C} p√•sar till. Du har ocks√• ${B} l√∂sa godisar.`,
                    en: `You have ${A} bags of candy (x) and buy ${C} more bags. You also have ${B} loose candies.`,
                    unitSv: "godisar", unitEn: "candies", varSv: "p√•sar", varEn: "bags",
                    explSv: "l√∂sa godisar l√§ggs till (+)", explEn: "loose candies are added (+)"
                },
                {
                    type: 'add',
                    sv: `Du sparar x kr i ${A} veckor och sedan i ${C} veckor till. Du f√•r ocks√• ${B} kr i present.`,
                    en: `You save x kr for ${A} weeks and then for ${C} more weeks. You also get ${B} kr as a gift.`,
                    unitSv: "kr", unitEn: "kr", varSv: "veckor", varEn: "weeks",
                    explSv: "presenten l√§ggs till sparandet (+)", explEn: "the gift adds to the savings (+)"
                },
                {
                    type: 'add',
                    sv: `Du bygger ett staket med ${A} sektioner av l√§ngden x och ${C} sektioner till. Du har ocks√• en grind p√• ${B} meter.`,
                    en: `You build a fence with ${A} sections of length x and ${C} more sections. You also have a gate of ${B} meters.`,
                    unitSv: "meter", unitEn: "meters", varSv: "sektioner", varEn: "sections",
                    explSv: "grinden l√§gger till l√§ngd (+)", explEn: "the gate adds length (+)"
                },
                // --- SUBTRACTION SCENARIOS (ax - b) ---
                {
                    type: 'sub',
                    sv: `Du k√∂per ${A} tr√∂jor och ${C} byxor som alla kostar x kr styck. Du har en rabattkupong p√• ${B} kr.`,
                    en: `You buy ${A} shirts and ${C} pants that all cost x kr each. You have a discount coupon for ${B} kr.`,
                    unitSv: "kr", unitEn: "kr", varSv: "plagg", varEn: "items",
                    explSv: "en rabatt dras bort fr√•n priset (-)", explEn: "a discount is subtracted from the price (-)"
                },
                {
                    type: 'sub',
                    sv: `Du plockar ${A} korgar med jordgubbar och din kompis plockar ${C} korgar (x liter per korg). Ni r√•kar spilla ut ${B} liter.`,
                    en: `You pick ${A} baskets of strawberries and your friend picks ${C} baskets (x liters per basket). You accidentally spill ${B} liters.`,
                    unitSv: "liter", unitEn: "liters", varSv: "korgar", varEn: "baskets",
                    explSv: "det utspillda dras bort (-)", explEn: "the spilled amount is subtracted (-)"
                },
                {
                    type: 'sub',
                    sv: `Du har sparat x kr i veckan i ${A} veckor plus ${C} veckor till. Sedan k√∂per du en sak f√∂r ${B} kr.`,
                    en: `You saved x kr a week for ${A} weeks plus ${C} more weeks. Then you buy an item for ${B} kr.`,
                    unitSv: "kr", unitEn: "kr", varSv: "veckor", varEn: "weeks",
                    explSv: "kostnaden dras bort fr√•n sparandet (-)", explEn: "the cost is subtracted from savings (-)"
                },
                {
                    type: 'sub',
                    sv: `En snickare har ${A} l√•nga plankor och ${C} korta plankor som alla √§r x meter l√•nga. Han s√•gar bort totalt ${B} meter spillvirke.`,
                    en: `A carpenter has ${A} long boards and ${C} short boards that are all x meters long. He cuts off a total of ${B} meters waste.`,
                    unitSv: "meter", unitEn: "meters", varSv: "plankor", varEn: "boards",
                    explSv: "spillvirket dras bort (-)", explEn: "the waste is subtracted (-)"
                },
                {
                    type: 'sub',
                    sv: `Du prenumererar p√• en tj√§nst (x kr/m√•n) i ${A} m√•nader √•t dig sj√§lv och ${C} m√•nader √•t en v√§n. Du f√•r ${B} kr i √•terb√§ring.`,
                    en: `You subscribe to a service (x kr/mo) for ${A} months for yourself and ${C} months for a friend. You get ${B} kr cash back.`,
                    unitSv: "kr", unitEn: "kr", varSv: "m√•nader", varEn: "months",
                    explSv: "√•terb√§ringen minskar kostnaden (-)", explEn: "cash back reduces the cost (-)"
                }
            ];

            const s = rng.pick(scenarios);
            const isSub = s.type === 'sub';
            const operator = isSub ? "-" : "+";
            
            // Construct Answer: e.g. "8x - 20"
            answer = `${totalX}x ${operator} ${B}`;

            // Adjust the final question text based on type
            const totalTextSv = isSub ? "det som √•terst√•r/slutsumman" : "totalen";
            const totalTextEn = isSub ? "what remains/net total" : "the total";
            
            description = {
                sv: `${s.sv} Skriv ett uttryck f√∂r ${totalTextSv} och f√∂renkla det.`,
                en: `${s.en} Write an expression for ${totalTextEn} and simplify it.`
            };
            
            // Pedagogical Steps (Explaining how to get each term)
            steps = [
                { 
                    text: t(lang, { 
                        sv: `Steg 1: Hitta x-termerna. Du har ${A} ${s.varSv} och ${C} ${s.varSv}. Det blir ${A}x + ${C}x.`, 
                        en: `Step 1: Find the x-terms. You have ${A} ${s.varEn} and ${C} ${s.varEn}. That makes ${A}x + ${C}x.` 
                    }), 
                    latex: `${A}x + ${C}x` 
                },
                { 
                    text: t(lang, { 
                        sv: `Steg 2: Hantera konstanten (${B} ${s.unitSv}). Eftersom ${s.explSv}, skriver vi ${operator} ${B}.`, 
                        en: `Step 2: Handle the constant (${B} ${s.unitEn}). Since ${s.explEn}, we write ${operator} ${B}.` 
                    }), 
                    latex: isSub ? `- ${B}` : `+ ${B}`
                },
                { 
                    text: t(lang, { 
                        sv: `Steg 3: S√§tt ihop och f√∂renkla. ${A}x plus ${C}x blir ${totalX}x.`, 
                        en: `Step 3: Combine and simplify. ${A}x plus ${C}x becomes ${totalX}x.` 
                    }), 
                    latex: `${totalX}x ${operator} ${B} = ${formatColor(answer)}` 
                }
            ];
            
            return {
                questionId: `simp-l${level}-${seed}`,
                renderData: {
                    text_key: "simplify_word",
                    description: description,
                    latex: "", 
                    answerType: "text",
                    variables: {}
                },
                serverData: {
                    answer: answer,
                    solutionSteps: steps
                }
            };
        }

        return {
            questionId: `simp-l${level}-${seed}`,
            renderData: {
                text_key: "simplify",
                description: description,
                latex: expr,
                answerType: "text",
                variables: {}
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language } from "../utils/i18n";

export class GeometryGenerator {
  public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
    const rng = new Random(seed);
    const s = (val: number) => Math.round(val * multiplier);
    const piApprox = 3.14;

    const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

    let mode = level;
    if (level >= 6) mode = rng.intBetween(3, 5);

    let steps: Clue[] = [];
    let qData: { text_key: string, description: string | { sv: string, en: string }, latex: string, answer: number } = { text_key: "", description: "", latex: "", answer: 0 };
    let geometry: any = undefined;

    // --- LEVEL 1: Perimeter (Rectangles) ---
    if (mode === 1) {
        const w = rng.intBetween(s(3), s(12));
        const h = rng.intBetween(s(2), s(8));
        qData.answer = 2 * (w + h);
        qData.description = { sv: "Ber√§kna omkretsen.", en: "Calculate the perimeter." };
        geometry = { type: 'rectangle', width: w, height: h, labels: { width: w, height: h } };
        
        steps = [
            { 
                text: t(lang, { 
                    sv: "Omkretsen √§r str√§ckan runt hela figuren. En rektangel har tv√• baser och tv√• h√∂jder.", 
                    en: "Perimeter is the distance around the shape. A rectangle has two bases and two heights." 
                }), 
                latex: "" 
            },
            { 
                text: t(lang, { 
                    sv: "Addera alla fyra sidor.", 
                    en: "Add all four sides together." 
                }), 
                latex: `${w} + ${w} + ${h} + ${h} = ${formatColor(qData.answer)}` 
            }
        ];
    }

    // --- LEVEL 2: Area (Rectangles) ---
    else if (mode === 2) {
        const w = rng.intBetween(s(3), s(12));
        const h = rng.intBetween(s(2), s(8));
        qData.answer = w * h;
        qData.description = { sv: "Ber√§kna arean.", en: "Calculate the area." };
        geometry = { type: 'rectangle', width: w, height: h, labels: { width: w, height: h } };
        
        steps = [
            { 
                text: t(lang, { 
                    sv: "Arean ber√§ttar hur stor yta figuren t√§cker. F√∂r en rektangel multiplicerar vi basen med h√∂jden.", 
                    en: "Area tells us how much surface the shape covers. For a rectangle, we multiply the base by the height." 
                }), 
                latex: "Area = b \\cdot h" 
            },
            { 
                text: t(lang, { 
                    sv: "S√§tt in v√§rdena och r√§kna ut.", 
                    en: "Insert the values and calculate." 
                }), 
                latex: `${w} \\cdot ${h} = ${formatColor(qData.answer)}` 
            }
        ];
    }

    // --- LEVEL 3: Area (Triangles) ---
    else if (mode === 3) {
        const b = rng.intBetween(s(4), s(14));
        const h = rng.intBetween(s(3), s(10));
        qData.answer = (b * h) / 2;
        qData.description = { sv: "Ber√§kna arean.", en: "Calculate the area." };
        
        const subtype = rng.pick(['right', 'isosceles', 'scalene']);
        geometry = { type: 'triangle', subtype: subtype, width: b, height: h, labels: { base: b, height: h } };
        
        steps = [
            { 
                text: t(lang, { 
                    sv: "En triangel √§r alltid h√§lften av en rektangel med samma bas och h√∂jd.", 
                    en: "A triangle is always half of a rectangle with the same base and height." 
                }), 
                latex: "Area = \\frac{b \\cdot h}{2}" 
            },
            { 
                text: t(lang, { 
                    sv: "Multiplicera basen med h√∂jden och dela sedan med 2.", 
                    en: "Multiply the base by the height, then divide by 2." 
                }), 
                latex: `\\frac{${b} \\cdot ${h}}{2} = \\frac{${b*h}}{2} = ${formatColor(qData.answer)}` 
            }
        ];
    }

    // --- LEVEL 4: Circles (Area & Circumference) ---
    else if (mode === 4) {
        const isArea = rng.intBetween(0, 1) === 1;
        const showDiameter = rng.intBetween(0, 1) === 1; // 50% chance to show diameter
        const r = rng.intBetween(s(3), s(10));
        const d = r * 2;
        
        if (isArea) {
            const area = Math.PI * r * r;
            qData.answer = Math.round(area * 10) / 10;
            qData.description = { sv: "Ber√§kna arean (avrunda till 1 decimal).", en: "Calculate the area (round to 1 decimal)." };
            
            if (showDiameter) {
                // Diameter given, ask for Area
                steps = [
                    { 
                        text: t(lang, { 
                            sv: "F√∂r att r√§kna ut arean beh√∂ver vi radien (r). Radien √§r h√§lften av diametern (d).", 
                            en: "To calculate the area we need the radius (r). The radius is half of the diameter (d)." 
                        }), 
                        latex: `r = \\frac{d}{2} = \\frac{${d}}{2} = ${r}` 
                    },
                    { 
                        text: t(lang, { sv: "Anv√§nd formeln f√∂r cirkelns area.", en: "Use the formula for the area of a circle." }), 
                        latex: "Area = \\pi \\cdot r^2" 
                    },
                    { 
                        text: t(lang, { sv: "S√§tt in radien och r√§kna ut.", en: "Insert the radius and calculate." }), 
                        latex: `3.14 \\cdot ${r}^2 = 3.14 \\cdot ${r*r} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Radius given, ask for Area
                steps = [
                    { 
                        text: t(lang, { sv: "F√∂r att r√§kna ut ytan (arean) p√• en cirkel anv√§nder vi radien (r) och talet Pi (œÄ ‚âà 3.14).", en: "To find the surface (area) of a circle, we use the radius (r) and Pi (œÄ ‚âà 3.14)." }), 
                        latex: "Area = \\pi \\cdot r^2" 
                    },
                    { 
                        text: t(lang, { sv: "Radien i kvadrat betyder radien g√•nger sig sj√§lv.", en: "Radius squared means radius times itself." }), 
                        latex: `r^2 = ${r} \\cdot ${r} = ${r*r}` 
                    },
                    { 
                        text: t(lang, { sv: "Multiplicera med Pi.", en: "Multiply by Pi." }), 
                        latex: `3.14 \\cdot ${r*r} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
        } else {
            // Circumference
            const circ = 2 * Math.PI * r;
            qData.answer = Math.round(circ * 10) / 10;
            qData.description = { sv: "Ber√§kna omkretsen (avrunda till 1 decimal).", en: "Calculate the circumference (round to 1 decimal)." };
            
            if (showDiameter) {
                // Diameter given, ask for Circumference
                steps = [
                    { 
                        text: t(lang, { sv: "Omkretsen √§r str√§ckan runt cirkeln. Med diametern (d) √§r formeln enkel.", en: "Circumference is the distance around the circle. With diameter (d), the formula is simple." }), 
                        latex: "Omkrets = \\pi \\cdot d" 
                    },
                    { 
                        text: t(lang, { sv: "Multiplicera diametern med Pi (‚âà 3.14).", en: "Multiply the diameter by Pi (‚âà 3.14)." }), 
                        latex: `3.14 \\cdot ${d} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Radius given, ask for Circumference
                steps = [
                    { 
                        text: t(lang, { sv: "Omkretsen √§r str√§ckan runt cirkeln. Vi kan anv√§nda diametern (som √§r 2 g√•nger radien) eller formeln med radien.", en: "Circumference is the distance around the circle. We can use the diameter (2 times radius) or the radius formula." }), 
                        latex: "Omkrets = 2 \\cdot \\pi \\cdot r" 
                    },
                    { 
                        text: t(lang, { sv: "R√§kna ut diametern f√∂rst (dubbla radien).", en: "Calculate the diameter first (double the radius)." }), 
                        latex: `d = 2 \\cdot ${r} = ${2*r}` 
                    },
                    { 
                        text: t(lang, { sv: "Multiplicera diametern med Pi (‚âà 3.14).", en: "Multiply the diameter by Pi (‚âà 3.14)." }), 
                        latex: `${2*r} \\cdot 3.14 \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
        }
        
        geometry = { type: 'circle', radius: r, value: showDiameter ? d : r, show: showDiameter ? 'diameter' : 'radius' };
    }

    // --- LEVEL 5: Composite Shapes ---
    else {
        // Example: Rectangle + Semicircle (Portal) or Triangle on Rectangle (House)
        const type = rng.pick(['portal', 'house']);
        const width = rng.intBetween(s(4), s(12)); // Base
        const height = rng.intBetween(s(4), s(10)); // Side height
        
        let shapeNameSv = "", shapeNameEn = "";
        
        const isArea = rng.intBetween(0, 1) === 1;

        if (type === 'house') {
            const hRoof = rng.intBetween(s(3), s(8));
            shapeNameSv = "huset"; shapeNameEn = "the house";
            
            if (isArea) {
                const areaRect = width * height;
                const areaTri = (width * hRoof) / 2;
                qData.answer = areaRect + areaTri;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Dela upp figuren i tv√• delar: en rektangel i botten och en triangel p√• toppen.", en: "Split the shape into two parts: a rectangle at the bottom and a triangle on top." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "R√§kna ut arean f√∂r rektangeln.", en: "Calculate the area of the rectangle." }), 
                        latex: `${width} \\cdot ${height} = ${areaRect}` 
                    },
                    { 
                        text: t(lang, { sv: "R√§kna ut arean f√∂r taket (triangeln).", en: "Calculate the area of the roof (triangle)." }), 
                        latex: `\\frac{${width} \\cdot ${hRoof}}{2} = ${areaTri}` 
                    },
                    { 
                        text: t(lang, { sv: "Addera delarna f√∂r att f√• totalen.", en: "Add the parts to get the total." }), 
                        latex: `${areaRect} + ${areaTri} = ${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Perimeter of house (Base + 2 sides + 2 roof slopes)
                // Pythagoras for roof slope
                const halfBase = width / 2;
                const slope = Math.sqrt(halfBase*halfBase + hRoof*hRoof);
                const total = width + 2*height + 2*slope;
                qData.answer = Math.round(total * 10) / 10;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Omkretsen √§r v√§gen runt huset (golvet + v√§ggarna + taket).", en: "The perimeter is the path around the house (floor + walls + roof)." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "F√∂r att hitta takets l√§ngd anv√§nder vi Pythagoras sats p√• halva taket.", en: "To find the roof length, we use Pythagoras theorem on half the roof." }), 
                        latex: `\\sqrt{${halfBase}^2 + ${hRoof}^2} \\approx ${Math.round(slope*10)/10}` 
                    },
                    { 
                        text: t(lang, { sv: "Addera alla sidor runt om.", en: "Add all sides around the outside." }), 
                        latex: `${width} + ${height} + ${height} + ${Math.round(slope*10)/10} + ${Math.round(slope*10)/10} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
            geometry = { type: 'composite', subtype: 'house', labels: { w: width, h: height, h_roof: hRoof } };
        } 
        else { // Portal
            shapeNameSv = "portalen"; shapeNameEn = "the portal";
            // Rectangle with semicircle on top
            if (isArea) {
                const areaRect = width * height;
                const r = width / 2;
                const areaSemi = (Math.PI * r * r) / 2;
                qData.answer = Math.round((areaRect + areaSemi) * 10) / 10;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Dela upp figuren: en rektangel och en halvcirkel.", en: "Split the shape: a rectangle and a semicircle." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "Rektangelns area:", en: "Rectangle area:" }), 
                        latex: `${width} \\cdot ${height} = ${areaRect}` 
                    },
                    { 
                        text: t(lang, { sv: "Halvcirkelns area (radien √§r h√§lften av bredden).", en: "Semicircle area (radius is half the width)." }), 
                        latex: `\\frac{\\pi \\cdot ${r}^2}{2} \\approx ${Math.round(areaSemi*10)/10}` 
                    },
                    { 
                        text: t(lang, { sv: "Addera dem.", en: "Add them together." }), 
                        latex: `${formatColor(qData.answer)}` 
                    }
                ];
            } else {
                // Perimeter: Base + 2 sides + Arc (half circumference)
                const arc = (Math.PI * width) / 2;
                qData.answer = Math.round((width + 2 * height + arc) * 10) / 10;
                
                steps = [
                    { 
                        text: t(lang, { sv: "Vi ska g√• runt figuren: botten + tv√• sidor + den b√•gformade toppen.", en: "We walk around the shape: bottom + two sides + the curved top." }), 
                        latex: "" 
                    },
                    { 
                        text: t(lang, { sv: "Toppen √§r en halvcirkel. R√§kna ut omkretsen f√∂r en hel cirkel och dela med 2.", en: "The top is a semicircle. Calculate circumference for a full circle and divide by 2." }), 
                        latex: `\\frac{\\pi \\cdot ${width}}{2} \\approx ${Math.round(arc*10)/10}` 
                    },
                    { 
                        text: t(lang, { sv: "L√§gg ihop alla delar.", en: "Sum all the parts." }), 
                        latex: `${width} + ${height} + ${height} + ${Math.round(arc*10)/10} \\approx ${formatColor(qData.answer)}` 
                    }
                ];
            }
            // FIXED: Added 'h' to labels so frontend can draw vertical sides
            geometry = { type: 'composite', subtype: 'portal', w: width, labels: { w: width, h: height } };
        }
        
        qData.text_key = isArea ? "calc_area" : "calc_perim";
        qData.description = {
            sv: `Ber√§kna ${isArea ? 'arean' : 'omkretsen'} av ${shapeNameSv}.`,
            en: `Calculate the ${isArea ? 'area' : 'perimeter'} of ${shapeNameEn}.`
        };
            
        if (!geometry) geometry = { type: 'composite', subtype: 'ice_cream', width: width, height: height, labels: { top: width, side: height } };
    }

    return {
        questionId: `geo-l${level}-${seed}`,
        renderData: {
            text_key: qData.text_key,
            description: qData.description,
            latex: "",
            answerType: "numeric",
            geometry: geometry,
            variables: {}
        },
        serverData: {
            answer: qData.answer,
            solutionSteps: steps
        }
    };
  }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class LinearEquationGenerator {
  public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
    const rng = new Random(seed);
    const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

    let mode = level;
    // Level 7 is now the Mixed Level for drills
    if (level >= 7) mode = rng.intBetween(1, 4); 

    const s = (val: number) => Math.round(val * multiplier);
    let eq = "", answer = 0, steps: Clue[] = [];
    let description = { sv: "L√∂s ekvationen", en: "Solve the equation" };

    // --- LEVEL 1: One-Step Equations ---
    if (mode === 1) {
        const type = rng.intBetween(1, 4); 
        
        if (type === 1) { // x / k = res
            const k = rng.intBetween(s(2), s(9));
            const res = rng.intBetween(s(2), s(10)); 
            answer = res * k;
            eq = `\\frac{x}{${k}} = ${res}`;
            
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.multiply(k)), latex: `x = ${res} \\cdot ${k} = ${formatColor(answer)}` }
            ];
        } else if (type === 2) { // k * x = res
            const k = rng.intBetween(s(2), s(9));
            const x = rng.intBetween(s(2), s(10));
            answer = x;
            const res = k * x;
            eq = `${k}x = ${res}`;
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.divide(k)), latex: `x = \\frac{${res}}{${k}} = ${formatColor(answer)}` }
            ];
        } else if (type === 3) { // x + k = res
            const k = rng.intBetween(s(1), s(20));
            const x = rng.intBetween(s(1), s(20));
            answer = x;
            eq = `x + ${k} = ${x + k}`;
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.subtract(k)), latex: `x = ${x+k} - ${k} = ${formatColor(answer)}` }
            ];
        } else { // x - k = res
            const k = rng.intBetween(s(1), s(20));
            const x = rng.intBetween(s(1), s(20));
            answer = x;
            eq = `x - ${k} = ${x - k}`;
            steps = [
                { text: t(lang, TERMS.algebra.intro(eq)), latex: eq },
                { text: t(lang, TERMS.algebra.add(k)), latex: `x = ${x-k} + ${k} = ${formatColor(answer)}` }
            ];
        }
    }

    // --- LEVEL 2: Two-Step Equations ---
    // Variations: ax+b=c, ax-b=c, x/a+b=c, x/a-b=c
    else if (mode === 2) {
        const type = rng.intBetween(1, 4);
        const x = rng.intBetween(2, 12); // Solution

        if (type === 1) { // ax + b = c
            const a = rng.intBetween(2, 9);
            const b = rng.intBetween(1, 15);
            const c = a * x + b;
            answer = x;
            eq = `${a}x + ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a}x = ${c} - ${b} = ${c-b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = \\frac{${c-b}}{${a}} = ${formatColor(answer)}` }
            ];
        } 
        else if (type === 2) { // ax - b = c
            const a = rng.intBetween(2, 9);
            const b = rng.intBetween(1, 15);
            const c = a * x - b;
            answer = x;
            eq = `${a}x - ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.add(b)), latex: `${a}x = ${c} + ${b} = ${c+b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = \\frac{${c+b}}{${a}} = ${formatColor(answer)}` }
            ];
        }
        else if (type === 3) { // x/a + b = c
            const a = rng.intBetween(2, 8);
            const b = rng.intBetween(1, 10);
            const realX = x * a; 
            answer = realX;
            const c = x + b;
            eq = `\\frac{x}{${a}} + ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.subtract(b)), latex: `\\frac{x}{${a}} = ${c} - ${b} = ${c-b}` },
                { text: t(lang, TERMS.algebra.multiply(a)), latex: `x = ${c-b} \\cdot ${a} = ${formatColor(answer)}` }
            ];
        }
        else { // x/a - b = c
            const a = rng.intBetween(2, 8);
            const b = rng.intBetween(1, 10);
            const realX = x * a;
            answer = realX;
            const c = x - b; 
            eq = `\\frac{x}{${a}} - ${b} = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.add(b)), latex: `\\frac{x}{${a}} = ${c} + ${b} = ${c+b}` },
                { text: t(lang, TERMS.algebra.multiply(a)), latex: `x = ${c+b} \\cdot ${a} = ${formatColor(answer)}` }
            ];
        }
    }

    // --- LEVEL 3: Parentheses (Moved from Level 4) ---
    // Variations: a(x+b)=c, a(x-b)=c, a(bx-c)=d, a(bx+c)=d
    else if (mode === 3) {
        const type = rng.intBetween(1, 4);
        const a = rng.intBetween(2, 6);
        
        if (type === 1) { // a(x + b) = c
            const x = rng.intBetween(1, 10);
            const b = rng.intBetween(1, 9);
            const c = a * (x + b);
            answer = x;
            eq = `${a}(x + ${b}) = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a}x + ${a*b} = ${c}` },
                { text: t(lang, TERMS.algebra.subtract(a*b)), latex: `${a}x = ${c - a*b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 2) { // a(x - b) = c
            const x = rng.intBetween(5, 15);
            const b = rng.intBetween(1, x - 1); 
            const c = a * (x - b);
            answer = x;
            eq = `${a}(x - ${b}) = ${c}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a}x - ${a*b} = ${c}` },
                { text: t(lang, TERMS.algebra.add(a*b)), latex: `${a}x = ${c + a*b}` },
                { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 3) { // a(bx - c) = d
            const bVar = rng.intBetween(2, 5);
            const x = rng.intBetween(2, 8);
            const cVar = rng.intBetween(1, bVar * x - 1);
            const d = a * (bVar * x - cVar);
            answer = x;
            eq = `${a}(${bVar}x - ${cVar}) = ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a*bVar}x - ${a*cVar} = ${d}` },
                { text: t(lang, TERMS.algebra.add(a*cVar)), latex: `${a*bVar}x = ${d + a*cVar}` },
                { text: t(lang, TERMS.algebra.divide(a*bVar)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else { // a(bx + c) = d
            const bVar = rng.intBetween(2, 5);
            const x = rng.intBetween(1, 8);
            const cVar = rng.intBetween(1, 9);
            const d = a * (bVar * x + cVar);
            answer = x;
            eq = `${a}(${bVar}x + ${cVar}) = ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.distribute(a)), latex: `${a*bVar}x + ${a*cVar} = ${d}` },
                { text: t(lang, TERMS.algebra.subtract(a*cVar)), latex: `${a*bVar}x = ${d - a*cVar}` },
                { text: t(lang, TERMS.algebra.divide(a*bVar)), latex: `x = ${formatColor(answer)}` }
            ];
        }
    }

    // --- LEVEL 4: X on Both Sides (Moved from Level 3) ---
    // Constraints: x > 0.
    // Variations: ax+b=cx+d, ax-b=cx+d, ax+b=cx-d, ax-b=cx-d
    else if (mode === 4) {
        const type = rng.intBetween(1, 4);
        const x = rng.intBetween(1, 10); // x > 0 constraint
        let a = rng.intBetween(3, 9);
        let c = rng.intBetween(2, a - 1); // Ensure a > c to keep x positive
        
        if (a === c) a++;
        
        if (type === 1) { // ax + b = cx + d
            const b = rng.intBetween(1, 15);
            const d = a*x + b - c*x;
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x + ${b} = ${c}x + ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${c}x`)), latex: `${a-c}x + ${b} = ${d}` },
                { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a-c}x = ${d-b}` },
                { text: t(lang, TERMS.algebra.divide(a-c)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 2) { // ax - b = cx + d
            const b = rng.intBetween(1, 15);
            const d = a*x - b - c*x;
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x - ${b} = ${c}x + ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${c}x`)), latex: `${a-c}x - ${b} = ${d}` },
                { text: t(lang, TERMS.algebra.add(b)), latex: `${a-c}x = ${d+b}` },
                { text: t(lang, TERMS.algebra.divide(a-c)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else if (type === 3) { // ax + b = cx - d
            const temp = a; a = c; c = temp; // Swap so c > a (negative x term on left, or we solve differently)
            // Wait, if we want a positive answer with form ax + b = cx - d, then cx - d > b.
            // Also ax < cx.
            
            const b = rng.intBetween(1, 15);
            const d = c*x - a*x - b;
            
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x + ${b} = ${c}x - ${d}`;
            // Move ax to right: b + d = (c-a)x
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${a}x`)), latex: `${b} = ${c-a}x - ${d}` },
                { text: t(lang, TERMS.algebra.add(d)), latex: `${b+d} = ${c-a}x` },
                { text: t(lang, TERMS.algebra.divide(c-a)), latex: `x = ${formatColor(answer)}` }
            ];
        }
        else { // ax - b = cx - d
            if (a < c) { const t = a; a = c; c = t; }
            
            const b = rng.intBetween(5, 20);
            const d = b - (a*x - c*x);
            
            if (d <= 0) return LinearEquationGenerator.generate(level, seed + "retry", lang, multiplier);

            answer = x;
            eq = `${a}x - ${b} = ${c}x - ${d}`;
            steps = [
                { text: t(lang, TERMS.algebra.sub_var(`${c}x`)), latex: `${a-c}x - ${b} = -${d}` },
                { text: t(lang, TERMS.algebra.add(b)), latex: `${a-c}x = ${b} - ${d} = ${b-d}` },
                { text: t(lang, TERMS.algebra.divide(a-c)), latex: `x = ${formatColor(answer)}` }
            ];
        }
    }

    return {
        questionId: `leq-l${level}-${seed}`,
        renderData: {
            text_key: "solve_eq",
            description: description,
            latex: eq,
            answerType: "numeric",
            variables: {}
        },
        serverData: {
            answer: answer,
            solutionSteps: steps
        }
    };
  }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";
import { TextEngine, ContextKey, CONTEXTS } from "../utils/textEngine";

interface ProblemScenario {
    id: string;
    type: 'A' | 'B' | 'C' | 'D';
    logic: (rng: Random) => MathData;
    templates: { sv: string, en: string }[];
    context: ContextKey;
}

interface MathData {
    vars: Record<string, number>; // Constants a, b, c
    solution: number; // x
    equation: string;
    stepsSolve: (lang: Language, formatColor: (v:any)=>string) => Clue[];
    stepsWrite: (lang: Language, formatColor: (v:any)=>string) => Clue[];
}

export class LinearEquationProblemGen {
    
    private static getScenarios(): ProblemScenario[] {
        return [
            // --- TYPE A: ax + b = c (Shopping/Taxi) ---
            {
                id: 'shopping_bag',
                type: 'A',
                context: 'shopping',
                templates: [ TERMS.problem_solving.a_buy ],
                logic: (rng) => {
                    const x = rng.intBetween(3, 15); 
                    const a = rng.intBetween(5, 25); 
                    const b = rng.pick([2, 5, 10]); 
                    const c = a * x + b;
                    
                    // x IS NOT PASSED in vars to prevent auto-replacement in text
                    return {
                        vars: { a, b, c }, 
                        solution: x,
                        equation: `${a}x + ${b} = ${c}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.clue_var), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_rate_val), latex: `\\text{Pris} \\cdot \\text{Antal} = ${a} \\cdot x = ${a}x` },
                            { text: t(lang, TERMS.problem_solving.expl_fixed_val), latex: `+ ${b}` },
                            { text: t(lang, TERMS.problem_solving.clue_total), latex: `${a}x + ${b} = ${c}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `${a}x + ${b} = ${c}` },
                            { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a}x = ${c - b} = ${c - b}` },
                            { text: t(lang, TERMS.algebra.divide(a)), latex: `x = \\frac{${c - b}}{${a}} = ${fc(x)}` }
                        ]
                    };
                }
            },
            {
                id: 'taxi',
                type: 'A',
                context: 'shopping',
                templates: [ TERMS.problem_solving.a_taxi ],
                logic: (rng) => {
                    const x = rng.intBetween(5, 30); 
                    const a = rng.intBetween(10, 50); 
                    const b = rng.pick([45, 50, 75, 100]); 
                    const c = a * x + b;
                    return {
                        vars: { a, b, c },
                        solution: x,
                        equation: `${a}x + ${b} = ${c}`,
                        stepsWrite: (lang, fc) => [
                             { text: t(lang, TERMS.problem_solving.clue_var), latex: "x" },
                             { text: t(lang, TERMS.problem_solving.expl_rate_val), latex: `${a} \\cdot x` },
                             { text: t(lang, TERMS.problem_solving.expl_fixed_val), latex: `+ ${b}` },
                             { text: t(lang, TERMS.problem_solving.clue_total), latex: `${a}x + ${b} = ${c}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `${a}x + ${b} = ${c}` },
                            { text: t(lang, TERMS.algebra.subtract(b)), latex: `${a}x = ${c - b}` },
                            { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            },

            // --- TYPE B: ax - b = c (Discount) ---
            {
                id: 'shopping_discount',
                type: 'B',
                context: 'shopping',
                templates: [ TERMS.problem_solving.b_discount ],
                logic: (rng) => {
                    const x = rng.intBetween(2, 10); 
                    const a = rng.intBetween(50, 200); 
                    const b = rng.pick([20, 50, 100]); 
                    const c = a * x - b;
                    return {
                        vars: { a, b, c }, // x excluded
                        solution: x,
                        equation: `${a}x - ${b} = ${c}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.clue_var), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_item_cost), latex: `${a}x` },
                            { text: t(lang, TERMS.problem_solving.expl_discount_sub), latex: `-${b}` },
                            { text: t(lang, TERMS.problem_solving.clue_total), latex: `${a}x - ${b} = ${c}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `${a}x - ${b} = ${c}` },
                            { text: t(lang, TERMS.algebra.add(b)), latex: `${a}x = ${c + b}` },
                            { text: t(lang, TERMS.algebra.divide(a)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            },

            // --- TYPE C: x + (x + a) = c (Comparison Sum) ---
            {
                id: 'compare_sum',
                type: 'C',
                context: 'hobbies',
                templates: [ TERMS.problem_solving.c_compare ],
                logic: (rng) => {
                    const x = rng.intBetween(5, 20); 
                    const a = rng.intBetween(2, 10); 
                    const total = x + (x + a);
                    return {
                        vars: { a, c: total }, // x excluded
                        solution: x,
                        equation: `2x + ${a} = ${total}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.expl_person1), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_person2_more), latex: `x + ${a}` },
                            { text: t(lang, TERMS.problem_solving.expl_compare_sum), latex: `x + (x + ${a}) = ${total}` },
                            { text: t(lang, TERMS.common.simplify), latex: `2x + ${a} = ${total}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `2x + ${a} = ${total}` },
                            { text: t(lang, TERMS.algebra.subtract(a)), latex: `2x = ${total - a}` },
                            { text: t(lang, TERMS.algebra.divide(2)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            },

            // --- TYPE D: x + (x - b) = c (Comparison Diff) ---
            {
                id: 'compare_diff',
                type: 'D',
                context: 'hobbies',
                templates: [ TERMS.problem_solving.d_compare ],
                logic: (rng) => {
                    const x = rng.intBetween(10, 30); 
                    const b = rng.intBetween(2, 8);   
                    const total = x + (x - b);
                    return {
                        vars: { b, c: total }, // x excluded
                        solution: x,
                        equation: `2x - ${b} = ${total}`,
                        stepsWrite: (lang, fc) => [
                            { text: t(lang, TERMS.problem_solving.expl_person1), latex: "x" },
                            { text: t(lang, TERMS.problem_solving.expl_person2_less), latex: `x - ${b}` },
                            { text: t(lang, TERMS.problem_solving.expl_compare_sum), latex: `x + (x - ${b}) = ${total}` },
                            { text: t(lang, TERMS.common.simplify), latex: `2x - ${b} = ${total}` }
                        ],
                        stepsSolve: (lang, fc) => [
                            { text: t(lang, TERMS.common.equation), latex: `2x - ${b} = ${total}` },
                            { text: t(lang, TERMS.algebra.add(b)), latex: `2x = ${total + b}` },
                            { text: t(lang, TERMS.algebra.divide(2)), latex: `x = ${fc(x)}` }
                        ]
                    };
                }
            }
        ];
    }

    public static generate(level: number, seed: string, lang: Language = 'sv'): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        const scenarios = this.getScenarios();
        const scenario = rng.pick(scenarios);
        
        // Generate math - x is NOT in math.vars
        const math = scenario.logic(rng);
        
        const rawTemplateObj = rng.pick(scenario.templates);
        let text = t(lang, rawTemplateObj);

        // Replace math variables ($a$, $b$, $c$)
        Object.entries(math.vars).forEach(([key, val]) => {
            text = text.replace(new RegExp(`\\$${key}\\$`, 'g'), `$${val}$`);
            text = text.replace(new RegExp(`\\$${key}`, 'g'), `$${val}`);
        });

        // Replace Context
        const ctxData = CONTEXTS[scenario.context];
        if (ctxData) {
            const itemObj = rng.pick(ctxData.items);
            const itemStr = t(lang, itemObj);
            const name1 = rng.pick(ctxData.people);
            let name2 = rng.pick(ctxData.people);
            while (name1 === name2) name2 = rng.pick(ctxData.people);

            text = text.replace(/{item}/g, itemStr);
            text = text.replace(/{name1}/g, name1);
            text = text.replace(/{name2}/g, name2);
        }

        const isWriteMode = level === 5;
        const taskText = isWriteMode ? t(lang, TERMS.problem_solving.task_write) : t(lang, TERMS.problem_solving.task_solve);
        
        return {
            questionId: `prob-l${level}-${seed}`,
            renderData: {
                text_key: "problem_solving",
                description: `${text} ${taskText}`,
                latex: "",
                answerType: isWriteMode ? 'text' : 'numeric', 
                variables: {}
            },
            serverData: {
                answer: isWriteMode ? math.equation : math.solution,
                solutionSteps: isWriteMode ? math.stepsWrite(lang, formatColor) : math.stepsSolve(lang, formatColor)
            }
        };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { UI_STRINGS } from '../utils/i18n';

interface Point { x: number; y: number; label?: string; }
interface Line { x1: number; y1: number; x2: number; y2: number; color: string; width: number; }

interface VisualData {
    type: 'graph';
    lines: Line[];
    points: Point[];
    showGrid: boolean;
    showAxes: boolean;
}

interface Question {
    text: string;
    correctAnswer: number | string;
    visual: VisualData;
    meta: { topic: string; difficulty: number };
}

export class LinearGraphGenerator {
    /**
     * Generates a linear graph problem.
     * Level 1: Find m (y-intercept).
     * Level 2: Find k (slope).
     * Level 3: Find the full equation y = kx + m.
     */
    public static getQuestion(difficulty: number): Question {
        let k: number, m: number;
        let questionKey = "";
        let answer: number | string = "";

        // --- Difficulty Logic ---
        if (difficulty === 1) {
            // Level 1: Find m (intercept)
            // We use simple slopes (+/- 1 or 2) to keep the graph readable
            // m ranges from -4 to 4 to stay well within the standard -10 to 10 grid
            k = (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 2) + 1);
            m = Math.floor(Math.random() * 9) - 4; // -4 to 4
            
            questionKey = "graph.q_intercept";
            answer = m;
        } 
        else if (difficulty === 2) {
            // Level 2: Find k (slope)
            // m is strictly integer, k is integer
            k = (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 3) + 1);
            m = Math.floor(Math.random() * 7) - 3;
            
            questionKey = "graph.q_slope";
            answer = k;
        } 
        else {
            // Level 3: Find Equation y = kx + m
            // Slopes can be steeper here
            k = (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 3) + 1);
            m = Math.floor(Math.random() * 7) - 3;

            questionKey = "graph.q_func";
            
            // Format answer string: y = kx + m
            // We handle the edge cases for x (1x) and sign formatting
            let kStr = `${k}`;
            if (k === 1) kStr = "";
            if (k === -1) kStr = "-";
            
            const sign = m >= 0 ? '+' : '';
            
            answer = `y=${kStr}x${sign}${m}`;
            
            // Cleanup: if m is 0, we don't usually write +0
            if (m === 0) answer = `y=${kStr}x`;
        }

        // --- Visuals ---
        // Generate line points that extend across the typical view (-10 to 10)
        // Calculating y at x=-10 and x=10 ensures the line spans the canvas
        const x1 = -10;
        const y1 = k * x1 + m;
        const x2 = 10;
        const y2 = k * x2 + m;

        const visual: VisualData = {
            type: 'graph',
            lines: [
                { x1, y1, x2, y2, color: '#4F46E5', width: 3 } // Indigo-600
            ],
            points: [],
            showGrid: true,
            showAxes: true
        };

        // For Level 1, some pedagogical designs place a point at the intercept to focus attention.
        // We add it as a visual aid without a label to avoid giving the answer explicitly.
        if (difficulty === 1) {
            visual.points.push({ x: 0, y: m, label: '' });
        }

        return {
            text: questionKey,
            correctAnswer: answer,
            visual: visual,
            meta: { topic: 'linear_graph', difficulty }
        };
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class NegativeNumbersGen {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        let mode = level;
        if (level === 5) mode = rng.intBetween(1, 4);

        let steps: Clue[] = [];
        let answer: number = 0;
        let latex = "";
        let description = { sv: "Ber√§kna.", en: "Calculate." };

        const p = (n: number) => n < 0 ? `(${n})` : `${n}`;

        // --- LEVELS 1 & 2: Add/Sub ---
        if (mode === 1 || mode === 2) {
            const range = mode === 1 ? 10 : 50;
            const min = mode === 1 ? -10 : -20;
            const numCount = mode === 1 ? rng.intBetween(2, 3) : rng.intBetween(3, 4);
            
            let nums: number[] = [];
            let ops: string[] = [];

            nums.push(rng.intBetween(min, range));
            
            for(let i=1; i<numCount; i++) {
                nums.push(rng.intBetween(min, range));
                ops.push(rng.pick(['+', '-']));
            }

            latex = `${nums[0]}`;
            for(let i=0; i<ops.length; i++) {
                latex += ` ${ops[i]} ${p(nums[i+1])}`;
            }
            latex += " =";

            let runningVal = nums[0];
            
            for(let i=0; i<ops.length; i++) {
                const nextNum = nums[i+1];
                const op = ops[i];
                let stepExpl = "";
                let stepLatex = "";

                if (op === '+') {
                    if (nextNum < 0) {
                        stepExpl = "add_neg";
                        stepLatex = `${runningVal} + (${nextNum}) = ${runningVal} - ${Math.abs(nextNum)}`;
                        runningVal += nextNum;
                    } else {
                        stepExpl = "simple_calc";
                        stepLatex = `${runningVal} + ${nextNum}`;
                        runningVal += nextNum;
                    }
                } else {
                    if (nextNum < 0) {
                        stepExpl = "sub_neg";
                        stepLatex = `${runningVal} - (${nextNum}) = ${runningVal} + ${Math.abs(nextNum)}`;
                        runningVal -= nextNum;
                    } else {
                        stepExpl = "simple_calc";
                        stepLatex = `${runningVal} - ${nextNum}`;
                        runningVal -= nextNum;
                    }
                }

                if (stepExpl) {
                    // Safe access to TERMS
                    const explText = (TERMS.neg_signs as any)[stepExpl] 
                        ? t(lang, (TERMS.neg_signs as any)[stepExpl]) 
                        : "Calculate:";
                    steps.push({ text: explText, latex: stepLatex });
                }
                
                steps.push({ text: t(lang, TERMS.neg_signs.step_calc), latex: `= ${formatColor(runningVal)}` });
            }
            
            answer = runningVal;
        }

        // --- LEVEL 3: Multiplication ---
        else if (mode === 3) {
            const count = rng.intBetween(2, 3);
            const nums: number[] = [];
            for(let i=0; i<count; i++) nums.push(rng.intBetween(-10, 10));
            nums.forEach((n, i) => { if(n===0) nums[i] = 2; });

            latex = nums.map(n => p(n)).join(' \\cdot ') + " =";
            
            let runningVal = nums[0];
            
            for(let i=1; i<nums.length; i++) {
                const prev = runningVal;
                const next = nums[i];
                const isPrevNeg = prev < 0;
                const isNextNeg = next < 0;
                
                let explKey = "";
                if (isPrevNeg && isNextNeg) explKey = "mul_neg_neg";
                else if (isPrevNeg !== isNextNeg) explKey = "mul_pos_neg";
                else explKey = "simple_calc";
                
                runningVal *= next;
                
                const explText = (TERMS.neg_signs as any)[explKey] 
                    ? t(lang, (TERMS.neg_signs as any)[explKey]) 
                    : "";

                steps.push({ 
                    text: explText, 
                    latex: `${p(prev)} \\cdot ${p(next)} = ${formatColor(runningVal)}` 
                });
            }
            answer = runningVal;
        }

        // --- LEVEL 4: Division ---
        else { 
            let b = 0;
            while(b === 0) b = rng.intBetween(-10, 10);
            
            const maxRes = Math.floor(100 / Math.abs(b));
            let res = 0;
            while(res === 0) res = rng.intBetween(-maxRes, maxRes);
            
            const a = res * b;
            answer = res;
            
            latex = `\\frac{${a}}{${b}} =`;

            const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);
            const explKey = sameSign ? "div_sign_same" : "div_sign_diff";
            
            steps.push({
                text: t(lang, (TERMS.neg_signs as any)[explKey]),
                latex: `${a} / ${b} = ${formatColor(answer)}`
            });
        }

        return {
            questionId: `neg-l${level}-${seed}`,
            renderData: {
                text_key: "arithmetic", 
                description: description,
                latex: latex,
                answerType: "numeric",
                variables: {}
            },
            serverData: {
                answer: answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class ScaleGenerator {
    
    // Matched exactly to i18n.ts shapes to prevent crashes
    private static readonly SHAPES = [
        'square', 'rectangle', 'circle', 'triangle', 
        'rhombus', 'parallelogram', 'pentagon', 'hexagon', 'octagon',
        'star', 'arrow', 'heart', 'cross', 'lightning', 'kite',
        'cube', 'cylinder', 'pyramid', 'cone', 'sphere'
    ];

    private static readonly AREA_SHAPES = ['rectangle', 'triangle', 'circle', 'semicircle', 'parallelogram'];

    private static getScaleFactor(rng: Random): number {
        const type = rng.intBetween(1, 10);
        if (type <= 4) return rng.intBetween(2, 25);
        if (type <= 7) return rng.intBetween(6, 20) * 5;
        return rng.intBetween(10, 100) * 10;
    }

    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;
        
        let mode = level;
        if (level === 7) mode = rng.intBetween(1, 6); 

        // --- LEVEL 1: CONCEPTUAL ---
        if (mode === 1) {
            const isReduction = rng.intBetween(0, 1) === 1; 
            const ratio = rng.pick([2, 5, 10, 20, 50, 100]);
            const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
            const qType = rng.intBetween(1, 2);
            let descObj = { sv: "", en: "" }, correct = "", choices: string[] = [], expl = "";

            if (qType === 1) {
                descObj = { sv: `Visar skalan ${scaleStr} en f√∂rstoring eller en f√∂rminskning?`, en: `Does the scale ${scaleStr} show an enlargement or a reduction?` };
                correct = isReduction ? t(lang, TERMS.scale.reduction) : t(lang, TERMS.scale.enlargement);
                const wrong = isReduction ? t(lang, TERMS.scale.enlargement) : t(lang, TERMS.scale.reduction);
                choices = rng.intBetween(0,1) ? [wrong, correct] : [correct, wrong];
                expl = isReduction ? t(lang, TERMS.scale.rule_reduction) : t(lang, TERMS.scale.rule_enlargement);
            } else {
                descObj = { sv: `Skalan √§r ${scaleStr}. Vad √§r st√∂rst: bilden eller verkligheten?`, en: `The scale is ${scaleStr}. Which is larger: the image or reality?` };
                correct = isReduction ? t(lang, TERMS.scale.reality) : t(lang, TERMS.scale.drawing);
                const wrong = isReduction ? t(lang, TERMS.scale.drawing) : t(lang, TERMS.scale.reality);
                choices = rng.intBetween(0,1) ? [wrong, correct] : [correct, wrong];
                expl = isReduction ? t(lang, TERMS.scale.rule_reduction) : t(lang, TERMS.scale.rule_enlargement);
            }
            return {
                questionId: `scale-l1-${seed}`,
                renderData: { 
                    text_key: "concept", 
                    description: descObj, 
                    latex: scaleStr, 
                    answerType: 'multiple_choice', 
                    choices: choices,
                    variables: {} 
                },
                serverData: { answer: correct, solutionSteps: [{ text: expl, latex: scaleStr }] }
            };
        }

        // Shared Setup for L2-6
        const shape = rng.pick(this.SHAPES);
        // Safe access to shape terms using fallback
        const svShape = t('sv', (TERMS.shapes as any)[shape] || shape);
        const enShape = t('en', (TERMS.shapes as any)[shape] || shape);
        
        const scaleFactor = ScaleGenerator.getScaleFactor(rng);

        // --- LEVEL 2: FIND LENGTH (EASY - SAME UNITS) ---
        if (mode === 2) {
            const isReduction = rng.intBetween(0, 1) === 1;
            const scaleStr = isReduction ? `1:${scaleFactor}` : `${scaleFactor}:1`;
            const subType = rng.intBetween(0, 1);
            let drawingVal = 0, realVal = 0, answer = 0;
            let steps: Clue[] = [];
            let geomLabel = "";
            let descriptionObj = { sv: "", en: "" };
            const baseInt = rng.intBetween(2, 15);

            if (isReduction) {
                if (subType === 0) { // Find Real
                    drawingVal = baseInt; 
                    realVal = drawingVal * scaleFactor; 
                    answer = realVal;
                    descriptionObj = { sv: `En ${svShape} √§r ${drawingVal} cm p√• ritningen. Skalan √§r ${scaleStr}. Hur l√•ng √§r den i verkligheten? (Svara i cm)`, en: `A ${enShape} is ${drawingVal} cm on the drawing. Scale is ${scaleStr}. How long is it in reality? (Answer in cm)` };
                    geomLabel = `${drawingVal} cm`;
                    steps = [{ text: t(lang, TERMS.common.calculate), latex: `${drawingVal} \\cdot ${scaleFactor} = ${formatColor(realVal)}` }];
                } else { // Find Drawing
                    answer = baseInt;
                    realVal = answer * scaleFactor;
                    descriptionObj = { sv: `I verkligheten √§r en ${svShape} ${realVal} cm l√•ng. Hur l√•ng blir den p√• en ritning i skala ${scaleStr}? (Svara i cm)`, en: `In reality, a ${enShape} is ${realVal} cm long. How long will it be on a drawing with scale ${scaleStr}? (Answer in cm)` };
                    geomLabel = `${realVal} cm`;
                    steps = [{ text: t(lang, TERMS.scale.step_plug_in), latex: `\\frac{${realVal}}{${scaleFactor}} = ${formatColor(answer)}` }];
                }
            } else {
                if (subType === 0) { // Find Drawing
                    realVal = baseInt; 
                    drawingVal = realVal * scaleFactor; 
                    answer = drawingVal;
                    descriptionObj = { sv: `I verkligheten √§r en ${svShape} ${realVal} cm l√•ng. Skalan √§r ${scaleStr}. Hur l√•ng blir den p√• en ritning? (Svara i cm)`, en: `In reality, a ${enShape} is ${realVal} cm long. Scale is ${scaleStr}. How long on the drawing? (Answer in cm)` };
                    geomLabel = `${realVal} cm`;
                    steps = [{ text: t(lang, TERMS.common.calculate), latex: `${realVal} \\cdot ${scaleFactor} = ${formatColor(drawingVal)}` }];
                } else { // Find Reality
                    answer = baseInt;
                    drawingVal = answer * scaleFactor; 
                    descriptionObj = { sv: `En ${svShape} √§r ${drawingVal} cm p√• ritningen. Skalan √§r ${scaleStr}. Hur l√•ng √§r den i verkligheten? (Svara i cm)`, en: `A ${enShape} is ${drawingVal} cm on the drawing. Scale is ${scaleStr}. Find reality (cm).` };
                    geomLabel = `${drawingVal} cm`;
                    steps = [{ text: t(lang, TERMS.scale.step_plug_in), latex: `\\frac{${drawingVal}}{${scaleFactor}} = ${formatColor(answer)}` }];
                }
            }

            return {
                questionId: `scale-l2-${seed}`,
                renderData: { 
                    text_key: "calc_len_easy", 
                    description: descriptionObj, 
                    latex: scaleStr, 
                    answerType: 'numeric', 
                    geometry: { type: 'scale_single', shape, label: geomLabel }
                },
                serverData: { answer, solutionSteps: steps }
            };
        }

        // --- LEVEL 3: FIND LENGTH (HARD - MIXED UNITS) ---
        if (mode === 3) {
            const subType = rng.intBetween(0, 1);
            let answer = 0;
            let steps: Clue[] = [];
            let geomLabel = "";
            let descriptionObj = { sv: "", en: "" };
            const baseInt = rng.intBetween(2, 9);

            if (subType === 0) { // Find Real (Answer in m)
                const drawingVal = baseInt; 
                const realValCm = drawingVal * scaleFactor;
                const realValM = realValCm / 100;
                answer = realValM;

                descriptionObj = { sv: `En ${svShape} √§r ${drawingVal} cm p√• ritningen. Skalan √§r 1:${scaleFactor}. Hur l√•ng √§r den i verkligheten? (Svara i m)`, en: `A ${enShape} is ${drawingVal} cm on the drawing. Scale is 1:${scaleFactor}. How long is it in reality? (Answer in m)` };
                geomLabel = `${drawingVal} cm`;
                steps = [
                    { text: t(lang, TERMS.scale.calc_cm), latex: `${drawingVal} \\cdot ${scaleFactor} = ${realValCm} \\text{ cm}` },
                    { text: t(lang, TERMS.scale.conv_m), latex: `\\frac{${realValCm}}{100} = ${formatColor(realValM)}` }
                ];
            } else { // Find Drawing
                const drawingVal = baseInt; 
                const realValCm = drawingVal * scaleFactor;
                const realValM = realValCm / 100;
                answer = drawingVal;

                descriptionObj = { sv: `I verkligheten √§r en ${svShape} ${realValM} m l√•ng. Skalan √§r 1:${scaleFactor}. Hur l√•ng p√• ritningen? (Svara i cm)`, en: `In reality a ${enShape} is ${realValM} m long. Scale 1:${scaleFactor}. Find drawing (cm).` };
                geomLabel = `${realValM} m`;
                steps = [
                    { text: t(lang, TERMS.scale.conv_same), latex: `${realValM} \\text{ m} = ${realValCm} \\text{ cm}` },
                    { text: t(lang, TERMS.scale.step_plug_in), latex: `\\frac{${realValCm}}{${scaleFactor}} = ${formatColor(answer)}` }
                ];
            }

            return {
                questionId: `scale-l3-${seed}`,
                renderData: { 
                    text_key: "calc_len_hard", 
                    description: descriptionObj, 
                    latex: `1:${scaleFactor}`, 
                    answerType: 'numeric', 
                    geometry: { type: 'scale_single', shape, label: geomLabel }
                },
                serverData: { answer, solutionSteps: steps }
            };
        }

        // --- LEVEL 4: FIND SCALE ---
        if (mode === 4) {
            const base = rng.intBetween(2, 5); 
            const factor = ScaleGenerator.getScaleFactor(rng);
            
            const isReduction = rng.intBetween(0, 1) === 1;
            
            let drawVal, realVal;
            let ansLeft, ansRight;
            let steps: Clue[] = [];

            if (isReduction) {
                drawVal = base;
                realVal = base * factor; 
                ansLeft = 1;
                ansRight = factor;
                
                const realUnit = factor >= 100 ? 'm' : 'cm';
                const realDisplay = realUnit === 'm' ? realVal / 100 : realVal;

                steps = [
                    { text: t(lang, TERMS.scale.conv_same), latex: `${realDisplay} ${realUnit} = ${realVal} \\text{ cm}` },
                    { text: t(lang, TERMS.scale.setup_ratio), latex: `\\text{Bild} : \\text{Verklighet} = ${drawVal} : ${realVal}` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `1 : \\frac{${realVal}}{${drawVal}} \\implies ${formatColor('1:' + factor)}` }
                ];
            } else {
                realVal = base;
                drawVal = base * factor; 
                ansLeft = factor;
                ansRight = 1;

                steps = [
                    { text: t(lang, TERMS.scale.setup_ratio), latex: `\\text{Bild} : \\text{Verklighet} = ${drawVal} : ${realVal}` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `\\frac{${drawVal}}{${realVal}} : 1 \\implies ${formatColor(factor + ':1')}` }
                ];
            }

            const descriptionObj = { sv: `Best√§m skalan.`, en: `Determine the scale.` };
            const leftIsDrawing = rng.intBetween(0, 1) === 1;
            const leftLabel = leftIsDrawing ? t(lang, TERMS.scale.drawing) : t(lang, TERMS.scale.reality);
            const rightLabel = leftIsDrawing ? t(lang, TERMS.scale.reality) : t(lang, TERMS.scale.drawing);
            
            const realUnit = (!isReduction && factor < 100) ? 'cm' : (factor >= 100 ? 'm' : 'cm');
            const realDisplay = (realUnit === 'm' ? realVal / 100 : realVal);

            const leftValue = leftIsDrawing ? `${drawVal} cm` : `${realDisplay} ${realUnit}`;
            const rightValue = leftIsDrawing ? `${realDisplay} ${realUnit}` : `${drawVal} cm`;

            return {
                questionId: `scale-l4-${seed}`,
                renderData: {
                    text_key: "find_scale",
                    description: descriptionObj,
                    latex: "",
                    answerType: 'scale',
                    geometry: { type: 'scale_compare', shape, leftLabel, rightLabel, leftValue, rightValue }
                },
                serverData: { answer: { left: ansLeft, right: ansRight }, solutionSteps: steps }
            };
        }

        // --- LEVEL 5: TEXT ONLY (FIND SCALE) ---
        if (mode === 5) {
            const base = rng.intBetween(3, 8); 
            const factor = ScaleGenerator.getScaleFactor(rng); 
            const isReduction = rng.intBetween(0, 1) === 1;

            let drawVal, realVal, ansLeft, ansRight;
            let descriptionObj = { sv: "", en: "" };
            let steps: Clue[] = [];

            if (isReduction) {
                drawVal = base;
                realVal = base * factor; 
                const realM = realVal / 100;
                const showM = factor >= 100;
                
                ansLeft = 1; ansRight = factor;

                descriptionObj = {
                    sv: `P√• en ritning √§r en ${svShape} ${drawVal} cm l√•ng. I verkligheten √§r den ${showM ? realM + ' m' : realVal + ' cm'}. Vad √§r skalan?`,
                    en: `On a drawing, a ${enShape} is ${drawVal} cm long. In reality it is ${showM ? realM + ' m' : realVal + ' cm'}. What is the scale?`
                };
                
                if (showM) {
                    steps.push({ text: t(lang, TERMS.scale.conv_same), latex: `${realM} \\text{ m} = ${realVal} \\text{ cm}` });
                }
                steps.push({ text: t(lang, TERMS.scale.setup_ratio), latex: `${drawVal} : ${realVal}` });
                steps.push({ text: t(lang, TERMS.scale.step_simplify), latex: `1 : \\frac{${realVal}}{${drawVal}} \\implies ${formatColor('1:' + factor)}` });

            } else {
                realVal = base;
                drawVal = base * factor; 
                ansLeft = factor; ansRight = 1;

                descriptionObj = {
                    sv: `I verkligheten √§r en ${svShape} ${realVal} cm l√•ng. P√• en ritning √§r den ${drawVal} cm. Vad √§r skalan?`,
                    en: `In reality a ${enShape} is ${realVal} cm long. On a drawing it is ${drawVal} cm. What is the scale?`
                };

                steps = [
                    { text: t(lang, TERMS.scale.setup_ratio), latex: `${drawVal} : ${realVal}` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `\\frac{${drawVal}}{${realVal}} : 1 \\implies ${formatColor(factor + ':1')}` }
                ];
            }

            return {
                questionId: `scale-l5-${seed}`,
                renderData: { text_key: "find_scale_text", description: descriptionObj, latex: "", answerType: 'scale', variables: {} },
                serverData: { answer: { left: ansLeft, right: ansRight }, solutionSteps: steps }
            };
        }

        // --- LEVEL 6: AREA SCALE ---
        if (mode === 6) {
            const areaShape = rng.pick(ScaleGenerator.AREA_SHAPES);
            const subType = rng.intBetween(1, 4);
            const lengthScale = rng.pick([2, 3, 4, 5, 10]);
            const areaScale = lengthScale * lengthScale;

            const isReduction = rng.intBetween(0, 1) === 1;

            let steps: Clue[] = [];
            let qDesc: { sv: string, en: string } = { sv: "", en: "" };
            let geomData: any = {};
            let answer: any = 0;
            let answerType: any = 'numeric';

            const shapePluralSv = (t('sv', (TERMS.shapes_plural as any)[areaShape]) || areaShape);
            const shapePluralEn = (t('en', (TERMS.shapes_plural as any)[areaShape]) || areaShape);

            if (subType === 1) { // Find Scale (Visual)
                const w = rng.intBetween(2, 6);
                const h = (areaShape === 'rectangle' || areaShape === 'parallelogram' || areaShape === 'triangle') ? rng.intBetween(2, 6) : 0;
                const wReal = w * lengthScale; const hReal = h * lengthScale;
                let areaDraw = 0, areaReal = 0;

                if (areaShape === 'rectangle' || areaShape === 'parallelogram') { areaDraw = w * h; areaReal = wReal * hReal; }
                else if (areaShape === 'triangle') { areaDraw = (w * h) / 2; areaReal = (wReal * hReal) / 2; }
                else if (areaShape === 'circle') { areaDraw = Math.PI * w * w; areaReal = Math.PI * wReal * wReal; } 
                else if (areaShape === 'semicircle') { areaDraw = (Math.PI * w * w) / 2; areaReal = (Math.PI * wReal * wReal) / 2; }

                const dispAreaDraw = Math.round(areaDraw * 10) / 10;
                const dispAreaReal = Math.round(areaReal * 10) / 10;

                qDesc = {
                    sv: `H√§r √§r tv√• ${shapePluralSv}. Den f√∂rsta √§r en avbildning och den andra √§r verkligheten. Vad √§r areaskalan?`,
                    en: `Here are two ${shapePluralEn}. The first is a drawing, the second is reality. What is the area scale?`
                };

                steps = [
                    { text: t(lang, TERMS.scale.calc_area_img), latex: `A_{bild} = ${dispAreaDraw} \\text{ cm}^2` },
                    { text: t(lang, TERMS.scale.calc_area_real), latex: `A_{verklighet} = ${dispAreaReal} \\text{ cm}^2` },
                    { text: t(lang, TERMS.scale.step_simplify), latex: `${dispAreaDraw} : ${dispAreaReal} \\implies ${formatColor('1:' + areaScale)}` }
                ];
                answer = { left: 1, right: areaScale };
                answerType = 'scale';
                geomData = { type: 'compare_shapes', shapeType: areaShape, left: { width: w, height: h, radius: w, label: t(lang, TERMS.scale.drawing) }, right: { width: wReal, height: hReal, radius: wReal, label: t(lang, TERMS.scale.reality) } };
            } 
            else if (subType === 2) { // Find Real Area
                const baseArea = rng.pick([2, 3, 4, 5, 10]);
                const realArea = baseArea * areaScale;
                qDesc = {
                    sv: `Den lilla figuren har arean ${baseArea} cm$^2$. Hur stor √§r arean i den stora figuren om l√§ngdskalan √§r 1:${lengthScale}?`,
                    en: `The small shape has an area of ${baseArea} cm$^2$. How big is the area of the large shape if the length scale is 1:${lengthScale}?`
                };
                steps = [
                    { text: t(lang, TERMS.scale.calc_area_scale), latex: `(1:${lengthScale})^2 = 1:${areaScale}` },
                    { text: t(lang, TERMS.common.calculate), latex: `${baseArea} \\cdot ${areaScale} = ${formatColor(realArea)}` }
                ];
                answer = realArea;
                answerType = 'numeric';
                geomData = { type: 'compare_shapes_area', shapeType: areaShape, left: { area: baseArea, label: t(lang, TERMS.scale.drawing) }, right: { area: "?", label: t(lang, TERMS.scale.reality) } };
            }
            else if (subType === 3) { // Length -> Area Scale
                const lScaleStr = isReduction ? `1:${lengthScale}` : `${lengthScale}:1`;
                const aScaleLeft = isReduction ? 1 : areaScale;
                const aScaleRight = isReduction ? areaScale : 1;
                
                qDesc = { sv: `L√§ngdskalan √§r ${lScaleStr}. Vad √§r areaskalan?`, en: `The length scale is ${lScaleStr}. What is the area scale?` };
                const clueLatex = isReduction ? `(1^2 : ${lengthScale}^2)` : `(${lengthScale}^2 : 1^2)`;
                steps = [{ text: {sv: "Areaskala = (L√§ngdskala)¬≤", en: "Area Scale = (Length Scale)¬≤"}, latex: `${clueLatex} = ${formatColor(aScaleLeft + ':' + aScaleRight)}` }];

                answer = { left: aScaleLeft, right: aScaleRight };
                answerType = 'scale';
            }
            else { // Area -> Length Scale
                const aScaleStr = isReduction ? `1:${areaScale}` : `${areaScale}:1`;
                const lScaleLeft = isReduction ? 1 : lengthScale;
                const lScaleRight = isReduction ? lengthScale : 1;

                qDesc = { sv: `Areaskalan √§r ${aScaleStr}. Vad √§r l√§ngdskalan?`, en: `The area scale is ${aScaleStr}. What is the length scale?` };
                const clueLatex = isReduction ? `(\\sqrt{1} : \\sqrt{${areaScale}})` : `(\\sqrt{${areaScale}} : \\sqrt{1})`;
                steps = [{ text: {sv: "L√§ngdskala = ‚àöAreaskala", en: "Length Scale = ‚àöArea Scale"}, latex: `${clueLatex} = ${formatColor(lScaleLeft + ':' + lScaleRight)}` }];

                answer = { left: lScaleLeft, right: lScaleRight };
                answerType = 'scale';
            }

            return {
                questionId: `scale-l6-${seed}`,
                renderData: { text_key: "area_scale", description: qDesc, latex: "", answerType: answerType, geometry: geomData, variables: {} },
                serverData: { answer: answer, solutionSteps: steps }
            };
        }

        // Fallback or restart if mode is out of bounds
        return ScaleGenerator.generate(1, seed, lang, multiplier); 
    }
}

// FILE END: src\core\generators\ScaleGenerator.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGenerator.ts
// =======================================================

import { UI_STRINGS } from '../utils/i18n';

// Interfaces for strict typing
interface Point { x: number; y: number; }
interface ShapeData { points: Point[]; color: string; }
interface LabelData { x: number; y: number; text: string; shapeIndex: number; }

interface VisualData {
  type: 'similarity';
  shapes: ShapeData[];
  labels: LabelData[];
  showAxes: boolean;
}

interface Question {
  text: string; // The raw translation key to be processed by frontend
  correctAnswer: number | string;
  visual: VisualData;
  meta: { topic: string; difficulty: number };
}

export class SimilarityGenerator {
  /**
   * Generates a similarity problem.
   */
  public static getQuestion(difficulty: number): Question {
    // 1. Determine Scale Factor (k)
    let k: number;
    
    if (difficulty === 1) {
      // Level 1: Simple Integer (x2, x3, x4)
      k = Math.floor(Math.random() * 3) + 2; 
    } else {
      // Level 2 & 3: Decimals (1.5, 2.5, 3.5)
      // We ensure base dimensions are even so multiplying by 1.5 results in integer/clean decimal
      k = (Math.floor(Math.random() * 4) * 0.5) + 1.5; 
    }

    // 2. Base Triangle Dimensions
    // Ensure base dimensions are even to play nice with 0.5 scale factors
    const baseW = (Math.floor(Math.random() * 3) + 2) * 2; // 4, 6, 8, 10
    const baseH = (Math.floor(Math.random() * 3) + 2) * 2; // 4, 6, 8, 10

    // 3. Scaled Triangle Dimensions
    const scaledW = Number((baseW * k).toFixed(2));
    const scaledH = Number((baseH * k).toFixed(2));

    // 4. Determine Problem Mode
    const modes = ['find_height_big', 'find_width_big'];
    
    if (difficulty > 1) {
       modes.push('find_height_small', 'find_width_small');
    }
    if (difficulty === 3) {
        modes.push('find_k'); // Level 3 special: Find the scale factor
    }

    const mode = modes[Math.floor(Math.random() * modes.length)];

    let answer: number;
    let questionKey = "geometry.missing_side"; 
    
    const labels: LabelData[] = [];

    // --- Shape Definitions ---
    // Shape 1 (Small)
    const shape1Points: Point[] = [
      { x: 0, y: 0 },
      { x: baseW, y: 0 },
      { x: 0, y: baseH }
    ];

    // Shape 2 (Large)
    const shape2Points: Point[] = [
      { x: 0, y: 0 },
      { x: scaledW, y: 0 },
      { x: 0, y: scaledH }
    ];

    // --- Labeling Logic ---
    // Default: Label small shape fully
    labels.push({ x: baseW / 2, y: -0.5, text: `${baseW}`, shapeIndex: 0 }); // Base
    labels.push({ x: -0.5, y: baseH / 2, text: `${baseH}`, shapeIndex: 0 }); // Height

    if (mode === 'find_k') {
        questionKey = "geometry.scale_factor";
        answer = k;
        // Label everything
        labels.push({ x: scaledW / 2, y: -0.5, text: `${scaledW}`, shapeIndex: 1 });
        labels.push({ x: -0.5, y: scaledH / 2, text: `${scaledH}`, shapeIndex: 1 });
    }
    else if (mode === 'find_height_big') {
      answer = scaledH;
      labels.push({ x: scaledW / 2, y: -0.5, text: `${scaledW}`, shapeIndex: 1 });
      labels.push({ x: -0.5, y: scaledH / 2, text: "?", shapeIndex: 1 });
    } 
    else if (mode === 'find_width_big') {
      answer = scaledW;
      labels.push({ x: scaledW / 2, y: -0.5, text: "?", shapeIndex: 1 });
      labels.push({ x: -0.5, y: scaledH / 2, text: `${scaledH}`, shapeIndex: 1 });
    }
    else if (mode === 'find_height_small') {
      answer = baseH;
      labels[1].text = "?"; // Remove small height label
      labels.push({ x: scaledW / 2, y: -0.5, text: `${scaledW}`, shapeIndex: 1 });
      labels.push({ x: -0.5, y: scaledH / 2, text: `${scaledH}`, shapeIndex: 1 });
    }
    else if (mode === 'find_width_small') {
        answer = baseW;
        labels[0].text = "?"; // Remove small width label
        labels.push({ x: scaledW / 2, y: -0.5, text: `${scaledW}`, shapeIndex: 1 });
        labels.push({ x: -0.5, y: scaledH / 2, text: `${scaledH}`, shapeIndex: 1 });
    } else {
        answer = 0;
    }

    return {
      text: questionKey,
      correctAnswer: answer,
      visual: {
        type: 'similarity',
        shapes: [
          { points: shape1Points, color: '#3B82F6' },
          { points: shape2Points, color: '#F59E0B' }
        ],
        labels: labels,
        showAxes: false
      },
      meta: { topic: 'similarity', difficulty }
    };
  }
}

// FILE END: src\core\generators\SimilarityGenerator.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { t, Language } from "../utils/i18n";

export class TenPowersGenerator {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;

        // Helper to fix floating point issues (e.g. 0.1 + 0.2 = 0.300000004)
        const fixFloat = (n: number) => parseFloat(n.toFixed(6));

        let qData: any = { 
            text_key: "", 
            description: "", 
            latex: "", 
            answer: 0,
            answerType: "numeric"
        };
        let steps: Clue[] = [];

        // --- LEVEL 1: Basic 10, 100, 1000 ---
        if (level === 1) {
            const power = rng.pick([10, 100, 1000]);
            const isMult = rng.intBetween(0, 1) === 1;
            
            // Generate a number (integer or decimal)
            // Case A: Integer (e.g. 532)
            // Case B: Decimal (e.g. 0.13, 1.305)
            const isDecimal = rng.intBetween(0, 1) === 1;
            let num = 0;
            
            if (isDecimal) {
                // Generate something like 0.13 or 13.05
                const base = rng.intBetween(1, 9999);
                const div = rng.pick([10, 100, 1000]);
                num = base / div;
            } else {
                num = rng.intBetween(2, 900);
            }

            // Calculation
            let answer = 0;
            let zeros = power.toString().length - 1; // 10->1, 100->2, 1000->3

            if (isMult) {
                // Multiplication
                answer = fixFloat(num * power);
                qData.latex = `${num} \\cdot ${power} =`;
                
                const direction = lang === 'sv' ? "h√∂ger" : "right";
                steps.push({
                    text: t(lang, {
                        sv: `N√§r du multiplicerar med ${power} flyttar du kommatecknet ${zeros} steg √•t ${direction}.`,
                        en: `When multiplying by ${power}, move the decimal point ${zeros} steps to the ${direction}.`
                    }),
                    latex: `${num} \\cdot ${power} = ${formatColor(answer)}`
                });
            } else {
                // Division
                // Ensure we don't divide 10 by 1000 (0.01) if we want to keep it somewhat simple, 
                // but requirements say "variations with up to 3 decimal places".
                answer = fixFloat(num / power);
                qData.latex = `${num} / ${power} =`; // Horizontal division as requested

                const direction = lang === 'sv' ? "v√§nster" : "left";
                steps.push({
                    text: t(lang, {
                        sv: `N√§r du dividerar med ${power} flyttar du kommatecknet ${zeros} steg √•t ${direction}.`,
                        en: `When dividing by ${power}, move the decimal point ${zeros} steps to the ${direction}.`
                    }),
                    latex: `${num} / ${power} = ${formatColor(answer)}`
                });
            }

            qData.description = { sv: "Ber√§kna.", en: "Calculate." };
            qData.answer = answer;
        }

        // --- LEVEL 2: Conceptual Equivalence (Multiple Choice) ---
        else if (level === 2) {
            // Mappings
            // Mult 10 = Div 0.1
            // Mult 100 = Div 0.01
            // Mult 1000 = Div 0.001
            // Div 10 = Mult 0.1
            // ...
            
            const pairs = [
                { op: 'mul', val: 10, equivOp: 'div', equivVal: 0.1 },
                { op: 'mul', val: 100, equivOp: 'div', equivVal: 0.01 },
                { op: 'mul', val: 1000, equivOp: 'div', equivVal: 0.001 },
                { op: 'mul', val: 0.1, equivOp: 'div', equivVal: 10 },
                { op: 'mul', val: 0.01, equivOp: 'div', equivVal: 100 },
                { op: 'mul', val: 0.001, equivOp: 'div', equivVal: 1000 },
                // Division variants
                { op: 'div', val: 10, equivOp: 'mul', equivVal: 0.1 },
                { op: 'div', val: 100, equivOp: 'mul', equivVal: 0.01 },
                { op: 'div', val: 1000, equivOp: 'mul', equivVal: 0.001 },
                { op: 'div', val: 0.1, equivOp: 'mul', equivVal: 10 },
                { op: 'div', val: 0.01, equivOp: 'mul', equivVal: 100 },
                { op: 'div', val: 0.001, equivOp: 'mul', equivVal: 1000 },
            ];

            const scenario = rng.pick(pairs);
            
            const opStr = (op: string) => {
                if (lang === 'sv') return op === 'mul' ? "Multiplicera med" : "Dividera med";
                return op === 'mul' ? "Multiplying by" : "Dividing by";
            };
            
            const targetOpStr = (op: string) => {
                if (lang === 'sv') return op === 'div' ? "dividera med..." : "multiplicera med...";
                return op === 'div' ? "dividing by..." : "multiplying by...";
            };

            qData.description = {
                sv: `${opStr(scenario.op)} ${scenario.val} √§r samma sak som att ${targetOpStr(scenario.equivOp)}`,
                en: `${opStr(scenario.op)} ${scenario.val} is the same as ${targetOpStr(scenario.equivOp)}`
            };

            qData.answerType = 'multiple_choice';
            qData.choices = [10, 100, 1000, 0.1, 0.01, 0.001].map(String); // Ensure strings for MC comparison
            qData.answer = String(scenario.equivVal);

            // Clue
            const fraction = scenario.equivVal < 1 ? `1/${1/scenario.equivVal}` : `1/${1/scenario.equivVal}`; // e.g. 1/10
            steps.push({
                text: t(lang, { 
                    sv: "T√§nk p√• br√•kformen. Att dividera med ett tal √§r samma som att multiplicera med dess invers.",
                    en: "Think about fractions. Dividing by a number is the same as multiplying by its inverse."
                }),
                latex: ""
            });
        }

        // --- LEVEL 3: 0.1, 0.01, 0.001 Calculations ---
        else {
            const power = rng.pick([0.1, 0.01, 0.001]);
            const isMult = rng.intBetween(0, 1) === 1;
            
            // Pick a number
            const num = rng.intBetween(2, 900);
            
            // Determine zeros for explanation (0.1 -> 1 step, 0.01 -> 2 steps)
            let stepsCount = 0;
            if (power === 0.1) stepsCount = 1;
            else if (power === 0.01) stepsCount = 2;
            else stepsCount = 3;

            let answer = 0;

            if (isMult) {
                // Mult by 0.1 = Div by 10 = Left shift
                answer = fixFloat(num * power);
                qData.latex = `${num} \\cdot ${power} =`;
                
                const direction = lang === 'sv' ? "v√§nster" : "left";
                steps.push({
                    text: t(lang, {
                        sv: `Att multiplicera med ${power} √§r samma som att dividera med ${1/power}. Flytta kommatecknet ${stepsCount} steg √•t ${direction}.`,
                        en: `Multiplying by ${power} is the same as dividing by ${1/power}. Move the decimal ${stepsCount} steps to the ${direction}.`
                    }),
                    latex: `${num} / ${1/power} = ${formatColor(answer)}`
                });
            } else {
                // Div by 0.1 = Mult by 10 = Right shift
                answer = fixFloat(num / power);
                qData.latex = `${num} / ${power} =`;

                const direction = lang === 'sv' ? "h√∂ger" : "right";
                steps.push({
                    text: t(lang, {
                        sv: `Att dividera med ${power} √§r samma som att multiplicera med ${1/power}. Flytta kommatecknet ${stepsCount} steg √•t ${direction}.`,
                        en: `Dividing by ${power} is the same as multiplying by ${1/power}. Move the decimal ${stepsCount} steps to the ${direction}.`
                    }),
                    latex: `${num} \\cdot ${1/power} = ${formatColor(answer)}`
                });
            }

            qData.description = { sv: "Ber√§kna.", en: "Calculate." };
            qData.answer = answer;
        }

        return {
            questionId: `ten-l${level}-${seed}`,
            renderData: {
                text_key: "ten_powers",
                description: qData.description,
                latex: qData.latex,
                answerType: qData.answerType,
                choices: qData.choices,
                variables: {}
            },
            serverData: {
                answer: qData.answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGenerator.ts
// =======================================================

import { GeneratedQuestion, Clue } from "../types/generator";
import { Random } from "../utils/random";
import { TERMS, t, Language } from "../utils/i18n";

export class VolumeGenerator {
    public static generate(level: number, seed: string, lang: Language = 'sv', multiplier: number = 1): GeneratedQuestion {
        const rng = new Random(seed);
        const formatColor = (val: string | number) => `\\textcolor{#D35400}{\\mathbf{${val}}}`;
        const piApprox = 3.14;

        // Helper to constrain values preventing extreme aspect ratios
        const getConstrainedValues = (count: number, min: number, max: number): number[] => {
            const vals: number[] = [];
            for(let i = 0; i < count; i++) vals.push(rng.intBetween(min, max));
            return vals;
        };

        let mode = level;
        const isUnitConversion = level === 7;
        if (level >= 6) mode = rng.intBetween(1, 5); 

        const UNITS = [
            { id: 'mm', factor: 0.001 },
            { id: 'cm', factor: 0.01 },
            { id: 'dm', factor: 0.1 },
            { id: 'm', factor: 1.0 }
        ];

        let qData: any = { answer: 0, description: "", latex: "", answerType: "numeric" };
        let geometry: any = undefined;
        let steps: Clue[] = [];

        // --- LEVEL 1: Prisms & Cubes ---
        if (mode === 1) {
            const isCube = rng.intBetween(0, 1) === 1;
            const s = (val: number) => Math.round(val * multiplier);
            
            if (isCube) {
                const side = rng.intBetween(s(2), s(10));
                qData.answer = Math.pow(side, 3);
                qData.description = { sv: "Ber√§kna volymen (Kub).", en: "Calculate the volume (Cube)." };
                geometry = { type: 'cuboid', labels: { w: side, h: side, d: side } };
                
                steps.push({ text: t(lang, { sv: "Volym = sida ¬∑ sida ¬∑ sida", en: "Volume = side ¬∑ side ¬∑ side" }), latex: "V = s^3" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `${side}^3 = ${formatColor(qData.answer)}` });
            } else {
                const [w, h, d] = getConstrainedValues(3, s(3), s(10));
                qData.answer = w * h * d;
                qData.description = { sv: "Ber√§kna volymen (R√§tblock).", en: "Calculate the volume (Rectangular Prism)." };
                geometry = { type: 'cuboid', labels: { w: w, h: h, d: d } };

                steps.push({ text: t(lang, { sv: "Volym = Bredd ¬∑ H√∂jd ¬∑ Djup", en: "Volume = Width ¬∑ Height ¬∑ Depth" }), latex: "V = b \\cdot h \\cdot d" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `${w} \\cdot ${h} \\cdot ${d} = ${formatColor(qData.answer)}` });
            }
        }

        // --- LEVEL 2: Triangular Prism ---
        else if (mode === 2) {
            const b = rng.intBetween(3, 10);
            const hTri = rng.intBetween(3, 8);
            const len = rng.intBetween(5, 15);
            
            const areaBase = (b * hTri) / 2;
            qData.answer = areaBase * len;
            qData.description = { sv: "Ber√§kna volymen.", en: "Calculate the volume." };
            geometry = { type: 'triangular_prism', b: b, h_tri: hTri, len: len, labels: { b: b, h: hTri, l: len } };

            steps.push({ text: t(lang, { sv: "1. R√§kna ut basytan (triangeln).", en: "1. Calculate base area (triangle)." }), latex: `A = \\frac{${b} \\cdot ${hTri}}{2} = ${areaBase}` });
            steps.push({ text: t(lang, { sv: "2. Multiplicera med l√§ngden.", en: "2. Multiply by the length." }), latex: `${areaBase} \\cdot ${len} = ${formatColor(qData.answer)}` });
        }

        // --- LEVEL 3: Cylinder ---
        else if (mode === 3) {
            const r = rng.intBetween(2, 6);
            const h = rng.intBetween(5, 15);
            const areaBase = piApprox * r * r;
            qData.answer = Math.round(areaBase * h * 10) / 10;
            
            // Randomly show radius or diameter
            const showDiameter = rng.intBetween(0, 1) === 1;
            const d = r * 2;
            
            qData.description = { sv: "Ber√§kna volymen (avrunda till 1 decimal).", en: "Calculate the volume (round to 1 decimal)." };
            geometry = { 
                type: 'cylinder', 
                labels: { r: r, h: h, val: showDiameter ? `d=${d}` : `r=${r}` }, 
                show: showDiameter ? 'diameter' : 'radius' 
            };

            if (showDiameter) {
                steps.push({ text: t(lang, { sv: "Radien √§r h√§lften av diametern.", en: "Radius is half the diameter." }), latex: `r = ${d}/2 = ${r}` });
            }
            steps.push({ text: t(lang, { sv: "Volym = Basytan ¬∑ H√∂jden", en: "Volume = Base Area ¬∑ Height" }), latex: "V = \\pi r^2 \\cdot h" });
            steps.push({ text: t(lang, TERMS.common.calculate), latex: `3.14 \\cdot ${r}^2 \\cdot ${h} \\approx ${formatColor(qData.answer)}` });
        }

        // --- LEVEL 4: Pyramid & Cone ---
        else if (mode === 4) {
            const isCone = rng.intBetween(0, 1) === 1;
            const h = rng.intBetween(5, 15);
            
            if (isCone) {
                const r = rng.intBetween(3, 8);
                const baseArea = piApprox * r * r;
                qData.answer = Math.round((baseArea * h / 3) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Kon).", en: "Calculate the volume (Cone)." };
                geometry = { type: 'cone', labels: { r: r, h: h, val: `r=${r}` }, show: 'radius' }; // Explicitly set show radius

                steps.push({ text: t(lang, { sv: "Volym = (Basytan ¬∑ H√∂jden) / 3", en: "Volume = (Base Area ¬∑ Height) / 3" }), latex: "V = \\frac{\\pi r^2 h}{3}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\frac{3.14 \\cdot ${r}^2 \\cdot ${h}}{3} \\approx ${formatColor(qData.answer)}` });
            } else {
                const side = rng.intBetween(4, 10);
                const baseArea = side * side;
                qData.answer = Math.round((baseArea * h / 3) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Pyramid med kvadratisk bas).", en: "Calculate volume (Square-based Pyramid)." };
                geometry = { type: 'pyramid', labels: { s: side, h: h } };

                steps.push({ text: t(lang, { sv: "Volym = (Basytan ¬∑ H√∂jden) / 3", en: "Volume = (Base Area ¬∑ Height) / 3" }), latex: "V = \\frac{s^2 \\cdot h}{3}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\frac{${side}^2 \\cdot ${h}}{3} \\approx ${formatColor(qData.answer)}` });
            }
        }

        // --- LEVEL 5: Sphere & Composite ---
        else if (mode === 5) {
            // Restore variety: Sphere, Hemisphere, Ice Cream, Silo
            const type = rng.pick(['sphere', 'hemisphere', 'ice_cream', 'silo']);
            const r = rng.intBetween(3, 8);
            const d = r * 2;
            const showDiameter = rng.intBetween(0, 1) === 1; // Randomize presentation
            
            const labelVal = showDiameter ? `d=${d}` : `r=${r}`;

            if (type === 'sphere') {
                qData.answer = Math.round((4 * piApprox * Math.pow(r, 3) / 3) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Klot).", en: "Calculate volume (Sphere)." };
                geometry = { type: 'sphere', labels: { val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                if (showDiameter) steps.push({ text: t(lang, { sv: "Radien √§r h√§lften av diametern.", en: "Radius is half the diameter." }), latex: `r = ${r}` });
                steps.push({ text: "Formel", latex: "V = \\frac{4 \\pi r^3}{3}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\frac{4 \\cdot 3.14 \\cdot ${r}^3}{3} \\approx ${formatColor(qData.answer)}` });
            }
            else if (type === 'hemisphere') {
                const sphereVol = (4 * piApprox * Math.pow(r, 3) / 3);
                qData.answer = Math.round((sphereVol / 2) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Halvklot).", en: "Calculate volume (Hemisphere)." };
                geometry = { type: 'hemisphere', labels: { val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                steps.push({ text: t(lang, { sv: "R√§kna ut volymen f√∂r ett helt klot och dela med 2.", en: "Calc volume for full sphere and divide by 2." }), latex: "V = \\frac{4 \\pi r^3}{3} \\cdot \\frac{1}{2}" });
                steps.push({ text: t(lang, TERMS.common.calculate), latex: `\\approx ${formatColor(qData.answer)}` });
            }
            else if (type === 'ice_cream') {
                // Cone + Hemisphere
                const hCone = rng.intBetween(r + 2, r * 3);
                const volCone = (piApprox * r * r * hCone) / 3;
                const volHemi = (4 * piApprox * Math.pow(r, 3) / 3) / 2;
                qData.answer = Math.round((volCone + volHemi) * 10) / 10;
                qData.description = { sv: "Ber√§kna totala volymen.", en: "Calculate total volume." };
                geometry = { type: 'ice_cream', labels: { h: hCone, val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                steps.push({ text: t(lang, { sv: "Total = Kon + Halvklot", en: "Total = Cone + Hemisphere" }), latex: "" });
                steps.push({ text: "Kon", latex: `V_{kon} = \\frac{\\pi \\cdot ${r}^2 \\cdot ${hCone}}{3} \\approx ${Math.round(volCone)}` });
                steps.push({ text: "Halvklot", latex: `V_{halv} \\approx ${Math.round(volHemi)}` });
                steps.push({ text: "Summa", latex: `${Math.round(volCone)} + ${Math.round(volHemi)} \\approx ${formatColor(qData.answer)}` });
            }
            else { // Silo
                // Cylinder + Hemisphere
                const hCyl = rng.intBetween(r + 2, r * 3);
                const volCyl = piApprox * r * r * hCyl;
                const volHemi = (4 * piApprox * Math.pow(r, 3) / 3) / 2;
                qData.answer = Math.round((volCyl + volHemi) * 10) / 10;
                qData.description = { sv: "Ber√§kna volymen (Silo).", en: "Calculate volume (Silo)." };
                geometry = { type: 'silo', labels: { h: hCyl, val: labelVal }, show: showDiameter ? 'd' : 'r' };
                
                steps.push({ text: t(lang, { sv: "Total = Cylinder + Halvklot", en: "Total = Cylinder + Hemisphere" }), latex: "" });
                steps.push({ text: "Cylinder", latex: `V_{cyl} = \\pi \\cdot ${r}^2 \\cdot ${hCyl} \\approx ${Math.round(volCyl)}` });
                steps.push({ text: "Halvklot", latex: `V_{halv} \\approx ${Math.round(volHemi)}` });
                steps.push({ text: "Summa", latex: `${formatColor(qData.answer)}` });
            }
        }

        // --- LEVEL 7: Unit Conversion (Volume) ---
        else if (isUnitConversion) {
            // e.g. Convert 2 m^3 to dm^3
            // Scale factor k=10 -> Volume factor k^3 = 1000
            
            const unitInIdx = rng.intBetween(1, 3); // cm, dm, m
            const unitOutIdx = unitInIdx - 1; // Step down (larger number)
            
            const unitIn = UNITS[unitInIdx];
            const unitOut = UNITS[unitOutIdx];
            const k = 10;
            const volRatio = 1000;

            const val = rng.intBetween(1, 10);
            qData.answer = val * volRatio;
            
            const uVol = (u: string) => `${u}^3`;
            
            qData.description = { 
                sv: `Omvandla ${val} ${uVol(unitIn.id)} till ${uVol(unitOut.id)}.`, 
                en: `Convert ${val} ${uVol(unitIn.id)} to ${uVol(unitOut.id)}.` 
            };
            
            // To make the visual interesting, show a cube with side 1 unit vs 10 smaller units
            geometry = { 
                type: 'cuboid', 
                labels: { w: `1${unitIn.id}`, h: `1${unitIn.id}`, d: `1${unitIn.id}` } 
            };
            
            const originalAns = qData.answer;
            const convertedAns = Math.round(originalAns * volRatio * 1000) / 1000;
            
            qData.answer = convertedAns;
            qData.description = { 
                sv: `Svara i enheten ${uVol(unitOut.id)}. (Nuvarande m√•tt i ${unitIn.id})`, 
                en: `Answer in ${uVol(unitOut.id)}. (Current dims in ${unitIn.id})` 
            };

            steps.push({
                text: t(lang, { sv: "Omvandla enheterna. Volymskalan √§r l√§ngdskalan upph√∂jt till 3.", en: "Convert units. Volume scale is length scale cubed." }), 
                latex: `1 \\text{ ${uVol(unitIn.id)}} = ${volRatio} \\text{ ${uVol(unitOut.id)}}`
            });
            steps.push({
                text: t(lang, { sv: "Multiplicera resultatet med omvandlingsfaktorn.", en: "Multiply result by conversion factor." }),
                latex: `${originalAns} \\cdot ${volRatio} = ${formatColor(convertedAns)}`
            });
        }

        return {
            questionId: `vol-l${level}-${seed}`,
            renderData: {
                text_key: "vol_calc",
                description: qData.description,
                latex: "",
                answerType: "numeric",
                geometry: geometry,
                variables: {}
            },
            serverData: {
                answer: qData.answer,
                solutionSteps: steps
            }
        };
    }
}

// FILE END: src\core\generators\VolumeGenerator.ts

// =======================================================
// FILE START: src\core\interfaces\Generator.ts
// =======================================================

export interface QuestionData {
    text?: string;
    renderData?: any; // Preferred
    visual?: any;     // Legacy
    answer: string | number;
    clues: string[];
}

export interface Generator {
    /**
     * Generates a new question.
     * @param level Difficulty level (1-9)
     * @param lang Language code ('sv' | 'en')
     */
    generate(level: number, lang: string): QuestionData;

    /**
     * Optional: Custom validation logic for answers.
     * @param userAnswer The user's input
     * @param systemAnswer The generated correct answer
     */
    validate?(userAnswer: string, systemAnswer: string): boolean;
}

// FILE END: src\core\interfaces\Generator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 5,
        volume: 7,
        graph: 5,
        similarity: 4 // UPDATED to 4
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export const UI_STRINGS = {
    sv: {
        // --- General UI ---
        submit: "Svara",
        next: "N√§sta fr√•ga",
        correct: "R√§tt!",
        incorrect: "Inte riktigt, f√∂rs√∂k igen",
        try_again: "F√∂rs√∂k igen",
        score: "Po√§ng",
        streak: "Svit",
        level: "Niv√•",
        loading: "Laddar...",
        error: "Fel vid laddning",
        dashboard_title: "V√§lj omr√•de att √∂va p√•",
        backBtn: "Meny",
        history: "Historik",
        noHistory: "Inga svar √§n.",
        btnHint: "Ledtr√•d",
        btnSolution: "Visa l√∂sning",
        btnSkip: "Hoppa √∂ver",
        placeholder: "Skriv ditt svar...",
        hintsTitle: "Ledtr√•dar",
        clueUsed: "Hj√§lp",
        donow: "Startuppgift",
        donow_title: "Uppstart (Do Now)",
        donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
        donow_gen: "Generera",
        donow_show_all: "Visa alla",
        donow_hide_all: "D√∂lj alla",
        aboutBtn: "Om skaparen",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Aritmetik",
            negative: "Negativa Tal",
            simplification: "F√∂renkling",
            linear_eq: "Ekvationer",
            linear_eq_prob: "Probleml√∂sning",
            geometry: "Geometri",
            volume: "Volym & Area",
            similarity: "Likformighet",
            scale: "Skala",
            linear_graph: "R√§ta Linjen",
            ten_powers: "Tiopotenser"
        },

        // --- Math Vocabulary (Common) ---
        common: {
            calculate: "Ber√§kna",
            equation: "Ekvation",
            simplify: "F√∂renkla",
            solve: "L√∂s ut x",
            evaluate: "Ber√§kna",
            find_k: "Best√§m k-v√§rdet",
            find_m: "Best√§m m-v√§rdet",
            find_equation: "Best√§m linjens ekvation",
            match_graph: "Vilken ekvation h√∂r till grafen?",
            determine_equation: "Best√§m ekvationen f√∂r linjen som g√•r genom:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Ber√§kna summan",
            sub: "Ber√§kna differensen",
            mul: "Ber√§kna produkten",
            div: "Ber√§kna kvoten",
            mixed: "Ber√§kna",
            missing_term: "Hitta det saknade talet"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Vi har ekvationen: $${eq}$`,
            multiply: (k: any) => `Multiplicera b√•da sidor med $${k}$ f√∂r att bli av med divisionen.`,
            divide: (k: any) => `Dividera b√•da sidor med $${k}$ f√∂r att f√• $x$ ensamt.`,
            add: (k: any) => `Addera $${k}$ p√• b√•da sidor.`,
            subtract: (k: any) => `Subtrahera $${k}$ p√• b√•da sidor.`,
            distribute: (k: any) => `Multiplicera in $${k}$ i parentesen.`,
            sub_var: (term: string) => `Subtrahera $${term}$ fr√•n b√•da sidor f√∂r att samla $x$ p√• en sida.`,
            collect: "Samla lika termer",
            expand: "Utveckla parentesen",
            factorise: "Faktorisera uttrycket",
            substitute: "Ers√§tt och ber√§kna"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Att addera ett negativt tal √§r samma som subtraktion.",
            sub_neg: "Tv√• minus blir plus (‚Äì ‚Äì blir +).",
            mul_neg_neg: "Minus g√•nger minus blir plus.",
            mul_pos_neg: "Plus g√•nger minus blir minus.",
            div_sign_same: "Lika tecken ger positivt svar.",
            div_sign_diff: "Olika tecken ger negativt svar.",
            simple_calc: "Ber√§kna:", 
            step_calc: "Ber√§kna:",
            plus_plus: "Positivt + Positivt",
            plus_minus: "Positivt + Negativt",
            minus_plus: "Negativt + Positivt",
            minus_minus: "Negativt - Negativt",
            mixed: "Blandat",
            multiplication: "Multiplikation",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "Best√§m m-v√§rdet (d√§r linjen sk√§r y-axeln).", en: "Find the intercept (m)." },
            q_slope: { sv: "Best√§m k-v√§rdet (lutningen).", en: "Find the slope (k)." },
            q_func: { sv: "Best√§m linjens ekvation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Titta p√• grafen: Var sk√§r linjen y-axeln (d√§r $x=0$)?",
            step_intercept: (m:any) => `Linjen sk√§r y-axeln vid $y = ${m}$.`,
            step_delta: "Lutningen $k$ √§r skillnaden i $y$ delat med skillnaden i $x$.",
            step_slope_calc: "R√§kna rutor: Hur mycket √§ndras $y$ n√§r vi g√•r 1 steg √•t h√∂ger?",
            find_m: "Hitta m-v√§rdet (sk√§rning med y-axeln).",
            find_k: "Hitta k-v√§rdet (lutningen).",
            parallel: "Best√§m lutningen f√∂r en linje som √§r parallell med:",
            perpendicular: "Best√§m lutningen f√∂r en linje som √§r vinkelr√§t mot:",
            find_gradient: "Ber√§kna lutningen (k)",
            find_intercept: "Hitta y-axelsk√§rningen (m)"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Skala",
            real: "Verklig str√§cka",
            map_dist: "Avst√•nd p√• kartan",
            ratio: "Skala",
            problem_map_to_real: "Ber√§kna det verkliga avst√•ndet.",
            problem_real_to_map: "Ber√§kna avst√•ndet p√• kartan.",
            problem_find_scale: "Best√§m kartans skala.",
            reduction: "F√∂rminskning",
            enlargement: "F√∂rstoring",
            reality: "Verkligheten",
            drawing: "Bilden",
            rule_reduction: "N√§r skalan √§r 1:X √§r bilden mindre √§n verkligheten.",
            rule_enlargement: "N√§r skalan √§r X:1 √§r bilden st√∂rre √§n verkligheten.",
            step_plug_in: "S√§tt in v√§rdena i formeln: $\\frac{\\text{Bild}}{\\text{Verklighet}}$",
            calc_cm: "R√§kna f√∂rst ut det i cm.",
            conv_m: "Omvandla till meter (1 m = 100 cm).",
            conv_same: "Se till att b√•da m√•tten har samma enhet.",
            setup_ratio: "St√§ll upp f√∂rh√•llandet Bild : Verklighet.",
            step_simplify: "F√∂renkla br√•ket.",
            calc_area_img: "Ber√§kna bildens area.",
            calc_area_real: "Ber√§kna verklighetens area.",
            calc_area_scale: "Areaskalan √§r l√§ngdskalan i kvadrat."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "L√∂s ekvationen och ber√§kna $x$.",
            task_write: "Skriv en ekvation som beskriver situationen (du beh√∂ver inte l√∂sa den).",
            clue_var: "L√•t $x$ vara det vi s√∂ker.",
            clue_total: "S√§tt uttrycket lika med totalen.",
            expl_rate_val: "Pris per styck g√•nger antal.",
            expl_fixed_val: "L√§gg till den fasta avgiften.",
            expl_item_cost: "Kostnaden f√∂r varorna innan rabatt.",
            expl_discount_sub: "Subtrahera rabatten.",
            expl_person1: "Person 1 har $x$.",
            expl_person2_more: "Person 2 har mer.",
            expl_person2_less: "Person 2 har mindre.",
            expl_compare_sum: "Summan av b√•da √§r totalen.",
            a_buy: { sv: "Du k√∂per $a$ st {item} f√∂r $x$ kr/st och en p√•se f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $a$ {item} for $x$ kr each and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "En taxiresa kostar $b$ kr i startavgift och $a$ kr per km. Resan kostar totalt $c$ kr. Hur m√•nga km ($x$) √•kte du?", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "Du k√∂per $a$ st {item} som kostar $x$ kr/st. Du har en rabattkupong p√• $b$ kr. Du betalar totalt $c$ kr.", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "{name1} och {name2} samlar p√• {item}. {name2} har $a$ fler √§n {name1}. Tillsammans har de $c$ st. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "{name1} och {name2} har $c$ {item} tillsammans. {name2} har $b$ f√§rre √§n {name1}. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Ber√§kna arean",
            perimeter: "Ber√§kna omkretsen",
            circumference: "Ber√§kna omkretsen",
            volume: "Ber√§kna volymen",
            surface_area: "Ber√§kna begr√§nsningsarean",
            similarity: "Likformighet",
            scale_factor: "Hitta skalfaktorn (k)",
            missing_side: "Ber√§kna den saknade sidan",
            shape: "Figur",
            cube: "Kub",
            cuboid: "R√§tblock",
            cylinder: "Cylinder",
            sphere: "Klot",
            cone: "Kon",
            triangle: "Triangel",
            rectangle: "Rektangel",
            circle: "Cirkel",
            parallelogram: "Parallellogram",
            trapezium: "Trapets"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplikation med tiopotenser",
            div: "Division med tiopotenser",
            standard_form: "Grundpotensform",
            prefix: "Prefix"
        },

        // --- Shapes ---
        shapes: {
            square: "kvadrat",
            rectangle: "rektangel",
            circle: "cirkel",
            triangle: "triangel",
            rhombus: "romb",
            parallelogram: "parallellogram",
            pentagon: "femh√∂rning",
            hexagon: "sexh√∂rning",
            octagon: "√•ttah√∂rning",
            star: "stj√§rna",
            arrow: "pil",
            heart: "hj√§rta",
            cross: "kors",
            lightning: "blixt",
            kite: "drake",
            cube: "kub",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "kon",
            sphere: "klot"
        },
        shapes_plural: {
            rectangle: "rektanglar",
            triangle: "trianglar",
            circle: "cirklar",
            semicircle: "halvcirklar",
            parallelogram: "parallellogram"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    },

    en: {
        // --- General UI ---
        submit: "Submit Answer",
        next: "Next Question",
        correct: "Correct!",
        incorrect: "Incorrect.",
        try_again: "Try Again",
        score: "Score",
        streak: "Streak",
        level: "Level",
        loading: "Loading...",
        error: "Error loading question",
        dashboard_title: "Choose a topic to practice",
        backBtn: "Menu",
        history: "History",
        noHistory: "No answers yet.",
        btnHint: "Hint",
        btnSolution: "Show Solution",
        btnSkip: "Skip",
        placeholder: "Enter your answer...",
        hintsTitle: "Hints",
        clueUsed: "Clue",
        donow: "Do Now",
        donow_title: "Do Now Activity",
        donow_desc: "Select up to 3 levels. System generates 6 questions total.",
        donow_gen: "Generate",
        donow_show_all: "Show All",
        donow_hide_all: "Hide All",
        aboutBtn: "About",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Arithmetic",
            negative: "Negative Numbers",
            simplification: "Simplification",
            linear_eq: "Linear Equations",
            linear_eq_prob: "Equation Problems",
            geometry: "Geometry",
            volume: "Volume & Surface Area",
            similarity: "Similarity",
            scale: "Scale & Maps",
            linear_graph: "Linear Graphs",
            ten_powers: "Powers of 10"
        },

        // --- Math Vocabulary ---
        common: {
            calculate: "Calculate",
            equation: "Equation",
            simplify: "Simplify",
            solve: "Solve for x",
            evaluate: "Evaluate",
            find_k: "Find the gradient (k)",
            find_m: "Find the y-intercept (m)",
            find_equation: "Find the equation of the line",
            match_graph: "Which equation matches the graph?",
            determine_equation: "Determine the equation of the line passing through:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Calculate the sum",
            sub: "Calculate the difference",
            mul: "Calculate the product",
            div: "Calculate the quotient",
            mixed: "Evaluate the expression",
            missing_term: "Find the missing number"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Equation: $${eq}$`,
            multiply: (k: any) => `Multiply both sides by $${k}$ to remove the division.`,
            divide: (k: any) => `Divide both sides by $${k}$ to isolate $x$.`,
            add: (k: any) => `Add $${k}$ to both sides.`,
            subtract: (k: any) => `Subtract $${k}$ from both sides.`,
            distribute: (k: any) => `Distribute $${k}$ into the parentheses.`,
            sub_var: (term: string) => `Subtract $${term}$ from both sides to collect $x$ on one side.`,
            collect: "Collect like terms",
            expand: "Expand the brackets",
            factorise: "Factorise the expression",
            substitute: "Substitute and evaluate"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Adding a negative number is the same as subtraction.",
            sub_neg: "Subtracting a negative number is the same as addition (‚Äì ‚Äì becomes +).",
            mul_neg_neg: "Negative times negative becomes positive.",
            mul_pos_neg: "Positive times negative becomes negative.",
            div_sign_same: "Same signs give a positive result.",
            div_sign_diff: "Different signs give a negative result.",
            simple_calc: "Calculate:",
            step_calc: "Calculate:",
            plus_plus: "Positive + Positive",
            plus_minus: "Positive + Negative",
            minus_plus: "Negative + Positive",
            minus_minus: "Negative - Negative",
            mixed: "Mixed",
            multiplication: "Multiplication",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "", en: "Find the intercept (m)." },
            q_slope: { sv: "", en: "Find the slope (k)." },
            q_func: { sv: "", en: "Find the line equation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Look at the graph: Where does the line cross the y-axis (where $x=0$)?",
            step_intercept: (m:any) => `The line crosses the y-axis at $y = ${m}$.`,
            step_delta: "The slope $k$ is the change in $y$ divided by the change in $x$.",
            step_slope_calc: "Count squares: How much does $y$ change when we go 1 step to the right?",
            find_m: "Find the m-value (y-intercept).",
            find_k: "Find the k-value (slope).",
            parallel: "Find the slope of a line parallel to:",
            perpendicular: "Find the slope of a line perpendicular to:",
            find_gradient: "Calculate the gradient",
            find_intercept: "Find the intercept"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Map Scale",
            real: "Real Distance",
            map_dist: "Map Distance",
            ratio: "Ratio",
            problem_map_to_real: "Calculate the real world distance.",
            problem_real_to_map: "Calculate the distance on the map.",
            problem_find_scale: "Determine the scale of the map.",
            reduction: "Reduction",
            enlargement: "Enlargement",
            reality: "Reality",
            drawing: "Drawing",
            rule_reduction: "When the scale is 1:X, the image is smaller than reality.",
            rule_enlargement: "When the scale is X:1, the image is larger than reality.",
            step_plug_in: "Insert the values into the formula: $\\frac{\\text{Image}}{\\text{Reality}}$",
            calc_cm: "Calculate it in cm first.",
            conv_m: "Convert to meters (1 m = 100 cm).",
            conv_same: "Ensure both measurements have the same unit.",
            setup_ratio: "Set up the ratio Image : Reality.",
            step_simplify: "Simplify the fraction.",
            calc_area_img: "Calculate the area of the image.",
            calc_area_real: "Calculate the area of reality.",
            calc_area_scale: "The area scale is the length scale squared."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "Solve the equation and calculate $x$.",
            task_write: "Write an equation that describes the situation (you don't need to solve it).",
            clue_var: "Let $x$ be what we are looking for.",
            clue_total: "Set the expression equal to the total.",
            expl_rate_val: "Price per item times quantity.",
            expl_fixed_val: "Add the fixed fee.",
            expl_item_cost: "The cost of items before discount.",
            expl_discount_sub: "Subtract the discount.",
            expl_person1: "Person 1 has $x$.",
            expl_person2_more: "Person 2 has more.",
            expl_person2_less: "Person 2 has less.",
            expl_compare_sum: "The sum of both is the total.",
            a_buy: { sv: "", en: "You buy $a$ {item} for $x$ kr/st and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Calculate the Area",
            perimeter: "Calculate the Perimeter",
            circumference: "Calculate the Circumference",
            volume: "Calculate the Volume",
            surface_area: "Calculate the Surface Area",
            similarity: "Similarity",
            scale_factor: "Find the Scale Factor",
            missing_side: "Find the missing side length",
            shape: "Shape",
            cube: "Cube",
            cuboid: "Rectangular Prism",
            cylinder: "Cylinder",
            sphere: "Sphere",
            cone: "Cone",
            triangle: "Triangle",
            rectangle: "Rectangle",
            circle: "Circle",
            parallelogram: "Parallelogram",
            trapezium: "Trapezium"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplication by powers of 10",
            div: "Division by powers of 10",
            standard_form: "Standard Form (Scientific Notation)",
            prefix: "Unit Prefixes"
        },

        // --- Shapes ---
        shapes: {
            square: "square",
            rectangle: "rectangle",
            circle: "circle",
            triangle: "triangle",
            rhombus: "rhombus",
            parallelogram: "parallellogram",
            pentagon: "pentagon",
            hexagon: "hexagon",
            octagon: "octagon",
            star: "star",
            arrow: "arrow",
            heart: "heart",
            cross: "cross",
            lightning: "lightning",
            kite: "kite",
            cube: "cube",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "cone",
            sphere: "sphere"
        },
        shapes_plural: {
            rectangle: "rectangles",
            triangle: "triangles",
            circle: "circles",
            semicircle: "semicircles",
            parallelogram: "parallelograms"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    }
};

export const TERMS = UI_STRINGS;

// Helper to handle both string and object keys safely
export function t(lang: Language, keyOrObj: string | { sv: string, en: string }): string {
    const l = (lang === 'en') ? 'en' : 'sv';
    
    // Check if input is a localized object {sv:..., en:...}
    if (typeof keyOrObj === 'object' && keyOrObj !== null) {
        // @ts-ignore
        return keyOrObj[l] || keyOrObj['sv'] || "";
    }
    
    // Check if input is a dot-notation string "geometry.area"
    if (typeof keyOrObj === 'string') {
        if (keyOrObj.includes('.')) {
            const keys = keyOrObj.split('.');
            let value: any = UI_STRINGS[l];
            for (const k of keys) {
                if (value && value[k]) {
                    value = value[k];
                } else {
                    return keyOrObj; // Return key if missing
                }
            }
            return typeof value === 'string' ? value : keyOrObj;
        }
        
        // Direct key lookup in UI root
        // @ts-ignore
        return UI_STRINGS[l][keyOrObj] || keyOrObj;
    }
    
    return String(keyOrObj);
}

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: src\index.css
// =======================================================

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
  -webkit-font-smoothing: antialiased;
  @apply bg-gray-50 text-gray-800;
}

/* Legacy Animations */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Custom Scrollbar from Legacy Code */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Print Styles for Do Now Grid */
.print-break-inside-avoid {
  break-inside: avoid;
}

/* Katex Adjustments */
.katex {
  font-size: 1.1em;
}

// FILE END: src\index.css

// =======================================================
// FILE START: src\main.jsx
// =======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// FILE END: src\main.jsx

// =======================================================
// FILE START: tailwind.config.js
// =======================================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Legacy Color Palette
        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
      },
      fontFamily: { 
        sans: ['Inter', 'sans-serif'] 
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      }
    },
  },
  plugins: [],
}

// FILE END: tailwind.config.js

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020", "DOM"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["api/**/*", "src/**/*"]
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/:match*", "destination": "/api/:match*" },
    { "source": "/(.*)", "destination": "/public/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json

// =======================================================
// FILE START: vite.config.js
// =======================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@core': path.resolve(__dirname, './src/core'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  }
})

// FILE END: vite.config.js
