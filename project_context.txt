PROJECT EXPORT GENERATED AT 2026-02-07T08:05:35.041Z

--- FILE STRUCTURE ---
api\answer.ts
api\batch.ts
api\curriculum.ts
api\debug.ts
api\question.ts
backup_UI.html
bundle_project.ts
dev-server.ts
index.html
package-lock.json
package.json
postcss.config.js
src\App.jsx
src\components\modals\AboutModal.jsx
src\components\modals\ContentModal.jsx
src\components\modals\LevelUpModal.jsx
src\components\modals\LgrModal.jsx
src\components\modals\StatsModal.jsx
src\components\modals\StreakModal.jsx
src\components\practice\CluePanel.jsx
src\components\practice\HistoryList.jsx
src\components\practice\MobileDrawer.jsx
src\components\ui\Button.jsx
src\components\ui\InputComponents.jsx
src\components\ui\MathText.jsx
src\components\views\Dashboard.jsx
src\components\views\DoNowConfig.jsx
src\components\views\DoNowGrid.jsx
src\components\views\PracticeView.jsx
src\components\visuals\AngleComponents.jsx
src\components\visuals\ComplexGeometry.jsx
src\components\visuals\GeometryComponents.jsx
src\components\visuals\GeometryShapes.jsx
src\components\visuals\GraphCanvas.jsx
src\components\visuals\PatternComponents.jsx
src\components\visuals\ProbabilityTree.jsx
src\components\visuals\ProbabilityVisuals.jsx
src\components\visuals\ScaleVisuals.jsx
src\components\visuals\SimpleTextLevel.jsx
src\components\visuals\StatisticsVisuals.jsx
src\components\visuals\VolumeVisualization.jsx
src\constants\content_map.js
src\constants\curriculum.js
src\constants\localization.js
src\core\generators\AnglesGen.ts
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ChangeFactorGen.ts
src\core\generators\ExponentsGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\FractionArithGen.ts
src\core\generators\FractionBasicsGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\PatternsGen.ts
src\core\generators\PercentGen.ts
src\core\generators\ProbabilityGen.ts
src\core\generators\PythagorasGen.ts
src\core\generators\ScaleGen.ts
src\core\generators\SimilarityGen.ts
src\core\generators\StatisticsGen.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGen.ts
src\core\interfaces\Generator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\MathUtils.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
src\index.css
src\main.jsx
tailwind.config.js
tsconfig.json
vercel.json
vite.config.js

==================================================


// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: "Method not allowed. Use POST." });
    }

    try {
        const { answer, token, streak = 0 } = req.body;

        if (!token) {
            return res.status(400).json({ error: "Missing token" });
        }

        // 1. Decode the correct answer from the Base64 token
        const correctAnswer = Buffer.from(token, 'base64').toString('utf-8');

        // 2. Normalize inputs for comparison
        // We remove spaces and convert to lowercase to be forgiving
        // e.g. "x + 5" should match "x+5"
        const normalize = (str: any) => String(str).toLowerCase().replace(/\s+/g, '').replace(',', '.');
        
        const userClean = normalize(answer);
        const correctClean = normalize(correctAnswer);

        const isCorrect = userClean === correctClean;

        let newStreak = streak;
        let levelUp = false;

        // 3. Update Streak Logic
        if (isCorrect) {
            newStreak++;
            // Propose level up every 8 correct answers
            if (newStreak > 0 && newStreak % 8 === 0) {
                levelUp = true;
            }
        } else {
            newStreak = 0;
        }

        return res.status(200).json({
            correct: isCorrect,
            correctAnswer, // Send back correct answer so UI can display it if wrong
            newStreak,
            levelUp
        });

    } catch (error) {
        console.error("Answer Validation Error:", error);
        return res.status(500).json({ error: "Validation failed." });
    }
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// IMPORTS
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExponentsGen } from '../src/core/generators/ExponentsGen.js';
import { PercentGen } from '../src/core/generators/PercentGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { PythagorasGen } from '../src/core/generators/PythagorasGen.js';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen.js';
import { StatisticsGen } from '../src/core/generators/StatisticsGen.js';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen.js';
import { FractionArithGen } from '../src/core/generators/FractionArithGen.js';
import { ChangeFactorGen } from '../src/core/generators/ChangeFactorGen.js';
import { AnglesGen } from '../src/core/generators/AnglesGen.js';
import { PatternsGen } from '../src/core/generators/PatternsGen.js';

interface VercelRequest extends IncomingMessage {
    body: any;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
};

const generators: any = {
    arithmetic: new BasicArithmeticGen(),
    negative: new NegativeNumbersGen(),
    ten_powers: new TenPowersGen(),
    exponents: new ExponentsGen(),
    percent: new PercentGen(),
    fraction_basics: new FractionBasicsGen(),
    fraction_arith: new FractionArithGen(),
    simplify: new ExpressionSimplificationGen(),
    equation: new LinearEquationGen(),
    graph: new LinearGraphGenerator(),
    geometry: new GeometryGenerator(),
    scale: new ScaleGen(),
    volume: new VolumeGen(),
    similarity: new SimilarityGen(),
    pythagoras: new PythagorasGen(),
    probability: new ProbabilityGen(),
    statistics: new StatisticsGen(),
    change_factor: new ChangeFactorGen(),
    angles: new AnglesGen(),
    patterns: new PatternsGen() // NY
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    const { requests } = req.body;

    if (!Array.isArray(requests)) {
        return res.status(400).json({ error: 'Invalid request format' });
    }

    try {
        const results = requests.map((req: any) => {
            if (!generators[req.category]) return null;
            return generators[req.category].generate(Number(req.level), req.lang);
        });
        res.status(200).json({ results });
    } catch (error) {
        console.error("Batch error:", error);
        res.status(500).json({ error: 'Batch generation failed' });
    }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang.",
      "F√∂rm√•ga att anv√§nda matematikens uttrycksformer f√∂r att samtala om, argumentera och redog√∂ra f√∂r fr√•gest√§llningar, ber√§kningar och slutsatser."
    ],

    // Centralt Inneh√•ll (Core Content)
    // Mapped to specific modules in the app
    centralt_innehall: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        modules: ["arithmetic", "negative", "ten_powers", "exponents", "percent", "fraction_basics", "fraction_arith"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.", // arithmetic
          "Talsystemets utveckling fr√•n naturliga tal till reella tal.", // negative
          "Tal i br√•k- och decimalform samt deras anv√§ndning i vardagliga och matematiska situationer.", // fraction_basics
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform.", // fraction_arith
          "Procent f√∂r att uttrycka f√∂r√§ndring och f√∂r√§ndringsfaktor samt ber√§kningar med procent i vardagliga situationer och i situationer inom olika √§mnesomr√•den.", // percent, change_factor
          "Potensform f√∂r att uttrycka sm√• och stora tal samt anv√§ndning av prefix." // ten_powers, exponents
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["simplify", "equation", "linear_graph"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.", // simplify
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Algebraiska m√∂nster och hur de kan beskrivas med uttryck.",
          "Metoder f√∂r ekvationsl√∂sning.", // equation
          "Funktioner och r√§ta linjens ekvation." // linear_graph
        ]
      },
      geometri: {
        category: "Geometri",
        modules: ["geometry", "scale", "volume", "similarity", "pythagoras","angles"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt. Skala vid f√∂rminskning och f√∂rstoring av en- och tv√•dimensionella objekt.", // scale
          "Likformighet och symmetri i planet.", // similarity
          "Geometriska satser och formler och behovet av argumentation f√∂r deras giltighet. Pythagoras sats.", // pythagoras
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta.", // geometry, volume
          "Vinkelbegreppet och vinkelm√§tning. Vinkelsumman i m√•ngh√∂rningar." // Vinklar
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"], // change_factor fits here too conceptually, but mapped to statistics in app structure
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      statistik: {
        category: "Sannolikhet och statistik",
        modules: ["probability", "statistics", "change_factor"], // Added change_factor here as requested
        content: [
          "Likformig sannolikhet och metoder f√∂r att ber√§kna sannolikhet i vardagliga situationer.", // probability
          "Tabeller och diagram f√∂r att beskriva resultat fr√•n unders√∂kningar.", // statistics
          "L√§gesm√•tt: medelv√§rde, median och typv√§rde.", // statistics
          "Spridningsm√•tt: variationsbredd.", // statistics
          "F√∂r√§ndringsfaktor och procentuella f√∂r√§ndringar." // change_factor
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"],
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\debug.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import fs from 'fs';
import path from 'path';

export default function handler(req: VercelRequest, res: VercelResponse) {
    try {
        // Look for the generators folder relative to this executing function
        const generatorsPath = path.join(process.cwd(), 'src/core/generators');
        
        let files: string[] = [];
        if (fs.existsSync(generatorsPath)) {
            files = fs.readdirSync(generatorsPath);
        } else {
            files = ["Generators folder not found at: " + generatorsPath];
        }

        res.status(200).json({
            status: "Debug Online",
            cwd: process.cwd(),
            foundFiles: files
        });
    } catch (error) {
        res.status(500).json({ error: String(error) });
    }
}

// FILE END: api\debug.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import { IncomingMessage, ServerResponse } from 'http';

// IMPORTS: Pointing to ../src/core/generators/ with .js extension for Vercel/ESM
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExponentsGen } from '../src/core/generators/ExponentsGen.js';
import { PercentGen } from '../src/core/generators/PercentGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { PythagorasGen } from '../src/core/generators/PythagorasGen.js';
import { ProbabilityGen } from '../src/core/generators/ProbabilityGen.js';
import { StatisticsGen } from '../src/core/generators/StatisticsGen.js';
import { FractionBasicsGen } from '../src/core/generators/FractionBasicsGen.js';
import { FractionArithGen } from '../src/core/generators/FractionArithGen.js';
import { ChangeFactorGen } from '../src/core/generators/ChangeFactorGen.js';
import { AnglesGen } from '../src/core/generators/AnglesGen.js'; 
import { PatternsGen } from '../src/core/generators/PatternsGen.js';

interface VercelRequest extends IncomingMessage {
    body: any;
    query: Partial<{ [key: string]: string | string[] }>;
}

type VercelResponse = ServerResponse & {
    status: (statusCode: number) => VercelResponse;
    json: (data: any) => VercelResponse;
    send: (data: any) => VercelResponse;
};

// Instantiate generators
const graphGen = new LinearGraphGenerator();

const generators: any = {
    arithmetic: new BasicArithmeticGen(),
    negative: new NegativeNumbersGen(),
    ten_powers: new TenPowersGen(),
    exponents: new ExponentsGen(),
    percent: new PercentGen(),
    fraction_basics: new FractionBasicsGen(),
    fraction_arith: new FractionArithGen(),
    simplify: new ExpressionSimplificationGen(),
    equation: new LinearEquationGen(),
    
    // FIX: Map both 'graph' and 'linear_graph' to the same generator
    graph: graphGen,
    linear_graph: graphGen, 

    geometry: new GeometryGenerator(),
    scale: new ScaleGen(),
    volume: new VolumeGen(),
    similarity: new SimilarityGen(),
    pythagoras: new PythagorasGen(),
    probability: new ProbabilityGen(),
    statistics: new StatisticsGen(),
    change_factor: new ChangeFactorGen(),
    angles: new AnglesGen(),
    patterns: new PatternsGen()
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Handling
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,POST');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    // Handle both GET (query) and POST (body)
    const body = req.body || {};
    const query = req.query || {};

    // Normalize parameters (Frontend uses 'topic', API uses 'category')
    const category = body.category || body.topic || query.category || query.topic;
    const level = body.level || query.level;
    const lang = body.lang || query.lang || 'sv';

    // Debug log
    console.log(`[API] Generating: ${category} Level ${level} (${lang})`);

    if (!category) {
        return res.status(400).json({ error: "Missing 'topic' or 'category' parameter" });
    }

    if (!generators[category]) {
        return res.status(400).json({ error: `Generator not found: ${category}` });
    }

    try {
        const question = generators[category].generate(Number(level), String(lang));
        res.status(200).json(question);
    } catch (error) {
        console.error(`[API] Generation error for ${category}:`, error);
        res.status(500).json({ error: 'Generation failed', details: String(error) });
    }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: dev-server.ts
// =======================================================

import express, { Request, Response } from 'express';
import cors from 'cors';
import { register } from 'tsconfig-paths';
import path from 'path';

// 1. Register Path Aliases (@core/*) from tsconfig
// This ensures the backend logic can find files in src/core
import tsConfig from './tsconfig.json' assert { type: "json" };

const baseUrl = path.resolve(process.cwd(), tsConfig.compilerOptions.baseUrl || '.');
const cleanup = register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths,
});

// 2. Import API Handlers
// We import these AFTER registering paths so they resolve correctly
import questionHandler from './api/question';
import answerHandler from './api/answer';
import curriculumHandler from './api/curriculum';

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// 3. Vercel -> Express Adapter
// Vercel functions are (req, res) => void, which matches Express,
// but we wrap them to ensure errors are caught.
const adapter = (handler: any) => async (req: Request, res: Response) => {
    try {
        await handler(req, res);
    } catch (err) {
        console.error("API Error:", err);
        res.status(500).json({ error: 'Internal Server Error', details: String(err) });
    }
};

// 4. Define Routes
// These must match the filenames in your /api folder
app.get('/api/question', adapter(questionHandler));
app.post('/api/answer', adapter(answerHandler));
app.get('/api/curriculum', adapter(curriculumHandler));

// 5. Start Server
app.listen(PORT, () => {
    console.log(`\nüöÄ Backend Simulation running at http://localhost:${PORT}`);
    console.log(`   - /api/question`);
    console.log(`   - /api/answer`);
    console.log(`   - /api/curriculum`);
    console.log(`\nüé® Frontend running at http://localhost:5173 (Proxy active)\n`);
});

// FILE END: dev-server.ts

// =======================================================
// FILE START: index.html
// =======================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <title>Anpassa | Math Platform</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// FILE END: index.html

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"vite\"",
    "dev:frontend": "vite",
    "dev:server": "tsx watch dev-server.ts",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "katex": "^0.16.9",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vercel/node": "^5.5.28",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.7.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.6"
  }
}


// FILE END: package.json

// =======================================================
// FILE START: postcss.config.js
// =======================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// FILE END: postcss.config.js

// =======================================================
// FILE START: src\App.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import Dashboard from './components/views/Dashboard';
import PracticeView from './components/views/PracticeView';
import DoNowConfig from './components/views/DoNowConfig';
import DoNowGrid from './components/views/DoNowGrid';
import AboutModal from './components/modals/AboutModal';
import LgrModal from './components/modals/LgrModal';
import StatsModal from './components/modals/StatsModal';
import StreakModal from './components/modals/StreakModal'; 
import ContentModal from './components/modals/ContentModal'; 
import MobileDrawer from './components/practice/MobileDrawer';
import { UI_TEXT, CATEGORIES, LEVEL_DESCRIPTIONS } from './constants/localization';

function App() {
    const [view, setView] = useState('dashboard');
    const [lang, setLang] = useState('sv');
    const [topic, setTopic] = useState('');
    const [level, setLevel] = useState(0);

    const [question, setQuestion] = useState(null);
    const [input, setInput] = useState('');
    const [feedback, setFeedback] = useState(null);
    const [loading, setLoading] = useState(false);

    // Session Stats
    const [streak, setStreak] = useState(0);
    const [totalCorrect, setTotalCorrect] = useState(0);
    const [sessionStats, setSessionStats] = useState({
        attempted: 0,
        correctNoHelp: 0,
        correctHelp: 0,
        incorrect: 0,
        skipped: 0,
        maxStreak: 0
    });
    
    const [granularStats, setGranularStats] = useState({});
    const [history, setHistory] = useState([]);
    const [revealedClues, setRevealedClues] = useState([]);
    const [levelUpAvailable, setLevelUpAvailable] = useState(false);
    
    // Modals State
    const [aboutOpen, setAboutOpen] = useState(false);
    const [statsOpen, setStatsOpen] = useState(false);
    const [timeUpOpen, setTimeUpOpen] = useState(false);
    const [lgrOpen, setLgrOpen] = useState(false);
    const [contentOpen, setContentOpen] = useState(false); 
    const [showStreakModal, setShowStreakModal] = useState(false);
    // REMOVED: showTotalModal state
    const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);

    // Do Now State
    const [doNowQuestions, setDoNowQuestions] = useState([]);
    const [doNowConfig, setDoNowConfig] = useState([]); 

    const [usedHelp, setUsedHelp] = useState(false);
    const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);

    // Timer State
    const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

    const ui = UI_TEXT[lang];

    // Timer Logic
    useEffect(() => {
        let interval = null;
        if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
            interval = setInterval(() => {
                setTimerSettings(prev => {
                    if (prev.remaining <= 1) {
                        clearInterval(interval);
                        setTimeUpOpen(true);
                        return { ...prev, remaining: 0, isActive: false };
                    }
                    return { ...prev, remaining: prev.remaining - 1 };
                });
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [timerSettings.isActive, view, timerSettings.remaining]);

    const toggleTimer = (minutes) => {
        const seconds = minutes * 60;
        setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
    };

    const resetTimer = () => {
        setTimerSettings({ duration: 0, remaining: 0, isActive: false });
    };

    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    };

    useEffect(() => {
        if (streak > sessionStats.maxStreak) {
            setSessionStats(prev => ({ ...prev, maxStreak: streak }));
        }
    }, [streak]);

    const fetchQuestion = async (t = topic, l = level, lg = lang, force = false) => {
        // Guard: Don't fetch if a blocking modal is open
        if (!force && (showStreakModal || levelUpAvailable || timeUpOpen)) return;
        if (!t || !l) return;
        
        setLoading(true);
        setFeedback(null);
        setInput('');
        setRevealedClues([]);
        setUsedHelp(false);
        setIsSolutionRevealed(false);
        setLevelUpAvailable(false);
        
        try {
            const timestamp = new Date().getTime();
            const res = await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}${force ? `&force=true&t=${timestamp}` : ''}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            setQuestion(data);
        } catch (e) {
            console.error(e);
            setQuestion(null);
        } finally {
            setLoading(false);
        }
    };

    const startPractice = () => {
        if (topic && level) {
            setStreak(0);
            setView('practice');
            if (timerSettings.duration > 0) {
                setTimerSettings(prev => ({ ...prev, isActive: true }));
            }
            fetchQuestion(topic, level, lang);
        }
    };

    const quitPractice = () => {
        setStreak(0);
        setView('dashboard');
        setQuestion(null);
    };

    // --- DO NOW LOGIC ---
    const handleDoNowGenerate = async (selected) => {
        if (selected.length === 0) return;
        setDoNowConfig(selected);
        setLoading(true);
        
        const requests = [];
        const targetCount = Math.max(selected.length, 6);
        
        for (let i = 0; i < targetCount; i++) {
            const selection = selected[i % selected.length];
            requests.push({
                category: selection.topic,
                level: selection.level,
                lang: lang
            });
        }

        try {
            const res = await fetch('/api/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ requests })
            });
            const data = await res.json();
            
            if (data.results && Array.isArray(data.results)) {
                const validQuestions = data.results.filter(q => q !== null);
                setDoNowQuestions(validQuestions);
                setView('donow_grid');
            }
        } catch (e) {
            console.error("Do Now Generation Error:", e);
        } finally {
            setLoading(false);
        }
    };

    const handleRefreshAll = async () => {
        if (doNowConfig.length > 0) {
            await handleDoNowGenerate(doNowConfig);
        }
    };

    const handleRefreshOne = async (index, topic, level) => {
        try {
            const timestamp = new Date().getTime();
            const res = await fetch(`/api/question?category=${topic}&level=${level}&lang=${lang}&force=true&t=${timestamp}`);
            const newQuestion = await res.json();
            if (newQuestion.error) throw new Error(newQuestion.error);

            setDoNowQuestions(prev => {
                const copy = [...prev];
                copy[index] = newQuestion;
                return copy;
            });
        } catch (e) {
            console.error("Single refresh failed", e);
        }
    };

    // --- GAMEPLAY HANDLERS ---
    const handleSelection = (t, l) => { setTopic(t); setLevel(l); };

    const handleHint = () => {
        if (question?.clues) {
            setUsedHelp(true);
            const currentLen = revealedClues.length;
            if (currentLen < question.clues.length) {
                setRevealedClues([...revealedClues, question.clues[currentLen]]);
            }
        }
    };

    // UPDATED: Now registers as incorrect answer when clicked
    const handleSolution = () => {
        if (question?.clues) {
            setUsedHelp(true);
            setRevealedClues(question.clues);
            
            // STATS CHANGE: Register as incorrect if not already revealed/locked
            if (!isSolutionRevealed) {
                updateStats('incorrect');
                updateGranularStats(topic, level, 'incorrect');
            }

            setIsSolutionRevealed(true);
            setStreak(0);
        }
    };

    const updateStats = (type) => {
        setSessionStats(prev => ({
            ...prev,
            attempted: prev.attempted + 1,
            [type]: prev[type] + 1
        }));
    };

    const updateGranularStats = (topicId, levelId, resultType) => {
        setGranularStats(prev => {
            const topicData = prev[topicId] || {};
            const levelData = topicData[levelId] || { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 };
            return {
                ...prev,
                [topicId]: {
                    ...topicData,
                    [levelId]: {
                        ...levelData,
                        [resultType]: (levelData[resultType] || 0) + 1
                    }
                }
            };
        });
    };

    const handleSkip = () => {
        const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
        const historyText = question.renderData.latex || descText;
        setHistory(prev => [{ topic, level, correct: false, skipped: true, text: historyText, clueUsed: revealedClues.length > 0 || isSolutionRevealed, time: Date.now() }, ...prev]);
        setStreak(0);
        updateStats('skipped');
        updateGranularStats(topic, level, 'skipped');
        fetchQuestion(topic, level, lang);
    };

    const handleChangeLevel = (delta) => { 
        const newLevel = level + delta; 
        const max = Object.keys(LEVEL_DESCRIPTIONS[topic] || {}).length; 
        if (newLevel >= 1 && newLevel <= max) { 
            setLevel(newLevel); 
            fetchQuestion(topic, newLevel, lang, true); 
        } 
    };

    const handleSubmit = async (e, directInput) => {
        e.preventDefault();
        // Global Guard: If any blocking modal is open, ignore submission
        if (showStreakModal || timeUpOpen) return;
        if (feedback === 'correct') return;
        
        let finalInput = directInput !== undefined ? directInput : input;
        if (!question || !finalInput) return;

        // Capture lock state at moment of submission
        const isStatsLocked = isSolutionRevealed;
        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        try {
            const res = await fetch('/api/answer', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ 
                    answer: finalInput, 
                    token: question.token, 
                    streak: streak, 
                    level: level, 
                    topic: topic, 
                    usedHelp: helpUsed, 
                    solutionUsed: isSolutionRevealed, 
                    attempts: question.attempts 
                }) 
            });
            const result = await res.json();
            const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
            const historyText = question.renderData.latex || descText;

            if (result.correct) {
                // LOCK CHECK: Only update stats if solution was NOT revealed
                if (!isStatsLocked) {
                    setHistory(prev => [{ topic, level, correct: true, text: historyText, clueUsed: helpUsed, time: Date.now() }, ...prev]);
                    setStreak(result.newStreak);
                    
                    if (!helpUsed) {
                        updateStats('correctNoHelp');
                        updateGranularStats(topic, level, 'correctNoHelp');
                    } else {
                        updateStats('correctHelp');
                        updateGranularStats(topic, level, 'correctHelp');
                    }

                    const newTotal = totalCorrect + 1;
                    setTotalCorrect(newTotal);

                    // --- MILESTONE LOGIC (No Total Modal) ---
                    const isStreakMilestone = [15, 20, 30, 40, 50].includes(result.newStreak);

                    if (isStreakMilestone) {
                        setShowStreakModal(true);
                        // Waiting for modal close.
                    } else if (result.levelUp) {
                        setLevelUpAvailable(true);
                        // Waiting for user choice in LevelUpModal.
                    } else {
                        // Standard flow: Auto-advance
                        setTimeout(() => {
                            // Using a boolean flag logic here is safer than checking state in timeout
                            fetchQuestion(topic, level, lang);
                        }, 1500);
                    }
                }
                setFeedback('correct');
            } else {
                // Incorrect Logic
                question.attempts = (question.attempts || 0) + 1;
                if (question.attempts >= 2) {
                    
                    // Add to history BEFORE calling handleSolution (which locks stats)
                    if (!isStatsLocked) {
                        setHistory(prev => [{
                            topic, level, correct: false, text: historyText, clueUsed: true, correctAnswer: result.correctAnswer || "See Solution", time: Date.now()
                        }, ...prev]);
                    }

                    // This will now trigger the stats update ('incorrect') and reveal the solution UI
                    handleSolution(); 
                    
                } else {
                    handleHint();
                }
                setFeedback('incorrect');
                setStreak(0);
            }
        } catch (e) { console.error(e); }
    };

    const toggleLang = () => setLang(prev => prev === 'sv' ? 'en' : 'sv');

    // RENDER LOGIC
    if (view === 'donow_config') {
        return <div className="min-h-screen bg-gray-50 font-sans"><DoNowConfig ui={ui} lang={lang} onBack={() => setView('dashboard')} onGenerate={handleDoNowGenerate} /></div>;
    }
    if (view === 'donow_grid') {
        return (
            <DoNowGrid 
                questions={doNowQuestions} 
                ui={ui} 
                onBack={() => setView('donow_config')} 
                lang={lang} 
                onRefreshAll={handleRefreshAll}
                onRefreshOne={handleRefreshOne}
            />
        );
    }

    return (
        <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
            <AboutModal visible={aboutOpen} onClose={() => setAboutOpen(false)} ui={ui} />
            <LgrModal visible={lgrOpen} onClose={() => setLgrOpen(false)} ui={ui} />
            <ContentModal visible={contentOpen} onClose={() => setContentOpen(false)} /> 
            
            <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} ui={ui} />
            <StatsModal visible={statsOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setStatsOpen(false)} title={ui.stats_title} />
            <StatsModal visible={timeUpOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setTimeUpOpen(false)} title={ui.stats_times_up} />
            <StreakModal visible={showStreakModal} onClose={() => setShowStreakModal(false)} streak={streak} ui={ui} />

            <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                    <div className="flex items-center gap-4">
                        <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                        {view === 'dashboard' && timerSettings.remaining > 0 && (
                            <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                <span>‚è∏ {ui.timer_paused}</span>
                                <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                            </div>
                        )}
                    </div>
                    <div className="flex items-center gap-3">
                        <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>
                        <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>
                        <button onClick={toggleLang} className="px-3 py-1 rounded-md text-xs font-bold border border-slate-200 bg-white text-slate-600 hover:bg-slate-50 transition-all shadow-sm flex items-center gap-1.5" title={lang === 'sv' ? "Byt spr√•k" : "Switch Language"}>
                            <span className="text-sm">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span><span>{lang === 'sv' ? 'SE' : 'ENG'}</span>
                        </button>
                        <button onClick={() => setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                        </button>
                        <button onClick={() => setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                    </div>
                </div>
            </header>

            <div className="flex-1 flex flex-col">
                {view === 'dashboard' ? (
                    <Dashboard
                        lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice} timerSettings={timerSettings} toggleTimer={toggleTimer} resetTimer={resetTimer} ui={ui} 
                        onLgrOpen={() => setLgrOpen(true)} 
                        onContentOpen={() => setContentOpen(true)} 
                        onDoNowOpen={() => setView('donow_config')} 
                        toggleLang={toggleLang}
                    />
                ) : (
                    <PracticeView
                        lang={lang} 
                        ui={ui} 
                        question={question} 
                        loading={loading} 
                        feedback={feedback} 
                        streak={streak} 
                        input={input} 
                        setInput={setInput} 
                        handleSubmit={handleSubmit} 
                        handleHint={handleHint} 
                        handleSolution={handleSolution} 
                        handleSkip={handleSkip} 
                        handleChangeLevel={handleChangeLevel} 
                        revealedClues={revealedClues} 
                        uiState={{ history, topic, level }} 
                        actions={{ retry: (force) => fetchQuestion(topic, level, lang, force), goBack: quitPractice }} 
                        levelUpAvailable={levelUpAvailable} 
                        setLevelUpAvailable={setLevelUpAvailable} 
                        isSolutionRevealed={isSolutionRevealed} 
                        timerSettings={timerSettings} 
                        formatTime={formatTime} 
                        setMobileHistoryOpen={setMobileHistoryOpen}
                    />
                )}
            </div>
        </div>
    );
}

export default App;

// FILE END: src\App.jsx

// =======================================================
// FILE START: src\components\modals\AboutModal.jsx
// =======================================================

import React from 'react';

const AboutModal = ({ visible, onClose, ui }) => {
    if (!visible) return null;
    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1">‚úï</button>

                <div className="mb-4 flex justify-center">
                    <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100">
                        <img
                            src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                            alt="Creator"
                            className="w-full h-full object-cover"
                        />
                    </div>
                </div>

                <div className="text-center mb-6">
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                    <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                    <hr className="my-4 border-gray-200" />
                    <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" /></svg>
                        {ui.contactLink}
                    </a>
                </div>
            </div>
        </div>
    );
};

export default AboutModal;

// FILE END: src\components\modals\AboutModal.jsx

// =======================================================
// FILE START: src\components\modals\ContentModal.jsx
// =======================================================

import React from 'react';
import { CONTENT_MAP } from '../../constants/content_map';

const ContentModal = ({ visible, onClose }) => {
    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-4xl max-h-[85vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden animate-bounce-in border border-slate-200">
                
                {/* Header */}
                <div className="bg-slate-50 border-b border-slate-200 p-6 flex justify-between items-center shrink-0">
                    <div>
                        <h2 className="text-2xl font-black text-slate-800 tracking-tight">Inneh√•llsf√∂rteckning</h2>
                        <p className="text-slate-500 text-sm mt-1">√ñversikt √∂ver alla omr√•den och niv√•er</p>
                    </div>
                    <button 
                        onClick={onClose} 
                        className="w-10 h-10 flex items-center justify-center rounded-full bg-white border border-slate-200 text-slate-400 hover:text-slate-700 hover:border-slate-300 transition-all text-xl font-bold"
                    >
                        ‚úï
                    </button>
                </div>

                {/* Scrollable Content */}
                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
                    <div className="space-y-12">
                        {Object.entries(CONTENT_MAP).map(([catKey, category]) => (
                            <div key={catKey}>
                                <h3 className="text-xl font-bold text-slate-900 uppercase tracking-widest border-b-2 border-slate-100 pb-2 mb-6">
                                    {category.title}
                                </h3>
                                
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    {category.topics.map(topic => (
                                        <div key={topic.id} className="bg-slate-50 rounded-xl p-5 border border-slate-100 hover:border-indigo-100 transition-colors">
                                            <h4 className="font-bold text-indigo-700 mb-4 flex items-center gap-2">
                                                <span className="w-2 h-2 rounded-full bg-indigo-500"></span>
                                                {topic.title}
                                            </h4>
                                            
                                            <div className="space-y-3">
                                                {topic.levels.map(lvl => (
                                                    <div key={lvl.lvl} className="flex items-start gap-3 text-sm">
                                                        <div className="font-mono font-bold text-slate-400 bg-white px-2 py-0.5 rounded border border-slate-200 text-xs mt-0.5">
                                                            {lvl.lvl}
                                                        </div>
                                                        <div>
                                                            <div className="font-semibold text-slate-700">{lvl.desc}</div>
                                                            <div className="text-slate-500 text-xs italic mt-0.5">Ex: {lvl.ex}</div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Footer */}
                <div className="bg-slate-50 border-t border-slate-200 p-4 flex justify-end shrink-0">
                    <button 
                        onClick={onClose} 
                        className="px-6 py-2 bg-slate-800 hover:bg-slate-900 text-white rounded-lg font-bold text-sm transition-colors"
                    >
                        St√§ng
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ContentModal;

// FILE END: src\components\modals\ContentModal.jsx

// =======================================================
// FILE START: src\components\modals\LevelUpModal.jsx
// =======================================================

import React from 'react';

const LevelUpModal = ({ visible, ui, onNext, onStay, lang }) => {
    if (!visible) return null;

    // Robust Fallback Logic: Ensure text exists even if UI keys are missing
    // We use the 'lang' prop to determine the default language
    const currentLang = lang || 'sv'; 
    
    const defaultTitle = currentLang === 'sv' ? "Niv√• upp?" : "Level Up?";
    const defaultDesc = currentLang === 'sv' 
        ? "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?" 
        : "You seem to know this! Do you want to skip to the next level?";
    const defaultYes = currentLang === 'sv' ? "Ja, k√∂r!" : "Yes, let's go!";
    const defaultNo = currentLang === 'sv' ? "Nej, stanna h√§r" : "No, stay here";

    const title = ui?.levelUpTitle || defaultTitle;
    const desc = ui?.levelUpDesc || defaultDesc;
    const btnYes = ui?.levelUpYes || defaultYes;
    const btnNo = ui?.levelUpNo || defaultNo;

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <div className="text-center mb-6">
                    <div className="text-5xl mb-4">üöÄ</div>
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{title}</h3>
                    <p className="text-gray-600">{desc}</p>
                </div>
                <div className="flex flex-col gap-3">
                    <button 
                        onClick={onNext} 
                        className="w-full py-4 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                    >
                        {btnYes}
                    </button>
                    <button 
                        onClick={onStay} 
                        className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95"
                    >
                        {btnNo}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default LevelUpModal;

// FILE END: src\components\modals\LevelUpModal.jsx

// =======================================================
// FILE START: src\components\modals\LgrModal.jsx
// =======================================================

import React, { useState, useEffect } from 'react';

const LgrModal = ({ visible, onClose, ui }) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (visible && !data) {
            setLoading(true);
            fetch('/api/curriculum')
                .then(res => res.json())
                .then(d => { setData(d); setLoading(false); })
                .catch(err => { console.error(err); setLoading(false); });
        }
    }, [visible, data]);

    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden animate-bounce-in">
                <div className="flex justify-between items-start mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                    <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600 transition-colors text-xl font-bold">‚úï</button>
                </div>

                <div className="flex-1 overflow-y-auto custom-scrollbar pr-2">
                    {loading ? (
                        <div className="flex justify-center items-center py-12">
                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-sky-600"></div>
                        </div>
                    ) : data ? (
                        <div className="space-y-8">
                            <p className="text-slate-600 italic border-l-4 border-sky-200 pl-4 py-1">{data.description}</p>
                            
                            {/* Syfte */}
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                <ul className="space-y-2">
                                    {data.syfte.map((item, i) => (
                                        <li key={i} className="flex gap-3 text-sm text-slate-700">
                                            <span className="text-sky-500 font-bold">‚Ä¢</span>
                                            {item}
                                        </li>
                                    ))}
                                </ul>
                            </div>

                            {/* Centralt Inneh√•ll */}
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Centralt Inneh√•ll (√•k 7-9)</h4>
                                <div className="grid gap-6">
                                    {/* FIX: Changed data.mapping to data.centralt_innehall */}
                                    {data.centralt_innehall && Object.entries(data.centralt_innehall).map(([key, section]) => (
                                        <div key={key} className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                            <h5 className="font-bold text-slate-900 mb-2 text-sm">{section.category}</h5>
                                            <ul className="list-disc pl-5 space-y-1 text-xs text-slate-600">
                                                {section.content.map((c, i) => <li key={i}>{c}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                    )}
                </div>

                <div className="mt-6 pt-4 border-t border-slate-100 text-center shrink-0">
                    <a href="https://www.skolverket.se" target="_blank" rel="noreferrer" className="text-xs text-sky-600 hover:underline">K√§lla: Skolverket (Lgr22)</a>
                </div>
            </div>
        </div>
    );
};

export default LgrModal;

// FILE END: src\components\modals\LgrModal.jsx

// =======================================================
// FILE START: src\components\modals\StatsModal.jsx
// =======================================================

import React from 'react';
import { CATEGORIES } from '../../constants/localization';

const LevelBreakdown = ({ granularStats, ui, lang }) => {
    const topics = Object.keys(granularStats);
    if (topics.length === 0) return null;

    return (
        <div className="mt-6 border-t border-gray-100 pt-4 w-full">
            <h4 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-4">
                {ui.level_breakdown}
            </h4>
            <div className="space-y-4">
                {topics.map(topicKey => {
                    const topicLevels = granularStats[topicKey];
                    const levels = Object.keys(topicLevels).sort((a, b) => Number(a) - Number(b));

                    let topicLabel = topicKey;
                    for (const catKey in CATEGORIES) {
                        const found = CATEGORIES[catKey].topics.find(t => t.id === topicKey);
                        if (found) {
                            topicLabel = found.label[lang];
                            break;
                        }
                    }

                    return (
                        <div key={topicKey} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                            <h5 className="font-bold text-gray-700 text-sm mb-2 capitalize">{topicLabel}</h5>
                            <div className="space-y-2">
                                {levels.map(lvl => {
                                    const stats = topicLevels[lvl];
                                    const total = stats.skipped + stats.incorrect + stats.correctHelp + stats.correctNoHelp;
                                    if (total === 0) return null;

                                    const pSkip = (stats.skipped / total) * 100;
                                    const pWrong = (stats.incorrect / total) * 100;
                                    const pHelp = (stats.correctHelp / total) * 100;
                                    const pCorrect = (stats.correctNoHelp / total) * 100;
                                    const unassistedPct = Math.round(pCorrect);

                                    return (
                                        <div key={lvl} className="flex flex-col gap-1 mb-3 last:mb-0">
                                            <div className="flex justify-between items-center text-xs font-medium text-gray-500 mb-1">
                                                <span>{lang === 'sv' ? 'Niv√•' : 'Level'} {lvl}</span>
                                            </div>
                                            <div className="flex w-full h-3 rounded-full overflow-hidden bg-gray-200">
                                                {pSkip > 0 && <div style={{ width: `${pSkip}%` }} className="bg-gray-400" />}
                                                {pWrong > 0 && <div style={{ width: `${pWrong}%` }} className="bg-red-500" />}
                                                {pHelp > 0 && <div style={{ width: `${pHelp}%` }} className="bg-yellow-400" />}
                                                {pCorrect > 0 && <div style={{ width: `${pCorrect}%` }} className="bg-green-500" />}
                                            </div>
                                            <div className="flex flex-wrap gap-x-3 text-[10px] text-gray-500 mt-1">
                                                <span className="text-gray-500 font-semibold">{ui.stat_skip}: {stats.skipped}</span>
                                                <span className="text-red-600 font-semibold">{ui.stat_wrong}: {stats.incorrect}</span>
                                                <span className="text-yellow-600 font-semibold">{ui.stat_help}: {stats.correctHelp}</span>
                                                <span className="text-green-600 font-semibold">{ui.stat_correct}: {stats.correctNoHelp}</span>
                                            </div>
                                            <div className="text-[10px] text-gray-400 italic">
                                                {ui.stat_total}: {total} ({unassistedPct}% unassisted)
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const StatsModal = ({ visible, stats, granularStats, ui, onClose, title, lang }) => {
    if (!visible) return null;
    const attemptCount = stats.attempted || 0;
    const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

    return (
        <div className="fixed inset-0 z-[100] flex sm:items-center justify-center sm:p-4 bg-white sm:bg-black/50 sm:backdrop-blur-sm fade-in">
            <div className="bg-white w-full h-full sm:h-auto sm:max-h-[90vh] sm:rounded-2xl sm:shadow-2xl sm:max-w-md p-6 relative flex flex-col sm:border-4 sm:border-blue-500 overflow-y-auto custom-scrollbar">
                <div className="flex justify-between items-center mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-gray-900">{title || ui.stats_title}</h3>
                    <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 sm:hidden">‚úï</button>
                </div>

                <div className="shrink-0 grid grid-cols-2 gap-4 text-left text-sm mb-6">
                    <div className="text-gray-500">{ui.stats_longest_streak}</div>
                    <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                    <div className="text-gray-500">{ui.stats_attempted}</div>
                    <div className="font-bold text-right">{stats.attempted}</div>
                    <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                    <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_correct_help}</div>
                    <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_incorrect}</div>
                    <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                    <div className="text-gray-500">{ui.stats_skipped}</div>
                    <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                </div>

                <LevelBreakdown granularStats={granularStats} ui={ui} lang={lang} />

                <button onClick={onClose} className="mt-8 w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg shrink-0 hidden sm:block">
                    {ui.stats_close}
                </button>
            </div>
        </div>
    );
};

export default StatsModal;

// FILE END: src\components\modals\StatsModal.jsx

// =======================================================
// FILE START: src\components\modals\StreakModal.jsx
// =======================================================

import React from 'react';

const StreakModal = ({ visible, streak, ui, onClose }) => {
    if (!visible) return null;

    let icon = "ü•â";
    if (streak >= 50) icon = "üëë";
    else if (streak >= 40) icon = "üèÜ";
    else if (streak >= 30) icon = "ü•á";
    else if (streak >= 20) icon = "ü•à";
    else if (streak >= 15) icon = "ü•â";

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                <button 
                    onClick={onClose} 
                    className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                >
                    {ui.btn_close_streak}
                </button>
            </div>
        </div>
    );
};

export default StreakModal;

// FILE END: src\components\modals\StreakModal.jsx

// =======================================================
// FILE START: src\components\practice\CluePanel.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const CluePanel = ({ revealedClues, question, ui, isSolutionRevealed }) => {
    if (!revealedClues || revealedClues.length === 0) return null;

    // We need the total count to identify which clue is the "final" one
    const totalCluesCount = question.clues ? question.clues.length : 0;

    return (
        <div className="bg-orange-50 border border-orange-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
            <div className="flex items-center gap-2 mb-4 text-orange-800 font-bold border-b border-orange-200 pb-2">
                <span>üí° {ui.hintsTitle} ({revealedClues.length}/{totalCluesCount})</span>
            </div>
            <div className="space-y-6">
                {revealedClues.map((clue, i) => {
                    // Identify if this is the absolute last clue in the sequence
                    const isTheFinalClue = i === totalCluesCount - 1;
                    
                    // RESTORED LOGIC: 
                    // Hide the latex box for the final clue unless the solution is unlocked.
                    // This forces the student to perform the final step themselves.
                    const showLatex = !isTheFinalClue || isSolutionRevealed;

                    return (
                        <div key={i} className="group animate-slide-down">
                            {/* 1. Text Description (Always shown) */}
                            <div className="text-sm text-orange-900 mb-2 font-medium leading-relaxed">
                                <MathText text={clue.text} />
                            </div>
                            
                            {/* 2. Math Box (Conditional) */}
                            {clue.latex && showLatex && (
                                <div className="bg-white p-3 rounded-lg border border-orange-200 text-center shadow-sm overflow-x-auto mt-2">
                                    <MathText text={`$${clue.latex}$`} large={true} />
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default CluePanel;

// FILE END: src\components\practice\CluePanel.jsx

// =======================================================
// FILE START: src\components\practice\HistoryList.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const HistoryList = ({ history, ui }) => {
    return (
        <div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                <h2 className="font-bold text-gray-700">{ui.history}</h2>
                <span className="text-xs text-gray-400">{history.length}</span>
            </div>
            <div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px] custom-scrollbar">
                {history.length === 0 ? (
                    <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>
                ) : (
                    history.map((entry, i) => (
                        <div 
                            key={i} 
                            className={`p-3 rounded-lg border-l-4 text-sm ${
                                entry.correct 
                                    ? 'border-emerald-500 bg-emerald-50' 
                                    : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')
                            }`}
                        >
                            <div className="flex justify-between items-start mb-1">
                                <span className="font-semibold capitalize text-gray-700">
                                    {entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span>
                                </span>
                                <span className="text-xs text-gray-400">
                                    {new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                            </div>
                            
                            <div className="text-gray-600 mb-1 line-clamp-2">
                                <MathText text={entry.text} />
                            </div>

                            {!entry.correct && !entry.skipped && entry.correctAnswer && (
                                <div className="text-xs text-red-600 mt-1 font-medium">
                                    <MathText text={`Correct: ${entry.correctAnswer}`} />
                                </div>
                            )}

                            <div className="mt-2">
                                {entry.clueUsed && (
                                    <span className="inline-block px-1.5 py-0.5 bg-orange-100 text-orange-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">
                                        {ui.clueUsed}
                                    </span>
                                )} 
                                <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${
                                    entry.correct 
                                        ? 'bg-emerald-100 text-emerald-700' 
                                        : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')
                                }`}>
                                    {entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}
                                </span>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default HistoryList;

// FILE END: src\components\practice\HistoryList.jsx

// =======================================================
// FILE START: src\components\practice\MobileDrawer.jsx
// =======================================================

import React from 'react';
import HistoryList from './HistoryList';

const MobileDrawer = ({ open, onClose, history, ui }) => {
    return (
        <>
            {open && <div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}
            <div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}>
                <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                    <h2 className="font-bold text-gray-700">{ui.history}</h2>
                    <button onClick={onClose} className="text-gray-400">‚úï</button>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                    <HistoryList history={history} ui={ui} />
                </div>
            </div>
        </>
    );
};

export default MobileDrawer;

// FILE END: src\components\practice\MobileDrawer.jsx

// =======================================================
// FILE START: src\components\ui\Button.jsx
// =======================================================

import React from 'react';

export const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  className = '', 
  disabled = false,
  fullWidth = false 
}) => {
  const baseStyles = "px-4 py-2 rounded-lg font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-math-blue text-white hover:bg-blue-600 focus:ring-math-blue shadow-sm",
    secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500",
    success: "bg-math-green text-white hover:bg-green-600 focus:ring-math-green shadow-sm",
    danger: "bg-math-red text-white hover:bg-red-600 focus:ring-math-red shadow-sm",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
    >
      {children}
    </button>
  );
};

// FILE END: src\components\ui\Button.jsx

// =======================================================
// FILE START: src\components\ui\InputComponents.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

// =====================================================================
// FRACTION INPUT COMPONENT
// =====================================================================
export const FractionInput = ({ value, onChange, allowMixed = false, autoFocus = false }) => {
    const wholeRef = useRef(null);
    const numRef = useRef(null);
    const denRef = useRef(null);

    // Safe parsing of the value
    let w = "", n = "", d = "";
    const strVal = value || "";

    if (strVal.includes(' ')) {
        const parts = strVal.split(' ');
        w = parts[0];
        if (parts[1] && parts[1].includes('/')) {
            [n, d] = parts[1].split('/');
        } else {
            n = parts[1] || "";
        }
    } else if (strVal.includes('/')) {
        [n, d] = strVal.split('/');
    } else {
        n = strVal;
    }

    const update = (newW, newN, newD) => {
        let res = "";
        if (newW) {
            res += newW;
            if (newN || newD) res += " ";
        }
        if (newN || newD) {
            res += `${newN}/${newD}`;
        }
        onChange(res);
    };

    // Auto-focus logic
    useEffect(() => {
        if (autoFocus) {
            if (allowMixed) wholeRef.current?.focus();
            else numRef.current?.focus();
        }
    }, [autoFocus, allowMixed]);

    return (
        <div className="inline-flex items-center gap-2 font-mono text-xl text-slate-800">
            {allowMixed && (
                <input
                    ref={wholeRef}
                    className="w-12 h-14 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                    value={w}
                    onChange={(e) => update(e.target.value, n, d)}
                    placeholder="0"
                />
            )}
            <div className="flex flex-col items-center gap-1">
                <input
                    ref={numRef}
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={n}
                    onChange={(e) => update(w, e.target.value, d)}
                    placeholder="n"
                />
                <div className="w-full h-0.5 bg-slate-800 rounded-full"></div>
                <input
                    ref={denRef}
                    className="w-12 h-10 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white"
                    value={d}
                    onChange={(e) => update(w, n, e.target.value)}
                    placeholder="d"
                />
            </div>
        </div>
    );
};

// =====================================================================
// EXPONENT INPUT COMPONENT
// =====================================================================
export const ExponentInput = ({ value, onChange, autoFocus = false }) => {
    const baseRef = useRef(null);
    const expRef = useRef(null);

    let base = "", exp = "";
    const strVal = value || "";
    
    if (strVal.includes('^')) {
        [base, exp] = strVal.split('^');
    } else {
        base = strVal;
    }

    const update = (newBase, newExp) => {
        if (newExp) onChange(`${newBase}^${newExp}`);
        else onChange(newBase);
    };

    useEffect(() => {
        if (autoFocus) baseRef.current?.focus();
    }, [autoFocus]);

    return (
        <div className="inline-flex items-start font-mono text-xl text-slate-800 pt-4">
            <input
                ref={baseRef}
                className="w-16 h-12 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-2xl"
                value={base}
                onChange={(e) => update(e.target.value, exp)}
                placeholder="x"
            />
            <input
                ref={expRef}
                className="w-10 h-8 text-center border-2 border-slate-300 rounded focus:border-blue-500 focus:outline-none bg-white text-sm relative -top-3 ml-1 shadow-sm"
                value={exp}
                onChange={(e) => update(base, e.target.value)}
                placeholder="n"
            />
        </div>
    );
};

// FILE END: src\components\ui\InputComponents.jsx

// =======================================================
// FILE START: src\components\ui\MathText.jsx
// =======================================================

import React from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css'; // Ensure CSS is imported

const MathText = ({ text, className = "", large = false }) => {
    if (!text) return null;

    // 1. Patch common LaTeX color syntax differences if necessary
    const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');

    // 2. Split by $ delimiters
    const parts = patchedText.split(/(\$[^\$]+\$)/g);

    return (
        <span className={className}>
            {parts.map((part, index) => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const tex = part.slice(1, -1);
                    try {
                        const html = katex.renderToString(tex, { 
                            throwOnError: false, 
                            displayMode: large 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index} className="text-red-500">{part}</span>;
                    }
                } else if (part.includes('\\')) {
                    // Catch-all for stray LaTeX without $ delimiters (legacy support)
                    try {
                        const html = katex.renderToString(part, { 
                            throwOnError: false, 
                            displayMode: false 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index}>{part}</span>;
                    }
                }
                return <span key={index}>{part}</span>;
            })}
        </span>
    );
};

export default MathText;

// FILE END: src\components\ui\MathText.jsx

// =======================================================
// FILE START: src\components\views\Dashboard.jsx
// =======================================================

import React from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const COLOR_VARIANTS = {
    pink: {
        bgLight: 'bg-pink-50', bgDark: 'bg-pink-500', border: 'border-pink-100', text: 'text-pink-700', ring: 'ring-pink-500', borderSolid: 'border-pink-500', selectFocus: 'focus:ring-pink-500'
    },
    indigo: {
        bgLight: 'bg-indigo-50', bgDark: 'bg-indigo-500', border: 'border-indigo-100', text: 'text-indigo-700', ring: 'ring-indigo-500', borderSolid: 'border-indigo-500', selectFocus: 'focus:ring-indigo-500'
    },
    emerald: {
        bgLight: 'bg-emerald-50', bgDark: 'bg-emerald-500', border: 'border-emerald-100', text: 'text-emerald-700', ring: 'ring-emerald-500', borderSolid: 'border-emerald-500', selectFocus: 'focus:ring-emerald-500'
    },
    purple: {
        bgLight: 'bg-purple-50', bgDark: 'bg-purple-500', border: 'border-purple-100', text: 'text-purple-700', ring: 'ring-purple-500', borderSolid: 'border-purple-500', selectFocus: 'focus:ring-purple-500'
    },
    yellow: {
        bgLight: 'bg-yellow-50', bgDark: 'bg-yellow-500', border: 'border-yellow-100', text: 'text-yellow-700', ring: 'ring-yellow-500', borderSolid: 'border-yellow-500', selectFocus: 'focus:ring-yellow-500'
    }
};

const Dashboard = ({ 
    lang, 
    selectedTopic, 
    selectedLevel, 
    onSelect, 
    onStart, 
    timerSettings, 
    toggleTimer, 
    resetTimer, 
    ui, 
    onLgrOpen, 
    onContentOpen, // New Prop
    onDoNowOpen, 
    toggleLang 
}) => {
    
    const getStyles = (category) => {
        const color = category.color || 'emerald';
        return COLOR_VARIANTS[color] || COLOR_VARIANTS.emerald;
    };

    return (
        <div className="max-w-6xl mx-auto w-full p-4 fade-in flex flex-col min-h-[calc(100vh-80px)]">
            
            <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-emerald-50/50 rounded-3xl mx-4 relative overflow-hidden">
                <h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight relative z-10">Anpassa</h1>
                <p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide relative z-10">{ui.tagline}</p>

                <div className="mt-8 flex justify-center relative z-10">
                    <div className="bg-white/80 backdrop-blur-sm rounded-xl p-2 px-4 shadow-sm border border-gray-100 flex items-center gap-3">
                        <span className="font-bold text-gray-700 text-xs uppercase tracking-wider">{ui.timer_title}</span>
                        <div className="relative group">
                            <select
                                value={timerSettings.duration / 60}
                                onChange={(e) => toggleTimer(Number(e.target.value))}
                                className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-emerald-500 cursor-pointer"
                            >
                                <option value="0">{ui.timer_off}</option>
                                {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                            </select>
                            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                        </div>
                        {timerSettings.duration > 0 && (
                            <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                        )}
                    </div>
                </div>
            </div>

            <div className="text-center mb-10">
                <p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">
                {Object.entries(CATEGORIES).map(([catKey, category]) => {
                    const styles = getStyles(category);
                    
                    return (
                        <div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}>
                            <div className={`${styles.bgLight} p-4 border-b ${styles.border}`}>
                                <h3 className={`text-lg font-bold ${styles.text} uppercase tracking-wide flex items-center gap-2`}>
                                    <span className={`w-3 h-3 rounded-full ${styles.bgDark}`}></span>
                                    {category.label[lang]}
                                </h3>
                            </div>
                            
                            <div className="p-4 space-y-4 flex-1">
                                {category.topics.map(topic => {
                                    return (
                                        <div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                                            <div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div>
                                            <div className="relative">
                                                <select 
                                                    value={selectedTopic === topic.id ? selectedLevel : 0} 
                                                    onChange={(e) => onSelect(topic.id, Number(e.target.value))} 
                                                    className={`
                                                        w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none appearance-none cursor-pointer
                                                        ${selectedTopic === topic.id ? `ring-2 ${styles.ring} ${styles.borderSolid}` : styles.selectFocus}
                                                    `}
                                                >
                                                    <option value={0} disabled>{ui.selectLevel}</option>
                                                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                        if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                        return (
                                                            <option key={lvl} value={lvl}>
                                                                {lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang] || ""}
                                                            </option>
                                                        );
                                                    })}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" /></svg>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>

            <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20">
                <button 
                    onClick={onStart} 
                    className={`
                        px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 
                        ${selectedTopic 
                            ? 'bg-orange-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-orange-600 shadow-orange-200' 
                            : 'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}
                    `}
                >
                    {ui.startBtn} <span>üöÄ</span>
                </button>
            </div>

            <footer className="mt-auto py-6 border-t border-gray-200 flex flex-col md:flex-row justify-between items-center px-4 gap-4">
                <button onClick={onDoNowOpen} className="w-full md:w-auto bg-slate-800 hover:bg-slate-900 text-white font-bold py-2 px-6 rounded-full text-sm transition-colors shadow-sm order-2 md:order-1">
                    {ui.donow_btn}
                </button>

                <div className="flex items-center gap-3 order-1 md:order-2 w-full md:w-auto justify-center md:justify-end">
                    {/* NEW CONTENT BUTTON */}
                    <button onClick={onContentOpen} className="bg-emerald-100 hover:bg-emerald-200 text-emerald-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-emerald-200 shadow-sm">
                        Inneh√•ll
                    </button>
                    <button onClick={onLgrOpen} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-sky-200 shadow-sm">
                        {ui.lgr_btn}
                    </button>
                </div>
            </footer>
        </div>
    );
};

export default Dashboard;

// FILE END: src\components\views\Dashboard.jsx

// =======================================================
// FILE START: src\components\views\DoNowConfig.jsx
// =======================================================

import React, { useState } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const DoNowConfig = ({ ui, onBack, onGenerate, lang }) => {
    const [selected, setSelected] = useState([]);

    const handleToggle = (topicId, level) => {
        setSelected(prev => {
            const exists = prev.find(p => p.topic === topicId && p.level === level);
            if (exists) {
                return prev.filter(p => !(p.topic === topicId && p.level === level));
            } else {
                if (prev.length >= 3) return prev; // Max 3
                return [...prev, { topic: topicId, level }];
            }
        });
    };

    return (
        <div className="max-w-5xl mx-auto p-6 h-full flex flex-col">
            <div className="flex justify-between items-center mb-6">
                <button onClick={onBack} className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2">
                    <span>‚Üê</span> {ui.backBtn}
                </button>
                <h2 className="text-2xl font-bold text-slate-800">{ui.donow_title}</h2>
                <button
                    onClick={() => onGenerate(selected)}
                    disabled={selected.length === 0}
                    className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
                >
                    {ui.donow_gen} ({selected.length}/3)
                </button>
            </div>

            <p className="text-slate-500 mb-6 text-center">{ui.donow_desc}</p>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-6 overflow-y-auto custom-scrollbar pb-10">
                {Object.entries(CATEGORIES).map(([catKey, category]) => (
                    <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                        <h3 className="font-bold text-slate-700 mb-3 border-b pb-2">{category.label[lang]}</h3>
                        <div className="space-y-4">
                            {category.topics.map(topic => (
                                <div key={topic.id}>
                                    <div className="text-xs font-bold text-slate-400 uppercase mb-2">{topic.label[lang]}</div>
                                    <div className="flex flex-col gap-2">
                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                            if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                            const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);
                                            return (
                                                <button
                                                    key={lvl}
                                                    onClick={() => handleToggle(topic.id, lvl)}
                                                    className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${isSelected ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'}`}
                                                >
                                                    <span className="font-mono font-bold w-6 text-center bg-white/50 rounded">{lvl}</span>
                                                    <span className="truncate">{LEVEL_DESCRIPTIONS[topic.id][lvl][lang]}</span>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default DoNowConfig;

// FILE END: src\components\views\DoNowConfig.jsx

// =======================================================
// FILE START: src\components\views\DoNowGrid.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual } from '../visuals/GeometryComponents';

const DoNowCard = ({ q, index, showAnswer, onToggle, lang, onRefresh }) => {
    const desc = typeof q.renderData.description === 'object' ? q.renderData.description[lang] : q.renderData.description;
    const latex = q.renderData.latex;

    // --- Adaptive Layout Logic ---
    const isTextOnly = 
        (q.topic === 'equation' && (q.level === 5 || q.level === 6)) ||
        (q.topic === 'simplify' && q.level === 5);

    // --- Dynamic Text Scaling ---
    const getDescSize = (text) => {
        if (!text) return 'text-xl md:text-3xl';
        const len = text.length;
        if (isTextOnly) {
            if (len > 200) return 'text-base md:text-xl leading-relaxed';
            if (len > 100) return 'text-lg md:text-2xl leading-relaxed';
            if (len > 50) return 'text-xl md:text-3xl leading-relaxed';
            return 'text-2xl md:text-4xl leading-relaxed';
        } else {
            if (len > 80) return 'text-sm md:text-base leading-snug';
            if (len > 40) return 'text-base md:text-xl leading-normal';
            return 'text-lg md:text-2xl font-medium';
        }
    };

    const hasVisualData = (q.renderData.geometry || q.renderData.graph) && !isTextOnly;

    const renderVisual = () => {
        if (!hasVisualData) return null;

        if (q.renderData.graph) {
            return <GraphCanvas data={q.renderData.graph} width={300} height={200} />;
        }

        const geom = q.renderData.geometry;
        if (!geom) return null;

        const volumeTypes = ['cuboid', 'cylinder', 'cone', 'sphere', 'hemisphere', 'pyramid', 'triangular_prism', 'silo', 'ice_cream'];
        if (volumeTypes.includes(geom.type)) {
            return <VolumeVisualization data={geom} width={300} height={200} />;
        }

        return <GeometryVisual data={geom} />;
    };

    // Calculate rotation for refresh icon interaction
    const [isSpinning, setIsSpinning] = useState(false);
    
    // Auto-stop spinning if the question data actually changes (detected by token or description change)
    useEffect(() => {
        if (isSpinning) {
            const timer = setTimeout(() => setIsSpinning(false), 500); // Minimum spin time
            return () => clearTimeout(timer);
        }
    }, [q.token, q.renderData.description]); // Dependency ensures spin stops when new data arrives

    const handleRefreshClick = (e) => {
        e.stopPropagation();
        if (isSpinning) return; // Prevent double-clicks
        
        setIsSpinning(true);
        if (onRefresh) onRefresh();
        
        // Safety timeout in case props don't change (e.g. same question generated)
        setTimeout(() => setIsSpinning(false), 2000); 
    };

    return (
        <div 
            onClick={onToggle}
            className={`
                relative flex flex-col justify-between 
                bg-white rounded-2xl shadow-sm border-2 transition-all duration-300 cursor-pointer overflow-hidden group
                ${showAnswer ? 'border-indigo-500 ring-4 ring-indigo-500/20 scale-[1.02]' : 'border-slate-200 hover:border-indigo-300 hover:shadow-md'}
            `}
        >
            {/* Card Content */}
            <div className="p-5 flex flex-col flex-1 h-full">
                
                {/* Refresh Button (New) */}
                <button
                    onClick={handleRefreshClick}
                    disabled={isSpinning}
                    className={`
                        absolute top-3 right-3 w-8 h-8 rounded-full flex items-center justify-center transition-colors z-20 border 
                        ${isSpinning ? 'bg-indigo-50 border-indigo-200 cursor-wait' : 'bg-slate-50 hover:bg-indigo-100 text-slate-400 hover:text-indigo-600 border-slate-200'}
                    `}
                    title={lang === 'sv' ? "Ny fr√•ga" : "New question"}
                >
                    <span className={`text-sm ${isSpinning ? 'animate-spin' : ''}`}>üîÑ</span>
                </button>

                {/* Visual Container */}
                {hasVisualData && (
                    <div className="mb-4 bg-slate-50 rounded-xl border border-slate-100 overflow-hidden flex justify-center items-center py-4 min-h-[160px]">
                        {renderVisual()}
                    </div>
                )}

                {/* Text Content */}
                <div className="flex-1 flex flex-col justify-center items-center text-center">
                    <p className={`font-medium text-slate-700 mb-3 ${getDescSize(desc)}`}>
                        {desc}
                    </p>
                    
                    {latex && (
                        <div className="mt-2 text-2xl md:text-4xl font-black text-slate-800 tracking-wide">
                            <MathText text={latex} />
                        </div>
                    )}
                </div>
            </div>

            {/* Answer Overlay */}
            {showAnswer && (
                <div className="absolute inset-0 z-10 bg-white/95 backdrop-blur-sm flex flex-col items-center justify-center p-6 animate-in fade-in duration-200">
                    <div className="text-xs font-bold text-indigo-500 uppercase tracking-widest mb-2">
                        {lang === 'sv' ? 'FACIT' : 'ANSWER'}
                    </div>
                    <div className="text-3xl md:text-5xl font-black text-indigo-900 text-center break-words w-full">
                        {tryDecode(q.token)} <span className="text-xl text-slate-400 font-medium ml-1">{q.renderData.suffix}</span>
                    </div>
                </div>
            )}

            {/* Number Badge */}
            <div className={`absolute top-3 left-3 w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold transition-colors ${showAnswer ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-400 group-hover:bg-slate-200'}`}>
                {index + 1}
            </div>
        </div>
    );
};

const tryDecode = (str) => {
    try { return atob(str); } catch (e) { return "Error"; }
};

const DoNowGrid = ({ questions, ui, lang, onBack, onRefreshAll, onRefreshOne }) => {
    const [revealed, setRevealed] = useState({});
    const [showAll, setShowAll] = useState(false);
    const [isRegenerating, setIsRegenerating] = useState(false);

    const toggleOne = (idx) => {
        setRevealed(prev => ({ ...prev, [idx]: !prev[idx] }));
    };

    const toggleAll = () => {
        if (showAll) {
            setRevealed({});
            setShowAll(false);
        } else {
            const all = {};
            questions.forEach((_, i) => all[i] = true);
            setRevealed(all);
            setShowAll(true);
        }
    };

    const handleRegenerateAll = () => {
        setIsRegenerating(true);
        setRevealed({});
        setShowAll(false);
        
        if (onRefreshAll) {
            onRefreshAll().finally(() => setIsRegenerating(false));
        } else {
            setTimeout(() => setIsRegenerating(false), 500);
        }
    };

    return (
        <div className="h-screen flex flex-col bg-slate-50">
            {/* Header */}
            <header className="bg-white border-b border-slate-200 px-6 py-4 flex justify-between items-center shadow-sm z-20 sticky top-0">
                <div className="flex items-center gap-4">
                    <button onClick={onBack} className="flex items-center gap-2 text-slate-500 font-bold hover:text-indigo-600 transition-colors">
                        <span className="text-xl">‚Üê</span> 
                        <span>{ui.backBtn || "Back"}</span>
                    </button>
                    <h2 className="text-lg font-black text-slate-800 hidden md:block tracking-tight border-l border-slate-200 pl-4 ml-2">
                        {ui.donow_title}
                    </h2>
                </div>

                <div className="flex items-center gap-3">
                    {/* Regenerate All Button (New) */}
                    <button 
                        onClick={handleRegenerateAll}
                        disabled={isRegenerating}
                        className="px-4 py-2 rounded-full font-bold text-sm bg-slate-100 text-slate-600 hover:bg-slate-200 hover:text-indigo-600 transition-all flex items-center gap-2"
                        title={ui.donow_regenerate || "Regenerate all"}
                    >
                        <span className={isRegenerating ? 'animate-spin' : ''}>üîÑ</span>
                        <span className="hidden sm:inline">{ui.donow_regenerate || "New Set"}</span>
                    </button>

                    <button 
                        onClick={toggleAll} 
                        className={`
                            px-5 py-2 rounded-full font-bold text-sm transition-all shadow-sm flex items-center gap-2
                            ${showAll 
                                ? 'bg-slate-800 text-white hover:bg-black' 
                                : 'bg-indigo-600 text-white hover:bg-indigo-700 hover:shadow-md'}
                        `}
                    >
                        <span>{showAll ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è'}</span>
                        {showAll ? (ui.donow_hide_all || "Hide All") : (ui.donow_show_all || "Show All")}
                    </button>
                </div>
            </header>

            {/* Scrollable Grid Area */}
            <div className="flex-1 p-4 md:p-8 overflow-y-auto">
                {/* STRICT 3 COLUMN GRID */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-3 gap-6 max-w-8xl mx-auto pb-10">
                    {questions.map((q, i) => (
                        <DoNowCard
                            key={i}
                            index={i}
                            q={q}
                            showAnswer={!!revealed[i]}
                            onToggle={() => toggleOne(i)}
                            lang={lang}
                            onRefresh={() => onRefreshOne && onRefreshOne(i, q.topic, q.level)}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
};

export default DoNowGrid;

// FILE END: src\components\views\DoNowGrid.jsx

// =======================================================
// FILE START: src\components\views\PracticeView.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual, StaticGeometryVisual } from '../visuals/GeometryComponents';
import CluePanel from '../practice/CluePanel';
import HistoryList from '../practice/HistoryList';
import LevelUpModal from '../modals/LevelUpModal';
import { LEVEL_DESCRIPTIONS, CATEGORIES } from '../../constants/localization'; 
import { FractionInput } from '../ui/InputComponents';

// --- SECURITY HELPERS ---

const isValidInput = (val, type) => {
    if (val === '') return true;
    const numericRegex = /^-?[\d\s]*([.,:]\d*)?$/;
    
    if (type === 'numeric' || type === 'scale' || type === 'range' || type === 'fraction') {
        return numericRegex.test(val) || (type === 'fraction' && val.includes('/'));
    }
    
    const dangerousRegex = /[<>{}]/g;
    return !dangerousRegex.test(val);
};

const sanitize = (val) => {
    return val.replace(/[<>{}]/g, "");
};

const PracticeView = ({ 
    lang, 
    ui, 
    question, 
    loading, 
    feedback, 
    input, 
    setInput, 
    handleSubmit, 
    handleHint, 
    handleSolution, 
    handleSkip, 
    handleChangeLevel, 
    revealedClues, 
    uiState, 
    actions, 
    levelUpAvailable, 
    setLevelUpAvailable, 
    isSolutionRevealed, 
    timerSettings, 
    formatTime, 
    setMobileHistoryOpen 
}) => {
    // --- STATE FOR STRUCTURED INPUTS ---
    const [scaleInputLeft, setScaleInputLeft] = useState('');
    const [scaleInputRight, setScaleInputRight] = useState('');
    
    const [powerBase, setPowerBase] = useState('');
    const [powerExp, setPowerExp] = useState('');
    const [sciMantissa, setSciMantissa] = useState('');
    const [sciExp, setSciExp] = useState('');
    const [rangeLower, setRangeLower] = useState('');
    const [rangeUpper, setRangeUpper] = useState('');

    const inputRef = useRef(null);
    const [shake, setShake] = useState(false);

    // Auto-advance logic
    const retryRef = useRef(actions.retry);
    useEffect(() => { retryRef.current = actions.retry; }, [actions.retry]);
    
    useEffect(() => {
        if (feedback === 'correct' && isSolutionRevealed) {
            const timer = setTimeout(() => {
                retryRef.current(); 
            }, 1500);
            return () => clearTimeout(timer);
        }
    }, [feedback, isSolutionRevealed]);

    // Auto-focus logic
    useEffect(() => {
        if (!loading && !feedback && !levelUpAvailable && inputRef.current) {
            setTimeout(() => inputRef.current?.focus(), 50);
        }
    }, [question, loading, feedback, levelUpAvailable]);

    const descriptionText = typeof question?.renderData?.description === 'object' ? question.renderData.description[lang] : question?.renderData?.description;
    
    const handleChoiceClick = (choice) => { 
        if (feedback === 'correct') return; 
        setInput(choice); 
        handleSubmit({ preventDefault: () => { } }, choice); 
    };
    
    // --- SUBMIT HANDLER ---
    const handleFormSubmit = (e) => {
        e.preventDefault();
        
        if (feedback === 'correct') {
            actions.retry(true);
            return;
        }

        let finalInput = input;
        const type = question.renderData.answerType;

        if (type === 'scale') {
            if (scaleInputLeft === '' || scaleInputRight === '') return;
            finalInput = `${scaleInputLeft}:${scaleInputRight}`;
        } 
        else if (type === 'structured_power') {
            if (powerBase === '' || powerExp === '') return;
            finalInput = `${powerBase}^${powerExp}`;
        }
        else if (type === 'structured_scientific') {
            if (sciMantissa === '' || sciExp === '') return;
            finalInput = `${sciMantissa}*10^${sciExp}`;
        }
        else if (type === 'structured_range') {
            if (rangeLower === '' || rangeUpper === '') return;
            finalInput = `${rangeLower}:${rangeUpper}`;
        }
        else if (type === 'fraction') {
             if (!input) return;
             finalInput = input; 
        }
        else {
            if (!isValidInput(input, type === 'numeric' ? 'numeric' : 'text')) {
                setShake(true);
                setTimeout(() => setShake(false), 500);
                return;
            }
            if (type !== 'numeric') finalInput = sanitize(input);
        }

        if (!finalInput || finalInput.trim() === '') return;

        handleSubmit(e, finalInput);
    };

    const handleInputChange = (e, setter, type) => {
        const val = e.target.value;
        if (isValidInput(val, type)) {
            setter(val);
        }
    };

    // Reset specialized inputs on new question
    useEffect(() => {
        if (question && !loading) {
            setScaleInputLeft(''); setScaleInputRight('');
            setPowerBase(question.renderData.prefillBase || '');
            setPowerExp('');
            setSciMantissa('');
            setSciExp('');
            setRangeLower('');
            setRangeUpper('');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            const isMobile = window.innerWidth < 768;
            if (!isMobile && inputRef.current) {
                inputRef.current.focus();
            }
        }
    }, [question, loading]);

    const maxLevels = Object.keys(LEVEL_DESCRIPTIONS[uiState.topic] || {}).length;

    const renderVisual = () => {
        if (!question?.renderData) return null;

        if (question.renderData.graph) return <GraphCanvas data={question.renderData.graph} />;
        
        const geom = question.renderData.geometry;
        if (geom) {
            if (geom.type === 'frequency_table') return <GeometryVisual data={geom} />; 
            const volumeTypes = ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'];
            if (volumeTypes.includes(geom.type)) return <VolumeVisualization data={geom} />;
            return <GeometryVisual data={geom} />;
        }

        if (uiState.topic === 'geometry') return <StaticGeometryVisual description={descriptionText} />;

        if (question.renderData.latex) {
             return <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center overflow-x-auto py-2"><MathText text={`$$${question.renderData.latex}$$`} large={true} /></div>;
        }

        return <div className="flex flex-col items-center justify-center w-full min-h-[100px]"></div>;
    };

    const getSubmitLabel = () => {
        if (feedback === 'correct') return ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°");
        if (feedback === 'incorrect') return ui.tagWrong || "Incorrect";
        return ui.btnCheck || (lang === 'sv' ? "Svara" : "Submit");
    };

    const isDisabled = feedback === 'correct';

    if (!question && !loading) {
        return (
            <div className="flex flex-col items-center justify-center min-h-[50vh]">
                <p className="text-red-400 mb-4">{ui.error || "Error loading question"}</p>
                <button onClick={() => actions.retry(true)} className="bg-indigo-600 text-white px-6 py-2 rounded-full hover:bg-indigo-700 transition">
                    Retry
                </button>
            </div>
        );
    }

    return (
        <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in relative">
            
            <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => { setLevelUpAvailable(false); actions.retry(true); }} lang={lang} />
            
            <div className="flex-1 w-full min-w-0">
                {/* HEADER */}
                <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100 sticky top-0 z-20">
                    <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>

                    <div className="flex items-center gap-3">
                        {timerSettings.isActive && (
                            <div className={`font-mono text-sm font-bold px-3 py-1.5 rounded-lg border hidden sm:block ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                {formatTime(timerSettings.remaining)}
                            </div>
                        )}
                        <div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200">
                            <button onClick={() => handleChangeLevel(-1)} disabled={uiState.level <= 1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel || "<"}>&lt;</button>
                            <span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">
                                {(CATEGORIES && CATEGORIES[uiState.topic.toUpperCase()]?.label[lang]) || uiState.topic} ‚Ä¢ Lvl {uiState.level}
                            </span>
                            <button onClick={() => handleChangeLevel(1)} disabled={uiState.level >= maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel || ">"}>&gt;</button>
                        </div>
                        
                        <button onClick={() => setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500 hover:bg-gray-200 transition-colors">
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                    </div>
                </div>

                <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                    {loading ? (
                        <div className="p-20 text-center flex flex-col items-center gap-4">
                            <div className="w-10 h-10 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"></div>
                        </div>
                    ) : question ? (
                        <div className="p-4 sm:p-6">
                            <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                {renderVisual()}
                            </div>
                            
                            <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText} /></h2></div>
                            
                            {question.renderData.answerType === 'multiple_choice' ? (
                                <div className="max-w-md mx-auto grid grid-cols-2 gap-4">
                                    {(question.renderData.options || question.renderData.choices || []).map((choice, idx) => (
                                        <button key={idx} onClick={() => handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback === 'correct' && choice === input ? 'bg-green-500 border-green-500 text-white' : feedback === 'incorrect' && choice === input ? 'bg-red-500 border-red-500 text-white' : 'bg-white border-gray-200 text-gray-700 hover:border-indigo-500 hover:text-indigo-600'}`} disabled={feedback !== null}>{choice}</button>
                                    ))}
                                    {feedback === 'correct' && <div className="col-span-2 mt-4"><button onClick={() => actions.retry(true)} className="w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 bg-primary-500 shadow-green-200 hover:bg-primary-600">{ui.btnNext || (lang === 'sv' ? "N√§sta ‚û°" : "Next ‚û°")}</button></div>}
                                </div>
                            ) : (
                                <form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                    <div className={`relative transition-transform ${shake ? 'animate-shake' : ''}`}>
                                        
                                        {question.renderData.answerType === 'fraction' && (
                                            <div className="flex justify-center py-2">
                                                <FractionInput 
                                                    value={input} 
                                                    onChange={setInput} 
                                                    allowMixed={true}
                                                    autoFocus={!loading && !feedback} 
                                                />
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'scale' && (
                                            <div className="flex items-center justify-center gap-2">
                                                <input type="text" value={scaleInputLeft} onChange={(e) => handleInputChange(e, setScaleInputLeft, 'numeric')} className="w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm focus:border-indigo-500" placeholder="X" disabled={isDisabled} />
                                                <span className="text-2xl font-bold text-gray-400">:</span>
                                                <input type="text" value={scaleInputRight} onChange={(e) => handleInputChange(e, setScaleInputRight, 'numeric')} className="w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm focus:border-indigo-500" placeholder="X" disabled={isDisabled} />
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'structured_power' && (
                                            <div className="flex items-end justify-center gap-1">
                                                <input type="text" value={powerBase} onChange={(e) => handleInputChange(e, setPowerBase, 'text')} className="w-24 p-4 text-center text-2xl font-bold border-2 rounded-xl outline-none focus:border-indigo-500" placeholder="Base" disabled={isDisabled} />
                                                <div className="mb-8">
                                                    <input type="text" value={powerExp} onChange={(e) => handleInputChange(e, setPowerExp, 'numeric')} className="w-16 p-2 text-center text-lg font-bold border-2 rounded-lg outline-none focus:border-indigo-500 bg-gray-50" placeholder="exp" disabled={isDisabled} />
                                                </div>
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'structured_scientific' && (
                                            <div className="flex items-center justify-center gap-2 text-2xl font-bold text-gray-600">
                                                <input type="text" value={sciMantissa} onChange={(e) => handleInputChange(e, setSciMantissa, 'numeric')} className="w-28 p-3 text-center border-2 rounded-xl outline-none focus:border-indigo-500" placeholder="a" disabled={isDisabled} />
                                                <span>¬∑ 10</span>
                                                <div className="mb-8">
                                                    <input type="text" value={sciExp} onChange={(e) => handleInputChange(e, setSciExp, 'numeric')} className="w-16 p-2 text-center text-lg border-2 rounded-lg outline-none focus:border-indigo-500 bg-gray-50" placeholder="n" disabled={isDisabled} />
                                                </div>
                                            </div>
                                        )}

                                        {question.renderData.answerType === 'structured_range' && (
                                            <div className="flex items-center justify-center gap-3 text-xl font-bold text-gray-500">
                                                <input type="text" value={rangeLower} onChange={(e) => handleInputChange(e, setRangeLower, 'numeric')} className="w-20 p-3 text-center border-2 rounded-xl" placeholder="min" disabled={isDisabled} />
                                                <span>&lt;</span>
                                                <span className="text-black"><MathText text={question.renderData.latex} /></span>
                                                <span>&lt;</span>
                                                <input type="text" value={rangeUpper} onChange={(e) => handleInputChange(e, setRangeUpper, 'numeric')} className="w-20 p-3 text-center border-2 rounded-xl" placeholder="max" disabled={isDisabled} />
                                            </div>
                                        )}

                                        {!['scale', 'structured_power', 'structured_scientific', 'structured_range', 'fraction'].includes(question.renderData.answerType) && (
                                            <div className="relative">
                                                <input ref={inputRef} type="text" value={input} onChange={(e) => handleInputChange(e, setInput, question.renderData.answerType)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-green-500 bg-green-50 text-green-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-indigo-500 focus:ring-4 focus:ring-indigo-50'}`} placeholder={ui.placeholder || "..."} disabled={isDisabled} />
                                                {question.renderData.suffix && <span className="absolute right-6 top-1/2 -translate-y-1/2 text-slate-400 font-bold text-lg pointer-events-none">{question.renderData.suffix}</span>}
                                            </div>
                                        )}

                                        {feedback === 'correct' && <div className="absolute right-4 top-1/2 -translate-y-1/2 text-2xl animate-bounce-in">‚úÖ</div>}
                                        {feedback === 'incorrect' && <div className="absolute right-4 top-1/2 -translate-y-1/2 text-2xl animate-shake">‚ùå</div>}
                                    </div>
                                    
                                    <button 
                                        type="submit" 
                                        className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback === 'correct' ? 'bg-green-500 shadow-green-200 hover:bg-green-600' : 'bg-indigo-600 hover:bg-indigo-700 shadow-indigo-200 hover:shadow-lg'}`}
                                        disabled={loading}
                                    >
                                        {getSubmitLabel()}
                                    </button>
                                </form>
                            )}

                            <div className="mt-6 flex gap-3 justify-center flex-wrap">
                                <button type="button" onClick={handleHint} disabled={!question.clues || revealedClues.length >= question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-yellow-50 text-yellow-700 border border-yellow-200 hover:bg-yellow-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button>
                                <button type="button" onClick={handleSolution} disabled={!question.clues || isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button>
                                <button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button>
                            </div>
                        </div>
                    ) : (
                        <div className="p-12 text-center text-red-400">
                            <p>{ui.error || "Failed to load question."}</p>
                            <button onClick={() => actions.retry(true)} className="text-indigo-600 underline text-sm mt-2">Retry</button>
                        </div>
                    )}
                </main>

                <div className="lg:hidden mt-6 w-full">
                    {(revealedClues.length > 0 || isSolutionRevealed) && (
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                    )}
                </div>

            </div>
            
            <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui} /></div>
            </div>
        </div>
    );
};

export default PracticeView;

// FILE END: src\components\views\PracticeView.jsx

// =======================================================
// FILE START: src\components\visuals\AngleComponents.jsx
// =======================================================

import React from 'react';

// =====================================================================
// ANGLE VISUALIZATION COMPONENT
// Handles drawing rays, arcs, and labels for angle geometry problems.
// =====================================================================

const AngleVisual = ({ data }) => {
    // Data expected structure:
    // {
    //   type: 'angle',
    //   lines: [[p1, p2], ...],
    //   arcs: [{center, startAngle, endAngle, radius, label, color}],
    //   labels: [{x, y, text}],
    //   polygons: [{points: "x1,y1 x2,y2..."}]
    // }

    if (!data) return null;

    const { lines = [], arcs = [], labels = [], polygons = [] } = data;
    const width = 300;
    const height = 250;
    
    // Helper to draw an arc
    const drawArc = (arc, i) => {
        const { x, y } = arc.center;
        const r = arc.radius || 30;
        
        // Convert to radians (SVG Y is down, so standard math angles are inverted)
        const start = -arc.startAngle * (Math.PI / 180);
        const end = -arc.endAngle * (Math.PI / 180);
        
        const x1 = x + r * Math.cos(start);
        const y1 = y + r * Math.sin(start);
        const x2 = x + r * Math.cos(end);
        const y2 = y + r * Math.sin(end);
        
        let diff = arc.endAngle - arc.startAngle;
        while(diff < 0) diff += 360;
        
        const largeArc = diff > 180 ? 1 : 0;
        const sweep = 0; // Inverted Y logic
        
        const d = `M ${x} ${y} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} ${sweep} ${x2} ${y2} Z`;
        
        const midAngle = -(arc.startAngle + arc.endAngle) / 2 * (Math.PI / 180);
        const lx = x + (r + 25) * Math.cos(midAngle);
        const ly = y + (r + 25) * Math.sin(midAngle);

        return (
            <g key={`arc-${i}`}>
                <path d={d} fill={arc.color || "rgba(255, 165, 0, 0.2)"} stroke={arc.stroke || "orange"} strokeWidth="2" />
                {arc.label && (
                    <text x={lx} y={ly} textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#374151">
                        {arc.label}
                    </text>
                )}
            </g>
        );
    };

    return (
        <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} className="mx-auto bg-white rounded-lg shadow-sm border border-slate-100">
            {/* Draw Polygons (if any) */}
            {polygons.map((poly, i) => (
                <polygon 
                    key={`poly-${i}`} 
                    points={poly.points} 
                    fill="rgba(59, 130, 246, 0.1)" 
                    stroke="#3b82f6" 
                    strokeWidth="2" 
                />
            ))}

            {/* Draw Lines */}
            {lines.map((line, i) => (
                <line 
                    key={`line-${i}`} 
                    x1={line.x1} y1={line.y1} 
                    x2={line.x2} y2={line.y2} 
                    stroke="#1e293b" 
                    strokeWidth="3" 
                    strokeLinecap="round" 
                />
            ))}

            {/* Draw Arcs/Angles */}
            {arcs.map((arc, i) => drawArc(arc, i))}

            {/* Draw Independent Labels */}
            {labels.map((lbl, i) => (
                <text 
                    key={`lbl-${i}`} 
                    x={lbl.x} y={lbl.y} 
                    textAnchor="middle" 
                    fontSize={lbl.size || "18"} 
                    fontWeight="bold" 
                    fill={lbl.color || "#1f2937"}
                >
                    {lbl.text}
                </text>
            ))}
        </svg>
    );
};

export default AngleVisual;

// FILE END: src\components\visuals\AngleComponents.jsx

// =======================================================
// FILE START: src\components\visuals\ComplexGeometry.jsx
// =======================================================

import React from 'react';

export const TransversalVisual = ({ data }) => {
    const labels = data.labels;
    return (
        <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
            <polygon points="150,30 50,220 250,220" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.3" />
            <line x1="100" y1="125" x2="200" y2="125" stroke="#059669" strokeWidth="3" />
            <path d="M 150 125 l -5 -5 m 5 5 l -5 5" stroke="#059669" strokeWidth="2" fill="none"/>
            <path d="M 150 220 l -5 -5 m 5 5 l -5 5" stroke="#10b981" strokeWidth="2" fill="none"/>

            {/* Standard Labels */}
            <text x="85" y="80" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_top}</text>
            <text x="150" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_top}</text>
            <text x="150" y="240" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_bot}</text>

            {/* Conditional Labels: Total Bracket OR Bottom Extension */}
            {labels.left_tot && (
                <g transform="translate(-10, 0)"> 
                    <line x1="110" y1="20" x2="10" y2="210" stroke="#64748b" strokeWidth="2" />
                    <line x1="110" y1="20" x2="120" y2="25" stroke="#64748b" strokeWidth="2" />
                    <line x1="10" y1="210" x2="20" y2="215" stroke="#64748b" strokeWidth="2" />
                    <text x="50" y="115" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end" dominantBaseline="middle">{labels.left_tot}</text>
                </g>
            )}
            {labels.left_bot && (
                <text x="65" y="170" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_bot}</text>
            )}
        </svg>
    );
};

export const CompositeVisual = ({ data }) => {
    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200" className="border border-gray-100 rounded-lg bg-white shadow-sm">
                {data.subtype === 'house' ? (
                    <>
                        <rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <text x="160" y="120" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                        <text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                        <text x="130" y="60" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h_roof}</text>
                    </>
                ) : (
                    <>
                        <rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                        <text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                        <text x="160" y="120" textAnchor="start" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                    </>
                )}
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\ComplexGeometry.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryComponents.jsx
// =======================================================

import React from 'react';

// 3D & Graphing
import { GraphCanvas } from './GraphCanvas';
import { VolumeVisualization } from './VolumeVisualization';

// Statistics & Probability
import { FrequencyTable, PercentGrid } from './StatisticsVisuals';
import { ProbabilityMarbles, ProbabilitySpinner } from './ProbabilityVisuals';
import ProbabilityTree from './ProbabilityTree';

// 2D Geometry & Utilities
import { RenderShape } from './GeometryShapes';
import { ScaleVisual, SimilarityCompare, CompareShapesArea } from './ScaleVisuals';
import { TransversalVisual, CompositeVisual } from './ComplexGeometry';
import PatternVisual from './PatternComponents';
import AngleVisual from './AngleComponents';

export const GeometryVisual = ({ data }) => {
    if (!data) return null;

    // --- ANGLE VISUAL ---
    if (data.type === 'angle') {
        return <AngleVisual data={data} />;
    }
    // --- PATTERNS ---
    if (data.type === 'pattern') {
        return <PatternVisual data={data} />;
    }
    // --- PROBABILITY TREES ---
    if (data.type === 'probability_tree') {
        return <ProbabilityTree data={data} />;
    }

    // --- FREQUENCY TABLE ---
    if (data.type === 'frequency_table') {
        return <FrequencyTable data={data} />;
    }

    // --- PROBABILITY MARBLES ---
    if (data.type === 'probability_marbles') {
        return <ProbabilityMarbles data={data} />;
    }

    // --- PROBABILITY SPINNER ---
    if (data.type === 'probability_spinner') {
        return <ProbabilitySpinner data={data} />;
    }

    // --- PERCENT GRID ---
    if (data.type === 'percent_grid') {
        return <PercentGrid data={data} />;
    }

    // --- SIMILARITY COMPARISON ---
    if (data.type === 'similarity_compare') {
        return <SimilarityCompare data={data} />;
    }

    // --- SCALES (Single & Compare) ---
    if (data.type === 'scale_single' || data.type === 'scale_compare') { 
        return <ScaleVisual data={data} />;
    }

    // --- TRANSVERSAL ---
    if (data.type === 'transversal') {
        return <TransversalVisual data={data} />;
    }

    // --- AREA COMPARISON ---
    if (data.type === 'compare_shapes_area') {
        return <CompareShapesArea data={data} />;
    }

    // --- BASIC & COMPOSITE SHAPES (Dispatcher) ---
    // UPDATED: 'composite' is now handled by RenderShape which has logic for new and legacy subtypes
    if (['rectangle', 'square', 'parallelogram', 'triangle', 'circle', 'semicircle', 'quarter_circle', 'composite'].includes(data.type)) {
        return (
            <svg width="300" height="250" viewBox="0 0 300 250" className="my-2 w-full max-w-[300px] mx-auto">
                <RenderShape type={data.type} dims={data} labels={data.labels} />
            </svg>
        );
    }
    
    // Fallback or Legacy Composite (if any types remain that RenderShape doesn't handle)
    // Since RenderShape handles all 'composite' subtypes now, this might be redundant
    // but kept just in case of other 'composite' variants from ComplexGeometry.
    if (data.type === 'composite_legacy') { // Renaming or removing to prevent conflict
        return <CompositeVisual data={data} />;
    }

    return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>;
};

// Re-export these for backward compatibility if other files import them from here
export { GraphCanvas, VolumeVisualization };

export const StaticGeometryVisual = ({ description }) => { 
    if (!description) return null; 
    const d = description.toLowerCase(); 
    if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; 
    return null; 
};

// FILE END: src\components\visuals\GeometryComponents.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryShapes.jsx
// =======================================================

import React from 'react';

// Helper for text generation
export const mkTxt = (x, y, txt, anchor = "middle", baseline = "middle", color = "#374151") =>
    <text key={`${x}-${y}-${txt}`} x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill={color} fontSize="20">{txt}</text>;

export const RenderShape = ({ type, dims, labels, areaText, offsetX = 0, offsetY = 0, scale = 1 }) => {
    const cx = 150 + offsetX;
    const cy = 125 + offsetY;
    const safeDims = dims || {};
    // Ensure width and height have fallbacks to prevent NaN
    const rawW = safeDims.width || safeDims.w || 10;
    const rawH = safeDims.height || safeDims.h || 10;
    const rawR = safeDims.radius || safeDims.r || 5;

    const maxDim = Math.max(rawW, rawH, rawR * 2) || 10;
    const baseScale = (120 / maxDim) * scale;
    
    const sw = rawW * baseScale;
    const sh = rawH * baseScale;
    const sr = rawR * baseScale;

    // Use passed labels or fallback to dimension values if no label object exists
    const safeLabels = labels || {};
    const l_b = safeLabels.b || safeLabels.base || safeLabels.width || safeLabels.w;
    const l_h = safeLabels.h || safeLabels.height;
    const l_hyp = safeLabels.hyp || safeLabels.hypotenuse || safeLabels.c || safeLabels.diagonal;
    const l_slant = safeLabels.slant || safeLabels.s; // For parallelogram slant side
    
    // Angle Labels
    const l_a1 = safeLabels.a1;
    const l_a2 = safeLabels.a2;

    // Side Labels for Similarity (s1, s2)
    const l_s1 = safeLabels.s1;
    const l_s2 = safeLabels.s2;

    if (type === 'rectangle' || type === 'square') {
        return (
            <g>
                <rect x={cx - sw / 2} y={cy - sh / 2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {l_b && mkTxt(cx, cy + sh / 2 + 25, l_b)}
                {l_h && mkTxt(cx + sw / 2 + 15, cy, l_h, "start")}
                {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
            </g>
        );
    }

    if (type === 'parallelogram') {
        const skew = sw * 0.25; // fixed skew amount for visual
        // Points: BottomLeft, BottomRight, TopRight, TopLeft
        const xBL = cx - sw / 2 - skew/2;
        const xBR = cx + sw / 2 - skew/2;
        const xTR = cx + sw / 2 + skew/2;
        const xTL = cx - sw / 2 + skew/2;
        
        const yTop = cy - sh / 2;
        const yBot = cy + sh / 2;

        const path = `${xBL},${yBot} ${xBR},${yBot} ${xTR},${yTop} ${xTL},${yTop}`;

        return (
            <g>
                {/* Dotted Height Line */}
                <line x1={xTL} y1={yTop} x2={xTL} y2={yBot} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                {/* Main Shape */}
                <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                
                {/* Base Label */}
                {l_b && mkTxt((xBL + xBR)/2, yBot + 25, l_b)}
                
                {/* Height Label (Internal) */}
                {l_h && mkTxt(xTL + 10, (yTop+yBot)/2, l_h, "start")}
                
                {/* Slant Side Label (Right Side) for Perimeter */}
                {l_slant && mkTxt((xBR+xTR)/2 + 10, (yBot+yTop)/2, l_slant, "start")}

                {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
            </g>
        );
    }

    if (type === 'triangle') {
        const L = cx - sw / 2; 
        const R = cx + sw / 2;
        const T = cy - sh / 2; 
        const B = cy + sh / 2;
        
        if (safeDims.subtype === 'right') {
            const p1 = { x: L, y: T }; const p2 = { x: L, y: B }; const p3 = { x: R, y: B };
            const path = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
            return (
                <g>
                    <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                    {l_h && mkTxt(L - 15, cy, l_h)}
                    {l_b && mkTxt(cx, B + 25, l_b)}
                    {l_hyp && mkTxt(cx + 10, cy - 10, l_hyp, "start")}
                </g>
            );
        } else {
            // Isosceles / Generic Triangle
            const points = `${L},${B} ${R},${B} ${cx},${T}`;
            return (
                <g>
                    <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />
                    <polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                    {l_b && mkTxt(cx, B + 25, l_b)}
                    {l_h && mkTxt(cx + 5, cy, l_h, "start")}
                    
                    {l_s1 && mkTxt(L - 10, cy, l_s1, "end")}
                    {l_s2 && mkTxt(R + 10, cy, l_s2, "start")}

                    {l_a1 && (
                        <>
                            <path d={`M ${L + 15} ${B} A 15 15 0 0 0 ${L + 8} ${B - 13}`} fill="none" stroke="#374151" strokeWidth="2" />
                            <text x={L - 10} y={B - 5} fontSize="16" fontWeight="bold" fill="#374151">{l_a1}</text>
                        </>
                    )}
                    
                    {l_a2 && (
                        <>
                            <path d={`M ${R - 15} ${B} A 15 15 0 0 1 ${R - 8} ${B - 13}`} fill="none" stroke="#374151" strokeWidth="2" />
                            <text x={R + 10} y={B - 5} fontSize="16" fontWeight="bold" fill="#374151">{l_a2}</text>
                        </>
                    )}
                </g>
            );
        }
    }
    if (type === 'circle') {
        const isDiameter = safeDims.show === 'diameter';
        const labelTxt = safeLabels.val || (safeLabels.r ? `r=${safeLabels.r}` : (safeLabels.diameter ? `d=${safeLabels.diameter}` : null));
        return (
            <g>
                <circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {isDiameter ? (
                    <>
                        <line x1={cx - sr} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" strokeDasharray="4" />
                        {labelTxt && <text x={cx} y={cy - 15} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>}
                    </>
                ) : (
                    <>
                        <circle cx={cx} cy={cy} r={3} fill="#374151" />
                        <line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" />
                        {labelTxt && <text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labelTxt}</text>}
                    </>
                )}
            </g>
        );
    }

    // --- NEW: Semicircle ---
    if (type === 'semicircle') {
        const isDiameter = safeDims.show === 'diameter';
        const rVal = safeLabels.r;
        const dVal = safeLabels.diameter;
        const dPath = `M ${cx - sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx + sr} ${cy} Z`; 
        
        return (
            <g>
                <path d={dPath} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                {isDiameter ? (
                    <>
                        <line x1={cx - sr} y1={cy + 15} x2={cx + sr} y2={cy + 15} stroke="#374151" strokeWidth="2" markerEnd="url(#arrow)" markerStart="url(#arrow)" />
                        <text x={cx} y={cy + 35} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{dVal ? `d=${dVal}` : ''}</text>
                    </>
                ) : (
                    <>
                        <line x1={cx} y1={cy} x2={cx + sr*0.7} y2={cy - sr*0.7} stroke="#374151" strokeWidth="2" />
                        <text x={cx + 15} y={cy - 25} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
                        <circle cx={cx} cy={cy} r={3} fill="#374151" />
                    </>
                )}
            </g>
        );
    }

    // --- NEW: Quarter Circle ---
    if (type === 'quarter_circle') {
        const rVal = safeLabels.r;
        const originX = cx - sr/2;
        const originY = cy + sr/2;
        
        const dPath = `M ${originX} ${originY} L ${originX + sr} ${originY} A ${sr} ${sr} 0 0 0 ${originX} ${originY - sr} Z`;

        return (
            <g>
                <path d={dPath} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                <text x={originX + sr/2} y={originY + 20} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
                <text x={originX - 15} y={originY - sr/2} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="20">{rVal ? `r=${rVal}` : ''}</text>
            </g>
        );
    }
    
    // --- COMBINED SHAPES (Level 4) ---
    if (type === 'composite') {
        const lab = labels || {};
        
        if (dims.subtype === 'rect_right_tri') {
            const wRect = (lab.w || 10) * baseScale;
            const hRect = (lab.h || 10) * baseScale;
            const wTri = (lab.tri_b || 5) * baseScale;
            const totalW = wRect + wTri;
            const startX = cx - totalW / 2;
            const startY = cy + hRect / 2;

            return (
                <g>
                    <rect x={startX} y={startY - hRect} width={wRect} height={hRect} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <polygon points={`${startX + wRect},${startY} ${startX + wRect + wTri},${startY} ${startX + wRect},${startY - hRect}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {mkTxt(startX + wRect/2, startY + 20, lab.w)} 
                    {mkTxt(startX - 15, startY - hRect/2, lab.h)} 
                    {mkTxt(startX + wRect + wTri/2, startY + 20, lab.tri_b)} 
                </g>
            );
        }

        if (dims.subtype === 'l_shape') {
            const vW = (lab.vW || 3) * baseScale;
            const vH = (lab.vH || 8) * baseScale;
            const hW = (lab.hW || 6) * baseScale; // This is the extension width
            const hH = (lab.hH || 3) * baseScale;
            
            const showTotal = !!lab.totalW;
            
            const totW = vW + hW; 
            const totH = Math.max(vH, hH);
            const startX = cx - totW / 2;
            const startY = cy + totH / 2; 
            const p = `${startX},${startY} ${startX + vW + hW},${startY} ${startX + vW + hW},${startY - hH} ${startX + vW},${startY - hH} ${startX + vW},${startY - vH} ${startX},${startY - vH}`;
            return (
                <g>
                    <polygon points={p} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {mkTxt(startX + vW/2, startY - vH - 15, lab.vW)}
                    {mkTxt(startX - 15, startY - vH/2, lab.vH)}
                    
                    {/* Right Side Label */}
                    {mkTxt(startX + vW + hW + 15, startY - hH/2, lab.hH)}

                    {/* Bottom Label logic */}
                    {showTotal ? (
                        <>
                            {/* Draw a dimension line for total width */}
                            <line x1={startX} y1={startY + 25} x2={startX + totW} y2={startY + 25} stroke="#374151" strokeWidth="1" />
                            <line x1={startX} y1={startY + 20} x2={startX} y2={startY + 30} stroke="#374151" strokeWidth="1" />
                            <line x1={startX + totW} y1={startY + 20} x2={startX + totW} y2={startY + 30} stroke="#374151" strokeWidth="1" />
                            {mkTxt(startX + totW/2, startY + 45, lab.totalW)}
                        </>
                    ) : (
                        mkTxt(startX + vW + hW/2, startY + 20, lab.hW) // Fallback to extension label
                    )}
                </g>
            );
        }

        if (dims.subtype === 'house_area') {
            const s = (lab.s || 10) * baseScale;
            const hTri = (lab.h_tri || 5) * baseScale;
            
            const startX = cx - s/2;
            const startY = cy + s/2; 

            return (
                <g>
                    <rect x={startX} y={startY - s} width={s} height={s} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <polygon points={`${startX},${startY - s} ${startX + s},${startY - s} ${cx},${startY - s - hTri}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    <line x1={cx} y1={startY - s} x2={cx} y2={startY - s - hTri} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />

                    {mkTxt(cx, startY + 20, lab.s)} 
                    {mkTxt(startX - 15, startY - s/2, lab.s)} 
                    {mkTxt(cx + 15, startY - s - hTri/2, lab.h_tri, "start")} 
                </g>
            );
        }
        
        if (dims.subtype === 'house' || dims.subtype === 'portal') {
             return (
                <g>
                    {dims.subtype === 'house' ? (
                        <>
                            <rect x={cx - 50} y={cy - 20} width={100} height={80} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <polygon points={`${cx - 50},${cy - 20} ${cx + 50},${cy - 20} ${cx},${cy - 80}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            {mkTxt(cx + 60, cy + 20, lab.h)}
                            {mkTxt(cx, cy + 80, lab.w)}
                            {mkTxt(cx + 30, cy - 40, lab.h_roof)}
                        </>
                    ) : (
                        <>
                            <rect x={cx - 50} y={cy - 50} width={100} height={100} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <path d={`M ${cx - 50} ${cy - 50} A 50 50 0 0 1 ${cx + 50} ${cy - 50}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            {mkTxt(cx, cy + 70, lab.w)}
                            {mkTxt(cx + 60, cy, lab.h, "start")}
                        </>
                    )}
                </g>
            );
        }
    }

    return null;
};

// FILE END: src\components\visuals\GeometryShapes.jsx

// =======================================================
// FILE START: src\components\visuals\GraphCanvas.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

export const GraphCanvas = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const range = data.range || 10;
        ctx.clearRect(0, 0, width, height);
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const toX = (val) => (val + range) * (width / (range * 2));
        const toY = (val) => height - (val + range) * (height / (range * 2));
        
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        for (let i = -range; i <= range; i += data.gridStep || 1) {
            ctx.beginPath(); ctx.moveTo(toX(i), 0); ctx.lineTo(toX(i), height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, toY(i)); ctx.lineTo(width, toY(i)); ctx.stroke();
        }
        ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(width, toY(0)); ctx.stroke();
        ctx.fillStyle = '#6b7280';
        const step = data.labelStep || 2;
        for (let i = -range; i <= range; i += step) {
            if (i === 0) continue;
            const xPos = toX(i); const yOrigin = toY(0);
            ctx.beginPath(); ctx.moveTo(xPos, yOrigin - 3); ctx.lineTo(xPos, yOrigin + 3); ctx.stroke();
            ctx.fillText(i.toString(), xPos, yOrigin + 12);
            const yPos = toY(i); const xOrigin = toX(0);
            ctx.beginPath(); ctx.moveTo(xOrigin - 3, yPos); ctx.lineTo(xOrigin + 3, yPos); ctx.stroke();
            ctx.fillText(i.toString(), xOrigin - 12, yPos);
        }
        data.lines.forEach(line => {
            ctx.strokeStyle = line.color || '#dc2626'; ctx.lineWidth = 3;
            ctx.beginPath();
            const x1 = -range; const y1 = line.slope * x1 + line.intercept;
            const x2 = range; const y2 = line.slope * x2 + line.intercept;
            ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke();
        });
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};

// FILE END: src\components\visuals\GraphCanvas.jsx

// =======================================================
// FILE START: src\components\visuals\PatternComponents.jsx
// =======================================================

import React from 'react';

/**
 * PatternVisual hanterar rendering av algebraiska m√∂nster.
 * Den st√∂der t√§ndstickor (stick-figures), prickar och sifferf√∂ljder.
 */
const PatternVisual = ({ data }) => {
    if (!data) return null;

    const { subtype, sequence, figures = [] } = data;

    // --- Rendera en enkel sifferf√∂ljd (Niv√• 1-2) ---
    if (subtype === 'sequence') {
        return (
            <div className="flex flex-wrap justify-center gap-4 py-8">
                {sequence.map((num, i) => (
                    <div key={i} className="flex items-center">
                        <div className="w-12 h-12 flex items-center justify-center bg-white border-2 border-indigo-100 rounded-lg shadow-sm text-xl font-bold text-indigo-600 font-mono">
                            {num === '?' ? <span className="animate-pulse text-gray-400">?</span> : num}
                        </div>
                        {i < sequence.length - 1 && <span className="ml-4 text-gray-300">,</span>}
                    </div>
                ))}
            </div>
        );
    }

    // --- Rendera t√§ndsticksm√∂nster (Niv√• 3-5) ---
    if (subtype === 'matchsticks') {
        return (
            <div className="flex flex-col items-center gap-6 w-full overflow-x-auto py-4">
                <div className="flex justify-center items-end gap-12 min-w-max px-4">
                    {figures.map((fig, idx) => (
                        <div key={idx} className="flex flex-col items-center gap-4">
                            <svg 
                                width={fig.width || 100} 
                                height={fig.height || 100} 
                                viewBox={`0 0 ${fig.width || 100} ${fig.height || 100}`}
                            >
                                {fig.sticks.map((s, i) => (
                                    <line 
                                        key={i}
                                        x1={s.x1} y1={s.y1} x2={s.x2} y2={s.y2}
                                        stroke="#f59e0b"
                                        strokeWidth="4"
                                        strokeLinecap="round"
                                        className="drop-shadow-sm"
                                    />
                                ))}
                                {fig.sticks.map((s, i) => (
                                    <circle key={`head-${i}`} cx={s.x1} cy={s.y1} r="3" fill="#ef4444" />
                                ))}
                            </svg>
                            <span className="text-xs font-bold text-gray-400 uppercase tracking-widest">
                                Figur {idx + 1}
                            </span>
                        </div>
                    ))}
                </div>
            </div>
        );
    }

    return null;
};

export default PatternVisual;

// FILE END: src\components\visuals\PatternComponents.jsx

// =======================================================
// FILE START: src\components\visuals\ProbabilityTree.jsx
// =======================================================

import React from 'react';

/**
 * ProbabilityTree handles the rendering of:
 * 1. Standard Probability Trees (Top-down)
 * 2. Combinatorial Pathways (A to B)
 * 3. Constrained Pathways (A to B with obstacles)
 */
const ProbabilityTree = ({ data }) => {
    if (!data) return null;

    const { subtype, layers, groups, initialCounts, targetBranch, obstacles = [] } = data;

    // --- MODE: PATHWAYS (Combinatorics A -> B) ---
    if (subtype === 'pathway') {
        const width = 400;
        const height = 220;
        const padding = 50;
        
        // Define layers for the network
        const layerCounts = layers || [1, 2, 3, 1];
        const stepX = (width - padding * 2) / (layerCounts.length - 1);

        const getPos = (lIdx, nIdx, count) => {
            const x = padding + lIdx * stepX;
            const layerHeight = 140;
            const startY = (height - layerHeight) / 2;
            const spacing = layerHeight / (count > 1 ? count - 1 : 1);
            const y = count === 1 ? height / 2 : startY + nIdx * spacing;
            return { x, y };
        };

        return (
            <div className="flex justify-center w-full py-6 bg-slate-50 rounded-xl border border-slate-200 shadow-inner overflow-x-auto">
                <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                    <defs>
                        <filter id="nodeShadow">
                            <feDropShadow dx="0" dy="1" stdDeviation="1" floodOpacity="0.1"/>
                        </filter>
                    </defs>

                    {/* 1. Draw Paths (Lines) */}
                    {layerCounts.map((count, lIdx) => {
                        if (lIdx === layerCounts.length - 1) return null;
                        const nextCount = layerCounts[lIdx + 1];
                        
                        return Array.from({ length: count }).map((_, nIdx) => {
                            const start = getPos(lIdx, nIdx, count);
                            return Array.from({ length: nextCount }).map((__, nextNIdx) => {
                                const end = getPos(lIdx + 1, nextNIdx, nextCount);
                                
                                // Obstacle Logic: Only check if obstacles exist in data
                                const isBlocked = obstacles.some(o => 
                                    o.layer === lIdx && o.from === nIdx && o.to === nextNIdx
                                );

                                return (
                                    <g key={`path-${lIdx}-${nIdx}-${nextNIdx}`}>
                                        <line 
                                            x1={start.x} y1={start.y} x2={end.x} y2={end.y}
                                            stroke={isBlocked ? "#fee2e2" : "#cbd5e1"} 
                                            strokeWidth={isBlocked ? "1.5" : "2.5"}
                                            strokeDasharray={isBlocked ? "4 2" : "0"}
                                            strokeLinecap="round"
                                        />
                                        {/* Visual Block Marker */}
                                        {isBlocked && (
                                            <g transform={`translate(${(start.x + end.x)/2}, ${(start.y + end.y)/2})`}>
                                                <circle r="9" fill="white" stroke="#ef4444" strokeWidth="1" />
                                                <circle r="7" fill="#ef4444" />
                                                <line x1="-3.5" y1="0" x2="3.5" y2="0" stroke="white" strokeWidth="2.5" strokeLinecap="round" />
                                            </g>
                                        )}
                                    </g>
                                );
                            });
                        });
                    })}

                    {/* 2. Draw Nodes */}
                    {layerCounts.map((count, lIdx) => (
                        Array.from({ length: count }).map((_, nIdx) => {
                            const { x, y } = getPos(lIdx, nIdx, count);
                            const isStart = lIdx === 0;
                            const isEnd = lIdx === layerCounts.length - 1;
                            
                            return (
                                <g key={`n-${lIdx}-${nIdx}`}>
                                    <circle 
                                        cx={x} cy={y} r={isStart || isEnd ? 9 : 5} 
                                        fill={isStart || isEnd ? "#6366f1" : "white"} 
                                        stroke={isStart || isEnd ? "none" : "#94a3b8"}
                                        strokeWidth="2"
                                        filter="url(#nodeShadow)"
                                    />
                                    {(isStart || isEnd) && (
                                        <text x={x} y={y - 18} textAnchor="middle" className="text-sm font-black fill-indigo-600 tracking-tighter">
                                            {isStart ? 'A' : 'B'}
                                        </text>
                                    )}
                                </g>
                            );
                        })
                    ))}
                </svg>
            </div>
        );
    }

    // --- MODE: STANDARD TREE (Probability L5) ---
    const width = 400;
    const height = 320;
    const nodeRadius = 6;
    const total = initialCounts[0] + initialCounts[1];
    const centerX = width / 2;

    const root = { x: centerX, y: 40 };
    const s1 = [
        { x: centerX - 100, y: 140, label: groups[0], count: initialCounts[0], total: total },
        { x: centerX + 100, y: 140, label: groups[1], count: initialCounts[1], total: total }
    ];
    const s2 = [
        { x: centerX - 145, y: 270, parent: 0, label: groups[0], c: initialCounts[0] - 1, t: total - 1 },
        { x: centerX - 55, y: 270, parent: 0, label: groups[1], c: initialCounts[1], t: total - 1 },
        { x: centerX + 55, y: 270, parent: 1, label: groups[0], c: initialCounts[0], t: total - 1 },
        { x: centerX + 145, y: 270, parent: 1, label: groups[1], c: initialCounts[1] - 1, t: total - 1 }
    ];

    const renderProbLabel = (x1, y1, x2, y2, num, den, bId) => {
        const mx = (x1 + x2) / 2;
        const my = (y1 + y2) / 2;
        const isT = targetBranch === bId;
        return (
            <g>
                <rect x={mx - 22} y={my - 16} width="44" height="32" fill="white" stroke={isT ? "#6366f1" : "#e2e8f0"} strokeWidth={isT ? "2" : "1"} rx="6" />
                <text x={mx} y={my + 5} textAnchor="middle" className={`text-sm font-bold ${isT ? 'fill-indigo-600 animate-pulse' : 'fill-slate-600'}`}>
                    {isT ? 'x' : `${num}/${den}`}
                </text>
            </g>
        );
    };

    return (
        <div className="flex justify-center w-full py-4 bg-white rounded-2xl border border-slate-200 shadow-sm overflow-x-auto">
            <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
                {s1.map((n, i) => (
                    <g key={`l1-${i}`}>
                        <line x1={root.x} y1={root.y} x2={n.x} y2={n.y} stroke="#e2e8f0" strokeWidth="2.5" />
                        <text x={n.x} y={n.y - 18} textAnchor="middle" className="text-[10px] font-black fill-slate-400 uppercase tracking-widest">{n.label}</text>
                        {renderProbLabel(root.x, root.y, n.x, n.y, n.count, n.total, `s1_${i}`)}
                    </g>
                ))}
                {s2.map((n, i) => {
                    const p = s1[n.parent];
                    return (
                        <g key={`l2-${i}`}>
                            <line x1={p.x} y1={p.y} x2={n.x} y2={n.y} stroke="#e2e8f0" strokeWidth="2" />
                            <text x={n.x} y={n.y + 22} textAnchor="middle" className="text-[10px] font-bold fill-slate-400 uppercase tracking-wide">{n.label}</text>
                            {renderProbLabel(p.x, p.y, n.x, n.y, n.c, n.t, `s2_${i}`)}
                        </g>
                    );
                })}
                <circle cx={root.x} cy={root.y} r={nodeRadius} fill="#cbd5e1" />
                {s1.map((n, i) => <circle key={`cn1-${i}`} cx={n.x} cy={n.y} r={nodeRadius} fill="#94a3b8" />)}
                {s2.map((n, i) => <circle key={`cn2-${i}`} cx={n.x} cy={n.y} r={nodeRadius} fill="#94a3b8" />)}
            </svg>
        </div>
    );
};

export default ProbabilityTree;

// FILE END: src\components\visuals\ProbabilityTree.jsx

// =======================================================
// FILE START: src\components\visuals\ProbabilityVisuals.jsx
// =======================================================

import React from 'react';

export const ProbabilityMarbles = ({ data }) => {
    const { red, blue, green } = data.items;
    const colors = [];
    for(let i=0; i<red; i++) colors.push('#ef4444');
    for(let i=0; i<blue; i++) colors.push('#3b82f6');
    for(let i=0; i<green; i++) colors.push('#22c55e');
    
    const mixed = [];
    while(colors.length) {
        if (colors.length % 3 === 0) mixed.push(colors.pop()); 
        else mixed.unshift(colors.pop());
    }

    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200" className="bg-slate-100 rounded-full border-4 border-slate-300 shadow-inner">
                {mixed.map((c, i) => {
                    const angle = i * 2.4; 
                    const dist = 15 + i * 4; 
                    const x = 100 + dist * Math.cos(angle);
                    const y = 100 + dist * Math.sin(angle);
                    return <circle key={i} cx={x} cy={y} r={12} fill={c} stroke="rgba(0,0,0,0.2)" strokeWidth="1" />;
                })}
            </svg>
        </div>
    );
};

export const ProbabilitySpinner = ({ data }) => {
    const { sections } = data; 
    const radius = 80; const cx = 100; const cy = 100;
    const step = (2 * Math.PI) / sections;
    const colors = ['#3b82f6', '#ef4444', '#22c55e', '#eab308', '#a855f7', '#ec4899']; 
    const slices = [];
    for (let i = 0; i < sections; i++) {
        const startAngle = i * step - Math.PI/2; 
        const endAngle = (i + 1) * step - Math.PI/2;
        const x1 = cx + radius * Math.cos(startAngle); const y1 = cy + radius * Math.sin(startAngle);
        const x2 = cx + radius * Math.cos(endAngle); const y2 = cy + radius * Math.sin(endAngle);
        const largeArc = step > Math.PI ? 1 : 0;
        const pathData = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
        slices.push(<path key={i} d={pathData} fill={colors[i % colors.length]} stroke="white" strokeWidth="2" />);
    }
    return (
        <div className="flex justify-center my-4">
            <svg width="200" height="200" viewBox="0 0 200 200">
                {slices}
                <polygon points="100,20 90,40 110,40" fill="#1e293b" />
                <circle cx="100" cy="100" r="5" fill="#1e293b" />
            </svg>
        </div>
    );
};

// FILE END: src\components\visuals\ProbabilityVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\ScaleVisuals.jsx
// =======================================================

import React from 'react';
import { RenderShape } from './GeometryShapes';

export const ScaleVisual = ({ data }) => {
    const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ', arrow: '‚û°', star: '‚≠ê', lightning: '‚ö°', key: 'üîë', heart: '‚ù§Ô∏è', cloud: '‚òÅÔ∏è', moon: 'üåô', sun: '‚òÄÔ∏è', magnifying_glass: 'üîç', map: 'üó∫Ô∏è', car: 'üöó', ladybug: 'üêû', house: 'üè†' }; 
    const emoji = shapeEmojis[data.shape] || 'üì¶'; 
    const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl select-none" style={{ fontSize: size }}>{emoji}</div>; 
    
    if (data.type === 'scale_single') {
        return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="80px" /><span className="bg-white px-4 py-2 rounded shadow text-3xl font-bold font-mono border border-gray-200">{data.label}</span></div>; 
    }
    return (
        <div className="flex items-center justify-center gap-4 sm:gap-8 my-6">
            <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="60px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.leftValue}</span></div>
            <div className="text-gray-300 text-3xl">‚Üí</div>
            <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="100px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.rightValue}</span></div>
        </div>
    ); 
};

export const SimilarityCompare = ({ data }) => {
    const shapeType = data.shapeType || 'triangle';
    const leftDims = { ...data.left, width: 40, height: 40, radius: 20, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
    const rightDims = { ...data.right, width: 60, height: 60, radius: 30, subtype: shapeType === 'triangle' ? 'isosceles' : undefined };
    return (
        <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
            <RenderShape type={shapeType} dims={leftDims} labels={data.left.labels} offsetX={-25} scale={0.8} />
            <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
            <RenderShape type={shapeType} dims={rightDims} labels={data.right.labels} offsetX={225} scale={1.2} />
        </svg>
    );
};

export const CompareShapesArea = ({ data }) => {
    return (
            <svg width="500" height="250" viewBox="0 0 500 250" className="my-2 w-full mx-auto" style={{ maxWidth: '500px' }}>
            <RenderShape type={data.shapeType} dims={data.left} areaText={data.left.area} offsetX={-25} scale={0.8} />
            <text x="250" y="125" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
            <RenderShape type={data.shapeType} dims={data.right} areaText={data.right.area} offsetX={225} scale={1.2} />
        </svg>
    );
};

// FILE END: src\components\visuals\ScaleVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\SimpleTextLevel.jsx
// =======================================================

import React from 'react';

const SimpleTextLevel = ({ data }) => {
  return (
    <div className="text-content">
      <p>{data.question}</p>
    </div>
  );
};

// We simply don't add the property, or explicitly set it to false
// SimpleTextLevel.requiresCanvas = false; 

export default SimpleTextLevel;

// FILE END: src\components\visuals\SimpleTextLevel.jsx

// =======================================================
// FILE START: src\components\visuals\StatisticsVisuals.jsx
// =======================================================

import React from 'react';

export const FrequencyTable = ({ data }) => {
    const { headers, rows } = data;
    return (
        <div className="flex justify-center my-4 w-full">
            <div className="border border-slate-300 rounded-lg overflow-hidden shadow-sm bg-white min-w-[200px]">
                <table className="w-full text-sm text-left">
                    <thead className="bg-slate-100 text-slate-700 font-bold uppercase text-xs">
                        <tr>{headers.map((h, i) => <th key={i} className="px-4 py-2 border-b text-center">{h}</th>)}</tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                        {rows.map((row, rI) => (
                            <tr key={rI} className="hover:bg-slate-50">
                                {row.map((cell, cI) => <td key={cI} className="px-4 py-2 text-center font-mono text-slate-600">{cell}</td>)}
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export const PercentGrid = ({ data }) => {
    const { total = 100, colored = 0 } = data;
    const size = 300;
    const cellSize = size / 10;
    const cells = [];
    for (let i = 0; i < 100; i++) {
        const x = (i % 10) * cellSize;
        const y = Math.floor(i / 10) * cellSize;
        const isColored = i < colored;
        cells.push(<rect key={i} x={x} y={y} width={cellSize - 2} height={cellSize - 2} fill={isColored ? "#3b82f6" : "#f1f5f9"} stroke={isColored ? "#2563eb" : "#e2e8f0"} rx="4" />);
    }
    return <div className="flex justify-center my-4"><svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>{cells}</svg></div>;
};

// FILE END: src\components\visuals\StatisticsVisuals.jsx

// =======================================================
// FILE START: src\components\visuals\VolumeVisualization.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

export const VolumeVisualization = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = '#374151'; 
        ctx.fillStyle = '#f3f4f6';
        ctx.lineWidth = 2; 
        ctx.lineJoin = 'round'; 
        ctx.font = "bold 14px Inter, sans-serif"; 
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";
        const drawLabel = (text, x, y, color='#dc2626') => { 
            if (!text) return;
            ctx.save(); 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
            const m = ctx.measureText(text);
            ctx.fillRect(x - m.width/2 - 2, y - 10, m.width + 4, 20);
            ctx.fillStyle = color; 
            ctx.fillText(text, x, y); 
            ctx.restore(); 
        };
        const drawDashed = (x1, y1, x2, y2) => { 
            ctx.save(); 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath(); 
            ctx.moveTo(x1, y1); 
            ctx.lineTo(x2, y2); 
            ctx.stroke(); 
            ctx.restore(); 
        };
        const TARGET_SIZE = 140; 
        let dims = [];
        if (data.labels) {
            dims = Object.values(data.labels).map(v => parseInt(String(v))).filter(v => !isNaN(v));
        }
        const maxVal = Math.max(...dims, 10);
        const scale = TARGET_SIZE / maxVal;
        if (data.type === 'cuboid') {
            const dw = (parseInt(data.labels.w) || 10) * scale;
            const dh = (parseInt(data.labels.h) || 10) * scale;
            const dd = (parseInt(data.labels.d) || 10) * scale * 0.5;
            const x0 = cx - dw/2 - dd/2;
            const y0 = cy + dh/2 + dd/2;
            ctx.strokeRect(x0, y0 - dh, dw, dh);
            ctx.beginPath(); ctx.moveTo(x0, y0 - dh); ctx.lineTo(x0 + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw, y0 - dh); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dd); ctx.lineTo(x0 + dw, y0); ctx.stroke();
            drawLabel(data.labels.w, x0 + dw/2, y0 + 15);
            drawLabel(data.labels.h, x0 - 20, y0 - dh/2);
            drawLabel(data.labels.d, x0 + dw + dd/2 + 5, y0 - dd/2);
        } 
        else if (data.type === 'triangular_prism') {
            const b = (parseInt(data.labels.b) || 10) * scale;
            const hTri = (parseInt(data.labels.h) || 10) * scale;
            const len = (parseInt(data.labels.l) || 20) * scale * 0.7;
            const startX = cx - b/2 - len/2;
            const startY = cy + hTri/2;
            ctx.beginPath();
            ctx.moveTo(startX, startY); ctx.lineTo(startX + b, startY); ctx.lineTo(startX + b/2, startY - hTri); ctx.closePath(); ctx.stroke();
            const offX = len; const offY = -len * 0.3;
            ctx.beginPath(); ctx.moveTo(startX + b/2, startY - hTri); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX + b, startY); ctx.lineTo(startX + b + offX, startY + offY); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            drawDashed(startX + b/2, startY, startX + b/2, startY - hTri);
            drawLabel(data.labels.h, startX + b/2 + 10, startY - hTri/2);
            drawLabel(data.labels.b, startX + b/2, startY + 15);
            drawLabel(data.labels.l, startX + b + offX/2 + 10, startY + offY/2);
        }
        else if (data.type === 'pyramid') {
            const w = (parseInt(data.labels.w || data.labels.s || 10) * scale);
            const d = (parseInt(data.labels.d || data.labels.s || 10) * scale * 0.6); 
            const hPyr = (parseInt(data.labels.h) || 10) * scale;
            const x0 = cx - w/2 - d/2;
            const y0 = cy + hPyr/3; 
            
            // Define points
            const FL = {x: x0, y: y0}; 
            const FR = {x: x0+w, y: y0};
            const BR = {x: x0+w+d, y: y0-d}; 
            const BL = {x: x0+d, y: y0-d};
            const Apex = {x: x0 + w/2 + d/2, y: y0 - d/2 - hPyr};

            // Draw base and sides
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(FR.x, FR.y); ctx.lineTo(BR.x, BR.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(BL.x, BL.y); ctx.lineTo(FL.x, FL.y); ctx.stroke(); ctx.restore();
            
            // Draw edges to apex
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(FR.x, FR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BL.x, BL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke(); ctx.restore();
            
            // Draw height line
            const centerBase = {x: x0 + w/2 + d/2, y: y0 - d/2};
            drawDashed(centerBase.x, centerBase.y, Apex.x, Apex.y);
            
            // Draw Labels
            drawLabel("h=" + data.labels.h, Apex.x + 20, centerBase.y - hPyr/2);
            drawLabel(data.labels.w || data.labels.s, x0 + w/2, y0 + 15); // Width label
            
            // --- NEW: Draw Depth Label ---
            // Position it along the right edge (FR to BR)
            if (data.labels.d) {
                const depthLabelX = (FR.x + BR.x) / 2 + 15; // Midpoint + offset
                const depthLabelY = (FR.y + BR.y) / 2;
                drawLabel(data.labels.d, depthLabelX, depthLabelY);
            }
        }
        else {
            let r = 50; 
            if(data.labels.r) r = parseInt(data.labels.r) * scale;
            if(data.labels.d) r = (parseInt(data.labels.d)/2) * scale;
            r = Math.max(30, Math.min(r, 70));
            const drawCircleData = (centerY, showLabel=true) => {
                 const val = data.labels.val || (data.labels.r ? `r=${data.labels.r}` : `d=${data.labels.d}`);
                 if (data.show === 'diameter') {
                     drawDashed(cx - r, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx, centerY - 10);
                 } else {
                     ctx.beginPath(); ctx.arc(cx, centerY, 2, 0, 2*Math.PI); ctx.fill();
                     drawDashed(cx, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx + r/2, centerY - 10);
                 }
            };
            if (data.type === 'sphere') {
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, cy, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(cy);
            }
            else if (data.type === 'hemisphere') {
                const yBase = cy + 10;
                ctx.beginPath(); ctx.arc(cx, yBase, r, Math.PI, 0); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, yBase, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(yBase);
            }
            else if (data.type === 'cylinder' || data.type === 'silo') {
                const hCyl = (parseInt(data.labels.h) || 10) * scale;
                const topY = cy - hCyl/2;
                const botY = cy + hCyl/2;
                if (data.type === 'cylinder' || data.type === 'silo') {
                     ctx.beginPath(); ctx.ellipse(cx, topY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, topY); ctx.lineTo(cx-r, botY); ctx.stroke();
                     ctx.beginPath(); ctx.moveTo(cx+r, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 15, cy);
                }
                if (data.type === 'silo') { ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); }
                drawCircleData(topY, true);
            }
            else if (data.type === 'cone' || data.type === 'ice_cream') {
                 const hCone = (parseInt(data.labels.h) || 10) * scale;
                 if (data.type === 'cone') {
                     const topY = cy - hCone/2; const botY = cy + hCone/2;
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, botY); ctx.lineTo(cx, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawDashed(cx, botY, cx, topY);
                     drawLabel("h=" + data.labels.h, cx + 5, cy);
                     drawCircleData(botY, true);
                     
                     // Draw Slant Height if provided
                     if (data.labels.s) {
                         const sX = (cx + r + cx) / 2 + 15;
                         const sY = (botY + topY) / 2;
                         drawLabel("s=" + data.labels.s, sX, sY);
                     }
                 } else {
                     const seamY = cy - 20; const tipY = seamY + hCone;
                     ctx.beginPath(); ctx.moveTo(cx-r, seamY); ctx.lineTo(cx, tipY); ctx.lineTo(cx+r, seamY); ctx.stroke();
                     ctx.beginPath(); ctx.arc(cx, seamY, r, Math.PI, 0); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, seamY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 10, seamY + hCone/2);
                     drawCircleData(seamY, true);
                 }
            }
        }
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={320} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};

// FILE END: src\components\visuals\VolumeVisualization.jsx

// =======================================================
// FILE START: src\constants\content_map.js
// =======================================================

export const CONTENT_MAP = {
    arithmetic: {
        title: "Taluppfattning",
        topics: [
            {
                id: "arithmetic",
                title: "De Fyra R√§knes√§tten",
                levels: [
                    { lvl: 1, desc: "Addition (Uppst√§llning)", ex: "345 + 129" },
                    { lvl: 2, desc: "Subtraktion (Uppst√§llning)", ex: "502 - 148" },
                    { lvl: 3, desc: "Decimaltal (+/-)", ex: "4.5 + 2.15" },
                    { lvl: 4, desc: "Multiplikation (Enkel)", ex: "6 ¬∑ 12" },
                    { lvl: 5, desc: "Multiplikation (Medel)", ex: "23 ¬∑ 4" },
                    { lvl: 6, desc: "Multiplikation (Sv√•r)", ex: "45 ¬∑ 12" },
                    { lvl: 7, desc: "Kort Division", ex: "84 / 4" },
                    { lvl: 8, desc: "Blandade Heltal", ex: "Mix av alla r√§knes√§tt" },
                    { lvl: 9, desc: "Blandade Decimaltal", ex: "Mix med decimaler" }
                ]
            },
            {
                id: "fraction_basics",
                title: "Br√•k: Grunder",
                levels: [
                    { lvl: 1, desc: "Visuella Br√•k", ex: "Del av helhet" },
                    { lvl: 2, desc: "Ber√§kna delen", ex: "1/4 av 20" },
                    { lvl: 3, desc: "Blandad & Br√•kform", ex: "1 1/2 <-> 3/2" },
                    { lvl: 4, desc: "F√∂rl√§nga & F√∂rkorta", ex: "2/4 -> 1/2" },
                    { lvl: 5, desc: "Br√•k & Decimaltal", ex: "1/5 = 0.2" }
                ]
            },
            {
                id: "fraction_arith",
                title: "Br√•k: R√§kna",
                levels: [
                    { lvl: 1, desc: "Addition & Subtraktion (Lika)", ex: "1/5 + 2/5" },
                    { lvl: 2, desc: "Addition & Subtraktion (Olika)", ex: "1/2 + 1/4" },
                    { lvl: 3, desc: "Blandad form (+)", ex: "1 1/2 + 3/4" },
                    { lvl: 4, desc: "Multiplikation", ex: "2/3 ¬∑ 4/5" },
                    { lvl: 5, desc: "Division", ex: "1/2 / 1/4" }
                ]
            },
            {
                id: "negative",
                title: "Negativa Tal",
                levels: [
                    { lvl: 1, desc: "Enkel Addition/Subtraktion", ex: "5 - 8" },
                    { lvl: 2, desc: "Sv√•rare Addition/Subtraktion", ex: "-5 - (-8)" },
                    { lvl: 3, desc: "Multiplikation", ex: "-3 ¬∑ 4" },
                    { lvl: 4, desc: "Division", ex: "-12 / -3" },
                    { lvl: 5, desc: "Blandade Uppgifter", ex: "Mix av r√§knes√§tt" }
                ]
            },
            {
                id: "ten_powers",
                title: "10, 100, 1000",
                levels: [
                    { lvl: 1, desc: "Mult/Div med 10, 100, 1000", ex: "3.5 ¬∑ 100" },
                    { lvl: 2, desc: "Begreppsf√∂rst√•else", ex: "Vilket √§r st√∂rst?" },
                    { lvl: 3, desc: "Blandade Faktorer", ex: "0.1, 0.01, 1000" }
                ]
            },
            {
                id: "exponents",
                title: "Potenser & R√∂tter",
                levels: [
                    { lvl: 1, desc: "Grunder & x^0", ex: "3^2, 5^0" },
                    { lvl: 2, desc: "Tiopotenser", ex: "10^3, 10^-2" },
                    { lvl: 3, desc: "Grundpotensform", ex: "4.5 ¬∑ 10^3" },
                    { lvl: 4, desc: "Kvadratr√∂tter", ex: "sqrt(25)" },
                    { lvl: 5, desc: "Potenslagar (Enkel)", ex: "x^2 ¬∑ x^3" },
                    { lvl: 6, desc: "Potenslagar (Avancerad)", ex: "(x^2)^3" }
                ]
            },
            {
                id: "percent",
                title: "Procent",
                levels: [
                    { lvl: 1, desc: "Grundl√§ggande (Rutn√§t)", ex: "Bildst√∂d" },
                    { lvl: 2, desc: "Huvudr√§kning (10%, 50%)", ex: "10% av 500" },
                    { lvl: 3, desc: "Multiplar av 10%", ex: "30% av 200" },
                    { lvl: 4, desc: "Ber√§kna andelen (Decimal)", ex: "0.15 ¬∑ 400" },
                    { lvl: 5, desc: "Hitta helheten (100%)", ex: "Delen √§r 20, andel 50%" },
                    { lvl: 6, desc: "Verklig F√∂r√§ndring", ex: "Pris√∂kning" }
                ]
            }
        ]
    },
    algebra: {
        title: "Algebra",
        topics: [
            {
                id: "simplify",
                title: "Uttryck",
                levels: [
                    { lvl: 1, desc: "F√∂renkla Uttryck", ex: "2x + 3x" },
                    { lvl: 2, desc: "Parenteser (Addition)", ex: "2 + (x - 3)" },
                    { lvl: 3, desc: "Parenteser (Multiplikation)", ex: "3(x + 2)" },
                    { lvl: 4, desc: "Parenteser (Subtraktion)", ex: "5 - (x - 2)" },
                    { lvl: 5, desc: "Probleml√∂sning", ex: "Skriv uttryck f√∂r omkrets" },
                    { lvl: 6, desc: "Blandade Niv√•er", ex: "Mix av algebra" }
                ]
            },
            {
                id: "equation",
                title: "Ekvationer",
                levels: [
                    { lvl: 1, desc: "Enstegsekvationer", ex: "x + 5 = 12" },
                    { lvl: 2, desc: "Tv√•stegsekvationer", ex: "2x + 3 = 11" },
                    { lvl: 3, desc: "Med Parenteser", ex: "2(x + 1) = 10" },
                    { lvl: 4, desc: "Variabel p√• b√•da sidor", ex: "3x + 2 = x + 8" },
                    { lvl: 5, desc: "Skriv Ekvation", ex: "Fr√•n text till ekvation" },
                    { lvl: 6, desc: "L√∂s Problem", ex: "Textuppgifter" },
                    { lvl: 7, desc: "Blandade Ekvationer", ex: "Mix av problem" }
                ]
            },
            {
                id: "linear_graph",
                title: "R√§ta Linjen",
                levels: [
                    { lvl: 1, desc: "Hitta m-v√§rdet", ex: "Sk√§rning y-axel" },
                    { lvl: 2, desc: "Hitta k-v√§rdet (Pos)", ex: "Lutning upp√•t" },
                    { lvl: 3, desc: "Hitta k-v√§rdet (Neg)", ex: "Lutning ned√•t" },
                    { lvl: 4, desc: "Best√§m funktionen", ex: "y = kx + m" },
                    { lvl: 5, desc: "Blandat", ex: "Mix av grafer" }
                ]
            }
        ]
    },
    statistics: {
        title: "Sannolikhet & Statistik",
        topics: [
            {
                id: "probability",
                title: "Sannolikhet",
                levels: [
                    { lvl: 1, desc: "Visuell Sannolikhet", ex: "Kulor i p√•se, Snurrhjul" },
                    { lvl: 2, desc: "T√§rning & Slump", ex: "T√§rning, Kortlek" },
                    { lvl: 3, desc: "Sannolikhet som Procent", ex: "Andel i %" },
                    { lvl: 4, desc: "Komplementh√§ndelse", ex: "Sannolikhet f√∂r 'Inte'" },
                    { lvl: 5, desc: "Oberoende H√§ndelser", ex: "Tv√• mynt, T√§rning + Mynt" },
                    { lvl: 6, desc: "Kombinatorik", ex: "Antal kombinationer (Tr√§d)" }
                ]
            },
            {
                id: "statistics",
                title: "Statistik",
                levels: [
                    { lvl: 1, desc: "Typv√§rde & Variationsbredd", ex: "Mode, Range" },
                    { lvl: 2, desc: "Medelv√§rde", ex: "Summa / Antal" },
                    { lvl: 3, desc: "Median", ex: "Mittenv√§rdet (sorterat)" },
                    { lvl: 4, desc: "Bakl√§nges medelv√§rde", ex: "Hitta saknat tal" },
                    { lvl: 5, desc: "Frekvenstabell", ex: "Medel/Median ur tabell" },
                    { lvl: 6, desc: "Blandade begrepp", ex: "J√§mf√∂r m√•tt" }
                ]
            },
            {
                id: "change_factor",
                title: "F√∂r√§ndringsfaktor",
                levels: [
                    { lvl: 1, desc: "Begrepp & Definition", ex: "√ñkning 20% -> 1.20" },
                    { lvl: 2, desc: "Ber√§kna nya v√§rdet", ex: "500 * 1.20" },
                    { lvl: 3, desc: "Ber√§kna gamla v√§rdet", ex: "Nytt / Faktor" },
                    { lvl: 4, desc: "Total f√∂r√§ndring", ex: "1.10 * 0.90" },
                    { lvl: 5, desc: "Textuppgifter", ex: "Befolkning, R√§nta" }
                ]
            }
        ]
    },
    geometry: {
        title: "Geometri",
        topics: [
            {
                id: "geometry",
                title: "Area & Omkrets",
                levels: [
                    { lvl: 1, desc: "Omkrets (Rektangel)", ex: "2(b+h)" },
                    { lvl: 2, desc: "Area (Rektangel)", ex: "b*h" },
                    { lvl: 3, desc: "Area (Triangel)", ex: "b*h/2" },
                    { lvl: 4, desc: "Sammansatta (Rekt+Tri)", ex: "Rectanglar och trianglar" },
                    { lvl: 5, desc: "Cirklar", ex: "pi*r^2" },
                    { lvl: 6, desc: "Sammansatta (Alla)", ex: "Hus, Portal" }
                ]
            },
            {
                id: "scale",
                title: "Skala",
                levels: [
                    { lvl: 1, desc: "Begreppsf√∂rst√•else", ex: "1:100 vs 100:1" },
                    { lvl: 2, desc: "Ber√§kna l√§ngd (Enkel)", ex: "Bild -> Verklighet" },
                    { lvl: 3, desc: "Blandade Scenarier", ex: "Karta, Ritning" },
                    { lvl: 4, desc: "Best√§m Skalan", ex: "Bild / Verklighet" },
                    { lvl: 5, desc: "Probleml√∂sning", ex: "Textuppgifter" },
                    { lvl: 6, desc: "Areaskala", ex: "L√§ngdskala^2" },
                    { lvl: 7, desc: "Blandat", ex: "Mix av uppgifter" }
                ]
            },
            {
                id: "volume",
                title: "Volym",
                levels: [
                    { lvl: 1, desc: "R√§tblock & Kub", ex: "b*d*h" },
                    { lvl: 2, desc: "Prisma", ex: "B*h" },
                    { lvl: 3, desc: "Cylinder", ex: "pi*r^2*h" },
                    { lvl: 4, desc: "Pyramid & Kon", ex: "B*h/3" },
                    { lvl: 5, desc: "Klot", ex: "4*pi*r^3/3" },
                    { lvl: 6, desc: "Blandade Volymer", ex: "Mix av kroppar" },
                    { lvl: 7, desc: "Enhetsomvandling", ex: "dm3 <-> liter" },
                    { lvl: 8, desc: "Begr√§nsningsyta", ex: "Area till 3D former" }
                ]
            },
            {
                id: "similarity",
                title: "Likformighet",
                levels: [
                    { lvl: 1, desc: "Likformig eller inte?", ex: "J√§mf√∂r former" },
                    { lvl: 2, desc: "Ber√§kna sida", ex: "Skala * sida" },
                    { lvl: 3, desc: "Topptriangelsatsen", ex: "Liten/Stor triangel" },
                    { lvl: 4, desc: "Pythagoras", ex: "R√§tvinklig triangel" }
                ]
            },
            {
                id: "pythagoras",
                title: "Pythagoras Sats",
                levels: [
                    { lvl: 1, desc: "Kvadrater & R√∂tter", ex: "3^2, sqrt(9)" },
                    { lvl: 2, desc: "Hitta Hypotenusan", ex: "a^2 + b^2 = c^2" },
                    { lvl: 3, desc: "Hitta Kateten", ex: "c^2 - b^2 = a^2" },
                    { lvl: 4, desc: "Probleml√∂sning", ex: "Stege mot v√§gg" },
                    { lvl: 5, desc: "Avst√•nd", ex: "Koordinatsystem" },
                    { lvl: 6, desc: "R√§tvinklig?", ex: "Omv√§nd sats" }
                ]
            },
            {
                id: "angles",
                title: "Vinklar", // NEW
                levels: [
                    { lvl: 1, desc: "Vinkeltyper", ex: "Spetsig, R√§t, Trubbig" },
                    { lvl: 2, desc: "Komplement & Supplement", ex: "Summa 90/180" },
                    { lvl: 3, desc: "Vertikal- & Sidovinklar", ex: "Korsande linjer" },
                    { lvl: 4, desc: "Vinkelsumma (Triangel)", ex: "x + y + z = 180" },
                    { lvl: 5, desc: "Likbel√§gna & Alternatvinklar", ex: "Parallella linjer" },
                    { lvl: 6, desc: "Vinkelsumma (Polygoner)", ex: "(n-2)*180" }
                ]
            }
        ]
    }
};

// FILE END: src\constants\content_map.js

// =======================================================
// FILE START: src\constants\curriculum.js
// =======================================================

export const CATEGORIES = {
    ARITHMETIC: {
        id: 'ARITHMETIC',
        label: { en: 'Number Theory', sv: 'Taluppfattning' },
        color: 'pink',
        generators: [
            { id: 'BasicArithmeticGen', api: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'FractionBasicsGen', api: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, // Added
            { id: 'FractionArithGen', api: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, // Added
            { id: 'NegativeNumbersGen', api: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'TenPowersGen', api: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'PercentGen', api: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    ALGEBRA: {
        id: 'ALGEBRA',
        label: { en: 'Algebra', sv: 'Algebra' },
        color: 'indigo',
        generators: [
            { id: 'ExpressionSimplificationGen', api: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'PatternsGen', api: 'patterns', label: { sv: "Algebraiska m√∂nster", en: "Algebraic Patterns" } },
            { id: 'EquationGenerator', api: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'LinearGraphGenerator', api: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    },
    GEOMETRY: {
        id: 'GEOMETRY',
        label: { en: 'Geometry', sv: 'Geometri' },
        color: 'emerald',
        generators: [
            { id: 'GeometryGenerator', api: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'ScaleGenerator', api: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'VolumeGenerator', api: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'SimilarityGenerator', api: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'PythagorasGen', api: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } },
            { id: 'AnglesGen', api: 'angles', label: { sv: "Vinklar", en: "Angles" } }
        ]
    },
    STATISTICS: {
        id: 'STATISTICS',
        label: { en: 'Statistics', sv: 'Sannolikhet & Statistik' },
        color: 'yellow',
        generators: [
            { id: 'ProbabilityGen', api: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
            { id: 'StatisticsGen', api: 'statistics', label: { sv: "Statistik", en: "Statistics" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    BasicArithmeticGen: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    FractionBasicsGen: { // New
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Del av antal", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    FractionArithGen: { // New
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+)", en: "Mixed Numbers (+)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    NegativeNumbersGen: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    TenPowersGen: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    PatternsGen: { 
        1: { sv: "Hitta n√§sta tal & Skillnad", en: "Next Number & Difference" },
        2: { sv: "Ber√§kna h√∂ga figurer", en: "Calculate High Terms" },
        3: { sv: "Fr√•n bild till uttryck", en: "From Visual to Expression" },
        4: { sv: "Fr√•n tabell till formel", en: "Table to Formula" },
        5: { sv: "L√∂s ut n (bakl√§nges)", en: "Solve for n" }
    },
    PercentGen: {
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Ber√§kna det hela", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    EquationGenerator: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    ExpressionSimplificationGen: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    GeometryGenerator: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Sammansatta (Rekt+Tri)", en: "Combined (Rect+Tri)" },
        5: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        6: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    ScaleGenerator: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    VolumeGenerator: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" },
        7: { sv: "Begr√§nsningsyta", en: "Surface Area" } 
    },
    SimilarityGenerator: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    PythagorasGen: { 
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    },
    LinearGraphGenerator: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    },
    ProbabilityGen: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse", en: "Complementary Events" },
        5: { sv: "Tr√§ddiagram", en: "Probability tree" },
        6: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        7: { sv: "Kombinatorik", en: "Combinatorics" },
        8: { sv: "Kombinatorik (Sv√•r)", en: "Combinatorics (Hard)" }
    },
    StatisticsGen: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    AnglesGen: { 
        1: { sv: "Begrepp", en: "Concepts" },
        2: { sv: "Komplement/Supplementvinklar ", en: "Complementary/Supplementary angles" },
        3: { sv: "Vertikala vinklar", en: "Vertical Angles" },
        4: { sv: "Vinkelsumma (triangel)", en: "Angle sums (Triangle)" },
        5: { sv: "Vinkelsumma (m√•ngh√∂rning)", en: "Angle sums (Polygons)" },
        6: { sv: "Parallella linjer", en: "Parallel lines" }
    }
    
};

export const getColorClasses = (color, type) => {
    const c = color || 'emerald';
    switch (type) {
        case 'bg-light': return `bg-${c}-50`;
        case 'bg-dark': return `bg-${c}-500`;
        case 'border': return `border-${c}-100`;
        case 'text': return `text-${c}-700`;
        case 'ring': return `ring-${c}-500`;
        case 'border-solid': return `border-${c}-500`;
        default: return '';
    }
};

// FILE END: src\constants\curriculum.js

// =======================================================
// FILE START: src\constants\localization.js
// =======================================================

export const CATEGORIES = {
    arithmetic: {
        id: 'arithmetic', 
        label: { sv: "Taluppfattning", en: "Number Theory" },
        color: "pink",
        levels: 9,
        topics: [
            { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'fraction_basics', label: { sv: "Br√•k: Grunder", en: "Fractions: Basics" } }, 
            { id: 'fraction_arith', label: { sv: "Br√•k: R√§kna", en: "Fractions: Arithmetic" } }, 
            { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } },
            { id: 'exponents', label: { sv: "Potenser & R√∂tter", en: "Exponents & Roots" } },
            { id: 'percent', label: { sv: "Procent", en: "Percentage" } }
        ]
    },
    
    algebra: {
        id: 'algebra',
        label: { sv: "Algebra", en: "Algebra" },
        color: "indigo",
        levels: 6,
        topics: [
            { id: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'equation', label: { sv: "Ekvationer", en: "Equations" } },
            { id: 'patterns', label: { sv: "Algebraiska m√∂ster", en: "Algebraic patterns" } }
        ]
    },
    geometry: {
        id: 'geometry',
        label: { sv: "Geometri", en: "Geometry" },
        color: "emerald",
        levels: 7,
        topics: [
            { id: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } },
            { id: 'pythagoras', label: { sv: "Pythagoras Sats", en: "Pythagoras" } },
            { id: 'angles', label: { sv: "Vinklar", en: "Angles" } } // NEW
        ]
    },

    statistics: { 
        id: 'statistics',
        label: { sv: "Sannolikhet & Statistik", en: "Prob & Stats" },
        color: "yellow", 
        levels: 6,
        topics: [
             { id: 'probability', label: { sv: "Sannolikhet", en: "Probability" } },
             { id: 'statistics', label: { sv: "Statistik", en: "Statistics" } },
             { id: 'linear_graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } },
             { id: 'change_factor', label: { sv: "F√∂r√§ndringsfaktor", en: "Change Factor" } } // NEW
        ]
    }
};

export const CATEGORIES_ARRAY = Object.values(CATEGORIES);

export const UI_TEXT = {
    sv: {
        hero_title: "Mattest√∂d",
        hero_subtitle: "Anpassade uppgifter f√∂r h√∂gstadiet.",
        tagline: "R√§tt st√∂d. Direkt.",
        startBtn: "Starta √ñvning",
        aboutBtn: "Om Skaparen",
        contactTitle: "Kontakta mig",
        aboutTitle: "Om Skaparen",
        aboutText: "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att hitta nya s√§tt att undervisa i klassrummet.",
        contactLink: "F√∂lj mig p√• LinkedIn",
        tagCorrect: "R√§tt", tagWrong: "Fel", tagSkipped: "Hoppade √∂ver",
        streak_modal_title: "Grymt jobbat! üî•", streak_modal_msg: "Du har en streak p√• {streak}!",
        total_modal_title: "Bra jobbat! ‚úÖ", total_modal_msg: "Du har klarat {total} uppgifter! Forts√§tt s√•!",
        btn_close_streak: "K√∂r vidare!", btn_close_total: "Forts√§tt",
        timer_title: "Timer", timer_off: "Av", timer_min: "min", timer_reset: "Nollst√§ll", timer_paused: "Pausad",
        stats_title: "Statistik", stats_times_up: "Tiden √§r ute!", stats_longest_streak: "L√§ngsta streak", stats_attempted: "F√∂rs√∂k", stats_correct_no_help: "R√§tt (utan hj√§lp)", stats_correct_help: "R√§tt (med hj√§lp)", stats_incorrect: "Fel", stats_skipped: "Hoppade √∂ver", stats_close: "St√§ng",
        menu_btn: "Meny", level_breakdown: "Niv√•detaljer",
        stat_skip: "Hopp", stat_wrong: "Fel", stat_help: "Hj√§lp", stat_correct: "R√§tt", stat_total: "Totalt",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Aktivitet", donow_desc: "V√§lj upp till 3 niv√•er f√∂r att generera ett startkort.",
        donow_generate: "Generera", backBtn: "Tillbaka",
        donow_show_all: "Visa Alla Svar", donow_hide_all: "D√∂lj Alla Svar",
        donow_regenerate: "Nytt Set", 
        levels: "Niv√•er",
        clickToSelect: "Klicka f√∂r att v√§lja niv√•",
        selectLevel: "V√§lj Niv√•",
        btnCheck: "Svara", btnHint: "Ledtr√•d", btnSolution: "L√∂sning", btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        error: "N√•got gick fel. F√∂rs√∂k igen.",
        levelUpTitle: "Niv√• upp?", levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", levelUpYes: "Ja, k√∂r!", levelUpNo: "Nej, stanna h√§r"
    },
    en: {
        hero_title: "Math Support",
        hero_subtitle: "Adaptive exercises for middle school.",
        tagline: "Right support. Instantly.",
        startBtn: "Start Practice",
        aboutBtn: "About Creator",
        contactTitle: "Contact Me",
        aboutTitle: "About the Creator",
        aboutText: "Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
        contactLink: "Follow me on LinkedIn",
        tagCorrect: "Correct", tagWrong: "Wrong", tagSkipped: "Skipped",
        streak_modal_title: "Awesome! üî•", streak_modal_msg: "You hit a streak of {streak}!",
        total_modal_title: "Great work! ‚úÖ", total_modal_msg: "You answered {total} questions correctly! Great job!",
        btn_close_streak: "Great job!", btn_close_total: "Continue",
        timer_title: "Practice Timer", timer_off: "Off", timer_min: "min", timer_reset: "Reset", timer_paused: "Paused",
        stats_title: "Statistics", stats_times_up: "Time's up!", stats_longest_streak: "Longest streak", stats_attempted: "Problems attempted", stats_correct_no_help: "Correct (no help)", stats_correct_help: "Correct (with help)", stats_incorrect: "Incorrect", stats_skipped: "Skipped", stats_close: "Close",
        menu_btn: "Menu", level_breakdown: "Level Breakdown",
        stat_skip: "Skip", stat_wrong: "Wrong", stat_help: "Help", stat_correct: "Correct", stat_total: "Total",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Activity", donow_desc: "Select up to 3 levels to generate a startup card.",
        donow_generate: "Generate", backBtn: "Back",
        donow_show_all: "Show All Answers", donow_hide_all: "Hide All Answers",
        donow_regenerate: "New Set", 
        levels: "Levels",
        clickToSelect: "Click to select level",
        selectLevel: "Select Level",
        btnCheck: "Submit", btnHint: "Hint", btnSolution: "Solution", btnSkip: "Skip",
        btnNext: "Next ‚û°",
        error: "Something went wrong. Please retry.",
        levelUpTitle: "Level Up?", levelUpDesc: "You seem to know this! Do you want to skip to the next level?", levelUpYes: "Yes, let's go!", levelUpNo: "No, stay here"
    }
};

export const LEVEL_DESCRIPTIONS = {
    
    angles: {
        1: { sv: "Vinkeltyper", en: "Types of Angles" },
        2: { sv: "Komplement & Supplement", en: "Complementary & Supplementary" },
        3: { sv: "Vertikal- & Sidovinklar", en: "Vertical & Adjacent Angles" },
        4: { sv: "Vinkelsumma (Triangel)", en: "Triangle Angle Sum" },
        5: { sv: "Likbel√§gna & Alternatvinklar", en: "Parallel Lines" },
        6: { sv: "Vinkelsumma (Polygoner)", en: "Polygon Angle Sum" }
    },
    change_factor: {
        1: { sv: "Begrepp & Definition", en: "Concepts & Definitions" },
        2: { sv: "Ber√§kna nya v√§rdet", en: "Calculate New Value" },
        3: { sv: "Ber√§kna gamla v√§rdet", en: "Find Original Value" },
        4: { sv: "Total f√∂r√§ndring", en: "Total Change" },
        5: { sv: "Textuppgifter", en: "Word Problems" }
    },
    fraction_basics: {
        1: { sv: "Visuella Br√•k", en: "Visual Fractions" },
        2: { sv: "Ber√§kna delen", en: "Parts of a Quantity" },
        3: { sv: "Blandad & Br√•kform", en: "Mixed & Improper" },
        4: { sv: "F√∂rl√§nga & F√∂rkorta", en: "Simplify & Extend" },
        5: { sv: "Br√•k & Decimaltal", en: "Fractions & Decimals" }
    },
    fraction_arith: {
        1: { sv: "Addition & Subtraktion (Lika)", en: "Add & Sub (Same Denom)" },
        2: { sv: "Addition & Subtraktion (Olika)", en: "Add & Sub (Diff Denom)" },
        3: { sv: "Blandad form (+)", en: "Mixed Numbers (+)" },
        4: { sv: "Multiplikation", en: "Multiplication" },
        5: { sv: "Division", en: "Division" }
    },
    exponents: { 
        1: { sv: "Grunder & x^0", en: "Foundations & x^0" },
        2: { sv: "Tiopotenser", en: "Powers of 10" },
        3: { sv: "Grundpotensform", en: "Scientific Notation" },
        4: { sv: "Kvadratr√∂tter", en: "Square Roots" },
        5: { sv: "Potenslagar (Enkel)", en: "Exponent Laws (Basic)" },
        6: { sv: "Potenslagar (Avancerad)", en: "Exponent Laws (Adv)" }
    },
    arithmetic: {
        1: { sv: "Addition (Uppst√§llning)", en: "Addition (Vertical)" },
        2: { sv: "Subtraktion (Uppst√§llning)", en: "Subtraction (Vertical)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (Enkel)", en: "Multiplication (Simple)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Kort Division", en: "Short Division" },
        8: { sv: "Blandade Heltal", en: "Mixed Integers" },
        9: { sv: "Blandade Decimaltal", en: "Mixed Decimals" }
    },
    negative: {
        1: { sv: "Enkel Addition/Subtraktion", en: "Simple Add/Sub" },
        2: { sv: "Sv√•rare Addition/Subtraktion", en: "Harder Add/Sub" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandade Uppgifter", en: "Mixed Problems" }
    },
    ten_powers: {
        1: { sv: "Mult/Div med 10, 100, 1000", en: "Mult/Div by 10, 100, 1000" },
        2: { sv: "Begreppsf√∂rst√•else", en: "Conceptual Understanding" },
        3: { sv: "Blandade Faktorer (0.1, 100...)", en: "Mixed Factors" }
    },
    percent: { 
        1: { sv: "Grundl√§ggande (Rutn√§t)", en: "Basic Concepts (Grid)" },
        2: { sv: "Huvudr√§kning (10%, 50%)", en: "Mental Math" },
        3: { sv: "Multiplar av 10%", en: "Multiples of 10%" },
        4: { sv: "Ber√§kna andelen (Decimal)", en: "Calculate Part (Decimal)" },
        5: { sv: "Hitta helheten (100%)", en: "Find Whole" },
        6: { sv: "Verklig F√∂r√§ndring", en: "Real World Change" }
    },
    probability: { 
        1: { sv: "Visuell Sannolikhet", en: "Visual Probability" },
        2: { sv: "T√§rning & Slump", en: "Dice & Chance" },
        3: { sv: "Sannolikhet som Procent", en: "Probability as Percent" },
        4: { sv: "Komplementh√§ndelse (Inte)", en: "Complementary Events" },
        5: { sv: "Tr√§ddiagram", en: "Probability Trees" },
        6: { sv: "Oberoende H√§ndelser", en: "Independent Events" },
        7: { sv: "Kombinatorik", en: "Combinatorics" },
        8: { sv: "Kombinatorik (Sv√•r)", en: "Combinatorics (Hard)" }
    },
    statistics: { 
        1: { sv: "Typv√§rde & Variationsbredd", en: "Mode & Range" },
        2: { sv: "Medelv√§rde", en: "Mean" },
        3: { sv: "Median", en: "Median" },
        4: { sv: "Bakl√§nges medelv√§rde", en: "Reverse Mean" },
        5: { sv: "Frekvenstabell", en: "Frequency Table" },
        6: { sv: "Blandade begrepp", en: "Mixed Concepts" }
    },
    simplify: {
        1: { sv: "F√∂renkla Uttryck (Enkel)", en: "Simplify Expressions (Easy)" },
        2: { sv: "Parenteser (Addition)", en: "Parentheses (Addition)" },
        3: { sv: "Parenteser (Multiplikation)", en: "Parentheses (Multiplication)" },
        4: { sv: "Parenteser (Subtraktion)", en: "Parentheses (Subtraction)" },
        5: { sv: "Probleml√∂sning", en: "Problem Solving" },
        6: { sv: "Blandade Niv√•er", en: "Mixed Levels" }
    },
    equation: {
        1: { sv: "Enkels steg (x+a=b)", en: "One Step" },
        2: { sv: "Tv√• steg (ax+b=c)", en: "Two Steps" },
        3: { sv: "Med Parenteser", en: "With Parentheses" },
        4: { sv: "Variabel p√• b√•da sidor", en: "Variables on both sides" },
        5: { sv: "Skriv Ekvation (Problem)", en: "Write Equation (Word Problems)" },
        6: { sv: "L√∂s Problem (Ekvation)", en: "Solve Word Problems" },
        7: { sv: "Blandade Ekvationer", en: "Mixed Equations" }
    },
    linear_graph: {
        1: { sv: "Hitta m-v√§rdet", en: "Find m-value" },
        2: { sv: "Hitta k-v√§rdet (Positiv)", en: "Find k-value (Positive)" },
        3: { sv: "Hitta k-v√§rdet (Negativ)", en: "Find k-value (Negative)" },
        4: { sv: "Best√§m funktionen (y=kx+m)", en: "Determine Function" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    geometry: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Sammansatta (Rekt+Tri)", en: "Composite Shapes (Rect+Tri)" },
        5: { sv: "Cirkelns Area & Omkrets", en: "Circle Area & Perimeter" },
        6: { sv: "Sammansatta (Alla)", en: "Composite Shapes (All)" }
    },
    scale: {
        1: { sv: "F√∂rst√• Skala", en: "Understand Scale" },
        2: { sv: "Ber√§kna L√§ngd (Enkel)", en: "Calculate Length (Simple)" },
        3: { sv: "Blandade Scenarier", en: "Mixed Scenarios" }, 
        4: { sv: "Best√§m Skalan", en: "Determine Scale" },
        5: { sv: "Probleml√∂sning", en: "Word Problems" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    volume: {
        1: { sv: "R√§tblock & Kub", en: "Cuboid & Cube" },
        2: { sv: "Prisma", en: "Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot & Sammansatta", en: "Sphere & Composite" },
        6: { sv: "Blandade Volymer", en: "Mixed Volumes" },
        7: { sv: "Enhetsomvandling", en: "Unit Conversion" },
        8: { sv: "Begr√§ngsningsyta", en: "Surface Area" } 
    },
    similarity: {
        1: { sv: "√Ñr de likformiga?", en: "Are they similar?" },
        2: { sv: "Ber√§kna sida (Enkel)", en: "Calc Side (Simple)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras & Likformighet", en: "Pythagoras & Similarity" }
    },
    pythagoras: {
        1: { sv: "Kvadrater & R√∂tter", en: "Squares & Roots" },
        2: { sv: "Hitta Hypotenusan", en: "Find Hypotenuse" },
        3: { sv: "Hitta Kateten", en: "Find Leg" },
        4: { sv: "Probleml√∂sning", en: "Word Problems" },
        5: { sv: "Avst√•nd (Koordinater)", en: "Distance (Coordinates)" },
        6: { sv: "√Ñr den r√§tvinklig?", en: "Is it Right-Angled?" }
    },
    patterns: { 
        1: { sv: "Hitta n√§sta tal & Skillnad", en: "Next Number & Difference" },
        2: { sv: "Ber√§kna h√∂ga figurer", en: "Calculate High Terms" },
        3: { sv: "Fr√•n bild till uttryck", en: "From Visual to Expression" },
        4: { sv: "Fr√•n tabell till formel", en: "Table to Formula" },
        5: { sv: "L√∂s ut n (bakl√§nges)", en: "Solve for n" }
    }
};

// FILE END: src\constants\localization.js

// =======================================================
// FILE START: src\core\generators\AnglesGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class AnglesGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Terminology(lang);
            case 2: return this.level2_CompSupp(lang);
            case 3: return this.level3_Vertical(lang);
            case 4: return this.level4_TriangleSum(lang);
            case 5: return this.level5_Polygons(lang);
            case 6: return this.level6_Parallel(lang);
            default: return this.level1_Terminology(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // L1: Classification
    private level1_Terminology(lang: string): any {
        const type = MathUtils.randomChoice(['acute', 'right', 'obtuse', 'straight']);
        let angle = 0;
        let labelSv = "";
        let labelEn = "";

        if (type === 'acute') { angle = MathUtils.randomInt(20, 80); labelSv = "Spetsig"; labelEn = "Acute"; }
        else if (type === 'right') { angle = 90; labelSv = "R√§t"; labelEn = "Right"; }
        else if (type === 'obtuse') { angle = MathUtils.randomInt(100, 170); labelSv = "Trubbig"; labelEn = "Obtuse"; }
        else { angle = 180; labelSv = "Rak"; labelEn = "Straight"; }

        const cx = 150, cy = 200;
        const len = 100;
        const x2 = cx + len * Math.cos(-angle * Math.PI / 180);
        const y2 = cy + len * Math.sin(-angle * Math.PI / 180);

        return {
            renderData: {
                description: lang === 'sv' ? "Vad kallas denna typ av vinkel?" : "What is this type of angle called?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle(lang === 'sv' ? ["Spetsig", "R√§t", "Trubbig", "Rak"] : ["Acute", "Right", "Obtuse", "Straight"]),
                geometry: {
                    type: 'angle',
                    lines: [{x1: cx, y1: cy, x2: cx + len, y2: cy}, {x1: cx, y1: cy, x2, y2}],
                    arcs: [{ center: {x: cx, y: cy}, startAngle: 0, endAngle: angle, radius: 40, label: `${angle}¬∞` }]
                }
            },
            token: this.toBase64(lang === 'sv' ? labelSv : labelEn),
            clues: [{ text: lang === 'sv' ? "Titta p√• gradtalet. R√§t vinkel √§r 90¬∞. Rak vinkel √§r 180¬∞." : "Look at the degrees. Right angle is 90¬∞. Straight is 180¬∞." }]
        };
    }

    // L2: 90 / 180 Splits
    private level2_CompSupp(lang: string): any {
        const isSupp = MathUtils.randomInt(0, 1) === 1;
        const total = isSupp ? 180 : 90;
        const known = MathUtils.randomInt(20, total - 20);
        const unknown = total - known;
        const cx = 150, cy = 200;
        const len = 120;

        const lines = isSupp ? [{x1: cx - len, y1: cy, x2: cx + len, y2: cy}] : [{x1: cx, y1: cy, x2: cx + len, y2: cy}, {x1: cx, y1: cy, x2: cx, y2: cy - len}];
        const xCut = cx + len * Math.cos(-known * Math.PI / 180);
        const yCut = cy + len * Math.sin(-known * Math.PI / 180);
        lines.push({x1: cx, y1: cy, x2: xCut, y2: yCut});

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna vinkeln x." : "Calculate angle x.",
                answerType: 'numeric',
                geometry: {
                    type: 'angle', lines,
                    arcs: [
                        { center: {x: cx, y: cy}, startAngle: 0, endAngle: known, radius: 40, label: `${known}¬∞` },
                        { center: {x: cx, y: cy}, startAngle: known, endAngle: total, radius: 50, label: 'x' }
                    ]
                }
            },
            token: this.toBase64(unknown.toString()),
            clues: [
                { text: lang === 'sv' ? (isSupp ? "En rak linje √§r 180¬∞." : "Ett r√§tblocksh√∂rn √§r 90¬∞.") : (isSupp ? "A straight line is 180¬∞." : "A right angle is 90¬∞.") },
                { text: lang === 'sv' ? `Subtrahera: ${total} - ${known} = x` : `Subtract: ${total} - ${known} = x` }
            ]
        };
    }

    // L3: Vertical & Side
    private level3_Vertical(lang: string): any {
        const angle = MathUtils.randomInt(40, 140);
        const type = MathUtils.randomChoice(['vertical', 'side']);
        const cx = 150, cy = 125, len = 100;
        const rot = 15;

        const lines = [
            {x1: cx - len * Math.cos(rot * Math.PI / 180), y1: cy + len * Math.sin(rot * Math.PI / 180), x2: cx + len * Math.cos(rot * Math.PI / 180), y2: cy - len * Math.sin(rot * Math.PI / 180)},
            {x1: cx - len * Math.cos((rot + angle) * Math.PI / 180), y1: cy + len * Math.sin((rot + angle) * Math.PI / 180), x2: cx + len * Math.cos((rot + angle) * Math.PI / 180), y2: cy - len * Math.sin((rot + angle) * Math.PI / 180)}
        ];

        let target = type === 'vertical' ? angle : 180 - angle;
        const arcs = [{ center: {x: cx, y: cy}, startAngle: rot, endAngle: rot + angle, radius: 40, label: `${angle}¬∞` }];
        if (type === 'vertical') arcs.push({ center: {x: cx, y: cy}, startAngle: rot + 180, endAngle: rot + angle + 180, radius: 40, label: 'x' });
        else arcs.push({ center: {x: cx, y: cy}, startAngle: rot + angle, endAngle: rot + 180, radius: 35, label: 'x' });

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna x." : "Calculate x.",
                answerType: 'numeric',
                geometry: { type: 'angle', lines, arcs }
            },
            token: this.toBase64(target.toString()),
            clues: [{ text: type === 'vertical' ? (lang === 'sv' ? "Vertikalvinklar (mitt emot) √§r lika stora." : "Vertical angles (opposite) are equal.") : (lang === 'sv' ? "Sidovinklar blir 180¬∞ tillsammans." : "Adjacent angles sum to 180¬∞.") }]
        };
    }

    // L4: Triangle Sum
    private level4_TriangleSum(lang: string): any {
        const a = MathUtils.randomInt(30, 80);
        const b = MathUtils.randomInt(30, 80);
        const x = 180 - a - b;
        
        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna den saknade vinkeln x i triangeln." : "Find the missing angle x in the triangle.",
                answerType: 'numeric',
                geometry: {
                    type: 'angle',
                    polygons: [{ points: "50,220 250,220 150,50" }],
                    labels: [{x: 65, y: 210, text: `${a}¬∞`}, {x: 235, y: 210, text: `${b}¬∞`}, {x: 150, y: 85, text: 'x'}]
                }
            },
            token: this.toBase64(x.toString()),
            clues: [
                { text: lang === 'sv' ? "Summan av vinklarna i en triangel √§r alltid 180¬∞." : "The sum of angles in a triangle is always 180¬∞." },
                { latex: `${a} + ${b} + x = 180` }
            ]
        };
    }

    // L5: Polygons (Sums & Missing Angle)
    private level5_Polygons(lang: string): any {
        // Mode 0: Calculate Sum (n-gon)
        // Mode 1: Find missing angle in Quadrilateral
        const type = MathUtils.randomInt(0, 1);

        if (type === 0) {
            const n = MathUtils.randomChoice([4, 5, 6]);
            const sum = (n - 2) * 180;
            const names = { 4: {sv:"fyrh√∂rning", en:"quadrilateral"}, 5: {sv:"femh√∂rning", en:"pentagon"}, 6: {sv:"sexh√∂rning", en:"hexagon"} };
            
            // Draw Regular Polygon
            const r = 80;
            const cx = 150, cy = 125;
            let pointsStr = "";
            for(let i=0; i<n; i++) {
                const ang = (i * 2 * Math.PI / n) - Math.PI/2;
                pointsStr += `${cx + r*Math.cos(ang)},${cy + r*Math.sin(ang)} `;
            }

            return {
                renderData: {
                    description: lang === 'sv' ? `Vad √§r vinkelsumman i en ${names[n as keyof typeof names].sv}?` : `What is the sum of angles in a ${names[n as keyof typeof names].en}?`,
                    answerType: 'numeric',
                    geometry: { type: 'angle', polygons: [{points: pointsStr}] }
                },
                token: this.toBase64(sum.toString()),
                clues: [
                    { text: lang === 'sv' ? "Formel: (antal h√∂rn - 2) √ó 180¬∞" : "Formula: (number of corners - 2) √ó 180¬∞" },
                    { latex: `(${n} - 2) \\cdot 180^\\circ` }
                ]
            };
        } else {
            // Find missing angle in Quadrilateral (Sum = 360)
            const a = MathUtils.randomInt(70, 110);
            const b = MathUtils.randomInt(70, 110);
            const c = MathUtils.randomInt(70, 110);
            const x = 360 - a - b - c;

            // Draw Irregular Quadrilateral
            const poly = { points: "50,50 250,50 230,200 70,200" };
            const labels = [
                {x: 70, y: 70, text: `${a}¬∞`}, 
                {x: 230, y: 70, text: `${b}¬∞`}, 
                {x: 210, y: 185, text: `${c}¬∞`}, 
                {x: 90, y: 185, text: 'x'}
            ];

            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna vinkeln x i fyrh√∂rningen." : "Calculate angle x in the quadrilateral.",
                    answerType: 'numeric',
                    geometry: { type: 'angle', polygons: [poly], labels: labels }
                },
                token: this.toBase64(x.toString()),
                clues: [
                    { text: lang === 'sv' ? "Vinkelsumman i en fyrh√∂rning √§r 360¬∞." : "The sum of angles in a quadrilateral is 360¬∞." },
                    { latex: `${a} + ${b} + ${c} + x = 360` }
                ]
            };
        }
    }

    // L6: Parallel Lines Advanced
    private level6_Parallel(lang: string): any {
        const angle = MathUtils.randomInt(50, 130);
        // Types: 
        // 'corr' (Corresponding - F)
        // 'alt_int' (Alternate Interior - Z)
        // 'alt_ext' (Alternate Exterior)
        // 'interior' (Co-interior - U / Sum 180)
        const type = MathUtils.randomChoice(['corr', 'alt_int', 'alt_ext', 'interior']);

        let target = (type === 'interior') ? 180 - angle : angle;
        const cx = 150, cy = 125, offset = 50;

        const lines = [
            {x1: 30, y1: cy - offset, x2: 270, y2: cy - offset}, // Top Parallel
            {x1: 30, y1: cy + offset, x2: 270, y2: cy + offset}, // Bottom Parallel
            {x1: 100, y1: 50, x2: 200, y2: 200} // Transversal
        ];

        const labels = [];
        // Define standard positions based on intersection points
        // Intersection Top: approx (117, 75)
        // Intersection Bot: approx (183, 175)
        
        // Let's assume standard position for Known Angle is Top-Right Intersection (Top Right sector)
        // This is an "Exterior" angle relative to the parallel band if it's above top line.
        // Let's place Known Angle at Top-Right-Interior (below top line, right of transversal) for simpler logic?
        // Or stick to Top-Right-Exterior (above top line). Let's use Top-Right-Exterior.
        labels.push({ x: 145, y: 65, text: `${angle}¬∞` }); // Top-Right (Exterior)

        // Determine position of x based on relationship to Top-Right (Exterior)
        if (type === 'corr') {
            // Corresponding: Bottom-Right (Exterior) relative to bottom intersection?
            // No, Corresponding to Top-Right-Ext is Bottom-Right-Ext.
            // i.e. Same relative position at bottom intersection.
            // Pos: Above bottom line, right of transversal.
            labels.push({ x: 210, y: 165, text: 'x' });
        } else if (type === 'alt_ext') {
            // Alternate Exterior: Bottom-Left (Exterior).
            // Opposite side of transversal, outside parallel lines.
            labels.push({ x: 140, y: 195, text: 'x' });
        } else if (type === 'alt_int') {
            // Alternate Interior: 
            // Wait, Top-Right-Ext is NOT interior.
            // To test Alt-Int, we should probably START with an interior angle.
            // Let's change the setup dynamically based on type.
        } 
        
        // RE-SETUP based on Type to ensure clear diagrams
        // Clear labels
        labels.length = 0;

        if (type === 'alt_int') {
            // Known: Top-Right (Interior)
            labels.push({ x: 145, y: 90, text: `${angle}¬∞` });
            // x: Bottom-Left (Interior) -> Z shape
            labels.push({ x: 155, y: 160, text: 'x' });
        } else if (type === 'interior') { // Co-interior
            // Known: Top-Right (Interior)
            labels.push({ x: 145, y: 90, text: `${angle}¬∞` });
            // x: Bottom-Right (Interior) -> U shape (Sum 180)
            labels.push({ x: 195, y: 160, text: 'x' });
        } else if (type === 'alt_ext') {
            // Known: Top-Left (Exterior)
            labels.push({ x: 90, y: 60, text: `${angle}¬∞` });
            // x: Bottom-Right (Exterior)
            labels.push({ x: 230, y: 190, text: 'x' });
        } else { // Corresponding
            // Known: Top-Right (Exterior)
            labels.push({ x: 145, y: 60, text: `${angle}¬∞` });
            // x: Bottom-Right (Exterior)
            labels.push({ x: 215, y: 160, text: 'x' });
        }

        const clueSv = type === 'interior' 
            ? "Vinklar p√• samma sida innanf√∂r linjerna (U-form) blir tillsammans 180¬∞." 
            : (type === 'alt_int' ? "Alternatvinklar (Z-form) √§r lika stora." 
            : (type === 'alt_ext' ? "Yttre alternatvinklar √§r lika stora." 
            : "Likbel√§gna vinklar (F-form) √§r lika stora."));

        return {
            renderData: {
                description: lang === 'sv' ? "Linjerna √§r parallella. Best√§m x." : "Lines are parallel. Find x.",
                answerType: 'numeric',
                geometry: { type: 'angle', lines, labels }
            },
            token: this.toBase64(target.toString()),
            clues: [
                {
                    text: lang === 'sv' ? clueSv : "Corresponding and Alternate angles are equal. Co-interior sum to 180¬∞.",
                    latex: type === 'interior' ? `x + ${angle} = 180` : `x = ${angle}`
                }
            ]
        };
    }
}

// FILE END: src\core\generators\AnglesGen.ts

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class BasicArithmeticGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSimple(lang);
            case 2: return this.level2_SubSimple(lang);
            case 3: return this.level3_Decimals(lang);
            case 4: return this.level4_MultEasy(lang);
            case 5: return this.level5_MultMedium(lang);
            case 6: return this.level6_MultHard(lang);
            case 7: return this.level7_DivEasy(lang);
            case 8: return this.level8_MixedIntegers(lang);
            case 9: return this.level9_MixedDecimals(lang);
            default: return this.level1_AddSimple(lang);
        }
    }

    // Helper for vertical layout
    private makeVertical(top: number | string, bottom: number | string, op: string): string {
        return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
    }

    // Level 1: Addition (1-3 digits)
    private level1_AddSimple(lang: string): any {
        const a = MathUtils.randomInt(1, 999);
        const b = MathUtils.randomInt(1, 999);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        
        return this.createProblem(a, b, '+', lang, isVertical);
    }

    // Level 2: Subtraction
    private level2_SubSimple(lang: string): any {
        const a = MathUtils.randomInt(2, 999);
        const b = MathUtils.randomInt(1, a - 1);
        const isVertical = MathUtils.randomInt(0, 1) === 1;

        return this.createProblem(a, b, '-', lang, isVertical);
    }

    // Level 3: Decimals (+/-)
    private level3_Decimals(lang: string): any {
        const op = MathUtils.randomChoice(['+', '-']);
        
        // Legacy Logic: Ensure reasonable numbers
        const getDec = () => MathUtils.randomInt(1, 4900) / 100;
        let a = getDec();
        let b = getDec();

        if (op === '+') {
            while (Math.floor(a + b) > 50) { a = getDec(); b = getDec(); }
        } else {
            if (b > a) [a, b] = [b, a]; // Ensure positive result
            while (Math.floor(a - b) > 50) { a = getDec(); b = getDec(); if (b > a) [a, b] = [b, a]; }
        }
        
        // Always vertical for decimals to encourage alignment practice
        return this.createProblem(a, b, op, lang, true, [
            { text: lang === 'sv' ? "St√§ll upp talen ovanp√• varandra." : "Line up the numbers vertically." },
            { text: lang === 'sv' ? "Viktigt: Decimaltecknen m√•ste vara rakt under varandra." : "Important: The decimal points must line up vertically." }
        ]);
    }

    // Level 4: Mult Easy (Tables 2-9)
    private level4_MultEasy(lang: string): any {
        const a = MathUtils.randomInt(1, 10);
        const b = MathUtils.randomInt(1, 10);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        return this.createProblem(a, b, '*', lang, isVertical);
    }

    // Level 5: Mult Medium (2 digit x 1 digit)
    private level5_MultMedium(lang: string): any {
        const a = MathUtils.randomInt(2, 20);
        const b = MathUtils.randomInt(2, 20);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        return this.createProblem(a, b, '*', lang, isVertical);
    }

    // Level 6: Mult Hard (Decimals) - Restored Legacy Subtypes
    private level6_MultHard(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        let a = 0, b = 0;

        if (type === 1) { // 0.x * 0.y
            a = MathUtils.randomInt(1, 9) / 10;
            b = MathUtils.randomInt(1, 9) / 10;
        } else if (type === 2) { // Int * 0.x
            a = MathUtils.randomInt(2, 20);
            b = MathUtils.randomInt(1, 9) / 10;
        } else if (type === 3) { // 0.x * 0.yz
            a = MathUtils.randomInt(1, 9) / 10;
            b = MathUtils.randomInt(1, 99) / 100;
        } else { // Int * 0.yz
            a = MathUtils.randomInt(2, 20);
            b = MathUtils.randomInt(1, 99) / 100;
        }

        return this.createProblem(a, b, '*', lang, false, [
            { text: lang === 'sv' ? "Ignorera decimalen f√∂rst. R√§kna som heltal." : "Ignore the decimal first. Calculate as integers." },
            { text: lang === 'sv' ? "R√§kna sedan hur m√•nga decimaler talen har totalt och s√§tt in i svaret." : "Count total decimal places and apply to the answer." }
        ]);
    }

    // Level 7: Division Easy (Integer results)
    private level7_DivEasy(lang: string): any {
        const f1 = MathUtils.randomInt(1, 10);
        const f2 = MathUtils.randomInt(1, 10);
        const product = f1 * f2;
        const divisor = MathUtils.randomInt(0, 1) === 1 ? f1 : f2;
        const answer = product / divisor;
        
        const latex = `\\frac{${product}}{${divisor}}`;
        const desc = lang === 'sv' ? "Dividera." : "Divide.";

        return {
            renderData: { latex, description: desc, answerType: 'text' },
            token: Buffer.from(answer.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? `T√§nk multiplikation: Vad g√•nger ${divisor} blir ${product}?` : `Think multiplication: What times ${divisor} makes ${product}?`, latex: `${divisor} \\cdot ? = ${product}` }
            ]
        };
    }

    // Level 8: Mixed Integers
    private level8_MixedIntegers(lang: string): any {
        const mode = MathUtils.randomChoice([1, 2, 4, 7]);
        if (mode === 1) return this.level1_AddSimple(lang);
        if (mode === 2) return this.level2_SubSimple(lang);
        if (mode === 4) return this.level4_MultEasy(lang);
        return this.level7_DivEasy(lang);
    }

    // Level 9: Mixed Decimals
    private level9_MixedDecimals(lang: string): any {
        const type = MathUtils.randomInt(1, 7);
        // Map 1-7 range roughly to the decimal/harder types
        if (type <= 3) return this.level3_Decimals(lang); // Add/Sub
        if (type <= 6) return this.level6_MultHard(lang); // Mult
        return this.level7_DivEasy(lang); // Keep division integer based for now as per legacy
    }

    // Helper
    private createProblem(a: number, b: number, op: string, lang: string, vertical: boolean = false, extraClues: any[] = []) {
        let ans = 0;
        let latex = "";
        
        if (op === '+') ans = a + b;
        if (op === '-') ans = a - b;
        if (op === '*') ans = a * b;
        
        // JS Floating point fix
        ans = Math.round(ans * 1000) / 1000;

        if (vertical) {
            const opSymbol = op === '*' ? '\\times' : op;
            const top = Math.max(a, b); // Standard convention puts larger on top usually
            const bot = Math.min(a, b);
            // Exception: Subtraction must respect order a - b
            if (op === '-') {
                latex = this.makeVertical(a, b, opSymbol);
            } else {
                latex = this.makeVertical(top, bot, opSymbol);
            }
        } else {
            const opSymbol = op === '*' ? '\\cdot' : op;
            latex = `${a} ${opSymbol} ${b}`;
        }

        const description = vertical 
            ? (lang === 'sv' ? "St√§ll upp och ber√§kna." : "Set up and calculate.")
            : (lang === 'sv' ? "Ber√§kna." : "Calculate.");

        // Default clues if none provided
        const defaultClues = [];
        if (vertical) {
            defaultClues.push({ text: lang === 'sv' ? "B√∂rja r√§kna fr√•n h√∂ger (entalen)." : "Start calculating from the right (ones)." });
        }

        return {
            renderData: { latex, description, answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: extraClues.length > 0 ? extraClues : defaultClues
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ChangeFactorGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ChangeFactorGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_ApplyFactor(lang);
            case 3: return this.level3_FindOriginal(lang);
            case 4: return this.level4_TotalChange(lang);
            case 5: return this.level5_WordProblems(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    public getLevelKey(level: number): string {
        const map: any = {
            1: 'concept',
            2: 'apply_factor',
            3: 'find_original',
            4: 'total_change',
            5: 'word_problems'
        };
        return map[level] || 'unknown';
    }

    // Level 1: Concept & Definition (Factor <-> Percent)
    private level1_Concepts(lang: string): any {
        const type = MathUtils.randomChoice(['pct_to_factor', 'factor_to_pct']);
        const isIncrease = MathUtils.randomInt(0, 1) === 1;
        
        // Expanded range: 1% to 150% (allowing >100% increases)
        // Bias towards integers, but allow 1.5% type things? No, keep integer percents for now.
        let pct = 0;
        if (Math.random() < 0.3) pct = MathUtils.randomInt(1, 9) * 10; // 10, 20...
        else pct = MathUtils.randomInt(1, 150); // 1..150
        
        let factor = 0;
        if (isIncrease) factor = 1 + (pct / 100);
        else {
            // For decrease, max 99%
            pct = Math.min(pct, 99);
            factor = 1 - (pct / 100);
        }
        
        factor = Math.round(factor * 100) / 100;

        if (type === 'pct_to_factor') {
            const desc = lang === 'sv'
                ? (isIncrease ? `En √∂kning med ${pct}%. Vad √§r f√∂r√§ndringsfaktorn?` : `En minskning med ${pct}%. Vad √§r f√∂r√§ndringsfaktorn?`)
                : (isIncrease ? `An increase of ${pct}%. What is the change factor?` : `A decrease of ${pct}%. What is the change factor?`);
            
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Utg√• alltid fr√•n 100%." : "Always start from 100%.",
                        latex: `100\\%` 
                    },
                    {
                        text: lang === 'sv' 
                            ? (isIncrease ? `Addera √∂kningen (${pct}%).` : `Dra bort minskningen (${pct}%).`)
                            : (isIncrease ? `Add the increase (${pct}%).` : `Subtract the decrease (${pct}%).`),
                        latex: isIncrease 
                            ? `100\\% + ${pct}\\% = ${100+pct}\\% = ${factor}`
                            : `100\\% - ${pct}\\% = ${100-pct}\\% = ${factor}`
                    }
                ]
            };
        } else {
            // Factor -> Percent
            const diff = Math.abs(1 - factor);
            const diffPct = Math.round(diff * 100);
            
            const desc = lang === 'sv'
                ? `F√∂r√§ndringsfaktorn √§r ${factor}. Vad √§r ${factor > 1 ? '√∂kningen' : 'minskningen'} i procent?`
                : `The change factor is ${factor}. What is the ${factor > 1 ? 'increase' : 'decrease'} in percent?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(diffPct.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? "J√§mf√∂r med 1 (som √§r 100%)." : "Compare with 1 (which is 100%).",
                        latex: factor > 1 
                            ? `${factor} - 1.00 = ${diff.toFixed(2)}`
                            : `1.00 - ${factor} = ${diff.toFixed(2)}`
                    },
                    {
                        text: lang === 'sv' ? "G√∂r om decimaltalet till procent." : "Convert decimal to percent.",
                        latex: `${diff.toFixed(2)} = ${diffPct}\\%`
                    }
                ]
            };
        }
    }

    // Level 2: Applying the Factor (New = Old * Factor)
    private level2_ApplyFactor(lang: string): any {
        // Generate diverse percent
        const pct = MathUtils.randomInt(1, 99);
        const isIncrease = MathUtils.randomInt(0, 1) === 1;
        let factor = isIncrease ? 1 + pct/100 : 1 - pct/100;
        factor = Math.round(factor * 100) / 100;

        // Choose base so answer is integer
        // We need base * factor = Integer
        // factor = X / 100. So base * X / 100 = Int.
        // Base must clear the denominator of (factor simplified).
        // Simplest strategy: Base is always a multiple of 100.
        // Or multiple of 10 if factor ends in .X
        
        let base = MathUtils.randomInt(1, 50) * 100; // 100...5000
        // Add variety to base (e.g. 250, 50)
        if (Math.random() < 0.5) base = MathUtils.randomInt(1, 20) * 50;

        const ans = Math.round(base * factor * 100) / 100; // Should be clean

        const desc = lang === 'sv'
            ? `Ett pris p√• ${base} kr ${isIncrease ? '√∂kar' : 'minskar'} med ${pct}%. Ber√§kna nya priset med f√∂r√§ndringsfaktor.`
            : `A price of ${base} kr ${isIncrease ? 'increases' : 'decreases'} by ${pct}%. Calculate the new price using the change factor.`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(ans.toString()),
            clues: [
                {
                    text: lang === 'sv' ? "Hitta f√∂r√§ndringsfaktorn f√∂rst." : "Find the change factor first.",
                    latex: isIncrease ? `100\\% + ${pct}\\% = ${factor}` : `100\\% - ${pct}\\% = ${factor}`
                },
                {
                    text: lang === 'sv' ? "Multiplicera gamla v√§rdet med faktorn." : "Multiply the old value by the factor.",
                    latex: `\\text{Nytt} = ${base} \\cdot ${factor} = ${ans}`
                }
            ]
        };
    }

    // Level 3: Finding Original (Old = New / Factor)
    private level3_FindOriginal(lang: string): any {
        const pct = MathUtils.randomInt(1, 99); // Varied percent
        const isIncrease = MathUtils.randomInt(0, 1) === 1;
        let factor = isIncrease ? 1 + pct/100 : 1 - pct/100;
        factor = Math.round(factor * 100) / 100;

        // Reverse Engineering:
        // We want Original to be Integer.
        // New = Original * Factor
        // Pick Original first.
        const original = MathUtils.randomInt(1, 50) * 100; // e.g. 500
        const newPrice = Math.round(original * factor * 100) / 100;

        const desc = lang === 'sv'
            ? `Efter en ${isIncrease ? '√∂kning' : 'minskning'} med ${pct}% kostar en vara ${newPrice} kr. Vad kostade den fr√•n b√∂rjan?`
            : `After a ${isIncrease ? 'increase' : 'decrease'} of ${pct}%, an item costs ${newPrice} kr. What was the original price?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(original.toString()),
            clues: [
                {
                    text: lang === 'sv' ? "Vi vet Nya priset. Vi s√∂ker Gamla priset." : "We know the New price. We seek the Old price.",
                    latex: `\\text{Gammalt} \\cdot ${factor} = ${newPrice}`
                },
                {
                    text: lang === 'sv' ? "Dividera med f√∂r√§ndringsfaktorn." : "Divide by the change factor.",
                    latex: `\\frac{${newPrice}}{${factor}} = ${original}`
                }
            ]
        };
    }

    // Level 4: Total Change (Sequential Factors)
    private level4_TotalChange(lang: string): any {
        const pct1 = MathUtils.randomChoice([5, 10, 15, 20, 25, 30, 40, 50]);
        const pct2 = MathUtils.randomChoice([5, 10, 15, 20, 25, 30, 40, 50]);
        
        const inc1 = MathUtils.randomInt(0, 1) === 1;
        const inc2 = MathUtils.randomInt(0, 1) === 1; 

        const f1 = inc1 ? 1 + pct1/100 : 1 - pct1/100;
        const f2 = inc2 ? 1 + pct2/100 : 1 - pct2/100;
        
        // Round to 4 decimals to avoid float errors, then display
        const totalFactor = Math.round(f1 * f2 * 10000) / 10000;

        const desc = lang === 'sv'
            ? `V√§rdet √§ndras f√∂rst med ${inc1 ? '+' : '-'}${pct1}%, och sedan med ${inc2 ? '+' : '-'}${pct2}%. Vad √§r den totala f√∂r√§ndringsfaktorn?`
            : `The value changes first by ${inc1 ? '+' : '-'}${pct1}%, then by ${inc2 ? '+' : '-'}${pct2}%. What is the total change factor?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(totalFactor.toString()),
            clues: [
                {
                    text: lang === 'sv' ? "G√∂r om varje procent till en faktor." : "Convert each percent to a factor.",
                    latex: `F_1 = ${f1}, \\quad F_2 = ${f2}`
                },
                {
                    text: lang === 'sv' ? "Multiplicera faktorerna med varandra." : "Multiply the factors.",
                    latex: `${f1} \\cdot ${f2} = ${totalFactor}`
                }
            ]
        };
    }

    // Level 5: Word Problems (Expanded Scenarios)
    private level5_WordProblems(lang: string): any {
        const scenarios = [
            'population', // Inc
            'interest',   // Inc
            'depreciation', // Dec (Car)
            'sale',         // Dec (Clothes)
            'decay',        // Dec (Bacteria/Substance)
            'salary',       // Inc
            'inflation',    // Inc
            'stock'         // Mixed
        ];
        
        const type = MathUtils.randomChoice(scenarios);

        // --- 1. Population (Find Factor) ---
        if (type === 'population') {
            const start = MathUtils.randomInt(50, 500) * 100; // 5000 - 50000
            // Make end a clean ratio? Not strictly necessary for "Find Factor" but nicer.
            // Let's just pick random pct change
            const pct = MathUtils.randomInt(1, 50);
            const end = Math.round(start * (1 + pct/100));
            const factor = 1 + pct/100;
            
            const desc = lang === 'sv'
                ? `En stad √∂kade sin befolkning fr√•n ${start} till ${end}. Vad √§r f√∂r√§ndringsfaktorn?`
                : `A city increased its population from ${start} to ${end}. What is the change factor?`;
            
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? "J√§mf√∂r det nya v√§rdet med det gamla." : "Compare the new value with the old.",
                        latex: `\\text{Faktor} = \\frac{\\text{Nytt}}{\\text{Gammalt}}`
                    },
                    { latex: `\\frac{${end}}{${start}} = ${factor}` }
                ]
            };
        } 
        
        // --- 2. Interest (Apply Factor ^ Years) ---
        else if (type === 'interest') {
            const money = MathUtils.randomInt(10, 100) * 100; // 1000 - 10000
            const years = 2;
            const rate = MathUtils.randomInt(2, 12); 
            const factor = 1 + rate/100;
            // Round to nearest kr
            const ans = Math.round(money * factor * factor); 

            const desc = lang === 'sv'
                ? `Du sparar ${money} kr med ${rate}% r√§nta per √•r. Hur mycket har du efter ${years} √•r? (Avrunda till heltal)`
                : `You save ${money} kr with ${rate}% interest per year. How much do you have after ${years} years? (Round to integer)`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(ans.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? `F√∂r√§ndringsfaktorn √§r ${factor}. Vi multiplicerar den tv√• g√•nger.` : `The factor is ${factor}. Multiply it twice.`,
                        latex: `${money} \\cdot ${factor} \\cdot ${factor}`
                    },
                    { latex: `${money} \\cdot ${Math.round(factor*factor*1000)/1000} \\approx ${ans}` }
                ]
            };
        }

        // --- 3. Car Depreciation (Decrease) ---
        else if (type === 'depreciation') {
            const price = MathUtils.randomInt(10, 50) * 10000; // 100k - 500k
            const drop = MathUtils.randomInt(5, 25);
            const factor = 1 - drop/100;
            const years = 2;
            const ans = Math.round(price * factor * factor);

            const desc = lang === 'sv'
                ? `En bil v√§rderad till ${price} kr minskar i v√§rde med ${drop}% per √•r. Vad √§r v√§rdet efter ${years} √•r? (Avrunda till heltal)`
                : `A car valued at ${price} kr depreciates by ${drop}% per year. What is the value after ${years} years? (Round to integer)`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(ans.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? `Minskning med ${drop}% ger faktorn ${factor}.` : `Decrease by ${drop}% gives factor ${factor}.`,
                        latex: `100\\% - ${drop}\\% = ${factor}`
                    },
                    {
                        text: lang === 'sv' ? "Multiplicera f√∂r varje √•r." : "Multiply for each year.",
                        latex: `${price} \\cdot ${factor} \\cdot ${factor} \\approx ${ans}`
                    }
                ]
            };
        }

        // --- 4. Sale (Find Original from New) ---
        else if (type === 'sale') {
            const discount = MathUtils.randomChoice([10, 15, 20, 25, 30, 40, 50]);
            const factor = 1 - discount/100;
            const original = MathUtils.randomInt(4, 20) * 50; // 200 - 1000
            const salePrice = original * factor; 

            const desc = lang === 'sv'
                ? `P√• rean s√§nks priset med ${discount}%. Nu kostar tr√∂jan ${salePrice} kr. Vad var ordinarie pris?`
                : `On sale, the price drops by ${discount}%. The shirt now costs ${salePrice} kr. What was the original price?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(original.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? `S√§nkning med ${discount}% betyder att ${(100-discount)}% √§r kvar (Faktor ${factor}).` : `${discount}% drop means ${(100-discount)}% remains (Factor ${factor}).`,
                        latex: `x \\cdot ${factor} = ${salePrice}`
                    },
                    { latex: `x = \\frac{${salePrice}}{${factor}} = ${original}` }
                ]
            };
        }

        // --- 5. Decay (Bacteria/Substance) ---
        else if (type === 'decay') {
            const start = 1000;
            const rate = MathUtils.randomChoice([10, 20, 50]);
            const factor = 1 - rate/100;
            const hours = 3;
            const ans = Math.round(start * Math.pow(factor, hours));

            const desc = lang === 'sv'
                ? `En m√§ngd p√• ${start} g minskar med ${rate}% varje timme. Hur mycket finns kvar efter ${hours} timmar? (Avrunda)`
                : `An amount of ${start} g decreases by ${rate}% every hour. How much remains after ${hours} hours? (Round)`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(ans.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? `Faktorn √§r ${factor}.` : `Factor is ${factor}.`,
                        latex: `100\\% - ${rate}\\% = ${factor}`
                    },
                    { latex: `${start} \\cdot ${factor}^3 \\approx ${ans}` }
                ]
            };
        }

        // --- 6. Salary (Increase - Find Factor) ---
        else if (type === 'salary') {
            const oldSal = MathUtils.randomInt(20, 40) * 1000; // 20k-40k
            const increase = MathUtils.randomInt(2, 8); // 2-8% raise
            const newSal = oldSal * (1 + increase/100);
            const factor = 1 + increase/100;

            const desc = lang === 'sv'
                ? `Din l√∂n √∂kade fr√•n ${oldSal} kr till ${newSal} kr. Vad √§r f√∂r√§ndringsfaktorn?`
                : `Your salary increased from ${oldSal} kr to ${newSal} kr. What is the change factor?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    { latex: `\\text{Faktor} = \\frac{\\text{Nytt}}{\\text{Gammalt}}` },
                    { latex: `\\frac{${newSal}}{${oldSal}} = ${factor}` }
                ]
            };
        }

        // --- 7. Inflation (Reverse - Find Old Value) ---
        else if (type === 'inflation') {
            const rate = MathUtils.randomInt(2, 5); // 2-5% inflation
            const factor = 1 + rate/100;
            const costBefore = MathUtils.randomInt(10, 50) * 10;
            const costNow = costBefore * factor;

            const desc = lang === 'sv'
                ? `Priset p√• en vara √§r idag ${costNow} kr efter en √∂kning p√• ${rate}%. Vad kostade den innan √∂kningen?`
                : `The price of an item is today ${costNow} kr after an increase of ${rate}%. What did it cost before?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(costBefore.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? `√ñkning p√• ${rate}% ger faktorn ${factor}.` : `${rate}% increase gives factor ${factor}.`,
                        latex: `\\text{Gammalt} \\cdot ${factor} = ${costNow}`
                    },
                    { latex: `\\frac{${costNow}}{${factor}} = ${costBefore}` }
                ]
            };
        }

        // --- 8. Stock Market (Decrease - Find Factor) ---
        else {
            const start = 200;
            const drop = MathUtils.randomInt(10, 50);
            const end = start * (1 - drop/100);
            const factor = 1 - drop/100;

            const desc = lang === 'sv'
                ? `En aktie f√∂ll fr√•n ${start} kr till ${end} kr. Vad √§r f√∂r√§ndringsfaktorn?`
                : `A stock fell from ${start} kr to ${end} kr. What is the change factor?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(factor.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? "Eftersom v√§rdet minskar ska faktorn vara mindre √§n 1." : "Since value decreased, factor should be less than 1.",
                        latex: `\\frac{\\text{Nytt}}{\\text{Gammalt}}`
                    },
                    { latex: `\\frac{${end}}{${start}} = ${factor}` }
                ]
            };
        }
    }
}

// FILE END: src\core\generators\ChangeFactorGen.ts

// =======================================================
// FILE START: src\core\generators\ExponentsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExponentsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Foundations(lang);
            case 2: return this.level2_PowersOfTen(lang);
            case 3: return this.level3_ScientificNotation(lang);
            case 4: return this.level4_SquareRoots(lang);
            case 5: return this.level5_LawsBasic(lang);
            case 6: return this.level6_LawsAdvanced(lang);
            default: return this.level1_Foundations(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Level 1: Foundations & Zero Rule
    private level1_Foundations(lang: string): any {
        const type = MathUtils.randomInt(1, 3);
        
        if (type === 1) { // Zero Rule
            const base = MathUtils.randomInt(5, 1000);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `${base}^0`,
                    answerType: 'numeric'
                },
                token: this.toBase64("1"),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? "T√§nk p√• division. Ett tal delat med sig sj√§lvt √§r alltid 1." 
                            : "Think about division. A number divided by itself is always 1.",
                        latex: `\\frac{${base}^2}{${base}^2} = 1 \\quad \\text{and} \\quad ${base}^{2-2} = ${base}^0`
                    },
                    {
                        text: lang === 'sv' ? "D√§rf√∂r √§r alla tal upph√∂jt till 0 lika med 1." : "Therefore, any number to the power of 0 is just 1."
                    }
                ]
            };
        } else if (type === 2) { // Power of 1
            const base = MathUtils.randomInt(2, 20);
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                    latex: `${base}^1`,
                    answerType: 'numeric'
                },
                token: this.toBase64(base.toString()),
                clues: [{ text: lang === 'sv' ? "Ett tal upph√∂jt till 1 √§r bara talet sj√§lvt." : "A number to the power of 1 is just the number itself." }]
            };
        } else { // Simple Square
            const base = MathUtils.randomInt(2, 12);
            const ans = base * base;
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna kvadraten:" : "Calculate the square:",
                    latex: `${base}^2`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? "Exponenten √§r 2, s√• vi multiplicerar basen med sig sj√§lv en g√•ng." 
                            : "The exponent is 2, so we multiply the base by itself one time.",
                        latex: `${base} \\cdot ${base}` 
                    }
                ]
            };
        }
    }

    // Level 2: Powers of 10 (Updated with Negative Exponents)
    private level2_PowersOfTen(lang: string): any {
        const isNegative = MathUtils.randomInt(0, 1) === 1;

        if (isNegative) {
            const power = MathUtils.randomInt(1, 8); // represents -1 to -8
            // Calculate decimal string manually to avoid scientific notation issues with very small numbers in JS
            // 10^-1 = 0.1, 10^-2 = 0.01
            let ansStr = "0.";
            for(let i=0; i<power-1; i++) ansStr += "0";
            ansStr += "1";

            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv som ett decimaltal:" : "Write as a decimal number:",
                    latex: `10^{-${power}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ansStr),
                clues: [
                    { 
                        text: lang === 'sv' 
                            ? "En negativ exponent betyder att vi dividerar med 10." 
                            : "A negative exponent means we divide by 10.",
                        latex: `10^{-${power}} = \\frac{1}{10^{${power}}}`
                    },
                    {
                        text: lang === 'sv' 
                            ? `Exponenten (-${power}) ber√§ttar hur m√•nga decimaler talet ska ha.` 
                            : `The exponent (-${power}) tells you how many decimal places the number has.`,
                        latex: `10^{-${power}} \\rightarrow ${ansStr} \\quad (${power} \\text{ decimaler})`
                    }
                ]
            };
        } else {
            const power = MathUtils.randomInt(2, 6);
            const ans = Math.pow(10, power);
            
            return {
                renderData: {
                    description: lang === 'sv' ? "Skriv som ett vanligt tal:" : "Write as a standard number:",
                    latex: `10^${power}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "R√§kna antalet nollor." : "Count the number of zeros.",
                        latex: `10^${power} \\rightarrow \\text{1 med ${power} nollor som f√∂ljer}`
                    },
                    {
                        text: lang === 'sv' ? "Exponenten visar hur m√•nga g√•nger vi multiplicerar 10." : "The exponent shows how many times we multiply 10.",
                        latex: `10^${power} = \\underbrace{10 \\cdot ... \\cdot 10}_{${power} \\text{ g√•nger}}`
                    }
                ]
            };
        }
    }

    // Level 3: Scientific Notation
    private level3_ScientificNotation(lang: string): any {
        const base = MathUtils.randomInt(1, 9);
        const decimal = MathUtils.randomInt(1, 9);
        const power = MathUtils.randomInt(3, 6);
        const number = (base + decimal/10) * Math.pow(10, power); // e.g. 4.5 * 1000 = 4500
        
        const correct = `${base}.${decimal} \\cdot 10^${power}`; // "4.5 * 10^3"
        const wrong = `${base * 10 + decimal} \\cdot 10^${power-1}`; // "45 * 10^2"

        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Skriv talet ${number} i grundpotensform.` 
                    : `Write the number ${number} in scientific notation.`,
                answerType: 'structured_scientific',
                options: MathUtils.shuffle([correct, wrong])
            },
            token: this.toBase64(correct),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? "F√∂rst, hitta ett tal mellan 1 och 10." 
                        : "First, find a number between 1 and 10.",
                    latex: `${base}.${decimal}`
                },
                { 
                    text: lang === 'sv' 
                        ? "R√§kna nu hur m√•nga steg decimalkommat flyttades." 
                        : "Now count how many steps the decimal point moved.",
                    latex: `${base}.${decimal} \\cdot 10 \\cdot ... \\rightarrow 10^${power}` 
                }
            ]
        };
    }

    // Level 4: Square Roots
    private level4_SquareRoots(lang: string): any {
        const base = MathUtils.randomInt(3, 15);
        const square = base * base;
        
        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                latex: `\\sqrt{${square}}`,
                answerType: 'numeric'
            },
            token: this.toBase64(base.toString()),
            clues: [
                { 
                    text: lang === 'sv' 
                        ? `Vi s√∂ker ett tal som g√•nger sig sj√§lvt blir ${square}.` 
                        : `We are looking for a number that, when squared, equals ${square}.`,
                    latex: `? \\cdot ? = ${square}`
                },
                {
                    text: lang === 'sv' ? "Testa dig fram..." : "Try testing numbers...",
                    latex: `${base-1} \\cdot ${base-1} = ${(base-1)**2} \\quad (\\text{Too Low})`
                }
            ]
        };
    }

    // Level 5: Basic Laws (Mult/Div)
    private level5_LawsBasic(lang: string): any {
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const a = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(2, 5);
        
        if (isMult) {
            const ans = a + b;
            return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla:" : "Simplify:",
                    latex: `x^${a} \\cdot x^${b}`,
                    answerType: 'structured_power',
                    prefillBase: 'x'
                },
                token: this.toBase64(`x^${ans}`),
                clues: [
                    { 
                        text: lang === 'sv' ? "Skriv ut vad potenserna betyder." : "Write out what the powers mean.",
                        latex: `(\\underbrace{x \\cdot ...}_{${a}}) \\cdot (\\underbrace{x \\cdot ...}_{${b}})` 
                    },
                    {
                        text: lang === 'sv' ? "R√§kna hur m√•nga x du har totalt." : "Count how many x's you have in total.",
                        latex: `${a} + ${b} = ${ans}`
                    }
                ]
            };
        } else {
            // Division (ensure a > b)
            const big = Math.max(a, b) + 2;
            const small = Math.min(a, b);
            const ans = big - small;
             return {
                renderData: {
                    description: lang === 'sv' ? "F√∂renkla:" : "Simplify:",
                    latex: `\\frac{x^${big}}{x^${small}}`,
                    answerType: 'structured_power',
                    prefillBase: 'x'
                },
                token: this.toBase64(`x^${ans}`),
                clues: [
                    { 
                        text: lang === 'sv' ? "Skriv ut x:en p√• toppen och botten." : "Write out the x's on top and bottom.",
                        latex: `\\frac{\\overbrace{x \\cdot ... \\cdot x}^{${big}}}{\\underbrace{x \\cdot ...}_{${small}}}`
                    },
                    {
                        text: lang === 'sv' ? "Stryk de som tar ut varandra. Hur m√•nga √§r kvar?" : "Cancel out the matching pairs. How many are left?",
                        latex: `${big} - ${small} = ${ans}`
                    }
                ]
            };
        }
    }

    // Level 6: Advanced Laws
    private level6_LawsAdvanced(lang: string): any {
        const a = MathUtils.randomInt(2, 4);
        const b = MathUtils.randomInt(2, 4);
        const ans = a * b;
        
        return {
             renderData: {
                description: lang === 'sv' ? "F√∂renkla:" : "Simplify:",
                latex: `(x^${a})^${b}`,
                answerType: 'structured_power',
                prefillBase: 'x'
            },
            token: this.toBase64(`x^${ans}`),
            clues: [
                { 
                    text: lang === 'sv' ? `Den yttre exponenten (${b}) betyder att vi har ${b} grupper av inneh√•llet.` : `The outer exponent (${b}) means we have ${b} groups of the inside part.`,
                    latex: `\\underbrace{x^${a} \\cdot ... \\cdot x^${a}}_{${b} \\text{ times}}`
                },
                {
                    text: lang === 'sv' ? "R√§kna ihop alla x totalt." : "Now just add the total x's like before.",
                    latex: `${a} \\cdot ${b} = ${ans}`
                }
            ]
        };
    }
}

// FILE END: src\core\generators\ExponentsGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExpressionSimplificationGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_CombineTerms(lang);
            case 2: return this.level2_Parentheses(lang);
            case 3: return this.level3_DistributeAndSimplify(lang);
            case 4: return this.level4_SubtractParentheses(lang);
            case 5: return this.level5_WordProblems(lang);
            case 6: return this.level6_Mixed(lang);
            default: return this.level1_CombineTerms(lang);
        }
    }

    // --- LEVEL 1: Combine Like Terms ---
    private level1_CombineTerms(lang: string): any {
        // Subtypes:
        // 1. ax + bx (Simple)
        // 2. ax + b + cx (Interleaved constant)
        // 3. ax + b + cx + d (Full mix)
        // 4. a - bx + cx + d (Negative start var, or const first)

        const subType = MathUtils.randomInt(1, 4);
        const v = 'x'; // Keep it simple for lower levels
        let latex = "";
        let answer = "";
        let clues: any[] = [];
        let desc = lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.";

        if (subType === 1) {
            // ax + bx
            const c1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 9);
            latex = `${c1}${v} + ${c2}${v}`;
            answer = `${c1+c2}${v}`;
            clues.push({ 
                text: lang === 'sv' ? "Addera koefficienterna (siffrorna framf√∂r x)." : "Add the coefficients.",
                latex: `${c1} + ${c2} = ${c1+c2}`
            });
            clues.push({
                text: lang === 'sv' ? "Svaret beh√•ller variabeln." : "Keep the variable.",
                latex: `\\mathbf{${answer}}`
            });
        } 
        else if (subType === 2) {
            // ax + b + cx
            const c1 = MathUtils.randomInt(2, 9);
            const k1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 9);
            
            // Random order: ax + b + cx OR b + ax + cx
            if (Math.random() > 0.5) latex = `${c1}${v} + ${k1} + ${c2}${v}`;
            else latex = `${k1} + ${c1}${v} + ${c2}${v}`;

            answer = `${c1+c2}${v} + ${k1}`;
            
            clues.push({
                text: lang === 'sv' ? "Hitta termerna med x och l√§gg ihop dem." : "Find the x-terms and add them.",
                latex: `${c1}${v} + ${c2}${v} = ${c1+c2}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Konstanten (siffran utan x) √§r kvar." : "The constant remains.",
                latex: `+ ${k1}`
            });
            clues.push({
                text: lang === 'sv' ? "S√§tt ihop uttrycket." : "Combine them.",
                latex: `\\mathbf{${answer}}`
            });
        }
        else if (subType === 3) {
            // ax + b + cx + d
            const c1 = MathUtils.randomInt(2, 6);
            const k1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 6);
            const k2 = MathUtils.randomInt(2, 9);

            latex = `${c1}${v} + ${k1} + ${c2}${v} + ${k2}`;
            answer = `${c1+c2}${v} + ${k1+k2}`;

            clues.push({
                text: lang === 'sv' ? "Steg 1: Addera x-termerna." : "Step 1: Add the x-terms.",
                latex: `${c1}${v} + ${c2}${v} = ${c1+c2}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Steg 2: Addera siffrorna (konstanterna)." : "Step 2: Add the constants.",
                latex: `${k1} + ${k2} = ${k1+k2}`
            });
            clues.push({
                text: lang === 'sv' ? "Resultat:" : "Result:",
                latex: `\\mathbf{${answer}}`
            });
        }
        else {
            // a - bx + cx + d (Negative handling)
            // Ensure result x is positive for simplicity in L1
            const k1 = MathUtils.randomInt(5, 15);
            const c_neg = MathUtils.randomInt(2, 5); // -bx
            const c_pos = c_neg + MathUtils.randomInt(1, 5); // cx, ensuring sum > 0
            const k2 = MathUtils.randomInt(2, 9);

            latex = `${k1} - ${c_neg}${v} + ${c_pos}${v} + ${k2}`;
            // (c_pos - c_neg)x + (k1 + k2)
            answer = `${c_pos - c_neg}${v} + ${k1+k2}`;

            clues.push({
                text: lang === 'sv' ? "Steg 1: Hantera x-termerna. T√§nk p√• minustecknet." : "Step 1: Handle x-terms. Mind the minus sign.",
                latex: `-${c_neg}${v} + ${c_pos}${v} = ${c_pos - c_neg}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Steg 2: Addera siffrorna." : "Step 2: Add the numbers.",
                latex: `${k1} + ${k2} = ${k1+k2}`
            });
            clues.push({
                text: lang === 'sv' ? "S√§tt ihop delarna." : "Combine parts.",
                latex: `\\mathbf{${answer}}`
            });
        }

        return {
            renderData: { latex, description: desc, answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: clues
        };
    }

    // --- LEVEL 2: Parentheses (Distribution) ---
    private level2_Parentheses(lang: string): any {
        const v = 'x';
        const outer = MathUtils.randomInt(2, 5);
        const innerC = MathUtils.randomInt(2, 5);
        const innerK = MathUtils.randomInt(1, 5);
        
        const latex = `${outer}(${innerC}${v} + ${innerK})`;
        const resC = outer * innerC;
        const resK = outer * innerK;
        const answer = `${resC}${v} + ${resK}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Multiplicera talet utanf√∂r med B√ÖDA termerna inuti." : "Multiply the number outside with BOTH terms inside.", 
                    latex: `${outer} \\cdot ${innerC}${v} + ${outer} \\cdot ${innerK}` 
                },
                { 
                    text: lang === 'sv' ? "Ber√§kna produkterna." : "Calculate the products.", 
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 3: Distribute & Combine ---
    private level3_DistributeAndSimplify(lang: string): any {
        const outer = MathUtils.randomInt(2, 4);
        const inC = MathUtils.randomInt(2, 4);
        const inK = MathUtils.randomInt(1, 5);
        const extraX = MathUtils.randomInt(2, 6);
        
        const latex = `${outer}(${inC}x + ${inK}) + ${extraX}x`;
        
        const distX = outer * inC;
        const distK = outer * inK;
        const totalX = distX + extraX;
        
        const answer = `${totalX}x + ${distK}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "B√∂rja med att ta bort parentesen." : "Start by removing the parentheses.", 
                    latex: `${distX}x + ${distK} + ${extraX}x` 
                },
                { 
                    text: lang === 'sv' ? "L√§gg ihop x-termerna." : "Combine the x-terms.", 
                    latex: `${distX}x + ${extraX}x = ${totalX}x` 
                },
                {
                    text: lang === 'sv' ? "Resultat:" : "Result:",
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 4: Subtracting Parentheses ---
    private level4_SubtractParentheses(lang: string): any {
        const startX = MathUtils.randomInt(5, 10);
        const subX = MathUtils.randomInt(1, startX - 1);
        const subK = MathUtils.randomInt(1, 5);
        
        const latex = `${startX}x - (${subX}x + ${subK})`;
        const resX = startX - subX;
        const resK = -subK; 
        
        const answer = `${resX}x - ${Math.abs(resK)}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Minus framf√∂r en parentes √§ndrar tecken p√• allt inuti." : "A minus in front of parentheses changes the sign of everything inside.", 
                    latex: `${startX}x - ${subX}x - ${subK}` 
                },
                { 
                    text: lang === 'sv' ? "F√∂renkla x-termerna." : "Simplify the x-terms.",
                    latex: `${startX}x - ${subX}x = ${resX}x`
                },
                {
                    text: lang === 'sv' ? "Resultat:" : "Result:",
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 5: Word Problems ---
    private level5_WordProblems(lang: string): any {
        const A = MathUtils.randomInt(2, 6);  
        const B = MathUtils.randomInt(5, 30); 
        const C = MathUtils.randomInt(2, 6);  
        
        const scenarios = [
            {
                type: 'add',
                sv: `Du har ${A} p√•sar med godis (x) och k√∂per ${C} p√•sar till. Du har ocks√• ${B} l√∂sa godisar.`,
                en: `You have ${A} bags of candy (x) and buy ${C} more bags. You also have ${B} loose candies.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `Du k√∂per ${A} tr√∂jor och ${C} byxor som alla kostar x kr styck. Du har en rabattkupong p√• ${B} kr.`,
                en: `You buy ${A} shirts and ${C} pants that all cost x kr each. You have a discount coupon for ${B} kr.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `Du betalar x kr/m√•nad i ${A} m√•nader, sen ${C} m√•nader till. Startavgiften var ${B} kr.`,
                en: `You pay x kr/mo for ${A} months, then ${C} months. Start fee was ${B} kr.`,
                op: '+', expl: '+'
            },
            {
                type: 'add',
                sv: `En triangel har sidorna x, ${A}x och ${C}x. Plus en extra str√§cka p√• ${B} cm.`,
                en: `A triangle has sides x, ${A}x, and ${C}x. Plus an extra length of ${B} cm.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `Du sparar x kr i ${A} veckor och ${C} veckor. Sen k√∂per du n√•got f√∂r ${B} kr.`,
                en: `You save x kr for ${A} weeks and ${C} weeks. Then you spend ${B} kr.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `Ett lag k√∂per x biljetter till ${A} spelare och ${C} ledare. Bokningsavgiften √§r ${B} kr.`,
                en: `A team buys x tickets for ${A} players and ${C} coaches. Booking fee is ${B} kr.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `En lastbil lastar ${A} l√•dor och ${C} paket (vikt x). Man lastar av ${B} kg skr√§p.`,
                en: `A truck loads ${A} boxes and ${C} packages (weight x). Unloads ${B} kg trash.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `I ett spel f√•r du x po√§ng i runda 1. Runda 2 ger ${A} g√•nger mer, runda 3 ger ${C} g√•nger mer. Bonus ${B} po√§ng.`,
                en: `Game: x points round 1. Round 2 is ${A}x, Round 3 is ${C}x. Bonus ${B} points.`,
                op: '+', expl: '+'
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const totalX = A + C; // Simplified logic assuming 1x is implied or adjusted in prompt if A/C not 1
        // Note: Scenarios assume "A bags" means "Ax", "C bags" means "Cx". 
        // If A or C represents "times more", logic holds.
        
        const answer = `${totalX}x ${s.op} ${B}`;
        
        const desc = lang === 'sv' 
            ? `${s.sv} Skriv ett uttryck f√∂r totalen och f√∂renkla.` 
            : `${s.en} Write an expression for the total and simplify.`;

        return {
            renderData: { latex: "", description: desc, answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? `1. Hitta x-termerna: ${A}x + ${C}x.` : `1. Find x-terms: ${A}x + ${C}x.`,
                    latex: `${totalX}x`
                },
                { 
                    text: lang === 'sv' ? `2. L√§gg till konstanten (${B}).` : `2. Add the constant (${B}).`, 
                    latex: `${totalX}x ${s.op} ${B}` 
                }
            ]
        };
    }

    private level6_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        return this.generate(lvl, lang);
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\FractionArithGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionArithGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SameDenom(lang);
            case 2: return this.level2_DiffDenom(lang);
            case 3: return this.level3_MixedNumbers(lang);
            case 4: return this.level4_Multiplication(lang);
            case 5: return this.level5_Division(lang);
            default: return this.level1_SameDenom(lang);
        }
    }

    // --- INTERNAL HELPERS ---
    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return MathUtils.gcd(a, b);
    }

    private lcm(a: number, b: number): number {
        return (a * b) / this.gcd(a, b);
    }

    private simplify(n: number, d: number): { n: number, d: number } {
        const div = this.gcd(n, d);
        return { n: n / div, d: d / div };
    }

    // --- LEVEL 1: SAME DENOMINATORS ---
    private level1_SameDenom(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Concept Check (True/False)
        if (variation < 0.25) {
            const d = MathUtils.randomInt(4, 9);
            const n1 = 1;
            const n2 = MathUtils.randomInt(1, d - 2);
            const sum = n1 + n2;
            
            const correctEq = `\\frac{${n1}}{${d}} + \\frac{${n2}}{${d}} = \\frac{${sum}}{${d}}`;
            const wrongEq = `\\frac{${n1}}{${d}} + \\frac{${n2}}{${d}} = \\frac{${sum}}{${d*2}}`; // The Lie
            
            const q = lang==='sv' ? "Vilken utr√§kning √§r r√§tt?" : "Which calculation is correct?";
            const optCorrect = lang==='sv' ? "Alternativ A" : "Option A";
            const optWrong = lang==='sv' ? "Alternativ B" : "Option B";

            return {
                renderData: {
                    description: q,
                    latex: `A: ${correctEq} \\quad B: ${wrongEq}`,
                    answerType: 'multiple_choice',
                    options: [optCorrect, optWrong]
                },
                token: this.toBase64(optCorrect),
                clues: [
                    { text: lang==='sv' ? "N√§mnaren √§ndras inte vid addition." : "Denominator does not change in addition.", latex: "" }
                ]
            };
        }

        // VARIATION B: Missing Term (Algebraic)
        if (variation < 0.5) {
            const d = MathUtils.randomInt(5, 12);
            const n1 = MathUtils.randomInt(1, d - 2);
            const nMissing = MathUtils.randomInt(1, d - n1 - 1);
            const nTotal = n1 + nMissing;

            return {
                renderData: {
                    description: lang==='sv' ? "Vad ska st√• i rutan?" : "What goes in the box?",
                    latex: `\\frac{${n1}}{${d}} + \\frac{?}{${d}} = \\frac{${nTotal}}{${d}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(nMissing.toString()),
                clues: [
                    { text: lang==='sv' ? "T√§ljarna m√•ste bli summan." : "Numerators must sum up.", latex: `${n1} + ? = ${nTotal}` }
                ]
            };
        }

        // VARIATION C: Standard Calculation
        const den = MathUtils.randomInt(4, 15);
        const n1 = MathUtils.randomInt(1, den-2);
        const n2 = MathUtils.randomInt(1, den - n1 - 1) || 1;
        const sumN = n1 + n2;
        const simp = this.simplify(sumN, den);

        return {
            renderData: {
                description: lang==='sv' ? "Ber√§kna:" : "Calculate:",
                latex: `\\frac{${n1}}{${den}} + \\frac{${n2}}{${den}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [{ text: "Add numerators only", latex: `${n1}+${n2}` }]
        };
    }

    // --- LEVEL 2: DIFFERENT DENOMINATORS ---
    private level2_DiffDenom(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Find LCD Only
        if (variation < 0.3) {
            // Generate pairs with interesting LCMs (not just products)
            const d1 = MathUtils.randomChoice([4, 6, 8, 9, 10]);
            const d2 = MathUtils.randomChoice([2, 3, 5, 12]);
            
            // Ensure distinct
            if (d1 === d2) return this.level2_DiffDenom(lang);

            const lcd = this.lcm(d1, d2);

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `Vad √§r minsta gemensamma n√§mnare (MGN) f√∂r 1/${d1} och 1/${d2}?` 
                        : `What is the Lowest Common Denominator (LCD) for 1/${d1} and 1/${d2}?`,
                    latex: `\\frac{1}{${d1}} + \\frac{1}{${d2}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(lcd.toString()),
                clues: [
                    { text: lang==='sv' ? "Hitta multiplar..." : "Find multiples...", latex: "" }
                ]
            };
        }

        // VARIATION B: Spot the Error
        if (variation < 0.6) {
            const stmtCorrect = lang==='sv' ? "R√§tt" : "Correct";
            const stmtWrong = lang==='sv' ? "Fel" : "Wrong";
            
            // Generate a random erroneous equation
            const n1=1, n2=1;
            const d1 = MathUtils.randomInt(2, 5);
            const d2 = MathUtils.randomInt(d1+1, 8);
            
            return {
                renderData: {
                    description: lang==='sv' ? "√Ñr denna utr√§kning r√§tt?" : "Is this calculation correct?",
                    latex: `\\frac{${n1}}{${d1}} + \\frac{${n2}}{${d2}} = \\frac{${n1+n2}}{${d1+d2}}`,
                    answerType: 'multiple_choice',
                    options: [stmtCorrect, stmtWrong]
                },
                token: this.toBase64(stmtWrong),
                clues: [
                    { text: lang==='sv' ? "Man f√•r aldrig addera n√§mnare." : "You can never add denominators.", latex: "" }
                ]
            };
        }

        // VARIATION C: Standard Calculation
        const d1 = MathUtils.randomInt(2, 6);
        const d2 = MathUtils.randomInt(2, 6);
        // Ensure differents to force LCD logic
        if (d1 === d2) return this.level2_DiffDenom(lang);

        const n1 = 1;
        const n2 = 1; 

        // Calc
        const lcd = this.lcm(d1, d2);
        const newN1 = n1 * (lcd/d1);
        const newN2 = n2 * (lcd/d2);
        const resN = newN1 + newN2;
        const simp = this.simplify(resN, lcd);

        return {
            renderData: {
                description: lang==='sv' ? "Ber√§kna:" : "Calculate:",
                latex: `\\frac{${n1}}{${d1}} + \\frac{${n2}}{${d2}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [{latex: `\\frac{${newN1}}{${lcd}} + \\frac{${newN2}}{${lcd}}`}]
        };
    }

    // --- LEVEL 3: MIXED NUMBERS ---
    private level3_MixedNumbers(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Estimation
        if (variation < 0.3) {
            const w1 = MathUtils.randomInt(1, 3);
            const w2 = MathUtils.randomInt(1, 3);
            const threshold = w1 + w2 + 1;
            
            const ansYes = lang==='sv'?'Ja':'Yes';
            const ansNo = lang==='sv'?'Nej':'No';
            
            return {
                renderData: {
                    description: lang==='sv' ? `√Ñr summan st√∂rre √§n ${threshold}?` : `Is the sum greater than ${threshold}?`,
                    latex: `${w1}\\frac{3}{4} + ${w2}\\frac{3}{4}`,
                    answerType: 'multiple_choice',
                    options: [ansYes, ansNo]
                },
                token: this.toBase64(ansYes),
                clues: [
                    { text: `${w1} + ${w2} = ${w1+w2}`, latex: "" },
                    { text: "3/4 + 3/4 = 6/4 > 1", latex: "" }
                ]
            };
        }

        // VARIATION B: Standard Calc
        const w1 = MathUtils.randomInt(1, 3);
        const w2 = MathUtils.randomInt(1, 3);
        const d = MathUtils.randomInt(3, 6);
        const n = 1;
        
        // n/d + n/d = 2n/d. If 2n < d, no carry. If 2n >= d, carry.
        const resW = w1 + w2;
        const resN = n + n;
        
        return {
            renderData: {
                description: lang==='sv' ? "Ber√§kna:" : "Calculate:",
                latex: `${w1}\\frac{${n}}{${d}} + ${w2}\\frac{${n}}{${d}}`,
                answerType: 'mixed_fraction'
            },
            token: this.toBase64(`${resW} ${resN}/${d}`),
            clues: [{latex: `${w1}+${w2} = ${resW}, ${n}/${d}+${n}/${d}=${resN}/${d}`}]
        };
    }

    // --- LEVEL 4: MULTIPLICATION ---
    private level4_Multiplication(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Scaling Logic
        if (variation < 0.3) {
            const int = MathUtils.randomChoice([10, 20, 50, 100]);
            const fracD = MathUtils.randomChoice([2, 4, 5, 10]);
            
            const q = lang==='sv' 
                ? `Om du multiplicerar ${int} med 1/${fracD}, blir talet st√∂rre eller mindre √§n ${int}?` 
                : `If you multiply ${int} by 1/${fracD}, does the number get bigger or smaller than ${int}?`;
            const optSmall = lang==='sv' ? "Mindre" : "Smaller";
            const optBig = lang==='sv' ? "St√∂rre" : "Bigger";

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: [optSmall, optBig]
                },
                token: this.toBase64(optSmall),
                clues: [{ text: `1/${fracD} < 1`, latex: "" }]
            };
        }

        // VARIATION B: Area Concept
        if (variation < 0.6) {
            const d1 = MathUtils.randomInt(2, 4);
            const d2 = MathUtils.randomInt(2, 5);
            
            const areaD = d1 * d2;

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `En rektangel har sidorna 1/${d1} m och 1/${d2} m. Vad √§r arean?` 
                        : `A rectangle has sides 1/${d1} m and 1/${d2} m. What is the area?`,
                    latex: "",
                    answerType: 'fraction',
                    suffix: 'm¬≤'
                },
                token: this.toBase64(`1/${areaD}`),
                clues: [{text: "Area = base ¬∑ height", latex: `\\frac{1}{${d1}} \\cdot \\frac{1}{${d2}}`}]
            };
        }

        // VARIATION C: Standard
        const n1 = MathUtils.randomInt(1, 4);
        const d1 = MathUtils.randomInt(n1+1, 6);
        const n2 = MathUtils.randomInt(1, 4);
        const d2 = MathUtils.randomInt(n2+1, 6);

        const resN = n1*n2;
        const resD = d1*d2;
        const simp = this.simplify(resN, resD);

        return {
            renderData: { description: "Calculate:", latex: `\\frac{${n1}}{${d1}} \\cdot \\frac{${n2}}{${d2}}`, answerType: 'fraction' },
            token: this.toBase64(`${simp.n}/${simp.d}`),
            clues: [{latex: `${n1}\\cdot${n2} / ${d1}\\cdot${d2}`}]
        };
    }

    // --- LEVEL 5: DIVISION ---
    private level5_Division(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Missing Operator
        if (variation < 0.3) {
            const opMult = "√ó";
            const opDiv = "√∑";
            const opAdd = "+";
            
            const frac = "1/2"; // Keep simple for operator logic

            return {
                renderData: {
                    description: lang==='sv' ? "Vilket tecken saknas?" : "Which sign is missing?",
                    latex: `${frac} \\text{ [ ? ] } ${frac} = 1`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([opMult, opDiv, opAdd])
                },
                token: this.toBase64(opDiv),
                clues: [
                    { text: lang==='sv' ? "Ett tal delat med sig sj√§lv √§r alltid 1." : "A number divided by itself is always 1.", latex: "" }
                ]
            };
        }

        // VARIATION B: Reciprocal
        if (variation < 0.6) {
            const n = MathUtils.randomInt(2, 5);
            const d = MathUtils.randomInt(n+1, 9);
            return {
                renderData: {
                    description: lang==='sv' ? "Vad √§r inversen (reciprokalen) till:" : "What is the reciprocal of:",
                    latex: `\\frac{${n}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${d}/${n}`),
                clues: [{text: lang==='sv'?"V√§nd upp och ner p√• br√•ket.":"Flip the fraction.", latex:""}]
            };
        }

        // VARIATION C: Standard
        const n = 1;
        const d1 = MathUtils.randomInt(3, 6);
        const d2 = 2; // Keep simple 1/2 division usually

        return {
            renderData: { description: "Calculate:", latex: `\\frac{1}{${d1}} \\div \\frac{1}{${d2}}`, answerType: 'fraction' },
            token: this.toBase64(`${d2}/${d1}`),
            clues: [{text: "Flip second and multiply", latex: `\\frac{1}{${d1}} \\cdot \\frac{${d2}}{1}`}]
        };
    }
}

// FILE END: src\core\generators\FractionArithGen.ts

// =======================================================
// FILE START: src\core\generators\FractionBasicsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class FractionBasicsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_PartsOfQuantity(lang);
            case 3: return this.level3_MixedImproper(lang);
            case 4: return this.level4_SimplifyExtend(lang);
            case 5: return this.level5_Decimals(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    // --- INTERNAL HELPERS ---
    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private gcd(a: number, b: number): number {
        return MathUtils.gcd(a, b);
    }

    // --- LEVEL 1: VISUAL CONCEPTS ---
    private level1_Visuals(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Spot the Lie (Percent Grid)
        if (variation < 0.3) {
            // Generate dynamic percentages: 10, 20, 25, 40, 50, 60, 75, 80, 90
            const p = MathUtils.randomChoice([10, 20, 25, 40, 50, 60, 75, 80, 90]);
            const total = 100;
            const fractionN = p;
            const fractionD = 100;
            
            // Generate simplified fraction for the "True" statement
            const div = this.gcd(fractionN, fractionD);
            const simpleN = fractionN / div;
            const simpleD = fractionD / div;

            const statementPercent = `${p}%`;
            const statementFraction = `${simpleN}/${simpleD}`;
            
            // Generate a dynamic "Lie"
            let statementFalse = "";
            if (p < 50) {
                statementFalse = lang === 'sv' ? "Mer √§n h√§lften" : "More than half";
            } else if (p === 50) {
                statementFalse = lang === 'sv' ? "Mindre √§n 1/4" : "Less than 1/4";
            } else {
                statementFalse = lang === 'sv' ? "Mindre √§n h√§lften" : "Less than half";
            }

            const options = MathUtils.shuffle([statementPercent, statementFraction, statementFalse]);

            return {
                renderData: {
                    description: lang === 'sv' 
                        ? "Titta p√• figuren. Vilket p√•st√•ende √§r FALSKT?" 
                        : "Look at the figure. Which statement is FALSE?",
                    answerType: 'multiple_choice',
                    options: options,
                    geometry: {
                        type: 'percent_grid',
                        total: 100,
                        colored: p
                    }
                },
                token: this.toBase64(statementFalse),
                clues: [
                    { text: lang==='sv' ? "H√§lften √§r 50 rutor." : "Half is 50 squares.", latex: "50/100" },
                    { text: lang==='sv' ? `Det √§r ${p} f√§rgade rutor.` : `There are ${p} colored squares.`, latex: `${p} \\neq ${statementFalse}` }
                ]
            };
        }

        // VARIATION B: Inverse Logic (Word Problem)
        if (variation < 0.6) {
            const fractionD = MathUtils.randomInt(3, 8);
            const countPerPart = MathUtils.randomInt(2, 6);
            const total = countPerPart * fractionD;
            
            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Du har ${total} kulor. 1/${fractionD} av dem √§r r√∂da. Hur m√•nga √§r r√∂da?`
                        : `You have ${total} marbles. 1/${fractionD} of them are red. How many are red?`,
                    answerType: 'numeric',
                    geometry: null // No visual, force mental model
                },
                token: this.toBase64(countPerPart.toString()),
                clues: [
                    { 
                        text: lang==='sv' ? `Dela totalen i ${fractionD} lika stora h√∂gar.` : `Divide the total into ${fractionD} equal piles.`, 
                        latex: `${total} / ${fractionD}` 
                    }
                ]
            };
        }

        // VARIATION C: Standard Visuals (Marbles)
        const red = MathUtils.randomInt(1, 5);
        const blue = MathUtils.randomInt(1, 5);
        const green = MathUtils.randomInt(1, 5);
        const totalItems = red + blue + green;
        const target = MathUtils.randomChoice(['red', 'blue', 'green']);
        
        let count = 0;
        let colorName = "";
        if (target === 'red') { count = red; colorName = lang==='sv'?'r√∂da':'red'; }
        else if (target === 'blue') { count = blue; colorName = lang==='sv'?'bl√•a':'blue'; }
        else { count = green; colorName = lang==='sv'?'gr√∂na':'green'; }

        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Hur stor andel √§r ${colorName}?` 
                    : `What fraction are ${colorName}?`,
                answerType: 'fraction',
                geometry: { type: 'probability_marbles', items: { red, blue, green } }
            },
            token: this.toBase64(`${count}/${totalItems}`),
            clues: [{ text: lang==='sv' ? "Delen / Det hela" : "Part / Whole", latex: `\\frac{\\text{${colorName}}}{\\text{Total}}` }]
        };
    }

    // --- LEVEL 2: PARTS OF QUANTITY ---
    private level2_PartsOfQuantity(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Inverse (Find the Whole)
        if (variation < 0.3) {
            const denom = MathUtils.randomChoice([3, 4, 5, 6, 8, 10]);
            const partValue = MathUtils.randomChoice([5, 10, 15, 20, 25, 50, 100]);
            const total = partValue * denom;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `1/${denom} av ett pris √§r ${partValue} kr. Hur mycket √§r hela priset?`
                        : `1/${denom} of a prize is ${partValue} kr. How much is the total prize?`,
                    answerType: 'numeric',
                    suffix: 'kr'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { 
                        text: lang==='sv' ? `Om en del √§r ${partValue}, m√•ste vi ta det g√•nger ${denom} f√∂r att f√• helheten.` : `If one part is ${partValue}, multiply by ${denom} to get the whole.`,
                        latex: `${partValue} \\cdot ${denom}` 
                    }
                ]
            };
        }

        // VARIATION B: Comparison Check
        if (variation < 0.6) {
            // Generate two scenarios
            const d1 = MathUtils.randomInt(2, 5);
            const mult1 = MathUtils.randomInt(2, 6);
            const t1 = d1 * mult1;
            
            const d2 = MathUtils.randomInt(2, 5);
            const mult2 = MathUtils.randomInt(2, 6);
            const t2 = d2 * mult2;

            // Ensure they are not equal
            if (mult1 === mult2) return this.level2_PartsOfQuantity(lang);

            const isFirstLarger = mult1 > mult2;
            const winningOpt = isFirstLarger 
                ? `1/${d1} ${lang==='sv'?'av':'of'} ${t1}`
                : `1/${d2} ${lang==='sv'?'av':'of'} ${t2}`;
            
            const losingOpt = isFirstLarger
                ? `1/${d2} ${lang==='sv'?'av':'of'} ${t2}`
                : `1/${d1} ${lang==='sv'?'av':'of'} ${t1}`;

            const q = lang === 'sv' ? `Vilket √§r st√∂rst?` : `Which is largest?`;

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([winningOpt, losingOpt])
                },
                token: this.toBase64(winningOpt),
                clues: [
                    { text: "Calc A", latex: `${t1} / ${d1} = ${mult1}` },
                    { text: "Calc B", latex: `${t2} / ${d2} = ${mult2}` }
                ]
            };
        }

        // VARIATION C: Standard Calculation
        const denom = MathUtils.randomChoice([3, 4, 5, 6, 8, 10]);
        const mult = MathUtils.randomInt(2, 12);
        const total = denom * mult;

        return {
            renderData: {
                description: lang === 'sv' ? "Ber√§kna:" : "Calculate:",
                latex: `\\frac{1}{${denom}} \\text{ ${lang==='sv'?'av':'of'} } ${total}`,
                answerType: 'numeric'
            },
            token: this.toBase64(mult.toString()),
            clues: [{ text: "Division", latex: `${total} / ${denom}` }]
        };
    }

    // --- LEVEL 3: MIXED & IMPROPER ---
    private level3_MixedImproper(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Bounds Check (True/False)
        if (variation < 0.3) {
            const w = MathUtils.randomInt(2, 6);
            const den = MathUtils.randomInt(3, 8);
            const num = MathUtils.randomInt(1, den - 1);
            const improper = w * den + num; 

            // Pick a comparison integer close to w
            const isGreater = Math.random() > 0.5; // Do we want the answer to be Yes or No?
            const compareVal = isGreater ? w : w + 1; 
            
            // logic: improper/den is > w.
            // If compareVal == w, then improper > compareVal (True)
            // If compareVal == w+1, then improper < compareVal (False)
            
            const correctAnswer = (improper/den > compareVal) ? (lang==='sv'?'Ja':'Yes') : (lang==='sv'?'Nej':'No');
            const wrongAnswer = (improper/den > compareVal) ? (lang==='sv'?'Nej':'No') : (lang==='sv'?'Ja':'Yes');

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `√Ñr detta br√•k st√∂rre √§n ${compareVal}?` 
                        : `Is this fraction greater than ${compareVal}?`,
                    latex: `\\frac{${improper}}{${den}}`,
                    answerType: 'multiple_choice',
                    options: [correctAnswer, wrongAnswer]
                },
                token: this.toBase64(correctAnswer),
                clues: [
                    { 
                        text: lang==='sv' ? `G√∂r om ${compareVal} till ${den}-delar.` : `Convert ${compareVal} to ${den}-ths.`,
                        latex: `${compareVal} = \\frac{${compareVal*den}}{${den}}`
                    },
                    {
                        text: lang==='sv' ? "J√§mf√∂r t√§ljarna." : "Compare numerators.",
                        latex: `${improper} \\text{ vs } ${compareVal*den}`
                    }
                ]
            };
        }

        // VARIATION B: Missing Part
        if (variation < 0.6) {
            const w = MathUtils.randomInt(1, 5);
            const d = MathUtils.randomInt(3, 9);
            const n = MathUtils.randomInt(1, d - 1);
            const imp = w * d + n;

            return {
                renderData: {
                    description: lang==='sv' ? "Vilket tal saknas?" : "What number is missing?",
                    latex: `${w}\\frac{?}{${d}} = \\frac{${imp}}{${d}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(n.toString()),
                clues: [
                    { text: lang==='sv' ? "Heltalet g√•nger n√§mnaren plus ?" : "Whole times denominator plus ?", latex: `${w} \\cdot ${d} + ? = ${imp}` },
                    { latex: `${w*d} + ? = ${imp}` }
                ]
            };
        }

        // VARIATION C: Standard Conversion
        const isToImp = Math.random() > 0.5;
        const w = MathUtils.randomInt(1, 6);
        const d = MathUtils.randomInt(3, 9);
        const n = MathUtils.randomInt(1, d - 1);
        const imp = w * d + n;

        if (isToImp) {
            return {
                renderData: {
                    description: lang==='sv' ? "Skriv i br√•kform:" : "Write as improper fraction:",
                    latex: `${w}\\frac{${n}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${imp}/${d}`),
                clues: [{latex: `${w} \\cdot ${d} + ${n}`}]
            };
        } else {
            return {
                renderData: {
                    description: lang==='sv' ? "Skriv i blandad form:" : "Write as mixed number:",
                    latex: `\\frac{${imp}}{${d}}`,
                    answerType: 'fraction'
                },
                token: this.toBase64(`${w} ${n}/${d}`),
                clues: [{latex: `${imp} / ${d} = ${w} \\text{ rem } ${n}`}]
            };
        }
    }

    // --- LEVEL 4: SIMPLIFY & EXTEND ---
    private level4_SimplifyExtend(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Missing Factor (Equivalent Fractions)
        if (variation < 0.3) {
            const baseN = MathUtils.randomInt(1, 5);
            const baseD = MathUtils.randomInt(baseN + 1, 9);
            const factor = MathUtils.randomInt(2, 6);
            
            const targetD = baseD * factor;
            const targetN = baseN * factor; 

            return {
                renderData: {
                    description: lang==='sv' ? "Hitta t√§ljaren:" : "Find the numerator:",
                    latex: `\\frac{${baseN}}{${baseD}} = \\frac{?}{${targetD}}`,
                    answerType: 'numeric'
                },
                token: this.toBase64(targetN.toString()),
                clues: [
                    { 
                        text: lang==='sv' ? `Vad multiplicerades ${baseD} med f√∂r att f√• ${targetD}?` : `What was ${baseD} multiplied by to get ${targetD}?`, 
                        latex: `${baseD} \\cdot ${factor} = ${targetD}` 
                    },
                    { 
                        text: lang==='sv' ? "G√∂r samma sak med t√§ljaren." : "Do the same to the numerator.", 
                        latex: `${baseN} \\cdot ${factor}` 
                    }
                ]
            };
        }

        // VARIATION B: Concept Check
        if (variation < 0.6) {
            // Randomize between Extension (1), Simplification (2), or Modification (3)
            const type = MathUtils.randomInt(1, 3);
            const k = MathUtils.randomInt(2, 10);
            
            let q = "";
            let stmtTrue = "";
            let stmtFalse = "";
            let clue = "";

            if (type === 1) {
                // Extension (Value stays same)
                q = lang === 'sv' 
                    ? `Vad h√§nder med v√§rdet om du multiplicerar b√•de t√§ljare och n√§mnare med ${k}?`
                    : `What happens to the value if you multiply both numerator and denominator by ${k}?`;
                stmtTrue = lang === 'sv' ? "V√§rdet √§r detsamma" : "Value stays the same";
                stmtFalse = lang === 'sv' ? "V√§rdet blir st√∂rre" : "Value gets larger";
                clue = "1/2 = 2/4 = 3/6";
            } else if (type === 2) {
                // Simplification (Value stays same)
                q = lang === 'sv' 
                    ? `Vad h√§nder med v√§rdet om du dividerar b√•de t√§ljare och n√§mnare med ${k}?`
                    : `What happens to the value if you divide both numerator and denominator by ${k}?`;
                stmtTrue = lang === 'sv' ? "V√§rdet √§r detsamma" : "Value stays the same";
                stmtFalse = lang === 'sv' ? "V√§rdet blir mindre" : "Value gets smaller";
                clue = "4/8 = 1/2";
            } else {
                // Modification (Value changes)
                q = lang === 'sv'
                    ? `Vad h√§nder med v√§rdet om du ENDAST multiplicerar t√§ljaren med ${k}?`
                    : `What happens to the value if you ONLY multiply the numerator by ${k}?`;
                stmtTrue = lang === 'sv' ? "V√§rdet √§ndras" : "Value changes";
                stmtFalse = lang === 'sv' ? "V√§rdet √§r detsamma" : "Value stays the same";
                clue = `1/2 \\neq ${k}/2`;
            }
            
            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([stmtFalse, stmtTrue])
                },
                token: this.toBase64(stmtTrue),
                clues: [
                    { text: clue, latex: "" }
                ]
            };
        }

        // VARIATION C: Standard Simplify
        const factor = MathUtils.randomInt(2, 6);
        const simpN = MathUtils.randomInt(1, 9);
        const simpD = MathUtils.randomInt(simpN + 1, 15);
        
        // Ensure relative prime for valid simplification task
        if (this.gcd(simpN, simpD) !== 1) return this.level4_SimplifyExtend(lang);

        const bigN = simpN * factor;
        const bigD = simpD * factor;

        return {
            renderData: {
                description: lang==='sv' ? "F√∂rkorta s√• l√•ngt det g√•r:" : "Simplify fully:",
                latex: `\\frac{${bigN}}{${bigD}}`,
                answerType: 'fraction'
            },
            token: this.toBase64(`${simpN}/${simpD}`),
            clues: [{ text: `GCD is ${factor}`, latex: `\\div ${factor}` }]
        };
    }

    // --- LEVEL 5: DECIMALS ---
    private level5_Decimals(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Inequality Check
        if (variation < 0.3) {
            // Generate fraction and decimal that are somewhat close
            const d = MathUtils.randomChoice([2, 4, 5, 10]);
            const n = MathUtils.randomInt(1, d - 1);
            const fracVal = n / d;
            
            // Generate a random comparison decimal
            let compareDec = MathUtils.randomFloat(0.1, 0.9, 1);
            if (compareDec === fracVal) compareDec += 0.1;

            const correct = fracVal > compareDec ? ">" : "<";
            
            return {
                renderData: {
                    description: lang==='sv' ? "V√§lj r√§tt tecken:" : "Choose the correct sign:",
                    latex: `\\frac{${n}}{${d}} \\text{ [ ? ] } ${compareDec}`,
                    answerType: 'multiple_choice',
                    options: [">", "<", "="]
                },
                token: this.toBase64(correct),
                clues: [{ text: `${n}/${d} = ${fracVal}`, latex: `${fracVal} ${correct} ${compareDec}` }]
            };
        }

        // VARIATION B: Standard Translation
        // Expanded list of benchmarks
        const benchmarks = [
            { f: "1/2", d: 0.5 }, { f: "1/4", d: 0.25 }, { f: "3/4", d: 0.75 },
            { f: "1/5", d: 0.2 }, { f: "2/5", d: 0.4 }, { f: "3/5", d: 0.6 }, { f: "4/5", d: 0.8 },
            { f: "1/10", d: 0.1 }, { f: "3/10", d: 0.3 }, { f: "7/10", d: 0.7 }, { f: "9/10", d: 0.9 }
        ];
        const item = MathUtils.randomChoice(benchmarks);
        const toDec = Math.random() > 0.5;

        if (toDec) {
            return {
                renderData: { description: "Skriv som decimal", latex: item.f, answerType: 'numeric' },
                token: this.toBase64(item.d.toString()),
                clues: []
            };
        } else {
            return {
                renderData: { description: "Skriv som br√•ktal i enklaste form", latex: item.d.toString(), answerType: 'fraction' },
                token: this.toBase64(item.f),
                clues: []
            };
        }
    }
}

// FILE END: src\core\generators\FractionBasicsGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class GeometryGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_PerimeterBasic(lang);
            case 2: return this.level2_AreaBasic(lang);
            case 3: return this.level3_Triangles(lang);
            case 4: return this.level4_CombinedFigures(lang);
            case 5: return this.level5_Circles(lang);
            case 6: return this.level6_CompositeAdvanced(lang);
            default: return this.level1_PerimeterBasic(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: PERIMETER ONLY ---
    private level1_PerimeterBasic(lang: string): any {
        const type = MathUtils.randomChoice(['rectangle', 'square', 'parallelogram']);
        
        if (type === 'square') {
            const s = MathUtils.randomInt(3, 15);
            const ans = 4 * s;
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' 
                        ? "En kvadrat har sidan " + s + ". Ber√§kna omkretsen." 
                        : "A square has side " + s + ". Calculate the perimeter.",
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "En kvadrat har fyra sidor som alla √§r lika l√•nga." : "A square has four sides of equal length.", 
                        latex: "" 
                    },
                    {
                        text: lang === 'sv' ? "Addera sidan fyra g√•nger eller multiplicera med 4." : "Add the side four times or multiply by 4.",
                        latex: `O = 4 \\cdot ${s}`
                    }
                ]
            };
        } 
        else if (type === 'rectangle') {
            const b = MathUtils.randomInt(4, 15);
            const h = MathUtils.randomInt(3, 10);
            const ans = 2 * (b + h);
            
            return {
                renderData: {
                    geometry: { type: 'rectangle', width: b, height: h, labels: { b: b, h: h } },
                    description: lang === 'sv' 
                        ? `En rektangel har basen ${b} och h√∂jden ${h}. Ber√§kna omkretsen.` 
                        : `A rectangle has base ${b} and height ${h}. Calculate the perimeter.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Omkretsen √§r summan av alla sidor. Det finns tv√• baser och tv√• h√∂jder." : "Perimeter is the sum of all sides. There are two bases and two heights.", 
                        latex: "" 
                    },
                    {
                        text: lang === 'sv' ? "Addera ihop allt." : "Add everything together.",
                        latex: `O = ${b} + ${b} + ${h} + ${h} = 2(${b} + ${h})`
                    }
                ]
            };
        }
        else { // Parallelogram
            const b = MathUtils.randomInt(5, 15);
            const s = MathUtils.randomInt(4, 12); 
            const h = MathUtils.randomInt(3, s - 1); 
            const ans = 2 * (b + s);

            return {
                renderData: {
                    geometry: { type: 'parallelogram', width: b, height: h, labels: { b: b, s: s } }, 
                    description: lang === 'sv' 
                        ? `En parallellogram har sidorna ${b} och ${s}. Ber√§kna omkretsen.` 
                        : `A parallelogram has sides ${b} and ${s}. Calculate the perimeter.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Precis som en rektangel har den tv√• par av lika l√•nga sidor." : "Just like a rectangle, it has two pairs of equal sides.", 
                        latex: "" 
                    },
                    {
                        text: lang === 'sv' ? "Addera alla sidor f√∂r att f√• omkretsen." : "Add all sides to get the perimeter.",
                        latex: `O = 2 \\cdot ${b} + 2 \\cdot ${s}`
                    }
                ]
            };
        }
    }

    // --- LEVEL 2: AREA ---
    private level2_AreaBasic(lang: string): any {
        const type = MathUtils.randomChoice(['rectangle', 'square', 'parallelogram']);
        
        if (type === 'square') {
            const s = MathUtils.randomInt(3, 12);
            const ans = s * s;
            return {
                renderData: {
                    geometry: { type: 'square', width: s, height: s, labels: { b: s, h: s } },
                    description: lang === 'sv' 
                        ? `En kvadrat har sidan ${s}. Ber√§kna arean.` 
                        : `A square has side ${s}. Calculate the area.`,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? "Area √§r hur stor ytan √§r. F√∂r en kvadrat tar du sidan g√•nger sidan." : "Area is the size of the surface. For a square, take side times side.",
                        latex: `A = s \\cdot s`
                    },
                    {
                        latex: `${s} \\cdot ${s}`
                    }
                ]
            };
        } else {
            const b = MathUtils.randomInt(4, 12);
            const h = MathUtils.randomInt(3, 10);
            const ans = b * h;
            
            const desc = lang === 'sv'
                ? `Ber√§kna arean av ${type === 'rectangle' ? 'rektangeln' : 'parallellogrammen'}.`
                : `Calculate the area of the ${type}.`;

            return {
                renderData: {
                    geometry: { type: type, width: b, height: h, labels: { b: b, h: h } },
                    description: desc,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "F√∂r att hitta arean, multiplicera basen med h√∂jden." : "To find the area, multiply the base by the height.", 
                        latex: `A = \\text{Bas} \\cdot \\text{H√∂jd}` 
                    },
                    {
                        latex: `${b} \\cdot ${h}`
                    }
                ]
            };
        }
    }

    // --- LEVEL 3: TRIANGLES ---
    private level3_Triangles(lang: string): any {
        const isArea = MathUtils.randomInt(0, 1) === 1;
        
        if (isArea) {
            const b = MathUtils.randomInt(4, 12);
            const h = MathUtils.randomInt(3, 10);
            const ans = (b * h) / 2;
            
            return {
                renderData: {
                    geometry: { type: 'triangle', width: b, height: h, labels: { b: b, h: h } },
                    description: lang === 'sv' 
                        ? `En triangel har basen ${b} och h√∂jden ${h}. Ber√§kna arean.` 
                        : `A triangle has base ${b} and height ${h}. Calculate the area.`,
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "T√§nk dig att triangeln √§r halva rektangeln med samma bas och h√∂jd." : "Imagine the triangle is half of a rectangle with the same base and height.", 
                        latex: "" 
                    },
                    {
                        text: lang === 'sv' ? "R√§kna ut basen g√•nger h√∂jden, och dela sedan med 2." : "Calculate base times height, then divide by 2.",
                        latex: `A = \\frac{${b} \\cdot ${h}}{2}`
                    }
                ]
            };
        } else {
            // Perimeter
            const type = MathUtils.randomChoice(['right', 'isosceles', 'scalene']);
            
            if (type === 'right') {
                const triple = MathUtils.randomChoice([{a:3,b:4,c:5}, {a:5,b:12,c:13}, {a:6,b:8,c:10}]);
                return {
                    renderData: {
                        geometry: { 
                            type: 'triangle', width: triple.a, height: triple.b, subtype: 'right',
                            labels: { b: triple.a, h: triple.b, hyp: triple.c } 
                        },
                        description: lang === 'sv' ? "Ber√§kna triangelns omkrets." : "Calculate the triangle's perimeter.",
                        answerType: 'numeric'
                    },
                    token: this.toBase64((triple.a+triple.b+triple.c).toString()),
                    clues: [
                        { text: lang === 'sv' ? "Omkretsen √§r v√§gen runt hela figuren. Addera alla tre sidor." : "Perimeter is the path around the shape. Add all three sides.", latex: `${triple.a} + ${triple.b} + ${triple.c}` }
                    ]
                };
            } else if (type === 'isosceles') {
                const b = MathUtils.randomInt(4, 10);
                const leg = MathUtils.randomInt(b, b+5);
                return {
                    renderData: {
                        geometry: { 
                            type: 'triangle', width: b, height: leg, 
                            labels: { b: b, s1: leg, s2: leg } 
                        },
                        description: lang === 'sv' ? "Ber√§kna omkretsen av den likbenta triangeln." : "Calculate the perimeter of the isosceles triangle.",
                        answerType: 'numeric'
                    },
                    token: this.toBase64((b + 2*leg).toString()),
                    clues: [
                        { text: lang === 'sv' ? "En likbent triangel har tv√• sidor som √§r lika l√•nga." : "An isosceles triangle has two sides of equal length.", latex: "" },
                        { text: lang === 'sv' ? "Addera basen och de tv√• benen." : "Add the base and the two legs.", latex: `${b} + ${leg} + ${leg}` }
                    ]
                };
            } else {
                const s1 = MathUtils.randomInt(3, 8);
                const s2 = MathUtils.randomInt(4, 9);
                const s3 = MathUtils.randomInt(5, 10); 
                return {
                    renderData: {
                        geometry: { 
                            type: 'triangle', width: s2, height: s1, 
                            labels: { s1: s1, b: s2, s2: s3 } 
                        },
                        description: lang === 'sv' ? "Ber√§kna omkretsen." : "Calculate the perimeter.",
                        answerType: 'numeric'
                    },
                    token: this.toBase64((s1+s2+s3).toString()),
                    clues: [
                        { text: lang === 'sv' ? "Addera l√§ngden p√• alla tre sidorna." : "Add the lengths of all three sides.", latex: `${s1} + ${s2} + ${s3}` }
                    ]
                };
            }
        }
    }

    // --- LEVEL 4: COMBINED FIGURES ---
    private level4_CombinedFigures(lang: string): any {
        const type = MathUtils.randomChoice(['rect_right_tri', 'l_shape', 'house_area']);
        
        if (type === 'rect_right_tri') {
            const rectW = MathUtils.randomInt(4, 8);
            const rectH = MathUtils.randomInt(4, 8);
            const triBase = MathUtils.randomInt(3, 5);
            const area = rectW * rectH + (triBase * rectH) / 2;
            
            return {
                renderData: {
                    geometry: { 
                        type: 'composite', 
                        subtype: 'rect_right_tri', 
                        labels: { w: rectW, h: rectH, tri_b: triBase } 
                    },
                    description: lang === 'sv' 
                        ? "Figuren best√•r av en rektangel och en r√§tvinklig triangel. Ber√§kna totala arean." 
                        : "The figure consists of a rectangle and a right triangle. Calculate the total area.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(area.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Dela upp problemet. R√§kna f√∂rst ut rektangelns area (Bas ‚Ä¢ H√∂jd)." : "Split the problem. First calculate the rectangle's area (Base ‚Ä¢ Height).", 
                        latex: `A_{rect} = ${rectW} \\cdot ${rectH}` 
                    },
                    { 
                        text: lang === 'sv' ? "R√§kna sedan ut triangelns area (Bas ‚Ä¢ H√∂jd / 2)." : "Then calculate the triangle's area (Base ‚Ä¢ Height / 2).", 
                        latex: `A_{tri} = \\frac{${triBase} \\cdot ${rectH}}{2}` 
                    },
                    {
                        text: lang === 'sv' ? "Addera de tv√• areorna f√∂r att f√• totalen." : "Add the two areas to get the total.",
                        latex: `${rectW*rectH} + ${(triBase*rectH)/2}`
                    }
                ]
            };
        }
        else if (type === 'l_shape') {
            const vW = MathUtils.randomInt(2, 4);
            const vH = MathUtils.randomInt(6, 10);
            const extensionW = MathUtils.randomInt(4, 8); 
            const hH = MathUtils.randomInt(3, 5);
            
            const totalW = vW + extensionW;
            const area = vW * vH + extensionW * hH;
            
            return {
                renderData: {
                    geometry: {
                        type: 'composite',
                        subtype: 'l_shape',
                        labels: { vW, vH, hW: extensionW, hH, totalW }
                    },
                    description: lang === 'sv' 
                        ? "Figuren √§r sammansatt av tv√• rektanglar. Ber√§kna totala arean." 
                        : "The figure is composed of two rectangles. Calculate the total area.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(area.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Dela upp figuren. Du vet totala bredden och toppen. Vad √§r bredden p√• utsticket?" : "Split the figure. You know total width and top. What is the extension width?", 
                        latex: `\\text{Utstick} = ${totalW} - ${vW} = ${extensionW}` 
                    },
                    {
                        text: lang === 'sv' ? "R√§kna nu arean f√∂r den st√•ende delen och det liggande utsticket." : "Now calculate area for standing part and lying extension.",
                        latex: `(${vW} \\cdot ${vH}) + (${extensionW} \\cdot ${hH})`
                    }
                ]
            };
        }
        else {
            // House Area
            const s = MathUtils.randomInt(4, 8);
            const hTri = MathUtils.randomInt(3, 6);
            const area = s*s + (s*hTri)/2;
            
            return {
                renderData: {
                    geometry: { 
                        type: 'composite', 
                        subtype: 'house_area', 
                        labels: { s: s, h_tri: hTri } 
                    },
                    description: lang === 'sv' 
                        ? "Figuren best√•r av en kvadrat och en triangel. Ber√§kna totala arean." 
                        : "The figure consists of a square and a triangle. Calculate the total area.",
                    answerType: 'numeric', suffix: 'cm¬≤'
                },
                token: this.toBase64(area.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "R√§kna ut kvadratens area (sidan ‚Ä¢ sidan)." : "Calculate the square's area (side ‚Ä¢ side).", 
                        latex: `A_{sq} = ${s} \\cdot ${s}` 
                    },
                    { 
                        text: lang === 'sv' ? "R√§kna ut triangelns area (bas ‚Ä¢ h√∂jd / 2)." : "Calculate the triangle's area (base ‚Ä¢ height / 2).", 
                        latex: `A_{tri} = \\frac{${s} \\cdot ${hTri}}{2}` 
                    },
                    {
                        text: lang === 'sv' ? "Totalt:" : "Total:",
                        latex: `${s*s} + ${(s*hTri)/2}`
                    }
                ]
            };
        }
    }

    // --- LEVEL 5: CIRCLES ---
    private level5_Circles(lang: string): any {
        const type = MathUtils.randomChoice(['circle', 'semicircle', 'quarter']);
        const r = MathUtils.randomInt(3, 10);
        const pi = 3.14;

        if (type === 'circle') {
            const isArea = MathUtils.randomInt(0, 1) === 1;
            const ans = isArea ? Math.round(pi * r * r * 10) / 10 : Math.round(2 * pi * r * 10) / 10;
            return {
                renderData: { 
                    geometry: { 
                        type: 'circle', 
                        radius: r, 
                        show: isArea ? 'radius' : 'diameter', 
                        labels: isArea ? { r: r } : { diameter: 2*r } 
                    }, 
                    description: lang === 'sv' 
                        ? (isArea ? "Ber√§kna arean (pi = 3.14)." : "Ber√§kna omkretsen (pi = 3.14).")
                        : (isArea ? "Calculate area (pi = 3.14)." : "Calculate perimeter (pi = 3.14)."), 
                    answerType: 'numeric' 
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: isArea ? "Area = pi ‚Ä¢ r¬≤" : "Omkrets = pi ‚Ä¢ d", 
                        latex: isArea ? `3.14 \\cdot ${r}^2` : `3.14 \\cdot ${2*r}` 
                    },
                    {
                        text: lang === 'sv' ? "S√§tt in v√§rdena:" : "Insert values:",
                        latex: isArea ? `${r} \\cdot ${r} \\cdot 3.14` : `${2*r} \\cdot 3.14`
                    }
                ]
            };
        } else if (type === 'semicircle') {
            const isArea = MathUtils.randomInt(0, 1) === 1;
            if (isArea) {
                const area = (pi * r * r) / 2;
                const ans = Math.round(area * 10) / 10;
                return {
                    renderData: {
                        geometry: { type: 'semicircle', radius: r, labels: { r: r } },
                        description: lang === 'sv' ? "Ber√§kna halvcirkelns area." : "Calculate the semicircle's area.",
                        answerType: 'numeric', suffix: 'cm¬≤'
                    },
                    token: this.toBase64(ans.toString()),
                    clues: [
                        { text: lang==='sv' ? "R√§kna ut hela cirkelns area f√∂rst." : "Calculate the full circle area first.", latex: `\\pi \\cdot ${r}^2` },
                        { text: lang==='sv' ? "Eftersom det √§r en halvcirkel, dela med 2." : "Since it's a semicircle, divide by 2.", latex: `/ 2` }
                    ]
                };
            } else {
                const d = 2 * r;
                const arc = (pi * d) / 2;
                const perim = arc + d;
                const ans = Math.round(perim * 10) / 10;
                return {
                    renderData: {
                        geometry: { type: 'semicircle', radius: r, labels: { diameter: d }, show: 'diameter' },
                        description: lang === 'sv' ? "Ber√§kna halvcirkelns omkrets (b√•gen + basen)." : "Calculate the semicircle's perimeter (arc + base).",
                        answerType: 'numeric'
                    },
                    token: this.toBase64(ans.toString()),
                    clues: [
                        { text: lang==='sv' ? "R√§kna ut b√•gens l√§ngd (halva cirkelns omkrets)." : "Calculate arc length (half circle circumference).", latex: `(\\pi \\cdot ${d}) / 2` },
                        { text: lang==='sv' ? "Gl√∂m inte att addera den raka basen (diametern)!" : "Don't forget to add the straight base (diameter)!", latex: `+ ${d}` }
                    ]
                };
            }
        } else {
            const isArea = MathUtils.randomInt(0, 1) === 1;
            if (isArea) {
                const area = (pi * r * r) / 4;
                const ans = Math.round(area * 10) / 10;
                return {
                    renderData: {
                        geometry: { type: 'quarter_circle', radius: r, labels: { r: r } },
                        description: lang === 'sv' ? "Ber√§kna kvartscirkelns area." : "Calculate the quarter-circle's area.",
                        answerType: 'numeric', suffix: 'cm¬≤'
                    },
                    token: this.toBase64(ans.toString()),
                    clues: [
                        { text: lang==='sv' ? "Det √§r en fj√§rdedel av en cirkel. R√§kna ut hela arean och dela med 4." : "It's a quarter circle. Calculate full area and divide by 4.", latex: `(\\pi \\cdot ${r}^2) / 4` }
                    ]
                };
            } else {
                const circ = 2 * pi * r;
                const arc = circ / 4;
                const perim = arc + 2 * r;
                const ans = Math.round(perim * 10) / 10;
                return {
                    renderData: {
                        geometry: { type: 'quarter_circle', radius: r, labels: { r: r } },
                        description: lang === 'sv' ? "Ber√§kna kvartscirkelns omkrets." : "Calculate the quarter-circle's perimeter.",
                        answerType: 'numeric'
                    },
                    token: this.toBase64(ans.toString()),
                    clues: [
                        { text: lang==='sv' ? "B√•gen √§r en fj√§rdedel av cirkelns omkrets." : "The arc is one fourth of the circle's circumference.", latex: `(2 \\cdot \\pi \\cdot ${r}) / 4` },
                        { text: lang==='sv' ? "L√§gg till de tv√• raka sidorna (radierna)." : "Add the two straight sides (radii).", latex: `+ ${r} + ${r}` }
                    ]
                };
            }
        }
    }

    // --- LEVEL 6: COMPOSITE ADVANCED ---
    private level6_CompositeAdvanced(lang: string): any {
        const isHouse = MathUtils.randomInt(0, 1) === 1;
        const w = MathUtils.randomInt(4, 10) * 10; 
        const h = MathUtils.randomInt(4, 8) * 10;
        
        let ans = 0;
        let geom: any = {};
        let desc = "";
        let steps = [];

        if (isHouse) {
            const hRoof = MathUtils.randomInt(2, 5) * 10;
            const slope = Math.sqrt((w/2)**2 + hRoof**2);
            ans = Math.round((w + 2*h + 2*slope) * 10) / 10;
            desc = lang === 'sv' 
                ? `Ber√§kna husets omkrets (inklusive taket).` 
                : `Calculate the house's perimeter (including the roof).`;
            steps = [
                { text: lang==='sv' ? "R√§kna ut takets sneda sida med Pythagoras sats (valfritt, h√§r √§r l√§ngden given som ca X)." : "Calculate roof slope (length approx X).", latex: `s \\approx ${Math.round(slope*10)/10}` },
                { text: lang==='sv' ? "Addera botten, v√§ggarna och taket." : "Add bottom, walls, and roof.", latex: `${w} + 2\\cdot${h} + 2\\cdot${Math.round(slope*10)/10}` }
            ];
            geom = { type: 'composite', subtype: 'house', labels: { w, h, h_roof: hRoof } };
        } else {
            const r = w / 2;
            const arc = 3.14 * r;
            ans = Math.round((w + 2*h + arc) * 10) / 10;
            desc = lang === 'sv' 
                ? `Ber√§kna portalens omkrets.` 
                : `Calculate the portal's perimeter.`;
            steps = [
                { text: lang==='sv' ? "B√•gen √§r en halvcirkel. R√§kna ut dess l√§ngd." : "The arch is a semicircle. Calculate its length.", latex: `\\pi \\cdot ${r}` },
                { text: lang==='sv' ? "Addera golvet och v√§ggarna." : "Add the floor and walls.", latex: `+ ${w} + ${h} + ${h}` }
            ];
            geom = { type: 'composite', subtype: 'portal', labels: { w, h } };
        }

        return {
            renderData: { 
                geometry: geom, 
                description: desc, 
                answerType: 'numeric' 
            },
            token: this.toBase64(ans.toString()),
            clues: steps
        };
    }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';
import { LinearEquationProblemGen } from './LinearEquationProblemGen.js';

export class LinearEquationGen {
    private problemGen: LinearEquationProblemGen;

    constructor() {
        this.problemGen = new LinearEquationProblemGen();
    }

    public generate(level: number, lang: string = 'sv'): any {
        // Delegate Word Problems to the Specialist
        if (level === 5 || level === 6) {
            return this.problemGen.generate(level, lang);
        }
        
        // Mixed Level Drill
        if (level === 7) {
            return this.level7_Mixed(lang);
        }

        switch (level) {
            case 1: return this.level1_OneStep(lang);
            case 2: return this.level2_TwoStep(lang);
            case 3: return this.level3_Parentheses(lang);
            case 4: return this.level4_BothSides(lang);
            default: return this.level1_OneStep(lang);
        }
    }

    // --- LEVEL 1: One-Step Equations ---
    private level1_OneStep(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        let latex = '', answer = '', clues = [];
        
        if (type === 1) { // x / k = res
            const k = MathUtils.randomInt(2, 9);
            const res = MathUtils.randomInt(2, 10);
            const val = res * k;
            latex = `\\frac{x}{${k}} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. Eftersom x √§r delat med ${k}, g√∂r vi det motsatta: vi multiplicerar med ${k}.` 
                    : `We want x alone. Since x is divided by ${k}, we do the opposite: multiply by ${k}.`, 
                latex: `x = ${res} \\cdot ${k} \\\\ x = ${val}` 
            }];
        } 
        else if (type === 2) { // k * x = res
            const k = MathUtils.randomInt(2, 9);
            const val = MathUtils.randomInt(2, 10);
            const res = k * val;
            latex = `${k}x = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. Eftersom x √§r multiplicerat med ${k}, g√∂r vi det motsatta: vi dividerar med ${k}.` 
                    : `We want x alone. Since x is multiplied by ${k}, we do the opposite: divide by ${k}.`, 
                latex: `x = \\frac{${res}}{${k}} \\\\ x = ${val}` 
            }];
        } 
        else if (type === 3) { // x + k = res
            const k = MathUtils.randomInt(1, 20);
            const val = MathUtils.randomInt(1, 20);
            const res = val + k;
            latex = `x + ${k} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. H√§r st√•r plus ${k}, s√• vi g√∂r det motsatta: vi subtraherar ${k}.` 
                    : `We want x alone. It says plus ${k}, so we do the opposite: subtract ${k}.`, 
                latex: `x = ${res} - ${k} \\\\ x = ${val}` 
            }];
        } 
        else { // x - k = res
            const k = MathUtils.randomInt(1, 20);
            const val = MathUtils.randomInt(1, 20);
            const res = val - k;
            latex = `x - ${k} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' 
                    ? `Vi vill ha x ensamt. H√§r st√•r minus ${k}, s√• vi g√∂r det motsatta: vi adderar ${k}.` 
                    : `We want x alone. It says minus ${k}, so we do the opposite: add ${k}.`, 
                latex: `x = ${res} + ${k} \\\\ x = ${val}` 
            }];
        }

        return {
            renderData: { 
                latex, 
                description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", 
                answerType: 'text' 
            },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 2: Two-Step Equations ---
    private level2_TwoStep(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const x = MathUtils.randomInt(2, 12);
        let latex = '', answer = x.toString(), clues = [];

        if (type === 1) { // ax + b = c
            const a = MathUtils.randomInt(2, 9);
            const b = MathUtils.randomInt(1, 15);
            const c = a * x + b;
            latex = `${a}x + ${b} = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `F√∂rst m√•ste vi f√• termen med x ensam. Vi tar bort ${b} genom att subtrahera det.` 
                        : `First isolate the x-term. Remove ${b} by subtracting it.`, 
                    latex: `${a}x = ${c} - ${b} \\\\ ${a}x = ${c-b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Nu sitter ${a} ihop med x (g√•nger). Vi dividerar med ${a} f√∂r att f√• svaret.` 
                        : `Now ${a} is multiplied by x. Divide by ${a} to get the answer.`, 
                    latex: `x = \\frac{${c-b}}{${a}} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 2) { // ax - b = c
            const a = MathUtils.randomInt(2, 9);
            const b = MathUtils.randomInt(1, 15);
            const c = a * x - b;
            latex = `${a}x - ${b} = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `F√∂rst m√•ste vi f√• termen med x ensam. Vi tar bort minus ${b} genom att addera ${b}.` 
                        : `First isolate the x-term. Remove minus ${b} by adding ${b}.`, 
                    latex: `${a}x = ${c} + ${b} \\\\ ${a}x = ${c+b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Nu dividerar vi med ${a} f√∂r att f√• fram x.` 
                        : `Now divide by ${a} to find x.`, 
                    latex: `x = \\frac{${c+b}}{${a}} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 3) { // x/a + b = c
            const a = MathUtils.randomInt(2, 8);
            const b = MathUtils.randomInt(1, 10);
            const realX = x * a; 
            const c = x + b; 
            latex = `\\frac{x}{${a}} + ${b} = ${c}`;
            answer = realX.toString();
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Vi b√∂rjar med att isolera x-termen. Subtrahera ${b} fr√•n b√•da sidor.` 
                        : `Start by isolating the x-term. Subtract ${b} from both sides.`, 
                    latex: `\\frac{x}{${a}} = ${c} - ${b} \\\\ \\frac{x}{${a}} = ${c-b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `F√∂r att bli av med divisionen multiplicerar vi med ${a}.` 
                        : `To remove the division, multiply by ${a}.`, 
                    latex: `x = ${c-b} \\cdot ${a} \\\\ x = ${realX}` 
                }
            ];
        }
        else { // x/a - b = c
            const a = MathUtils.randomInt(2, 8);
            const b = MathUtils.randomInt(1, 10);
            const realX = x * a;
            const c = x - b; 
            latex = `\\frac{x}{${a}} - ${b} = ${c}`;
            answer = realX.toString();
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Isolera x-termen genom att addera ${b} p√• b√•da sidor.` 
                        : `Isolate the x-term by adding ${b} to both sides.`, 
                    latex: `\\frac{x}{${a}} = ${c} + ${b} \\\\ \\frac{x}{${a}} = ${c+b}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera med ${a} f√∂r att f√• x ensamt.` 
                        : `Multiply by ${a} to get x alone.`, 
                    latex: `x = ${c+b} \\cdot ${a} \\\\ x = ${realX}` 
                }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 3: Parentheses ---
    private level3_Parentheses(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const a = MathUtils.randomInt(2, 6);
        let latex = '', answer = '', clues = [];

        if (type === 1) { // a(x + b) = c
            const x = MathUtils.randomInt(1, 10);
            const b = MathUtils.randomInt(1, 9);
            const c = a * (x + b);
            answer = x.toString();
            latex = `${a}(x + ${b}) = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Vi b√∂rjar med att multiplicera in ${a} i parentesen (distribuera).` 
                        : `Start by multiplying ${a} into the parentheses (distribute).`, 
                    latex: `${a} \\cdot x + ${a} \\cdot ${b} = ${c} \\\\ ${a}x + ${a*b} = ${c}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Nu l√∂ser vi ekvationen som vanligt. Subtrahera konstanten och dela sedan." 
                        : "Now solve as usual. Subtract the constant then divide.", 
                    latex: `${a}x = ${c - a*b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 2) { // a(x - b) = c
            const x = MathUtils.randomInt(5, 15);
            const b = MathUtils.randomInt(1, x - 1);
            const c = a * (x - b);
            answer = x.toString();
            latex = `${a}(x - ${b}) = ${c}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera in ${a} i parentesen. Kom ih√•g minustecknet.` 
                        : `Multiply ${a} into the parentheses. Remember the minus sign.`, 
                    latex: `${a} \\cdot x - ${a} \\cdot ${b} = ${c} \\\\ ${a}x - ${a*b} = ${c}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${a*b} till b√•da sidor och dela sedan.` 
                        : `Add ${a*b} to both sides and then divide.`, 
                    latex: `${a}x = ${c + a*b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 3) { // a(bx - c) = d (Inner coefficient)
            const bVar = MathUtils.randomInt(2, 5);
            const x = MathUtils.randomInt(2, 8);
            const cVar = MathUtils.randomInt(1, bVar * x - 1);
            const d = a * (bVar * x - cVar);
            answer = x.toString();
            latex = `${a}(${bVar}x - ${cVar}) = ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera in ${a} med b√•da termerna i parentesen.` 
                        : `Multiply ${a} with both terms in the parentheses.`, 
                    latex: `${a} \\cdot ${bVar}x - ${a} \\cdot ${cVar} = ${d} \\\\ ${a*bVar}x - ${a*cVar} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Addera konstanten och dela med koefficienten." 
                        : "Add the constant and divide by the coefficient.", 
                    latex: `${a*bVar}x = ${d + a*cVar} \\\\ x = ${x}` 
                }
            ];
        }
        else { // a(bx + c) = d
            const bVar = MathUtils.randomInt(2, 5);
            const x = MathUtils.randomInt(1, 8);
            const cVar = MathUtils.randomInt(1, 9);
            const d = a * (bVar * x + cVar);
            answer = x.toString();
            latex = `${a}(${bVar}x + ${cVar}) = ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Multiplicera in ${a} i parentesen.` 
                        : `Distribute ${a} into the parentheses.`, 
                    latex: `${a} \\cdot ${bVar}x + ${a} \\cdot ${cVar} = ${d} \\\\ ${a*bVar}x + ${a*cVar} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Subtrahera konstanten och dela med koefficienten." 
                        : "Subtract the constant and divide by the coefficient.", 
                    latex: `${a*bVar}x = ${d - a*cVar} \\\\ x = ${x}` 
                }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 4: Variables on Both Sides ---
    private level4_BothSides(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const x = MathUtils.randomInt(1, 10);
        let a = MathUtils.randomInt(3, 9);
        let c = MathUtils.randomInt(2, a - 1); 
        if (a === c) a++;

        let latex = '', answer = x.toString(), clues = [];

        if (type === 1) { // ax + b = cx + d
            const b = MathUtils.randomInt(1, 15);
            const d = a*x + b - c*x;
            if (d <= 0) return this.level4_BothSides(lang); 

            latex = `${a}x + ${b} = ${c}x + ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Vi vill samla alla x p√• ena sidan. Vi subtraherar ${c}x fr√•n b√•da sidor.` 
                        : `Gather all x on one side. Subtract ${c}x from both sides.`, 
                    latex: `${a}x - ${c}x + ${b} = ${d} \\\\ ${a-c}x + ${b} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? "Nu √§r det en vanlig ekvation. Flytta √∂ver konstanten och l√∂s ut x." 
                        : "Now solve as usual. Move the constant and solve for x.", 
                    latex: `${a-c}x = ${d} - ${b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 2) { // ax - b = cx + d
            const b = MathUtils.randomInt(1, 15);
            const d = a*x - b - c*x;
            if (d <= 0) return this.level4_BothSides(lang);

            latex = `${a}x - ${b} = ${c}x + ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Subtrahera ${c}x fr√•n b√•da sidor f√∂r att samla x.` 
                        : `Subtract ${c}x from both sides to gather x.`, 
                    latex: `${a}x - ${c}x - ${b} = ${d} \\\\ ${a-c}x - ${b} = ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${b} till b√•da sidor och l√∂s ut x.` 
                        : `Add ${b} to both sides and solve for x.`, 
                    latex: `${a-c}x = ${d} + ${b} \\\\ x = ${x}` 
                }
            ];
        }
        else if (type === 3) { // ax + b = cx - d
            const temp = a; a = c; c = temp; 
            const b = MathUtils.randomInt(1, 15);
            const d = c*x - a*x - b; 
            if (d <= 0) return this.level4_BothSides(lang); 

            latex = `${a}x + ${b} = ${c}x - ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Subtrahera ${a}x fr√•n b√•da sidor (f√∂r att h√•lla x positivt).` 
                        : `Subtract ${a}x from both sides (to keep x positive).`, 
                    latex: `${b} = ${c}x - ${a}x - ${d} \\\\ ${b} = ${c-a}x - ${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${d} till b√•da sidor.` 
                        : `Add ${d} to both sides.`, 
                    latex: `${b} + ${d} = ${c-a}x \\\\ x = ${x}` 
                }
            ];
        }
        else { // ax - b = cx - d
            if (a < c) { const t = a; a = c; c = t; }
            const b = MathUtils.randomInt(5, 20);
            const d = b - (a*x - c*x);
            if (d <= 0) return this.level4_BothSides(lang);

            latex = `${a}x - ${b} = ${c}x - ${d}`;
            clues = [
                { 
                    text: lang === 'sv' 
                        ? `Subtrahera ${c}x fr√•n b√•da sidor.` 
                        : `Subtract ${c}x from both sides.`, 
                    latex: `${a}x - ${c}x - ${b} = -${d} \\\\ ${a-c}x - ${b} = -${d}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `Addera ${b} till b√•da sidor.` 
                        : `Add ${b} to both sides.`, 
                    latex: `${a-c}x = -${d} + ${b} \\\\ x = ${x}` 
                }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    private level7_Mixed(lang: string): any {
        return this.generate(MathUtils.randomInt(1, 4), lang);
    }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearEquationProblemGen {
    public generate(level: number, lang: string = 'sv'): any {
        const isWriteMode = level === 5;
        const type = MathUtils.randomChoice(['A', 'B', 'C', 'D']);
        
        let data: any;

        switch (type) {
            case 'A': data = this.scenarioA_RatePlusFixed(lang); break; // ax + b = c
            case 'B': data = this.scenarioB_RateMinusFixed(lang); break; // ax - b = c
            case 'C': data = this.scenarioC_CompareSum(lang); break; // x + (x+a) = c
            case 'D': data = this.scenarioD_CompareDiff(lang); break; // x + (x-b) = c
            default: data = this.scenarioA_RatePlusFixed(lang);
        }

        const taskText = isWriteMode 
            ? (lang === 'sv' ? "Skriv en ekvation som beskriver problemet (du beh√∂ver inte l√∂sa den)." : "Write an equation that describes the problem (you don't need to solve it).")
            : (lang === 'sv' ? "L√∂s problemet. Vilket tal √§r x?" : "Solve the problem. What number is x?");

        const answer = isWriteMode ? data.equation : data.solution;
        const steps = isWriteMode ? data.stepsWrite : data.stepsSolve;

        return {
            renderData: {
                latex: "",
                description: `${data.text} ${taskText}`,
                answerType: 'text' // Both modes expect text input (equation or number)
            },
            token: Buffer.from(answer.toString()).toString('base64'),
            // FIX: Added 'clues' at the top level so the frontend App.jsx can find them
            clues: steps,
            serverData: { answer: answer, solutionSteps: steps }
        };
    }

    // --- Type A: ax + b = c (Rate + Fixed Cost) ---
    private scenarioA_RatePlusFixed(lang: string) {
        // Expanded Scenarios
        const scenarios = [
            {   // Shopping
                item: lang === 'sv' ? "√§pplen" : "apples",
                unit: lang === 'sv' ? "st" : "each",
                fixed: lang === 'sv' ? "kasse" : "bag",
                textSv: (a:number, b:number, c:number) => `Du k√∂per x √§pplen f√∂r ${a} kr/st och en kasse f√∂r ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x apples for ${a} kr each and a bag for ${b} kr. In total you pay ${c} kr.`
            },
            {   // Taxi
                item: "km",
                unit: "km",
                fixed: lang === 'sv' ? "startavgift" : "start fee",
                textSv: (a:number, b:number, c:number) => `En taxi kostar ${a} kr/km plus ${b} kr i startavgift. Resan kostade totalt ${c} kr. Du √•kte x km.`,
                textEn: (a:number, b:number, c:number) => `A taxi costs ${a} kr/km plus a ${b} kr start fee. The trip cost ${c} kr in total. You traveled x km.`
            },
            {   // Rental
                item: "min",
                unit: "min",
                fixed: lang === 'sv' ? "uppl√•sningsavgift" : "unlock fee",
                textSv: (a:number, b:number, c:number) => `Att hyra en elscooter kostar ${b} kr i startavgift och ${a} kr per minut. Du betalade ${c} kr f√∂r x minuter.`,
                textEn: (a:number, b:number, c:number) => `Renting an e-scooter costs ${b} kr to unlock and ${a} kr per minute. You paid ${c} kr for x minutes.`
            },
            {   // Subscription
                item: lang === 'sv' ? "m√•nader" : "months",
                unit: lang === 'sv' ? "m√•n" : "mo",
                fixed: lang === 'sv' ? "startavgift" : "signup fee",
                textSv: (a:number, b:number, c:number) => `Ett gymkort kostar ${a} kr i m√•naden och ${b} kr i startavgift. Du har betalat totalt ${c} kr. Hur m√•nga m√•nader (x) har du tr√§nat?`,
                textEn: (a:number, b:number, c:number) => `A gym membership costs ${a} kr/month plus a ${b} kr signup fee. You have paid ${c} kr in total. For how many months (x)?`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(3, 15);
        const a = MathUtils.randomInt(5, 30);
        const b = MathUtils.randomChoice([10, 20, 49, 50, 99]);
        const c = a * x + b;

        const equation = `${a}x+${b}=${c}`;
        const text = lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c);

        const stepsWrite = [
            { text: lang === 'sv' ? `1. Den r√∂rliga kostnaden √§r priset per ${s.unit} g√•nger antalet (x).` : `1. The variable cost is the price per ${s.unit} times the quantity (x).`, latex: `${a} \\cdot x = ${a}x` },
            { text: lang === 'sv' ? `2. L√§gg till den fasta avgiften (${s.fixed}).` : `2. Add the fixed fee (${s.fixed}).`, latex: `+ ${b}` },
            { text: lang === 'sv' ? `3. Summan ska bli totalbeloppet ${c}.` : `3. The sum must equal the total ${c}.`, latex: `${a}x + ${b} = ${c}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? `Ta bort den fasta avgiften (${b}) fr√•n totalen.` : `Subtract the fixed fee (${b}) from the total.`, latex: `${a}x = ${c} - ${b} = ${c-b}` },
            { text: lang === 'sv' ? `Dela det som √§r kvar med priset per ${s.unit} (${a}).` : `Divide the remainder by the price per ${s.unit} (${a}).`, latex: `x = \\frac{${c-b}}{${a}} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type B: ax - b = c (Discount) ---
    private scenarioB_RateMinusFixed(lang: string) {
        const scenarios = [
            {
                textSv: (a:number, b:number, c:number) => `Du k√∂per x datorspel f√∂r ${a} kr/st. Du har en rabattkupong p√• ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x video games for ${a} kr each. You have a discount coupon for ${b} kr. You pay ${c} kr total.`
            },
            {
                textSv: (a:number, b:number, c:number) => `En grupp p√• x personer g√•r p√• bio. Biljetten kostar ${a} kr. Gruppen f√•r en grupprabatt p√• ${b} kr. De betalar totalt ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `A group of x people go to the cinema. Tickets are ${a} kr. The group gets a ${b} kr discount. They pay ${c} kr total.`
            },
            {
                textSv: (a:number, b:number, c:number) => `Du k√∂per x tr√∂jor som kostar ${a} kr styck. Eftersom du √§r medlem f√•r du ${b} kr rabatt p√• hela k√∂pet. Du betalar ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x shirts costing ${a} kr each. As a member, you get ${b} kr off the total purchase. You pay ${c} kr.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(2, 8);
        const a = MathUtils.randomInt(50, 150);
        const b = MathUtils.randomChoice([20, 50, 100]);
        const c = a * x - b;

        const equation = `${a}x-${b}=${c}`;
        const text = lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c);

        const stepsWrite = [
            { text: lang === 'sv' ? "1. B√∂rja med vad det hade kostat utan rabatt (pris g√•nger antal)." : "1. Start with the cost without discount (price times quantity).", latex: `${a}x` },
            { text: lang === 'sv' ? `2. Rabatten minskar priset, s√• vi subtraherar ${b}.` : `2. The discount reduces the price, so subtract ${b}.`, latex: `- ${b}` },
            { text: lang === 'sv' ? "3. S√§tt uttrycket lika med det du faktiskt betalade." : "3. Set the expression equal to what you actually paid.", latex: `${a}x - ${b} = ${c}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "L√§gg tillbaka rabatten p√• totalen f√∂r att se vad ordinarie pris var." : "Add the discount back to the total to find the original price.", latex: `${a}x = ${c} + ${b} = ${c+b}` },
            { text: lang === 'sv' ? `Dela med styckpriset (${a}) f√∂r att se hur m√•nga du k√∂pte.` : `Divide by the unit price (${a}) to see how many you bought.`, latex: `x = \\frac{${c+b}}{${a}} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type C: Compare Sum (x + (x+a) = c) ---
    private scenarioC_CompareSum(lang: string) {
        const scenarios = [
            {   // Money
                textSv: (a:number, c:number) => `Kim har x kr. Alex har ${a} kr mer √§n Kim. Tillsammans har de ${c} kr.`,
                textEn: (a:number, c:number) => `Kim has x kr. Alex has ${a} kr more than Kim. Together they have ${c} kr.`
            },
            {   // Age
                textSv: (a:number, c:number) => `Leo √§r x √•r. Hans syster √§r ${a} √•r √§ldre. Tillsammans √§r de ${c} √•r.`,
                textEn: (a:number, c:number) => `Leo is x years old. His sister is ${a} years older. Together they are ${c} years old.`
            },
            {   // Election/Votes
                textSv: (a:number, c:number) => `I ett val fick Parti A x r√∂ster. Parti B fick ${a} fler r√∂ster. Totalt fick de ${c} r√∂ster.`,
                textEn: (a:number, c:number) => `In an election, Party A got x votes. Party B got ${a} more votes. In total they got ${c} votes.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(5, 25);
        const a = MathUtils.randomInt(2, 10);
        const total = x + (x + a);
        
        const equation = `2x+${a}=${total}`;
        const text = lang === 'sv' ? s.textSv(a, total) : s.textEn(a, total);

        const stepsWrite = [
            { text: lang === 'sv' ? "Person/Sak 1:" : "Person/Item 1:", latex: "x" },
            { text: lang === 'sv' ? `Person/Sak 2 (som har ${a} mer):` : `Person/Item 2 (has ${a} more):`, latex: `x + ${a}` },
            { text: lang === 'sv' ? "Addera dem f√∂r att f√• summan:" : "Add them to get the sum:", latex: `x + (x + ${a}) = ${total} \\implies 2x + ${a} = ${total}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "Ta bort det extra (skillnaden) fr√•n totalen." : "Remove the extra difference from the total.", latex: `2x = ${total} - ${a} = ${total-a}` },
            { text: lang === 'sv' ? "Dela resten lika p√• tv√•." : "Divide the remainder equally by two.", latex: `x = \\frac{${total-a}}{2} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type D: Compare Diff (x + (x-b) = c) ---
    private scenarioD_CompareDiff(lang: string) {
        const scenarios = [
            {   // Class size
                textSv: (b:number, c:number) => `I klass 7A g√•r det x elever. I 7B g√•r det ${b} f√§rre elever. Totalt g√•r det ${c} elever i √•rskursen.`,
                textEn: (b:number, c:number) => `Class 7A has x students. 7B has ${b} fewer students. There are ${c} students in total.`
            },
            {   // Lengths
                textSv: (b:number, c:number) => `En planka delas i tv√• bitar. Den f√∂rsta √§r x cm. Den andra √§r ${b} cm kortare. Hela plankan var ${c} cm.`,
                textEn: (b:number, c:number) => `A plank is cut in two. The first piece is x cm. The second is ${b} cm shorter. The whole plank was ${c} cm.`
            },
            {   // Weight
                textSv: (b:number, c:number) => `Hundvalpen v√§ger x kg. Katten v√§ger ${b} kg mindre. Tillsammans v√§ger de ${c} kg.`,
                textEn: (b:number, c:number) => `The puppy weighs x kg. The cat weighs ${b} kg less. Together they weigh ${c} kg.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(10, 50);
        const b = MathUtils.randomInt(2, 9);
        const total = x + (x - b);

        const equation = `2x-${b}=${total}`;
        const text = lang === 'sv' ? s.textSv(b, total) : s.textEn(b, total);

        const stepsWrite = [
            { text: lang === 'sv' ? "Del 1:" : "Part 1:", latex: "x" },
            { text: lang === 'sv' ? `Del 2 (som √§r ${b} mindre):` : `Part 2 (which is ${b} less):`, latex: `x - ${b}` },
            { text: lang === 'sv' ? "Summan av delarna:" : "Sum of the parts:", latex: `x + (x - ${b}) = ${total} \\implies 2x - ${b} = ${total}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "L√§gg till skillnaden till totalen f√∂r att 'j√§mna ut' det." : "Add the difference to the total to 'even it out'.", latex: `2x = ${total} + ${b} = ${total+b}` },
            { text: lang === 'sv' ? "Dela resultatet p√• tv√•." : "Divide the result by two.", latex: `x = \\frac{${total+b}}{2} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearGraphGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_FindM(lang);
            case 2: return this.level2_FindK_Pos(lang);
            case 3: return this.level3_FindK_Neg(lang);
            case 4: return this.level4_FindFunction(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_FindM(lang);
        }
    }

    // Level 1: Find m (y-intercept) where k=1
    private level1_FindM(lang: string): any {
        const m = MathUtils.randomInt(-4, 4);
        return {
            renderData: { 
                graph: { range: 10, lines: [{ slope: 1, intercept: m, color: '#2563eb' }] }, 
                description: lang === 'sv' ? "Best√§m m-v√§rdet (var sk√§r linjen y-axeln?)." : "Determine the m-value (y-intercept).", 
                answerType: 'text' 
            },
            token: Buffer.from(m.toString()).toString('base64'),
            serverData: { 
                answer: m.toString(), 
                solutionSteps: [
                    { text: lang === 'sv' ? "m √§r v√§rdet d√§r linjen sk√§r y-axeln." : "m is where the line crosses the y-axis." },
                    { latex: `(0, ${m})` }
                ]
            }
        };
    }

    // Level 2: Find k (positive slope) where m=0
    private level2_FindK_Pos(lang: string): any {
        const k = MathUtils.randomInt(1, 3);
        return {
            renderData: { 
                graph: { range: 10, lines: [{ slope: k, intercept: 0, color: '#16a34a' }] }, 
                description: lang === 'sv' ? "Best√§m k-v√§rdet (lutningen)." : "Determine the k-value (slope).", 
                answerType: 'text' 
            },
            token: Buffer.from(k.toString()).toString('base64'),
            serverData: { 
                answer: k.toString(), 
                solutionSteps: [
                    { text: lang === 'sv' ? "G√• 1 steg √•t h√∂ger. Hur m√•nga steg g√•r du upp?" : "Go 1 step right. How many steps up?", latex: `\\Delta x = 1, \\Delta y = ${k}` }
                ]
            }
        };
    }

    // Level 3: Find k (negative slope)
    private level3_FindK_Neg(lang: string): any {
        const k = MathUtils.randomInt(-3, -1);
        // Using a slight offset for m to ensure the line is clearly visible in the grid
        const m = MathUtils.randomInt(1, 4); 
        
        return {
            renderData: { 
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#dc2626' }] }, 
                description: lang === 'sv' ? "Best√§m k-v√§rdet." : "Determine the k-value (slope).", 
                answerType: 'text' 
            },
            token: Buffer.from(k.toString()).toString('base64'),
            serverData: { 
                answer: k.toString(), 
                solutionSteps: [
                    { text: lang === 'sv' ? "Linjen lutar ned√•t, s√• k √§r negativt." : "Line slopes down, so k is negative.", latex: `k = ${k}` }
                ]
            }
        };
    }

    // Level 4: Find the full function y = kx + m
    private level4_FindFunction(lang: string): any {
        // Generate k (slope) avoiding 0
        let k = 0;
        while (k === 0) k = MathUtils.randomInt(-3, 3);
        
        const m = MathUtils.randomInt(-3, 3);
        
        // Smart Equation Formatting
        let eq = "y=";
        
        // 1. Handle Slope (k)
        if (k === 1) eq += "x";
        else if (k === -1) eq += "-x";
        else eq += `${k}x`;
        
        // 2. Handle Intercept (m)
        if (m > 0) eq += `+${m}`;
        else if (m < 0) eq += `${m}`; // m already includes '-' sign
        // if m is 0, we add nothing
        
        return {
            renderData: { 
                graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#7c3aed' }] }, 
                description: lang === 'sv' ? "Skriv formeln (y=kx+m)." : "Write the formula (y=kx+m).", 
                answerType: 'text' 
            },
            token: Buffer.from(eq).toString('base64'),
            serverData: { 
                answer: eq, 
                solutionSteps: [
                    { text: lang === 'sv' ? "1. Hitta m (y-sk√§rning)." : "1. Find m (intercept).", latex: `m=${m}` },
                    { text: lang === 'sv' ? "2. Hitta k (lutning)." : "2. Find k (slope).", latex: `k=${k}` },
                    { text: lang === 'sv' ? "S√§tt ihop:" : "Combine:", latex: eq }
                ]
            }
        };
    }

    // Level 5: Mixed Levels 1-4
    private level5_Mixed(lang: string): any {
        return this.generate(MathUtils.randomInt(1, 4), lang);
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class NegativeNumbersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSubSimple(lang);
            case 2: return this.level2_AddSubHard(lang);
            case 3: return this.level3_Multiplication(lang);
            case 4: return this.level4_Division(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_AddSubSimple(lang);
        }
    }

    private p(n: number): string {
        return n < 0 ? `(${n})` : `${n}`;
    }

    // Level 1: Simple (-5 + 3, 2 - 8)
    private level1_AddSubSimple(lang: string): any {
        // Range logic from legacy: 10 range, min -10
        const start = MathUtils.randomInt(-10, 10);
        const change = MathUtils.randomInt(1, 10);
        const op = Math.random() > 0.5 ? '+' : '-';
        const ans = op === '+' ? start + change : start - change;

        return {
            renderData: { 
                latex: `${start} ${op} ${change}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "T√§nk p√• en termometer." : "Think of a thermometer." },
                { 
                    text: op === '+' 
                        ? (lang === 'sv' ? `Starta p√• ${start} och g√• ${change} steg UPP√ÖT.` : `Start at ${start} and go ${change} steps UP.`) 
                        : (lang === 'sv' ? `Starta p√• ${start} och g√• ${change} steg NED√ÖT.` : `Start at ${start} and go ${change} steps DOWN.`) 
                }
            ]
        };
    }

    // Level 2: Double signs (5 - (-3))
    private level2_AddSubHard(lang: string): any {
        const a = MathUtils.randomInt(-10, 10);
        const b = MathUtils.randomInt(-10, -1); // Negative second number ensures double sign
        const op = Math.random() > 0.5 ? '+' : '-';
        const ans = op === '+' ? a + b : a - b;

        let ruleText = "";
        let ruleLatex = "";

        // Pedagogical Logic
        if (op === '+') {
            // Adding a negative: 5 + (-3) -> 5 - 3
            ruleText = lang === 'sv' ? "Plus och minus bredvid varandra blir MINUS." : "Plus and minus next to each other become MINUS.";
            ruleLatex = `${a} - ${Math.abs(b)}`;
        } else {
            // Subtracting a negative: 5 - (-3) -> 5 + 3
            ruleText = lang === 'sv' ? "Tv√• minus bredvid varandra blir PLUS." : "Two minuses next to each other become PLUS.";
            ruleLatex = `${a} + ${Math.abs(b)}`;
        }

        return {
            renderData: { 
                latex: `${a} ${op} (${b})`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: ruleText, latex: ruleLatex },
                { text: lang === 'sv' ? "R√§kna nu ut det nya uttrycket." : "Now calculate the new expression." }
            ]
        };
    }

    // Level 3: Multiplication (-5 * -5)
    private level3_Multiplication(lang: string): any {
        // Ensure non-zero to emphasize sign rules
        let a = 0, b = 0;
        while(a===0) a = MathUtils.randomInt(-10, 10);
        while(b===0) b = MathUtils.randomInt(-10, 10);
        
        const ans = a * b;
        const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);

        return {
            renderData: { 
                latex: `${this.p(a)} \\cdot ${this.p(b)}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { 
                    text: sameSign 
                    ? (lang === 'sv' ? "Lika tecken ger PLUS (+)." : "Same signs give PLUS (+).") 
                    : (lang === 'sv' ? "Olika tecken ger MINUS (-)." : "Different signs give MINUS (-).") 
                },
                {
                    text: lang === 'sv' ? `Multiplicera siffrorna: ${Math.abs(a)} * ${Math.abs(b)}` : `Multiply the numbers: ${Math.abs(a)} * ${Math.abs(b)}`,
                    latex: `\\mathbf{${ans}}`
                }
            ]
        };
    }

    // Level 4: Division
    private level4_Division(lang: string): any {
        let b = 0;
        while(b === 0) b = MathUtils.randomInt(-10, 10);
        
        const maxRes = Math.floor(100 / Math.abs(b));
        let res = 0;
        while(res === 0) res = MathUtils.randomInt(-maxRes, maxRes);
        
        const a = res * b;
        const ans = res;
        
        const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);

        return {
            renderData: { 
                latex: `\\frac{${a}}{${b}}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { 
                    text: sameSign 
                    ? (lang === 'sv' ? "Lika tecken ger PLUS (+)." : "Same signs give PLUS (+).") 
                    : (lang === 'sv' ? "Olika tecken ger MINUS (-)." : "Different signs give MINUS (-).") 
                },
                {
                    text: lang === 'sv' ? `Dividera siffrorna: ${Math.abs(a)} / ${Math.abs(b)}` : `Divide the numbers: ${Math.abs(a)} / ${Math.abs(b)}`
                }
            ]
        };
    }

    private level5_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        return this.generate(lvl, lang);
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\PatternsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PatternsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Sequences(lang);
            case 2: return this.level2_HighTerm(lang);
            case 3: return this.level3_VisualFormula(lang);
            case 4: return this.level4_TableToFormula(lang);
            case 5: return this.level5_ReverseEngineering(lang);
            default: return this.level1_Sequences(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Sequences ---
    private level1_Sequences(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Spot the Lie (Properties)
        if (variation < 0.25) {
            const start = MathUtils.randomInt(2, 10);
            const diff = MathUtils.randomInt(2, 5);
            const seq = [start, start + diff, start + diff * 2, start + diff * 3];
            
            const sTrue1 = lang==='sv' ? `√ñkningen √§r ${diff}` : `Increase is ${diff}`;
            const sTrue2 = lang==='sv' ? `Starttalet √§r ${start}` : `Starting number is ${start}`;
            
            const lieType = MathUtils.randomInt(0, 1);
            let sFalse = "";
            if (lieType === 0) {
                const wrongNext = seq[3] + diff + MathUtils.randomChoice([1, -1]);
                sFalse = lang==='sv' ? `N√§sta tal √§r ${wrongNext}` : `Next number is ${wrongNext}`;
            } else {
                sFalse = lang==='sv' ? "M√∂nstret minskar" : "The pattern is decreasing";
            }

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `M√∂nster: ${seq.join(', ')}... Vilket p√•st√•ende √§r FALSKT?` 
                        : `Pattern: ${seq.join(', ')}... Which statement is FALSE?`,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse]),
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(sFalse),
                clues: [
                    {
                        text: lang === 'sv' ? `Kolla m√∂nstret sj√§lv. Om du plussar p√• ${diff} till det sista talet (${seq[3]}), vad f√•r du d√•?` : `Check the pattern yourself. If you add ${diff} to the last number (${seq[3]}), what do you get?`,
                        latex: ""
                    }
                ]
            };
        }

        // VARIATION B: Concept Check (Arith vs Geo)
        if (variation < 0.5) {
            const isGeo = Math.random() > 0.5;
            const start = MathUtils.randomInt(2, 5);
            const factor = MathUtils.randomInt(2, 3);
            
            let seq: number[] = [];
            if (isGeo) {
                seq = [start, start*factor, start*factor*factor, start*factor*factor*factor];
            } else {
                seq = [start, start+factor, start+factor*2, start+factor*3];
            }

            const q = lang==='sv' 
                ? "√Ñr m√∂nstret Aritmetiskt (+/-) eller Geometriskt (* /)?" 
                : "Is the pattern Arithmetic (+/-) or Geometric (* /)?";
            
            const ans = isGeo ? (lang==='sv'?"Geometriskt":"Geometric") : (lang==='sv'?"Aritmetiskt":"Arithmetic");
            const wrong = isGeo ? (lang==='sv'?"Aritmetiskt":"Arithmetic") : (lang==='sv'?"Geometriskt":"Geometric");

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([ans, wrong]),
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(ans),
                clues: [
                    {
                        text: lang === 'sv' ? "Titta p√• hur talen √§ndras. Hoppar de lika mycket varje steg (addera), eller f√∂rdubblas de (multiplicera)?" : "Look at how numbers change. Do they jump by the same amount (adding) or do they double/triple (multiplying)?",
                        latex: ""
                    }
                ]
            };
        }

        // VARIATION C: Find Difference
        if (variation < 0.75) {
            const diff = MathUtils.randomInt(2, 9);
            const start = MathUtils.randomInt(1, 15);
            const seq = [start, start+diff, start+diff*2, start+diff*3];
            
            return {
                renderData: {
                    description: lang==='sv' ? "Vad √§r skillnaden (√∂kningen) mellan talen?" : "What is the difference (increase) between the numbers?",
                    answerType: 'numeric',
                    geometry: { type: 'pattern', subtype: 'sequence', sequence: [...seq, '...'] }
                },
                token: this.toBase64(diff.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Hur stort √§r hoppet fr√•n det f√∂rsta talet till det andra?" : "How big is the jump from the first number to the second?",
                        latex: `${seq[1]} - ${seq[0]} = ?` 
                    }
                ]
            };
        }

        // VARIATION D: Standard Next Number
        const diff = MathUtils.randomInt(2, 8);
        const start = MathUtils.randomInt(1, 12);
        const s = [start, start+diff, start+diff*2, start+diff*3];
        return {
            renderData: {
                description: lang==='sv' ? "Vad √§r n√§sta tal?" : "What is the next number?",
                answerType: 'numeric',
                geometry: { type: 'pattern', subtype: 'sequence', sequence: [...s, '?'] }
            },
            token: this.toBase64((s[3]+diff).toString()),
            clues: [
                {
                    text: lang === 'sv' ? "M√∂nstret √∂kar lika mycket varje g√•ng. L√§gg till √∂kningen p√• det sista talet." : "The pattern increases by the same amount each time. Add that increase to the last number.",
                    latex: `${s[3]} + ${diff} = ?`
                }
            ]
        };
    }

    // --- LEVEL 2: High Term ---
    private level2_HighTerm(lang: string): any {
        const diff = MathUtils.randomInt(3, 9);
        const start = MathUtils.randomInt(2, 15); 
        const targetN = MathUtils.randomChoice([10, 20, 50, 100]);
        const ans = start + (targetN - 1) * diff;

        return {
            renderData: { 
                description: lang==='sv' ? `Vilket tal √§r nummer ${targetN} i m√∂nstret?` : `What is number ${targetN} in the pattern?`, 
                answerType: 'numeric', 
                geometry: { type: 'pattern', subtype: 'sequence', sequence: [start, start+diff, start+diff*2, '...'] } 
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Ist√§llet f√∂r att plussa hela v√§gen, ta en genv√§g. Vi startar p√• det f√∂rsta talet och g√∂r sedan ett visst antal hopp." : "Instead of adding all the way, take a shortcut. Start at the first number, then take a specific number of jumps.",
                    latex: "" 
                },
                {
                    text: lang === 'sv' ? `F√∂r att komma till nummer ${targetN} beh√∂ver du g√∂ra ${targetN-1} hopp.` : `To get to number ${targetN}, you need to make ${targetN-1} jumps.`,
                    latex: `${start} + (${targetN}-1) \\cdot ${diff}`
                }
            ]
        };
    }

    // --- LEVEL 3: Visual Formulas ---
    private level3_VisualFormula(lang: string): any {
        const variation = Math.random();
        const a = MathUtils.randomInt(2, 5);
        const b = MathUtils.randomInt(1, 4);

        // VARIATION A: Missing Coefficient
        if (variation < 0.3) {
            const val1 = a + b;
            return {
                renderData: {
                    description: lang==='sv' 
                        ? `Formeln √§r ?n + ${b}. Figur 1 har v√§rdet ${val1}. Vad √§r det saknade talet?`
                        : `The formula is ?n + ${b}. Figure 1 has value ${val1}. What is the missing number?`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(a.toString()),
                clues: [
                    { 
                        text: lang==='sv' ? "Talet framf√∂r 'n' ber√§ttar hur mycket m√∂nstret v√§xer med. Hur mycket st√∂rre √§r Figur 1 √§n den fasta delen?" : "The number before 'n' tells you how much the pattern grows. How much bigger is Figure 1 than the fixed part?", 
                        latex: `${val1} - ${b} = ?` 
                    }
                ]
            };
        }

        // VARIATION B: Inverse Visual
        if (variation < 0.6) {
            const target = MathUtils.randomChoice([10, 20, 50]);
            const ans = a * target + b;
            return {
                renderData: {
                    description: lang==='sv'
                        ? `Formeln f√∂r ett m√∂nster √§r ${a}n + ${b}. Hur m√•nga stickor har Figur ${target}?`
                        : `The pattern formula is ${a}n + ${b}. How many sticks are in Figure ${target}?`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    {
                        text: lang === 'sv' ? `Formeln √§r som ett recept. Byt ut 'n' mot ${target} och r√§kna ut.` : `The formula is like a recipe. Swap 'n' for ${target} and calculate.`,
                        latex: `${a} \\cdot ${target} + ${b}`
                    }
                ]
            };
        }

        // VARIATION C: Standard Formula
        const seq = [a+b, a*2+b, a*3+b];
        return {
            renderData: {
                description: lang==='sv' ? "Vilken formel (an+b) beskriver m√∂nstret?" : "Which formula (an+b) describes the pattern?",
                answerType: 'text',
                geometry: { type: 'pattern', subtype: 'sequence', sequence: seq } 
            },
            token: this.toBase64(`${a}n+${b}`),
            clues: [
                {
                    text: lang === 'sv' ? "Talet som st√•r med 'n' √§r alltid √∂kningen mellan talen." : "The number with 'n' is always the increase between the numbers.",
                    latex: `\\text{√ñkning} = ${a}`
                },
                {
                    text: lang === 'sv' ? "Talet som st√•r ensamt √§r det vi startar med (innan steg 1). Ta f√∂rsta talet minus √∂kningen." : "The lone number is what we start with (before step 1). Take the first number minus the increase.",
                    latex: `${seq[0]} - ${a} = ${b}`
                }
            ]
        };
    }

    // --- LEVEL 4: Table to Formula ---
    private level4_TableToFormula(lang: string): any {
        const variation = Math.random();
        const a = MathUtils.randomInt(2, 6);
        const b = MathUtils.randomInt(0, 5);
        const rows = [
            { n: 1, v: a+b }, { n: 2, v: a*2+b }, { n: 3, v: a*3+b }, { n: 4, v: a*4+b }
        ];

        // VARIATION A: Find Formula
        if (variation < 0.5) {
            return {
                renderData: {
                    description: lang==='sv' ? "Hitta formeln f√∂r tabellen (an+b):" : "Find the formula for the table (an+b):",
                    answerType: 'text',
                    geometry: { type: 'frequency_table', headers: ['n', 'Val'], rows: rows.map(r => [r.n, r.v]) }
                },
                token: this.toBase64(b === 0 ? `${a}n` : `${a}n+${b}`),
                clues: [
                    { text: lang==='sv' ? "Kolla hur mycket v√§rdet √∂kar f√∂r varje steg n. Det √§r talet som ska st√• f√∂re n." : "Check how much the value increases for each step n. That's the number that goes before n.", latex: `+${a}` }
                ]
            };
        }

        // VARIATION B: Fill Missing Value
        const targetN = 5;
        const targetVal = a * targetN + b;
        return {
            renderData: {
                description: lang==='sv' ? `Vad √§r v√§rdet n√§r n=${targetN}?` : `What is the value when n=${targetN}?`,
                answerType: 'numeric',
                geometry: { type: 'frequency_table', headers: ['n', 'Val'], rows: rows.map(r => [r.n, r.v]) }
            },
            token: this.toBase64(targetVal.toString()),
            clues: [
                { text: lang==='sv' ? "Du vet att m√∂nstret √∂kar med samma tal varje g√•ng. L√§gg till √∂kningen p√• det sista v√§rdet i tabellen." : "You know the pattern increases by the same number each time. Add the increase to the last value in the table.", latex: `${rows[3].v} + ${a} = ?` }
            ]
        };
    }

    // --- LEVEL 5: Reverse Engineering ---
    private level5_ReverseEngineering(lang: string): any {
        const a = MathUtils.randomInt(3, 8);
        const b = MathUtils.randomInt(2, 10);
        const n = MathUtils.randomInt(10, 50);
        const total = a * n + b;
        const formula = `${a}n + ${b}`;

        return {
            renderData: {
                description: lang === 'sv'
                    ? `Ett m√∂nster f√∂ljer formeln $V = ${formula}$. Vilket nummer ($n$) har figuren med v√§rdet ${total}?`
                    : `A pattern follows the formula $V = ${formula}$. Which figure number ($n$) has the value ${total}?`,
                answerType: 'numeric',
                geometry: null
            },
            token: this.toBase64(n.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Jobba bakl√§nges som en detektiv. B√∂rja med totalen och ta bort den fasta delen." : "Work backwards like a detective. Start with the total and remove the fixed part.",
                    latex: `${total} - ${b} = ${total-b}` 
                },
                {
                    text: lang === 'sv' ? "Nu delar du resten med √∂kningen f√∂r att se vilket nummer det √§r." : "Now divide the remainder by the increase to see which number it is.",
                    latex: `${total-b} / ${a} = n`
                }
            ]
        };
    }
}

// FILE END: src\core\generators\PatternsGen.ts

// =======================================================
// FILE START: src\core\generators\PercentGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PercentGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ConceptsAndVisuals(lang);
            case 2: return this.level2_MentalMath(lang);
            case 3: return this.level3_BuildingBlocks(lang);
            case 4: return this.level4_PercentEquation(lang);
            case 5: return this.level5_ReversePercentage(lang);
            case 6: return this.level6_PercentageChange(lang);
            default: return this.level1_ConceptsAndVisuals(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Concepts & Visuals ---
    private level1_ConceptsAndVisuals(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Dynamic Visual Translation
        if (variation < 0.35) {
            const colored = MathUtils.randomInt(1, 99);
            const targetType = MathUtils.randomChoice(['fraction', 'decimal', 'percent']);
            
            let answer = "";
            let desc = "";
            let type = "";

            if (targetType === 'fraction') {
                desc = lang === 'sv' ? "Hur stor andel √§r f√§rgad? Svara i br√•kform." : "What fraction is colored?";
                type = 'fraction';
                answer = `${colored}/100`;
            } else if (targetType === 'decimal') {
                desc = lang === 'sv' ? "Hur stor andel √§r f√§rgad? Svara i decimalform." : "What decimal part is colored?";
                type = 'numeric';
                answer = (colored / 100).toString();
            } else {
                desc = lang === 'sv' ? "Hur m√•nga procent √§r f√§rgat?" : "What percent is colored?";
                type = 'numeric';
                answer = colored.toString();
            }

            return {
                renderData: {
                    description: desc,
                    answerType: type,
                    suffix: targetType === 'percent' ? '%' : '',
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(answer),
                clues: [
                    { 
                        text: lang === 'sv' ? "R√§kna f√∂rst hur m√•nga rutor som finns totalt (det √§r 100 st)." : "First count how many squares there are in total (there are 100).", 
                        latex: "" 
                    },
                    { 
                        text: lang === 'sv' ? `Det √§r ${colored} f√§rgade rutor. Eftersom det √§r av 100, s√• √§r det ${colored} hundradelar.` : `There are ${colored} colored squares. Since it is out of 100, it is ${colored} hundredths.`, 
                        latex: `${colored}/100` 
                    }
                ]
            };
        }

        // VARIATION B: Spot the Lie (Dynamic)
        if (variation < 0.7) {
            const colored = MathUtils.randomInt(10, 90);
            
            const sTrue1 = `${colored}%`;
            const sTrue2 = (colored > 50) 
                ? (lang==='sv' ? "Mer √§n h√§lften" : "More than half") 
                : (lang==='sv' ? "Mindre √§n h√§lften" : "Less than half");
            
            let sFalse = "";
            if (MathUtils.randomInt(0, 1) === 0) {
                sFalse = `1/${colored}`; 
            } else {
                sFalse = (colored / 10).toString(); 
            }

            return {
                renderData: {
                    description: lang==='sv' ? "Titta p√• figuren. Vilket p√•st√•ende √§r FALSKT?" : "Look at the figure. Which statement is FALSE?",
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([sTrue1, sTrue2, sFalse]),
                    geometry: { type: 'percent_grid', total: 100, colored: colored }
                },
                token: this.toBase64(sFalse),
                clues: [
                    { 
                        text: lang === 'sv' ? "Procent betyder 'per hundra'. T√§nk p√• hur m√•nga hundradelar som √§r f√§rgade." : "Percent means 'per hundred'. Think about how many hundredths are colored.", 
                        latex: "" 
                    },
                    {
                        text: lang === 'sv' ? `Eftersom ${colored} rutor √§r f√§rgade √§r det ${colored}%. J√§mf√∂r detta med alternativen.` : `Since ${colored} squares are colored, it is ${colored}%. Compare this with the options.`,
                        latex: ""
                    }
                ]
            };
        }

        // VARIATION C: Equivalence Check
        const p = MathUtils.randomChoice([10, 20, 25, 50, 75]);
        const dec = p / 100;
        const frac = `${p}/100`;
        const wrong = (p / 10).toString(); 

        return {
            renderData: {
                description: lang==='sv' ? `Vilket alternativ √§r INTE lika med ${p}%?` : `Which option is NOT equal to ${p}%?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([dec.toString(), frac, wrong, `${p/25}/${100/25}`]) 
            },
            token: this.toBase64(wrong),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r att g√∂ra om procent till decimaltal, dela med 100 (flytta kommat tv√• steg)." : "To convert percent to decimal, divide by 100 (move the decimal two steps).", 
                    latex: `${p} / 100 = ${dec}` 
                },
                {
                    text: lang === 'sv' ? "F√∂r att g√∂ra om procent till br√•k, s√§tt talet √∂ver 100." : "To convert percent to fraction, put the number over 100.",
                    latex: `\\frac{${p}}{100}`
                }
            ]
        };
    }

    // --- LEVEL 2: Mental Math Benchmarks ---
    private level2_MentalMath(lang: string): any {
        const variation = Math.random();
        const benchmark = MathUtils.randomChoice([10, 20, 25, 50]);

        // VARIATION A: Standard Calculation
        if (variation < 0.35) {
            // Ensure base is a multiple such that (base * benchmark) is an integer
            // 10% -> base multiple of 10
            // 20% -> base multiple of 5
            // 25% -> base multiple of 4
            // 50% -> base multiple of 2
            let step = 10;
            if (benchmark === 50) step = 2;
            else if (benchmark === 25) step = 4;
            else if (benchmark === 20) step = 5;

            const base = MathUtils.randomInt(2, 20) * step; 
            const ans = (base * benchmark) / 100;
            
            return {
                renderData: {
                    description: lang==='sv' ? `Ber√§kna ${benchmark}% av ${base}.` : `Calculate ${benchmark}% of ${base}.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `T√§nk p√• br√•ket f√∂r ${benchmark}%.` : `Think of the fraction for ${benchmark}%.`, 
                        latex: benchmark === 50 ? "\\text{Halvan} (1/2)" : (benchmark === 25 ? "\\text{Fj√§rdedelen} (1/4)" : "\\text{Tiondelen} (1/10)")
                    },
                    {
                        text: lang === 'sv' ? "Dela talet med n√§mnaren." : "Divide the number by the denominator.",
                        latex: benchmark === 50 ? `${base} / 2` : (benchmark === 25 ? `${base} / 4` : `${base} / 10`)
                    }
                ]
            };
        }

        // VARIATION B: Inverse Logic
        if (variation < 0.7) {
            const ans = MathUtils.randomInt(2, 20); 
            let whole = 0;
            if (benchmark === 50) whole = ans * 2;
            else if (benchmark === 25) whole = ans * 4;
            else if (benchmark === 10) whole = ans * 10;
            else whole = ans * 5; 

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `${benchmark}% av ett tal √§r ${ans}. Vilket √§r talet?` 
                        : `${benchmark}% of a number is ${ans}. What is the number?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(whole.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? `Vi vet att en liten del (${benchmark}%) √§r v√§rd ${ans}.` : `We know that a small part (${benchmark}%) is worth ${ans}.`, 
                        latex: ""
                    },
                    { 
                        text: lang === 'sv' ? "Multiplicera upp delen f√∂r att f√• hela kakan (100%)." : "Multiply the part up to get the whole cake (100%).", 
                        latex: benchmark === 50 ? `${ans} \\cdot 2` : (benchmark === 25 ? `${ans} \\cdot 4` : `${ans} \\cdot 10`)
                    }
                ]
            };
        }

        // VARIATION C: Commutative Trick
        const n1 = MathUtils.randomChoice([25, 50]);
        // Choose n2 such that calculation is clean
        // If n1=25, n2 must be multiple of 4
        // If n1=50, n2 must be multiple of 2
        const step = n1 === 25 ? 4 : 2;
        const n2 = MathUtils.randomInt(2, 10) * step; 
        
        const q = MathUtils.randomInt(0, 1) === 0 
            ? `${n1}% av ${n2}` 
            : `${n2}% av ${n1}`;
        
        const ans = (n1 * n2) / 100;

        return {
            renderData: {
                description: lang==='sv' ? `Ber√§kna: ${q}` : `Calculate: ${q}`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Ett smart trick: Du kan byta plats p√• talen! Det √§r samma sak som att r√§kna ut den 'enkla' procenten." : "A smart trick: You can swap the numbers! It is the same as calculating the 'easy' percent.", 
                    latex: "" 
                },
                {
                    text: lang === 'sv' ? `R√§kna ut ${n1}% av ${n2} ist√§llet.` : `Calculate ${n1}% of ${n2} instead.`,
                    latex: n1 === 50 ? `${n2} / 2` : `${n2} / 4`
                }
            ]
        };
    }

    // --- LEVEL 3: Building Blocks ---
    private level3_BuildingBlocks(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Standard Composition
        if (variation < 0.4) {
            const base = MathUtils.randomInt(2, 10) * 10;
            const pct = MathUtils.randomChoice([30, 40, 60, 70, 80, 90]);
            const ans = (base * pct) / 100;

            return {
                renderData: {
                    description: lang==='sv' ? `Ber√§kna ${pct}% av ${base}.` : `Calculate ${pct}% of ${base}.`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "B√∂rja med att r√§kna ut vad 10% √§r (dela med 10)." : "Start by calculating what 10% is (divide by 10).", 
                        latex: `10\\% = ${base/10}` 
                    },
                    { 
                        text: lang === 'sv' ? `Du vill ha ${pct}%, vilket √§r ${pct/10} g√•nger s√• mycket.` : `You want ${pct}%, which is ${pct/10} times as much.`, 
                        latex: `${base/10} \\cdot ${pct/10}` 
                    }
                ]
            };
        }

        // VARIATION B: Decomposition (15%)
        if (variation < 0.7) {
            const base = MathUtils.randomInt(4, 20) * 10; // Even multiple of 10
            const ans = (base * 5) / 100;

            return {
                renderData: {
                    description: lang==='sv'
                        ? `F√∂r att r√§kna ut 15% av ${base} kan man ta 10% och addera h√§lften av det. Vad √§r 5% av ${base}?`
                        : `To find 15% of ${base}, you can find 10% and add half of it. What is 5% of ${base}?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "F√∂rst, vad √§r 10%? (Dela med 10)." : "First, what is 10%? (Divide by 10).", 
                        latex: `${base} / 10 = ${base/10}` 
                    },
                    { 
                        text: lang === 'sv' ? "5% √§r h√§lften av 10%. Dela ditt svar med 2." : "5% is half of 10%. Divide your answer by 2.", 
                        latex: `${base/10} / 2` 
                    }
                ]
            };
        }

        // VARIATION C: Estimation
        const base = MathUtils.randomInt(10, 50) * 2;
        const target = 10; 
        const exactPct = (target / base) * 100;
        const testPct = MathUtils.randomInt(Math.floor(exactPct) - 5, Math.ceil(exactPct) + 5);
        
        if (testPct === exactPct) return this.level3_BuildingBlocks(lang);

        const isGreater = (base * testPct / 100) > target;
        const ans = isGreater ? (lang==='sv'?"St√∂rre":"Greater") : (lang==='sv'?"Mindre":"Smaller");
        const wrong = isGreater ? (lang==='sv'?"Mindre":"Smaller") : (lang==='sv'?"St√∂rre":"Greater");

        return {
            renderData: {
                description: lang==='sv' 
                    ? `√Ñr ${testPct}% av ${base} st√∂rre eller mindre √§n ${target}?`
                    : `Is ${testPct}% of ${base} greater or smaller than ${target}?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([ans, wrong])
            },
            token: this.toBase64(ans),
            clues: [
                { 
                    text: lang === 'sv' ? "Anv√§nd 10% som riktm√§rke. Vad √§r 10% av talet?" : "Use 10% as a benchmark. What is 10% of the number?", 
                    latex: `10\\% = ${base/10}` 
                },
                { 
                    text: lang === 'sv' ? "J√§mf√∂r nu. Verkar det rimligt?" : "Now compare. Does it seem reasonable?", 
                    latex: "" 
                }
            ]
        };
    }

    // --- LEVEL 4: Percent Equation ---
    private level4_PercentEquation(lang: string): any {
        const variation = Math.random();

        const wholes = [4, 5, 10, 20, 25, 40, 50, 100, 200];
        const w = MathUtils.randomChoice(wholes);
        const p = MathUtils.randomChoice([5, 10, 20, 25, 30, 40, 50, 60, 75, 80, 90]);
        const part = (p * w) / 100; 
        
        if (!Number.isInteger(part)) return this.level4_PercentEquation(lang);

        // VARIATION A: Standard Context-Free
        if (variation < 0.25) {
            // e.g. 5 is what percent of 20?
            // Fraction: 5/20. Scale to /100.
            const k = 100 / w; // The scaling factor
            const opText = k > 1 ? (lang==='sv' ? "F√∂rl√§ng" : "Extend") : (lang==='sv' ? "F√∂rkorta" : "Simplify");
            const opSymbol = k > 1 ? "\\cdot" : "/";
            const kDisp = k > 1 ? k : (1/k); // Display as integer

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `${part} √§r hur m√•nga procent av ${w}?` 
                        : `${part} is what percent of ${w}?`,
                    answerType: 'numeric', suffix: '%'
                },
                token: this.toBase64(p.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "St√§ll upp det som ett br√•k: Delen genom Det Hela." : "Set it up as a fraction: Part over Whole.", 
                        latex: `\\frac{${part}}{${w}}` 
                    },
                    { 
                        text: lang === 'sv' ? `${opText} br√•ket med ${kDisp} s√• att n√§mnaren blir 100.` : `${opText} the fraction by ${kDisp} so the denominator becomes 100.`, 
                        latex: `\\frac{${part} ${opSymbol} ${kDisp}}{${w} ${opSymbol} ${kDisp}} = \\frac{${p}}{100}` 
                    },
                    {
                        text: lang === 'sv' ? "Hundradelar √§r samma sak som procent." : "Hundredths are the same as percent.",
                        latex: `${p}\\%`
                    }
                ]
            };
        }

        // VARIATION B: Real World (Score/Test)
        if (variation < 0.5) {
            const desc = lang === 'sv'
                ? `Du fick ${part} po√§ng av ${w} m√∂jliga p√• ett prov. Hur m√•nga procent √§r det?`
                : `You scored ${part} out of ${w} on a test. What percent is that?`;
            
            const k = 100 / w;
            const kDisp = k > 1 ? k : (1/k);
            const opSymbol = k > 1 ? "\\cdot" : "/";

            return {
                renderData: { description: desc, answerType: 'numeric', suffix: '%' },
                token: this.toBase64(p.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Andelen √§r:" : "The fraction is:", 
                        latex: `\\frac{${part}}{${w}}` 
                    },
                    { 
                        text: lang === 'sv' ? "Vi vill ha 100 i n√§mnaren. Vad ska vi multiplicera n√§mnaren med f√∂r att f√• 100?" : "We want 100 in the denominator. What should we multiply the denominator by to get 100?", 
                        latex: `${w} \\cdot ? = 100 \\implies ${kDisp}`
                    },
                    { 
                        text: lang === 'sv' ? "G√∂r samma sak med t√§ljaren." : "Do the same to the numerator.", 
                        latex: `${part} ${opSymbol} ${kDisp} = ${p}` 
                    }
                ]
            };
        }

        // VARIATION C: Real World (Discount/Savings)
        if (variation < 0.75) {
            const desc = lang === 'sv'
                ? `Priset s√§nktes med ${part} kr. Det kostade ${w} kr fr√•n b√∂rjan. Hur stor var rabatten i procent?`
                : `The price was lowered by ${part} kr. It originally cost ${w} kr. What was the discount percent?`;

            const k = 100 / w; 
            // Reuse logic or simplify simply
            return {
                renderData: { description: desc, answerType: 'numeric', suffix: '%' },
                token: this.toBase64(p.toString()),
                clues: [
                    { 
                        text: lang==='sv' ? "R√§kna ut andelen: Rabatten delat med ordinarie pris." : "Calculate the share: Discount divided by original price.", 
                        latex: `\\frac{${part}}{${w}}` 
                    },
                    {
                        text: lang === 'sv' ? "Omvandla till procent." : "Convert to percent.",
                        latex: `${p}\\%`
                    }
                ]
            };
        }

        // VARIATION D: Visual Logic (Groups)
        const desc = lang === 'sv'
            ? `I en grupp p√• ${w} personer har ${part} personer keps. Hur m√•nga procent har keps?`
            : `In a group of ${w} people, ${part} have caps. What percent have caps?`;

        return {
            renderData: { description: desc, answerType: 'numeric', suffix: '%' },
            token: this.toBase64(p.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Delen genom det hela ger oss andelen." : "Part divided by whole gives us the share.", 
                    latex: `\\frac{${part}}{${w}}` 
                },
                {
                    text: lang === 'sv' ? "F√∂r att f√• procent, t√§nk 'hur m√•nga av 100?'" : "To get percent, think 'how many out of 100?'",
                    latex: `${p}\\%`
                }
            ]
        };
    }

    // --- LEVEL 5: Reverse Percentage ---
    private level5_ReversePercentage(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Find Whole
        if (variation < 0.4) {
            const p = MathUtils.randomChoice([10, 20, 25, 40, 50]);
            const w = MathUtils.randomInt(2, 10) * 10; 
            const part = (p * w) / 100;

            return {
                renderData: {
                    description: lang==='sv' ? `${p}% av ett tal √§r ${part}. Vilket √§r talet?` : `${p}% of a number is ${part}. What is the number?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(w.toString()),
                clues: [
                    { text: lang==='sv' ? "Hitta 1% f√∂rst." : "Find 1% first.", latex: `${part} / ${p} = ${part/p}` },
                    { text: lang==='sv' ? "G√•ngra med 100." : "Multiply by 100.", latex: `${part/p} \\cdot 100` }
                ]
            };
        }

        // VARIATION B: Scaling
        if (variation < 0.8) {
            const smallP = 10;
            const smallVal = MathUtils.randomInt(2, 9);
            const targetP = MathUtils.randomChoice([20, 30, 40, 50, 60]);
            const factor = targetP / smallP;
            const ans = smallVal * factor;

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `10% av ett pris √§r ${smallVal} kr. Vad √§r ${targetP}% av priset?` 
                        : `10% of a price is ${smallVal} kr. What is ${targetP}% of the price?`,
                    answerType: 'numeric', suffix: 'kr'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang==='sv' ? `Hur m√•nga g√•nger st√∂rre √§r ${targetP}% √§n 10%?` : `How many times bigger is ${targetP}% than 10%?`, latex: `${targetP} / 10 = ${factor}` },
                    { text: lang==='sv' ? "Multiplicera v√§rdet med den faktorn." : "Multiply the value by that factor.", latex: `${smallVal} \\cdot ${factor}` }
                ]
            };
        }

        // VARIATION C: Concept
        return {
            renderData: {
                description: lang==='sv' ? "Om du dubblerar procenten, vad h√§nder med delen?" : "If you double the percentage, what happens to the part?",
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([
                    lang==='sv' ? "Den dubblas" : "It doubles",
                    lang==='sv' ? "Den halveras" : "It halves",
                    lang==='sv' ? "Ingen skillnad" : "No change"
                ])
            },
            token: this.toBase64(lang==='sv' ? "Den dubblas" : "It doubles"),
            clues: [{text: "20% is 2x 10%", latex: ""}]
        };
    }

    // --- LEVEL 6: Percentage Change ---
    private level6_PercentageChange(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Calculate Change
        if (variation < 0.35) {
            const oldVal = MathUtils.randomInt(2, 10) * 100;
            const p = MathUtils.randomInt(1, 5) * 10;
            const isInc = MathUtils.randomInt(0, 1) === 1;
            const diff = (oldVal * p) / 100;
            const newVal = isInc ? oldVal + diff : oldVal - diff;

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `Priset √§ndras fr√•n ${oldVal} till ${newVal}. Hur m√•nga procent ${isInc?'√∂kade':'minskade'} det?`
                        : `Price changed from ${oldVal} to ${newVal}. What percent did it ${isInc?'increase':'decrease'}?`,
                    answerType: 'numeric', suffix: '%'
                },
                token: this.toBase64(p.toString()),
                clues: [
                    { text: lang==='sv' ? "R√§kna ut skillnaden." : "Calc difference.", latex: `${newVal} - ${oldVal}` },
                    { text: lang==='sv' ? "Dela skillnaden med ursprungsv√§rdet." : "Divide difference by original.", latex: `\\frac{\\text{Skillnad}}{${oldVal}}` }
                ]
            };
        }

        // VARIATION B: Multiplier
        if (variation < 0.7) {
            const p = MathUtils.randomInt(5, 95);
            const ans = 1 + (p/100);
            return {
                renderData: {
                    description: lang==='sv' ? `Vilket tal ska du multiplicera med f√∂r att √∂ka n√•got med ${p}%?` : `What number do you multiply by to increase something by ${p}%?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang==='sv' ? "Hela talet (1) + √∂kningen." : "Whole number (1) + increase.", latex: `1 + ${p/100}` }
                ]
            };
        }

        // VARIATION C: The Trap
        const p = 10;
        const ans = lang==='sv' ? "L√§gre" : "Lower";
        const wrong1 = lang==='sv' ? "H√∂gre" : "Higher";
        const wrong2 = lang==='sv' ? "Samma" : "Same";

        return {
            renderData: {
                description: lang==='sv' 
                    ? `Ett pris h√∂js med ${p}% och s√§nks sedan med ${p}%. √Ñr nya priset h√∂gre, l√§gre eller samma som startpriset?` 
                    : `A price increases by ${p}% and then decreases by ${p}%. Is the new price higher, lower, or same as start?`,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([ans, wrong1, wrong2])
            },
            token: this.toBase64(ans),
            clues: [
                { text: lang==='sv' ? "Testa med 100 kr." : "Test with 100 kr.", latex: `100 \\cdot 1.1 = 110` },
                { text: lang==='sv' ? "S√§nk nu 110 med 10%." : "Now decrease 110 by 10%.", latex: `110 \\cdot 0.9 = 99` }
            ]
        };
    }
}

// FILE END: src\core\generators\PercentGen.ts

// =======================================================
// FILE START: src\core\generators\ProbabilityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ProbabilityGen {
    // --- CONTEXT LIBRARY ---
    // A database of events categorized by their likelihood.
    private static readonly SCENARIOS = {
        impossible: [
            { sv: "sl√• en 7:a med en vanlig t√§rning", en: "rolling a 7 on a standard die" },
            { sv: "dra ett r√∂tt kort ur en lek med bara svarta kort", en: "picking a red card from a deck of only black cards" },
            { sv: "att det sn√∂ar n√§r det √§r +30 grader", en: "snowing when it is +30 degrees (86¬∞F)" },
            { sv: "att en triangel har 4 h√∂rn", en: "a triangle having 4 corners" },
            { sv: "att f√• klave p√• ett mynt med tv√• kronor", en: "getting tails on a two-headed coin" },
            { sv: "att m√•ndag kommer direkt efter onsdag", en: "Monday coming immediately after Wednesday" }
        ],
        certain: [ // P = 1 (100%)
            { sv: "sl√• mindre √§n 7 med en vanlig t√§rning", en: "rolling less than 7 on a standard die" },
            { sv: "dra en kula fr√•n en p√•se med bara kulor", en: "picking a marble from a bag of only marbles" },
            { sv: "att solen g√•r upp i √∂ster", en: "the sun rising in the East" },
            { sv: "att talet 5 √§r st√∂rre √§n 2", en: "the number 5 being greater than 2" },
            { sv: "f√• krona ELLER klave n√§r du singlar slant", en: "getting heads OR tails when flipping a coin" }
        ],
        even: [ // P = 0.5 (50%)
            { sv: "f√• krona n√§r du singlar slant", en: "getting heads when flipping a coin" },
            { sv: "sl√• ett udda tal med en t√§rning", en: "rolling an odd number on a die" },
            { sv: "dra ett r√∂tt kort ur en vanlig kortlek", en: "picking a red card from a standard deck" },
            { sv: "sl√• ett tal st√∂rre √§n 3 med en t√§rning", en: "rolling a number greater than 3 on a die" }
        ],
        unlikely: [ // 0 < P < 0.5
            { sv: "vinna p√• lotto", en: "winning the lottery" },
            { sv: "sl√• en 6:a med en t√§rning", en: "rolling a 6 on a die" },
            { sv: "att bli tr√§ffad av blixten", en: "being struck by lightning" },
            { sv: "gissa r√§tt pinkod p√• f√∂rsta f√∂rs√∂ket", en: "guessing a PIN code correctly on the first try" }
        ],
        likely: [ // 0.5 < P < 1
            { sv: "att det regnar i London", en: "it raining in London" }, // Playful stereotype, works for pedagogy
            { sv: "sl√• h√∂gre √§n 1 med en t√§rning", en: "rolling higher than 1 on a die" },
            { sv: "dra ett nummerkort (2-10) ur en kortlek", en: "picking a number card (2-10) from a deck" }
        ]
    };

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Visuals(lang);
            case 2: return this.level2_StandardGroups(lang);
            case 3: return this.level3_ConceptsAndLogic(lang); // Renamed & Refactored
            case 4: return this.level4_Complementary(lang);
            case 5: return this.level5_ProbabilityTree(lang);
            case 6: return this.level6_EventChains(lang); 
            case 7: return this.level7_Combinatorics(lang);
            case 8: return this.level8_CombinatoricsComplex(lang);
            default: return this.level1_Visuals(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private simplifyFraction(n: number, d: number): string {
        const gcd = (a: number, b: number): number => b ? gcd(b, a % b) : a;
        const divisor = gcd(n, d);
        return `${n / divisor}/${d / divisor}`;
    }

    // --- LEVEL 1: Visual Foundations ---
    private level1_Visuals(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Inverse Logic (Probability -> Count)
        if (variation < 0.3) {
            const red = MathUtils.randomInt(2, 6);
            const total = red * MathUtils.randomChoice([2, 3, 4]); 
            const probD = total / red; 
            
            const desc = lang === 'sv'
                ? `I en p√•se med ${total} kulor √§r sannolikheten att dra en r√∂d kula 1/${probD}. Hur m√•nga r√∂da kulor finns det?`
                : `In a bag of ${total} marbles, the probability of picking a red marble is 1/${probD}. How many red marbles are there?`;

            return {
                renderData: {
                    description: desc,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(red.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Sannolikheten 1/X betyder att '1 av X' kulor √§r r√∂d." : "A probability of 1/X means '1 out of X' marbles is red.", 
                        latex: `P(\\text{R√∂d}) = \\frac{1}{${probD}}` 
                    },
                    {
                        text: lang === 'sv' ? "Dela det totala antalet kulor i lika stora grupper enligt sannolikheten." : "Divide the total number of marbles into equal groups according to the probability.",
                        latex: `${total} \\div ${probD} = ${red}`
                    }
                ]
            };
        }

        // VARIATION B: Spot the Lie (Dynamic Visual Ratios)
        if (variation < 0.6) {
            const red = MathUtils.randomInt(2, 6);
            const blue = MathUtils.randomInt(1, 5); 
            const total = red + blue;
            
            const pBlue = blue/total;
            
            // 1. Generate TRUE statements
            const trueStatements = [];
            trueStatements.push(lang === 'sv' ? `P(R√∂d) = ${red}/${total}` : `P(Red) = ${red}/${total}`);
            
            if (red > blue) {
                trueStatements.push(lang === 'sv' ? "Det √§r st√∂rst chans att dra R√∂d" : "It is most likely to pick Red");
            } else if (blue > red) {
                trueStatements.push(lang === 'sv' ? "Det √§r st√∂rst chans att dra Bl√•" : "It is most likely to pick Blue");
            } else {
                trueStatements.push(lang === 'sv' ? "Chansen √§r lika stor f√∂r b√•da f√§rgerna" : "The chance is equal for both colors");
            }

            // 2. Generate FALSE statement (The Lie)
            let lie = "";
            const lieType = MathUtils.randomInt(0, 2);
            
            if (lieType === 0) {
                if (pBlue < 0.5) {
                    lie = lang === 'sv' ? "Chansen att dra Bl√• √§r √∂ver 50%" : "The chance to pick Blue is over 50%";
                } else {
                    lie = lang === 'sv' ? "Chansen att dra Bl√• √§r under 50%" : "The chance to pick Blue is under 50%";
                }
            } else if (lieType === 1) {
                lie = lang === 'sv' ? "Det √§r om√∂jligt att dra en R√∂d kula" : "It is impossible to pick a Red marble";
            } else {
                lie = lang === 'sv' ? `P(Bl√•) = ${total}/${blue}` : `P(Blue) = ${total}/${blue}`;
            }

            const options = MathUtils.shuffle([trueStatements[0], trueStatements[1], lie]);

            return {
                renderData: {
                    description: lang === 'sv' ? "Titta p√• bilden. Vilket p√•st√•ende √§r FALSKT?" : "Look at the image. Which statement is FALSE?",
                    answerType: 'multiple_choice',
                    options: options,
                    geometry: { type: 'probability_marbles', items: { red, blue, green: 0 } }
                },
                token: this.toBase64(lie),
                clues: [
                    { 
                        text: lang === 'sv' ? `R√§kna antalet kulor av varje f√§rg.` : `Count the marbles of each color.`,
                        latex: `\\text{Red}: ${red}, \\text{Blue}: ${blue}`
                    }
                ]
            };
        }

        // VARIATION C: Standard Visual Calc
        const red = MathUtils.randomInt(2, 5);
        const blue = MathUtils.randomInt(2, 5);
        const green = MathUtils.randomInt(1, 4);
        const total = red + blue + green;
        
        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Vad √§r sannolikheten att dra en r√∂d kula?`
                    : `What is the probability of picking a red marble?`,
                answerType: 'fraction',
                geometry: { type: 'probability_marbles', items: { red, blue, green } }
            },
            token: this.toBase64(this.simplifyFraction(red, total)),
            clues: [
                { 
                    text: lang === 'sv' ? "Sannolikhet √§r delen delat med det hela." : "Probability is the part divided by the whole.", 
                    latex: `P = \\frac{\\text{Antal r√∂da}}{\\text{Total}}` 
                },
                {
                    latex: `\\frac{${red}}{${total}}`
                }
            ]
        };
    }

    // --- LEVEL 2: Standard Groups ---
    private level2_StandardGroups(lang: string): any {
        const scenarios = [
            { itemSv: "personer", aSv: "vuxna", bSv: "barn", itemEn: "people", aEn: "adults", bEn: "children" },
            { itemSv: "bilar", aSv: "elbilar", bSv: "bensinbilar", itemEn: "cars", aEn: "electric cars", bEn: "petrol cars" },
            { itemSv: "pendlare", aSv: "t√•gresen√§rer", bSv: "bussresen√§rer", itemEn: "commuters", aEn: "train riders", bEn: "bus riders" },
            { itemSv: "anv√§ndare", aSv: "iPhone-anv√§ndare", bSv: "Android-anv√§ndare", itemEn: "users", aEn: "iPhone users", bEn: "Android users" },
            { itemSv: "djur", aSv: "hundar", bSv: "katter", itemEn: "animals", aEn: "dogs", bEn: "cats" },
            { itemSv: "frukter", aSv: "√§pplen", bSv: "bananer", itemEn: "fruits", aEn: "apples", bEn: "bananas" },
            { itemSv: "bestick", aSv: "gafflar", bSv: "skedar", itemEn: "cutlery", aEn: "forks", bEn: "spoons" },
            { itemSv: "tr√§d", aSv: "granar", bSv: "bj√∂rkar", itemEn: "trees", aEn: "pines", bEn: "birches" },
            { itemSv: "fordon", aSv: "lastbilar", bSv: "motorcyklar", itemEn: "vehicles", aEn: "trucks", bEn: "motorcycles" },
            { itemSv: "leksaker", aSv: "klossar", bSv: "bilar", itemEn: "toys", aEn: "blocks", bEn: "cars" },
            { itemSv: "b√∂cker", aSv: "deckare", bSv: "romaner", itemEn: "books", aEn: "mysteries", bEn: "novels" },
            { itemSv: "drycker", aSv: "mj√∂lkpaket", bSv: "juicepaket", itemEn: "drinks", aEn: "milk cartons", bEn: "juice cartons" },
            { itemSv: "bollar", aSv: "fotbollar", bSv: "tennisbollar", itemEn: "balls", aEn: "footballs", bEn: "tennis balls" },
            { itemSv: "blommor", aSv: "rosor", bSv: "tulpaner", itemEn: "flowers", aEn: "roses", bEn: "tulips" },
            { itemSv: "f√•glar", aSv: "duvor", bSv: "skator", itemEn: "birds", aEn: "pigeons", bEn: "magpies" },
            { itemSv: "instrument", aSv: "gitarrer", bSv: "trummor", itemEn: "instruments", aEn: "guitars", bEn: "drums" },
            { itemSv: "m√∂bler", aSv: "stolar", bSv: "bord", itemEn: "furniture", aEn: "chairs", bEn: "tables" },
            { itemSv: "enheter", aSv: "datorer", bSv: "surfplattor", itemEn: "devices", aEn: "computers", bEn: "tablets" },
            { itemSv: "bakverk", aSv: "bullar", bSv: "kakor", itemEn: "pastries", aEn: "buns", bEn: "cookies" }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const aCount = MathUtils.randomInt(5, 15);
        const bCount = MathUtils.randomInt(5, 15);
        const total = aCount + bCount;
        
        const targetA = MathUtils.randomInt(0, 1) === 1;
        const targetCount = targetA ? aCount : bCount;
        const targetName = targetA ? (lang === 'sv' ? s.aSv : s.aEn) : (lang === 'sv' ? s.bSv : s.bEn);
        const groupName = lang === 'sv' ? s.itemSv : s.itemEn;

        const desc = lang === 'sv'
            ? `I en grupp p√• ${total} ${groupName} √§r ${aCount} ${s.aSv} och resten ${s.bSv}. Vad √§r sannolikheten att en slumpm√§ssigt vald √§r ${targetName}?`
            : `In a group of ${total} ${groupName}, ${aCount} are ${s.aEn} and the rest are ${s.bEn}. What is the probability that a randomly chosen one is ${targetName}?`;

        return {
            renderData: { description: desc, answerType: 'fraction' },
            token: this.toBase64(this.simplifyFraction(targetCount, total)),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r att hitta sannolikheten, dela antalet du s√∂ker med det totala antalet i gruppen." : "To find the probability, divide the number you are looking for by the total number in the group.", 
                    latex: `\\frac{\\text{Antal ${targetName}}}{\\text{Total}} = \\frac{${targetCount}}{${total}}` 
                }
            ]
        };
    }

    // --- LEVEL 3: Concepts & Logic (MAJOR OVERHAUL) ---
    private level3_ConceptsAndLogic(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Context "Mad Libs" (Forward)
        // "What is the probability of [Scenario]?"
        if (variation < 0.3) {
            const category = MathUtils.randomChoice(['impossible', 'certain', 'even']);
            const scenario = MathUtils.randomChoice(ProbabilityGen.SCENARIOS[category as keyof typeof ProbabilityGen.SCENARIOS]);
            
            const text = lang==='sv' ? scenario.sv : scenario.en;
            const q = lang==='sv' ? `Vad √§r sannolikheten f√∂r att ${text}?` : `What is the probability of ${text}?`;
            
            // Answers can be percent, decimal, or text description? 
            // Let's stick to standard percent for consistency in grading
            let ans = "";
            let clue = "";
            if (category === 'impossible') { ans = "0%"; clue = "0"; }
            else if (category === 'certain') { ans = "100%"; clue = "1"; }
            else { ans = "50%"; clue = "0.5"; }

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle(["0%", "50%", "100%", "25%"])
                },
                token: this.toBase64(ans),
                clues: [{ text: lang==='sv' ? "T√§nk efter: Kan detta h√§nda? H√§nder det alltid?" : "Think: Can this happen? Does it always happen?", latex: "" }]
            };
        }

        // VARIATION B: Inverse Context (Backward)
        // "Which of these events is [Likelihood]?"
        if (variation < 0.6) {
            const targetType = MathUtils.randomChoice(['impossible', 'certain', 'even']);
            const targetScenario = MathUtils.randomChoice(ProbabilityGen.SCENARIOS[targetType as keyof typeof ProbabilityGen.SCENARIOS]);
            
            // Get distractors
            const distractorTypes = ['impossible', 'certain', 'even', 'unlikely', 'likely'].filter(t => t !== targetType);
            const dist1Type = MathUtils.randomChoice(distractorTypes);
            const dist2Type = MathUtils.randomChoice(distractorTypes.filter(t => t !== dist1Type));
            
            const dist1 = MathUtils.randomChoice(ProbabilityGen.SCENARIOS[dist1Type as keyof typeof ProbabilityGen.SCENARIOS]);
            const dist2 = MathUtils.randomChoice(ProbabilityGen.SCENARIOS[dist2Type as keyof typeof ProbabilityGen.SCENARIOS]);

            const termSv = targetType === 'impossible' ? "OM√ñJLIGT" : (targetType === 'certain' ? "S√ÑKERT" : "50% CHANS");
            const termEn = targetType === 'impossible' ? "IMPOSSIBLE" : (targetType === 'certain' ? "CERTAIN" : "50% CHANCE");
            
            const q = lang==='sv' ? `Vilken h√§ndelse √§r ${termSv}?` : `Which event is ${termEn}?`;
            const optCorrect = lang==='sv' ? targetScenario.sv : targetScenario.en;
            const optWrong1 = lang==='sv' ? dist1.sv : dist1.en;
            const optWrong2 = lang==='sv' ? dist2.sv : dist2.en;

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([optCorrect, optWrong1, optWrong2])
                },
                token: this.toBase64(optCorrect),
                clues: [{ text: lang==='sv' ? "L√§s alternativen noga. Bara ett st√§mmer." : "Read the options carefully. Only one fits.", latex: "" }]
            };
        }

        // VARIATION C: Definition Logic (Comparison)
        if (variation < 0.8) {
            // Compare P values
            const p1 = MathUtils.randomInt(1, 40);
            const p2 = MathUtils.randomInt(60, 99);
            const q = lang==='sv' 
                ? `H√§ndelse A har P=${p1}%. H√§ndelse B har P=${p2}%. Vilket p√•st√•ende √§r sant?`
                : `Event A has P=${p1}%. Event B has P=${p2}%. Which statement is true?`;
            
            const trueStmt = lang==='sv' ? "B √§r mer sannolikt √§n A" : "B is more likely than A";
            const falseStmt1 = lang==='sv' ? "A √§r mer sannolikt √§n B" : "A is more likely than B";
            const falseStmt2 = lang==='sv' ? "B√•da √§r lika sannolika" : "Both are equally likely";

            return {
                renderData: {
                    description: q,
                    answerType: 'multiple_choice',
                    options: MathUtils.shuffle([trueStmt, falseStmt1, falseStmt2])
                },
                token: this.toBase64(trueStmt),
                clues: [{ text: lang==='sv' ? "H√∂gre procent betyder h√∂gre sannolikhet." : "Higher percent means higher probability.", latex: `${p2} > ${p1}` }]
            };
        }

        // VARIATION D: Expected Value Logic (Calculation)
        const scenarios = [
            { sv: "att vinna p√• lotteriet", en: "winning the lottery" },
            { sv: "att ett fr√∂ gror", en: "a seed sprouting" },
            { sv: "att en produkt √§r defekt", en: "a product being defective" },
            { sv: "att g√∂ra m√•l p√• straff", en: "scoring a penalty" }
        ];
        const s = MathUtils.randomChoice(scenarios);
        const percent = MathUtils.randomChoice([10, 20, 25, 50]);
        const total = MathUtils.randomChoice([10, 20, 40, 50, 100]);
        const ans = (percent / 100) * total;
        const action = lang === 'sv' ? s.sv : s.en;

        const desc = lang === 'sv'
            ? `Sannolikheten f√∂r ${action} √§r ${percent}%. Om du g√∂r ${total} f√∂rs√∂k, hur m√•nga g√•nger f√∂rv√§ntas det h√§nda?`
            : `The probability of ${action} is ${percent}%. If you make ${total} attempts, how many times is it expected to happen?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "G√∂r om procenten till decimalform." : "Convert percent to decimal.", latex: `${percent}\\% = ${percent/100}` },
                { text: lang === 'sv' ? "Multiplicera sannolikheten med antalet f√∂rs√∂k." : "Multiply probability by attempts.", latex: `${percent/100} \\cdot ${total}` }
            ]
        };
    }

    // --- LEVEL 4: Complementary ---
    private level4_Complementary(lang: string): any {
        // ... (Same as previous, omitted for brevity but included in final compilation)
        const x = MathUtils.randomInt(5, 95);
        const ans = 100 - x;
        return {
            renderData: { 
                description: lang==='sv' ? `Chansen √§r ${x}%. Vad √§r risken att det INTE h√§nder?` : `Chance is ${x}%. Risk it does NOT happen?`, 
                answerType: 'numeric', suffix: '%' 
            },
            token: this.toBase64(ans.toString()),
            clues: [{latex: `100\\% - ${x}\\%`}]
        };
    }

    // --- LEVEL 5: Probability Trees ---
    private level5_ProbabilityTree(lang: string): any {
        const variation = Math.random();
        
        // VARIATION A: Concept (Dependency)
        if (variation < 0.3) {
            const desc = lang==='sv' ? "I ett tr√§ddiagram utan √•terl√§ggning, varf√∂r √§ndras n√§mnaren?" : "In a tree diagram without replacement, why does the denominator change?";
            const optCorrect = lang==='sv' ? "Totalt antal minskar" : "Total count decreases";
            const optWrong = lang==='sv' ? "Sannolikheten √∂kar alltid" : "Probability always increases";
            return {
                renderData: {
                    description: desc, answerType: 'multiple_choice', options: MathUtils.shuffle([optCorrect, optWrong]),
                    geometry: { type: 'probability_tree', groups: ["A", "B"], initialCounts: [3, 2], targetBranch: 's2_0' }
                },
                token: this.toBase64(optCorrect),
                clues: [{text: "Total = Total - 1", latex: ""}]
            };
        }
        
        // VARIATION B: Calc
        const c1 = MathUtils.randomInt(3, 6);
        const c2 = MathUtils.randomInt(3, 6);
        const tot = c1+c2;
        const p1N = c1, p1D = tot;
        const p2N = c2, p2D = tot - 1;
        
        return {
            renderData: {
                description: lang==='sv' ? `Du drar tv√• kulor utan √•terl√§ggning (A sen B).` : `Pick two marbles without replacement (A then B).`,
                answerType: 'fraction',
                geometry: { type: 'probability_tree', groups: ["A", "B"], initialCounts: [c1, c2], targetBranch: 's2_1' }
            },
            token: this.toBase64(this.simplifyFraction(p1N * p2N, p1D * p2D)),
            clues: [{latex: `\\frac{${p1N}}{${p1D}} \\cdot \\frac{${p2N}}{${p2D}}`}]
        };
    }

    // --- LEVEL 6: Event Chains (10 Scenarios - Without Replacement) ---
    private level6_EventChains(lang: string): any {
        const scenarios = [
            { itemSv: "godisbitar", itemEn: "candies", aNameSv: "sura", bNameSv: "s√∂ta", aNameEn: "sour", bNameEn: "sweet" },
            { itemSv: "frukter", itemEn: "fruits", aNameSv: "√§pplen", bNameSv: "p√§ron", aNameEn: "apples", bNameEn: "pears" },
            { itemSv: "strumpor", itemEn: "socks", aNameSv: "vita", bNameSv: "svarta", aNameEn: "white", bNameEn: "black" },
            { itemSv: "tennisbollar", itemEn: "tennis balls", aNameSv: "nya", bNameSv: "gamla", aNameEn: "new", bNameEn: "old" },
            { itemSv: "kort", itemEn: "cards", aNameSv: "spader", bNameSv: "hj√§rter", aNameEn: "spades", bNameEn: "hearts" },
            { itemSv: "cupcakes", itemEn: "cupcakes", aNameSv: "vanilj", bNameSv: "choklad", aNameEn: "vanilla", bNameEn: "chocolate" },
            { itemSv: "spelmarker", itemEn: "game tokens", aNameSv: "guld", bNameSv: "silver", aNameEn: "gold", bNameEn: "silver" },
            { itemSv: "skruvar", itemEn: "screws", aNameSv: "l√•nga", bNameSv: "korta", aNameEn: "long", bNameEn: "short" },
            { itemSv: "namnlappar", itemEn: "name tags", aNameSv: "tjejer", bNameSv: "killar", aNameEn: "girls", bNameEn: "boys" },
            { itemSv: "pennor", itemEn: "pens", aNameSv: "bl√•a", bNameSv: "svarta", aNameEn: "blue", bNameEn: "black" }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const aCount = MathUtils.randomInt(4, 6);
        const bCount = MathUtils.randomInt(4, 6);
        const total = aCount + bCount;

        const p1N = aCount;
        const p1D = total;
        const p2N = aCount - 1; 
        const p2D = total - 1; 

        const desc = lang === 'sv'
            ? `I en beh√•llare finns det ${aCount} ${s.aNameSv} och ${bCount} ${s.bNameSv} ${s.itemSv}. Du tar ut en slumpm√§ssigt och l√§gger den √•t sidan. Sedan tar du en till. Vad √§r sannolikheten att b√•da √§r ${s.aNameSv}?`
            : `In a container, there are ${aCount} ${s.aNameEn} and ${bCount} ${s.bNameEn} ${s.itemEn}. You pick one at random and set it aside. Then you pick another one. What is the probability that both are ${s.aNameEn}?`;

        return {
            renderData: { description: desc, answerType: 'fraction' },
            token: this.toBase64(this.simplifyFraction(p1N * p2N, p1D * p2D)),
            clues: [
                { text: lang === 'sv' ? "F√∂rsta draget:" : "First draw:", latex: `P(\\text{1}) = \\frac{${p1N}}{${p1D}}` },
                { text: lang === 'sv' ? "Andra draget (en √§r borta, s√• b√•de t√§ljare och n√§mnare minskar!):" : "Second draw (one is gone, so both numerator and denominator decrease!):", latex: `P(\\text{2}) = \\frac{${p2N}}{${p2D}}` },
                { text: lang === 'sv' ? "Multiplicera stegen f√∂r att f√• den totala sannolikheten." : "Multiply the steps to get the total probability.", latex: `\\frac{${p1N}}{${p1D}} \\cdot \\frac{${p2N}}{${p2D}}` }
            ]
        };
    }
   private level7_Combinatorics(lang: string): any {
        const mode = MathUtils.randomChoice(['multi_set', 'handshakes']);

        if (mode === 'handshakes') {
            const n = MathUtils.randomInt(5, 12);
            const ans = (n * (n - 1)) / 2;
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `I ett rum tr√§ffas ${n} personer och alla skakar hand med varandra exakt en g√•ng. Hur m√•nga handskakningar sker totalt?` 
                        : `In a room, ${n} people meet and everyone shakes hands with each other exactly once. How many handshakes occur in total?`,
                    answerType: 'numeric'
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang === 'sv' ? `Varje person (${n} st) h√§lsar p√• ${n - 1} andra.` : `Each person (${n}) greets ${n - 1} others.` },
                    { text: lang === 'sv' ? "Dela med 2 eftersom person A till B √§r samma handskakning som B till A." : "Divide by 2 because person A to B is the same handshake as B to A.", latex: `\\frac{${n} \\cdot ${n - 1}}{2}` }
                ]
            };
        }

        // --- SCENARIO: MULTI-SET COMBINATIONS ---
        const scenarios = [
            { sv: ["m√∂ssor", "halsdukar", "vantar"], en: ["hats", "scarves", "gloves"] },
            { sv: ["tr√∂jor", "byxor", "strumpor"], en: ["shirts", "pants", "socks"] },
            { sv: ["huvudr√§tter", "drycker", "efterr√§tter"], en: ["mains", "drinks", "desserts"] },
            { sv: ["telefoner", "skal", "h√∂rlurar"], en: ["phones", "cases", "headphones"] },
            { sv: ["flygresor", "hotell", "utflykter"], en: ["flights", "hotels", "tours"] },
            { sv: ["cyklar", "hj√§lmar", "l√•s"], en: ["bikes", "helmets", "locks"] }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const v = [MathUtils.randomInt(2, 5), MathUtils.randomInt(2, 5), MathUtils.randomInt(2, 5)];
        const items = lang === 'sv' ? s.sv : s.en;
        const ans = v[0] * v[1] * v[2];

        return {
            renderData: {
                description: lang === 'sv' 
                    ? `Du ska v√§lja en kombination av ${v[0]} ${items[0]}, ${v[1]} ${items[1]} och ${v[2]} ${items[2]}. Hur m√•nga olika kombinationer √§r m√∂jliga?`
                    : `You are choosing a combination of ${v[0]} ${items[0]}, ${v[1]} ${items[1]}, and ${v[2]} ${items[2]}. How many different combinations are possible?`,
                answerType: 'numeric'
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r varje val i f√∂rsta gruppen finns det flera val i n√§sta. Vi multiplicerar d√§rf√∂r antalen." : "For every choice in the first group, there are multiple choices in the next. Therefore, we multiply the counts.",
                    latex: `${v[0]} \\cdot ${v[1]} \\cdot ${v[2]} = ${ans}` 
                }
            ]
        };
    }

    private level8_CombinatoricsComplex(lang: string): any {
        const mode = MathUtils.randomChoice(['pathways_basic', 'pathways_blocked', 'pathways_prob']);

        // --- PATHWAY GENERATION LOGIC ---
        // Build dynamic layers: [A, Split1, Split2, (Optional Split3), B]
        const layers = [1];
        const n1 = MathUtils.randomChoice([2, 3]);
        const n2 = MathUtils.randomChoice([2, 3]);
        layers.push(n1, n2);
        
        const hasExtraSplit = MathUtils.randomInt(0, 1) === 1;
        if (hasExtraSplit) layers.push(2);
        layers.push(1);

        // Calculate total possible paths (without blocks)
        let totalPaths = 1;
        for (let i = 1; i < layers.length - 1; i++) {
            totalPaths *= layers[i];
        }

        const obstacles: any[] = [];
        const isBlockedMode = mode === 'pathways_blocked' || mode === 'pathways_prob';

        if (isBlockedMode) {
            // Find all possible edges in the network
            const allEdges: any[] = [];
            for (let l = 0; l < layers.length - 1; l++) {
                for (let f = 0; f < layers[l]; f++) {
                    for (let t = 0; t < layers[l + 1]; t++) {
                        allEdges.push({ layer: l, from: f, to: t });
                    }
                }
            }

            // Randomly block 1-3 pathways, ensuring at least one full path remains
            const numToBlock = MathUtils.randomInt(1, 3);
            const shuffledEdges = [...allEdges].sort(() => Math.random() - 0.5);
            
            for (const edge of shuffledEdges) {
                if (obstacles.length >= numToBlock) break;
                
                // Tentatively block
                const testObstacles = [...obstacles, edge];
                if (this.hasValidPath(layers, testObstacles)) {
                    obstacles.push(edge);
                }
            }
        }

        const validPathCount = this.countValidPaths(layers, obstacles);

        if (mode === 'pathways_basic') {
            const desc = lang === 'sv'
                ? `Figuren visar m√∂jliga v√§gar fr√•n A till B. P√• hur m√•nga olika s√§tt kan man g√• fr√•n A till B?`
                : `The figure shows possible paths from A to B. In how many different ways can you travel from A to B?`;
            
            return {
                renderData: {
                    description: desc,
                    answerType: 'numeric',
                    geometry: { type: 'probability_tree', subtype: 'pathway', layers, obstacles: [] }
                },
                token: this.toBase64(totalPaths.toString()),
                clues: [
                    { text: lang === 'sv' ? "Multiplicera antalet val i varje steg." : "Multiply the number of choices at each stage.", latex: layers.slice(1, -1).join(' \\cdot ') + ` = ${totalPaths}` }
                ]
            };
        }

        if (mode === 'pathways_blocked') {
            const desc = lang === 'sv'
                ? `De r√∂da symbolerna markerar v√§gar som √§r blockerade. Hur m√•nga fungerande v√§gar finns kvar fr√•n A till B?`
                : `The red symbols mark blocked paths. How many viable paths remain from A to B?`;

            return {
                renderData: {
                    description: desc,
                    answerType: 'numeric',
                    geometry: { type: 'probability_tree', subtype: 'pathway', layers, obstacles }
                },
                token: this.toBase64(validPathCount.toString()),
                clues: [
                    { text: lang === 'sv' ? "R√§kna hur m√•nga kompletta v√§gar som g√•r att f√∂lja utan att passera ett r√∂tt kryss." : "Count how many complete paths can be followed without passing a red cross." },
                    { text: lang === 'sv' ? "Tips: F√∂lj varje startv√§g och se hur m√•nga slutstationer den kan n√•." : "Tip: Follow each starting path and see how many endpoints it can reach." }
                ]
            };
        }

        // pathways_prob
        const desc = lang === 'sv'
            ? `Om du v√§ljer en v√§g fr√•n A till B helt slumpm√§ssigt, vad √§r sannolikheten att v√§gen du v√§ljer √§r √∂ppen?`
            : `If you choose a path from A to B completely at random, what is the probability that the path you choose is open?`;

        return {
            renderData: {
                description: desc,
                answerType: 'fraction',
                geometry: { type: 'probability_tree', subtype: 'pathway', layers, obstacles }
            },
            token: this.toBase64(`${validPathCount}/${totalPaths}`),
            clues: [
                { text: lang === 'sv' ? "Sannolikhet = (√ñppna v√§gar) / (Totala v√§gar)" : "Probability = (Open paths) / (Total paths)" },
                { text: lang === 'sv' ? `Det finns totalt ${totalPaths} kombinationer av v√§gar, och ${validPathCount} av dem √§r √∂ppna.` : `There are ${totalPaths} total combinations of paths, and ${validPathCount} of them are open.`, latex: `\\frac{${validPathCount}}{${totalPaths}}` }
            ]
        };
    }

    // --- HELPER METHODS FOR PATHWAYS ---

    private hasValidPath(layers: number[], obstacles: any[]): boolean {
        return this.countValidPaths(layers, obstacles) > 0;
    }

    private countValidPaths(layers: number[], obstacles: any[]): number {
        const memo = new Map<string, number>();

        const find = (layerIdx: number, nodeIdx: number): number => {
            if (layerIdx === layers.length - 1) return 1;
            const key = `${layerIdx}-${nodeIdx}`;
            if (memo.has(key)) return memo.get(key)!;

            let count = 0;
            const nextLayerSize = layers[layerIdx + 1];
            for (let nextNode = 0; nextNode < nextLayerSize; nextNode++) {
                // Check if the edge to nextNode is blocked
                const isBlocked = obstacles.some(o => 
                    o.layer === layerIdx && o.from === nodeIdx && o.to === nextNode
                );
                if (!isBlocked) {
                    count += find(layerIdx + 1, nextNode);
                }
            }
            memo.set(key, count);
            return count;
        };

        return find(0, 0);
    }
}

// FILE END: src\core\generators\ProbabilityGen.ts

// =======================================================
// FILE START: src\core\generators\PythagorasGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class PythagorasGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_SquaresRoots(lang);
            case 2: return this.level2_Hypotenuse(lang);
            case 3: return this.level3_Leg(lang);
            case 4: return this.level4_Applications(lang);
            case 5: return this.level5_Coordinates(lang);
            case 6: return this.level6_Converse(lang);
            default: return this.level1_SquaresRoots(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Helper: Get a scaled triple
    private getTriple(): { a: number, b: number, c: number, k: number } {
        const primitives = [
            // Classics
            [3, 4, 5], 
            [5, 12, 13], 
            [8, 15, 17], 
            [7, 24, 25], 
            [20, 21, 29],
            [12, 35, 37],
            [9, 40, 41],
            [28, 45, 53],
            [11, 60, 61],
            [16, 63, 65],
            [33, 56, 65],
            [48, 55, 73],
            [13, 84, 85],
            [36, 77, 85],
            [39, 80, 89]
        ];
        const base = MathUtils.randomChoice(primitives);
        
        // Random multiplier to ensure variety
        const k = MathUtils.randomChoice([1, 1, 1, 2, 2, 3, 4, 5, 10]); 
        
        return { a: base[0]*k, b: base[1]*k, c: base[2]*k, k: k };
    }

    // Level 1: Squares & Roots (Mental Math)
    private level1_SquaresRoots(lang: string): any {
        const isRoot = MathUtils.randomInt(0, 1) === 1;
        const base = MathUtils.randomInt(1, 15);
        const square = base * base;

        if (isRoot) {
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna roten ur:" : "Calculate the square root:",
                    latex: `\\sqrt{${square}}`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(base.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Vilket tal g√•nger sig sj√§lvt blir det h√§r?" : "Which number times itself equals this?", 
                        latex: `? \\cdot ? = ${square}` 
                    }
                ]
            };
        } else {
            return {
                renderData: {
                    description: lang === 'sv' ? "Ber√§kna kvadraten:" : "Calculate the square:",
                    latex: `${base}^2`,
                    answerType: 'numeric',
                    geometry: null
                },
                token: this.toBase64(square.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Multiplicera talet med sig sj√§lvt." : "Multiply the number by itself.", 
                        latex: `${base} \\cdot ${base}` 
                    }
                ]
            };
        }
    }

    // Level 2: Find Hypotenuse (Simple Algebra Logic)
    private level2_Hypotenuse(lang: string): any {
        const t = this.getTriple();
        // Randomize which leg is base vs height for visual variety
        const swap = MathUtils.randomInt(0, 1) === 1;
        const width = swap ? t.b : t.a;
        const height = swap ? t.a : t.b;

        const desc = lang === 'sv' 
            ? "Triangeln √§r r√§tvinklig. Ber√§kna den l√§ngsta sidan (hypotenusan x)." 
            : "The triangle is right-angled. Calculate the longest side (hypotenuse x).";

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: { 
                    type: 'triangle', subtype: 'right', 
                    width: width, height: height, 
                    // UPDATED: Explicitly map 'b' and 'h' so GeometryComponents renders them.
                    labels: { b: width, h: height, hyp: 'x', c: 'x' } 
                }
            },
            token: this.toBase64(t.c.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Anv√§nd Pythagoras sats: a¬≤ + b¬≤ = c¬≤." : "Use Pythagoras theorem: a¬≤ + b¬≤ = c¬≤.", 
                    latex: `${width}^2 + ${height}^2 = x^2` 
                },
                { 
                    text: lang === 'sv' ? "R√§kna ut summan och ta sedan roten ur." : "Calculate the sum, then take the square root.",
                    latex: `x = \\sqrt{${t.c*t.c}}` 
                }
            ]
        };
    }

    // Level 3: Find Leg (Subtraction Logic)
    private level3_Leg(lang: string): any {
        const t = this.getTriple();
        
        // Decide if we are solving for the base (b) or the height (h)
        const solveForBase = MathUtils.randomInt(0, 1) === 1;

        let labels: any = {};
        let missingVar = 'x';
        
        if (solveForBase) {
            // We know Height (h) and Hypotenuse (c). We need Base (b).
            labels = { h: t.a, b: 'x', hyp: t.c, c: t.c };
            missingVar = 'b';
        } else {
            // We know Base (b) and Hypotenuse (c). We need Height (h).
            labels = { b: t.b, h: 'x', hyp: t.c, c: t.c };
            missingVar = 'a';
        }

        // UPDATED: Added hypotenuse length to description
        const desc = lang === 'sv' 
            ? `Hypotenusan √§r ${t.c}. Ber√§kna den ok√§nda sidan (x).` 
            : `The hypotenuse is ${t.c}. Calculate the unknown side (x).`;

        const knownLeg = solveForBase ? t.a : t.b;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: { 
                    type: 'triangle', subtype: 'right', 
                    width: solveForBase ? t.b : t.b, // keep visual width proportional-ish
                    height: solveForBase ? t.a : t.a,
                    labels: labels 
                }
            },
            token: this.toBase64((solveForBase ? t.b : t.a).toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Du vet den l√§ngsta sidan. D√• ska du subtrahera (ta minus)." : "You know the longest side. So you must subtract.", 
                    latex: `c^2 - ${missingVar === 'a' ? 'b' : 'a'}^2 = ${missingVar}^2` 
                },
                { 
                    text: lang === 'sv' ? "Ta stora kvadraten minus lilla kvadraten." : "Take the big square minus the small square.",
                    latex: `${t.c}^2 - ${knownLeg}^2 = x^2` 
                }
            ]
        };
    }

    // Level 4: Applications (7 Scenarios)
    private level4_Applications(lang: string): any {
        const s = MathUtils.randomChoice([
            { id: 'ladder', type: 'find_c', txtSv: "En stege lutar mot en v√§gg. Stegen n√•r {a} m upp och st√•r {b} m fr√•n v√§ggen. Hur l√•ng √§r stegen?", txtEn: "A ladder leans against a wall. It reaches {a} m up and stands {b} m out. How long is the ladder?" },
            { id: 'map', type: 'find_c', txtSv: "Du g√•r {a} km norrut och sedan {b} km √∂sterut. Hur l√•ngt √§r du fr√•n starten (f√•gelv√§gen)?", txtEn: "You walk {a} km North and then {b} km East. How far are you from the start?" },
            { id: 'tv', type: 'find_c', txtSv: "En TV-sk√§rm √§r {a} cm bred och {b} cm h√∂g. Hur l√•ng √§r diagonalen?", txtEn: "A TV screen is {a} cm wide and {b} cm high. How long is the diagonal?" },
            { id: 'mast', type: 'find_c', txtSv: "En mast √§r {a} m h√∂g. En st√∂dvajer f√§sts i marken {b} m fr√•n masten. Hur l√•ng √§r vajern?", txtEn: "A mast is {a} m tall. A wire is attached to the ground {b} m away. How long is the wire?" },
            // Find Leg Scenarios
            { id: 'kite', type: 'find_a', txtSv: "Ett sn√∂re till en drake √§r {c} m l√•ngt. Draken sv√§var rakt ovanf√∂r en punkt {b} m bort. Hur h√∂gt √§r draken?", txtEn: "A kite string is {c} m long. The kite is above a spot {b} m away. How high is the kite?" },
            { id: 'ramp', type: 'find_a', txtSv: "En ramp √§r {c} m l√•ng. Den n√•r en h√∂jd p√• {b} m. Hur l√•ngt str√§cker den sig l√§ngs marken?", txtEn: "A ramp is {c} m long. It reaches a height of {b} m. How far does it stretch along the ground?" },
            { id: 'envelope', type: 'find_a', txtSv: "Diagonalen p√• ett kuvert √§r {c} cm. H√∂jden √§r {b} cm. Hur brett √§r kuvertet?", txtEn: "The diagonal of an envelope is {c} cm. The height is {b} cm. How wide is it?" }
        ]);

        const t = this.getTriple();
        const k = MathUtils.randomInt(1, 3);
        const primitive = MathUtils.randomChoice([[3,4,5], [5,12,13], [8,15,17]]);
        const a = primitive[0] * k; 
        const b = primitive[1] * k; 
        const c = primitive[2] * k;

        let desc = "";
        let ans = 0;
        let hintFormula = "";

        if (s.type === 'find_c') {
            // FIX: Added .toString() to inputs for replace
            desc = lang === 'sv' 
                ? s.txtSv.replace('{a}', a.toString()).replace('{b}', b.toString()) 
                : s.txtEn.replace('{a}', a.toString()).replace('{b}', b.toString());
            ans = c;
            hintFormula = `\\sqrt{${a}^2 + ${b}^2}`;
        } else {
            // FIX: Added .toString() to inputs for replace
            desc = lang === 'sv' 
                ? s.txtSv.replace('{c}', c.toString()).replace('{b}', b.toString()) 
                : s.txtEn.replace('{c}', c.toString()).replace('{b}', b.toString());
            ans = a;
            hintFormula = `\\sqrt{${c}^2 - ${b}^2}`;
        }

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: null 
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Rita en triangel och anv√§nd Pythagoras." : "Draw a triangle and use Pythagoras." },
                { latex: hintFormula }
            ]
        };
    }

    // Level 5: Coordinate Distance
    private level5_Coordinates(lang: string): any {
        const t = this.getTriple();
        const dx = t.a;
        const dy = t.b;
        const dist = t.c;

        const x1 = MathUtils.randomInt(0, 10);
        const y1 = MathUtils.randomInt(0, 10);
        const x2 = x1 + dx;
        const y2 = y1 + dy;

        const desc = lang === 'sv'
            ? `Ber√§kna avst√•ndet mellan punkterna (${x1}, ${y1}) och (${x2}, ${y2}).`
            : `Calculate the distance between points (${x1}, ${y1}) and (${x2}, ${y2}).`;

        return {
            renderData: {
                description: desc,
                answerType: 'numeric',
                geometry: null
            },
            token: this.toBase64(dist.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Skillnaden i x √§r basen. Skillnaden i y √§r h√∂jden." : "The difference in x is the base. The difference in y is the height.",
                    latex: `\\Delta x = ${dx}, \\quad \\Delta y = ${dy}`
                },
                { 
                    text: lang === 'sv' ? "Anv√§nd Pythagoras p√• skillnaderna." : "Use Pythagoras on the differences.",
                    latex: `\\sqrt{${dx}^2 + ${dy}^2}` 
                }
            ]
        };
    }

    // Level 6: Converse Theorem (Yes/No)
    private level6_Converse(lang: string): any {
        const isRight = MathUtils.randomInt(0, 1) === 1;
        let a=0, b=0, c=0;

        if (isRight) {
            const t = this.getTriple();
            a=t.a; b=t.b; c=t.c;
        } else {
            const base = MathUtils.randomChoice([[3,4,5], [5,12,13]]);
            const k = MathUtils.randomInt(1, 3);
            a = base[0]*k; 
            b = base[1]*k; 
            c = (base[2]*k) + 1; // Incorrect hypotenuse
        }

        const desc = lang === 'sv'
            ? `En triangel har sidorna ${a}, ${b} och ${c}. √Ñr den r√§tvinklig?`
            : `A triangle has sides ${a}, ${b}, and ${c}. Is it a right-angled triangle?`;

        const correct = lang === 'sv' ? (isRight ? "Ja" : "Nej") : (isRight ? "Yes" : "No");
        const wrong = lang === 'sv' ? (isRight ? "Nej" : "Ja") : (isRight ? "No" : "Yes");

        // FIX: Removed dependency on MathUtils.shuffle to avoid missing method errors.
        // Used local random swap instead.
        const options = Math.random() > 0.5 ? [correct, wrong] : [wrong, correct];

        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                options: options,
                geometry: null
            },
            token: this.toBase64(correct),
            clues: [
                { 
                    text: lang === 'sv' ? "Testa om ekvationen st√§mmer:" : "Test if the equation holds:", 
                    latex: `${a}^2 + ${b}^2 = ${c}^2 ?` 
                }
            ]
        };
    }
}

// FILE END: src\core\generators\PythagorasGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ScaleGen {
    // Standard shapes for visuals
    private static readonly SHAPES = ['arrow', 'star', 'lightning', 'key', 'heart', 'cloud', 'moon', 'sun'];

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_LinearFluency(lang);
            case 3: return this.level3_MixedScenarios(lang);
            case 4: return this.level4_DetermineScale(lang); // HUGE update here
            case 5: return this.level5_NoPictures(lang);
            case 6: return this.level6_AreaScaleDeep(lang);
            case 7: return this.level7_Mixed(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    // --- HELPERS ---
    
    private formatNum(n: number): string {
        return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private getRandomInt(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    private randomChoice<T>(arr: T[]): T {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    private shuffle<T>(array: T[]): T[] {
        return array.sort(() => Math.random() - 0.5);
    }

    // --- LEVEL 1: CONCEPTS ---
    private level1_Concepts(lang: string): any {
        const variation = Math.random();

        // Variation A: Spot the Lie
        if (variation < 0.4) {
             const scale = this.randomChoice([2, 4, 5, 10]);
             const correctStatement = lang === 'sv' 
                ? `Verkligheten √§r ${scale} g√•nger st√∂rre √§n bilden.` 
                : `Reality is ${scale} times larger than the image.`;
             const falseStatement = lang === 'sv'
                ? `Bilden √§r st√∂rre √§n verkligheten.`
                : `The image is larger than reality.`;
             const trivialStatement = lang === 'sv'
                ? `Skalan √§r en f√∂rminskning.`
                : `The scale is a reduction.`;

             const options = this.shuffle([correctStatement, falseStatement, trivialStatement]);
             
             return {
                renderData: {
                    description: lang === 'sv' ? `Betrakta skalan 1:${scale}. Vilket p√•st√•ende √§r FALSKT?` : `Consider scale 1:${scale}. Which statement is FALSE?`,
                    answerType: 'multiple_choice',
                    options: options,
                    geometry: { 
                        type: 'scale_single', 
                        label: `1:${scale}`, 
                        shape: 'map' 
                    }
                },
                token: this.toBase64(falseStatement),
                clues: []
             };
        }

        // Variation B: Standard Matching
        const isReduction = this.getRandomInt(0, 1) === 1;
        const ratio = this.randomChoice([2, 5, 10, 50, 100]);
        const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
        
        let correct = "", wrong = "";
        const same = lang === 'sv' ? "De √§r lika stora." : "They are the same size.";
        
        if (isReduction) {
            correct = lang === 'sv' ? `Verkligheten √§r ${ratio} ggr st√∂rre.` : `Reality is ${ratio}x larger.`;
            wrong = lang === 'sv' ? `Bilden √§r ${ratio} ggr st√∂rre.` : `Image is ${ratio}x larger.`;
        } else {
            correct = lang === 'sv' ? `Bilden √§r ${ratio} ggr st√∂rre.` : `Image is ${ratio}x larger.`;
            wrong = lang === 'sv' ? `Verkligheten √§r ${ratio} ggr st√∂rre.` : `Reality is ${ratio}x larger.`;
        }

        return {
            renderData: {
                description: lang === 'sv' ? `Vad betyder skalan ${scaleStr}?` : `What does the scale ${scaleStr} mean?`,
                answerType: 'multiple_choice',
                options: this.shuffle([correct, wrong, same]),
                geometry: { 
                    type: 'scale_compare', 
                    leftLabel: lang === 'sv' ? 'Bild' : 'Image', 
                    rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                    leftValue: isReduction ? 1 : ratio,
                    rightValue: isReduction ? ratio : 1,
                    shape: 'arrow'
                }
            },
            token: this.toBase64(correct),
            clues: []
        };
    }

    // --- LEVEL 2: LINEAR FLUENCY ---
    private level2_LinearFluency(lang: string): any {
        const variation = Math.random();
        const shape = this.randomChoice(ScaleGen.SHAPES);

        // VARIATION A: Calculate Reality (1:X)
        if (variation < 0.35) {
            const scale = this.randomChoice([2, 5, 10, 20, 50, 100]);
            const imgCm = this.getRandomInt(2, 15);
            const ans = imgCm * scale;
            
            return {
                renderData: {
                    description: lang === 'sv' 
                        ? `En bild √§r ritad i skala 1:${scale}. Bilden √§r ${imgCm} cm bred. Hur bred √§r den i verkligheten?`
                        : `A picture is drawn in scale 1:${scale}. The picture is ${imgCm} cm wide. How wide is it in reality?`,
                    answerType: 'numeric',
                    suffix: 'cm',
                    geometry: {
                        type: 'scale_compare',
                        leftLabel: lang === 'sv' ? 'Bild' : 'Image',
                        rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                        leftValue: 1, rightValue: scale, shape
                    }
                },
                token: this.toBase64(ans.toString()),
                clues: [
                    { text: lang==='sv' ? "Verkligheten = Bilden ¬∑ Skalan" : "Reality = Image ¬∑ Scale", latex: `${imgCm} \\cdot ${scale}` }
                ]
            };
        }

        // VARIATION B: Calculate Image (1:X)
        if (variation < 0.6) {
            const scale = this.randomChoice([10, 20, 50, 100]);
            const imgCm = this.getRandomInt(2, 10);
            const realCm = imgCm * scale;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Ett f√∂rem√•l √§r ${realCm} cm i verkligheten. Hur stor blir den p√• en ritning i skala 1:${scale}?`
                        : `An object is ${realCm} cm in reality. How big will it be on a drawing with scale 1:${scale}?`,
                    answerType: 'numeric',
                    suffix: 'cm',
                    geometry: {
                        type: 'scale_compare',
                        leftLabel: lang === 'sv' ? 'Ritning' : 'Drawing',
                        rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                        leftValue: 1, rightValue: scale, shape: 'house'
                    }
                },
                token: this.toBase64(imgCm.toString()),
                clues: [
                    { text: lang==='sv' ? "Bilden √§r mindre √§n verkligheten." : "The image is smaller than reality.", latex: `\\text{Image} < \\text{Reality}` },
                    { text: lang==='sv' ? "Bilden = Verkligheten / Skalan" : "Image = Reality / Scale", latex: `${realCm} / ${scale}` }
                ]
            };
        }

        // VARIATION C: Find the Scale
        if (variation < 0.8) {
            const scale = this.randomChoice([2, 4, 5, 10, 20, 50]);
            const imgCm = this.getRandomInt(2, 10);
            const realCm = imgCm * scale;

            return {
                renderData: {
                    description: lang === 'sv'
                        ? `Bilden √§r ${imgCm} cm. Verkligheten √§r ${realCm} cm. Vilken √§r skalan?`
                        : `The image is ${imgCm} cm. Reality is ${realCm} cm. What is the scale?`,
                    answerType: 'text',
                    placeholder: '1:X',
                    geometry: { type: 'scale_single', label: '?', shape: 'magnifying_glass' }
                },
                token: this.toBase64(`1:${scale}`),
                clues: [
                    { text: lang==='sv' ? "Hur m√•nga g√•nger st√∂rre √§r verkligheten?" : "How many times larger is reality?", latex: `${realCm} / ${imgCm}` }
                ]
            };
        }

        // VARIATION D: Magnification (X:1)
        const scale = this.randomChoice([5, 10, 20]);
        const realMm = this.getRandomInt(2, 9);
        const imgMm = realMm * scale;
        
        return {
            renderData: {
                description: lang === 'sv'
                    ? `En insekt f√∂rstoras i skala ${scale}:1. P√• bilden √§r den ${imgMm} mm. Hur stor √§r den i verkligheten?`
                    : `An insect is magnified in scale ${scale}:1. In the picture it is ${imgMm} mm. How big is it in reality?`,
                answerType: 'numeric',
                suffix: 'mm',
                geometry: {
                    type: 'scale_compare',
                    leftLabel: lang === 'sv' ? 'Bild' : 'Image',
                    rightLabel: lang === 'sv' ? 'Verklighet' : 'Reality',
                    leftValue: scale, rightValue: 1, shape: 'ladybug'
                }
            },
            token: this.toBase64(realMm.toString()),
            clues: [
                { text: lang==='sv' ? "Skala X:1 betyder att bilden √§r st√∂rst." : "Scale X:1 means image is largest.", latex: `\\text{Image} > \\text{Reality}` },
                { text: lang==='sv' ? "Verkligheten = Bilden / Skalan" : "Reality = Image / Scale", latex: `${imgMm} / ${scale}` }
            ]
        };
    }

    // --- LEVEL 3: MIXED SCENARIOS ---
    private level3_MixedScenarios(lang: string): any {
        const scenarioType = this.randomChoice([0, 1, 2, 3]);
        let desc="", answer=0, suffix="", visualData:any={}, clues:any[]=[];

        if (scenarioType === 0) { // Map
            const scale = this.randomChoice([10000, 20000, 50000]); 
            const mapCm = this.getRandomInt(3, 9); 
            const realCm = mapCm * scale;
            const useKm = realCm >= 100000;
            answer = useKm ? realCm / 100000 : realCm / 100;
            suffix = useKm ? 'km' : 'm';
            desc = lang === 'sv' ? `Karta 1:${this.formatNum(scale)}. Avst√•nd ${mapCm} cm. Verkligheten?` : `Map 1:${this.formatNum(scale)}. Dist ${mapCm} cm. Reality?`;
            visualData = { type: 'scale_compare', leftLabel: 'Map', rightLabel: 'Real', leftValue: 1, rightValue: scale, shape: 'map' };
            clues = [{ text: "Calc cm", latex: `${mapCm}\\cdot${scale}`}, { text: `Convert to ${suffix}`, latex: `/${useKm?100000:100}` }];
        } else if (scenarioType === 1) { // Blueprint
            const scale = 50, realM = 4;
            answer = (realM * 100) / scale; suffix='cm';
            desc = lang==='sv' ? `V√§gg ${realM}m. Ritning 1:${scale}. Hur m√•nga cm p√• ritning?` : `Wall ${realM}m. Blueprint 1:${scale}. Size in cm?`;
            visualData = { type: 'scale_compare', leftLabel: 'Blueprint', rightLabel: 'Real', leftValue: 1, rightValue: scale, shape: 'house' };
            clues = [{text: "m to cm", latex: `${realM}\\cdot100`}, {text:"Divide by scale", latex: `/${scale}`}];
        } else {
             return this.level2_LinearFluency(lang);
        }

        return {
            renderData: { description: desc, answerType: 'numeric', geometry: visualData, suffix },
            token: this.toBase64(answer.toString()),
            clues
        };
    }

    // --- LEVEL 4: DETERMINE SCALE (Updated with Variations) ---
    private level4_DetermineScale(lang: string): any {
        // 70% Chance for Reduction (1:X), 30% for Magnification (X:1)
        const isReduction = Math.random() < 0.7;
        let scale = 0, desc = "", clue1 = "", clue2 = "", clue3 = "", answerStr = "";
        
        if (isReduction) {
            // REDUCTION LOGIC (Real M -> Image CM)
            // Broader range of random scales
            const scaleBases = [10, 20, 25, 30, 40, 50, 60, 75, 100, 150, 200, 250, 300, 400, 500];
            scale = this.randomChoice(scaleBases);
            const imgCm = this.getRandomInt(2, 12);
            
            // Calculate Real (m)
            const realCm = imgCm * scale;
            const realM = realCm / 100;
            
            // 10 Reduction Scenarios
            const scenarios = [
                { sv: "Ett rum", en: "A room", attrSv: "l√•ngt", attrEn: "long" },
                { sv: "En buss", en: "A bus", attrSv: "l√•ng", attrEn: "long" },
                { sv: "En flaggst√•ng", en: "A flagpole", attrSv: "h√∂g", attrEn: "high" },
                { sv: "En pool", en: "A pool", attrSv: "l√•ng", attrEn: "long" },
                { sv: "En tr√§dg√•rd", en: "A garden", attrSv: "bred", attrEn: "wide" },
                { sv: "Ett t√•g", en: "A train", attrSv: "l√•ngt", attrEn: "long" },
                { sv: "En b√•t", en: "A boat", attrSv: "l√•ng", attrEn: "long" },
                { sv: "En byggnad", en: "A building", attrSv: "h√∂g", attrEn: "high" },
                { sv: "En lastbil", en: "A truck", attrSv: "l√•ng", attrEn: "long" },
                { sv: "Ett matbord", en: "A dining table", attrSv: "l√•ngt", attrEn: "long" }
            ];
            
            const s = this.randomChoice(scenarios);
            const objName = lang === 'sv' ? s.sv : s.en;
            const attr = lang === 'sv' ? s.attrSv : s.attrEn;
            const realMStr = realM.toString().replace('.', ','); 

            desc = lang === 'sv'
                ? `${objName} √§r ${realMStr} m ${attr} i verkligheten. P√• ritningen √§r det ${imgCm} cm. Vilken skala √§r ritningen?`
                : `${objName} is ${realMStr} m ${attr} in reality. On the drawing it is ${imgCm} cm. What is the scale?`;
            
            answerStr = `1:${scale}`;
            clue1 = lang === 'sv' ? `Omvandla ${realMStr} m till cm: ${realM} ¬∑ 100 = ${realCm} cm.` : `Convert ${realMStr} m to cm: ${realM} ¬∑ 100 = ${realCm} cm.`;
            clue2 = lang === 'sv' ? `J√§mf√∂r: Bild : Verklighet -> ${imgCm} : ${realCm}` : `Compare: Image : Reality -> ${imgCm} : ${realCm}`;
            clue3 = lang === 'sv' ? `F√∂renkla genom att dela b√•da med ${imgCm}.` : `Simplify by dividing both sides by ${imgCm}.`;

        } else {
            // MAGNIFICATION LOGIC (Real MM -> Image CM)
            const scaleBases = [2, 4, 5, 8, 10, 20, 50];
            scale = this.randomChoice(scaleBases);
            const realMm = this.getRandomInt(2, 9);
            const imgMm = realMm * scale;
            const imgCm = imgMm / 10; 
            
            // 10 Magnification Scenarios
            const scenarios = [
                { sv: "En myra", en: "An ant" },
                { sv: "Ett fr√∂", en: "A seed" },
                { sv: "En datorkomponent", en: "A computer chip" },
                { sv: "En sn√∂flinga", en: "A snowflake" },
                { sv: "En vattendroppe", en: "A water drop" },
                { sv: "En nyckelpiga", en: "A ladybug" },
                { sv: "Ett knappn√•lshuvud", en: "A pinhead" },
                { sv: "En insekt", en: "An insect" },
                { sv: "Ett sandkorn", en: "A grain of sand" },
                { sv: "En liten skruv", en: "A small screw" }
            ];
            
            const s = this.randomChoice(scenarios);
            const objName = lang === 'sv' ? s.sv : s.en;
            const imgCmDisplay = imgCm.toString().replace('.', ',');

            desc = lang === 'sv'
                ? `${objName} √§r ${realMm} mm i verkligheten. P√• bilden √§r den ${imgCmDisplay} cm. Vilken skala √§r bilden?`
                : `${objName} is ${realMm} mm in reality. In the picture it is ${imgCmDisplay} cm. What is the scale?`;
            
            answerStr = `${scale}:1`;
            clue1 = lang === 'sv' ? `Omvandla ${imgCmDisplay} cm till mm: ${imgCm} ¬∑ 10 = ${imgMm} mm.` : `Convert ${imgCmDisplay} cm to mm: ${imgCm} ¬∑ 10 = ${imgMm} mm.`;
            clue2 = lang === 'sv' ? `J√§mf√∂r: Bild : Verklighet -> ${imgMm} : ${realMm}` : `Compare: Image : Reality -> ${imgMm} : ${realMm}`;
            clue3 = lang === 'sv' ? `Eftersom bilden √§r st√∂rre √§r det en f√∂rstoring (X:1).` : `Since the image is larger, it's a magnification (X:1).`;
        }

        return {
            renderData: {
                description: desc,
                answerType: 'text',
                placeholder: isReduction ? '1:...' : '...:1',
                geometry: { 
                    type: 'scale_single', 
                    label: '?', 
                    shape: isReduction ? 'magnifying_glass' : 'ladybug'
                }
            },
            token: this.toBase64(answerStr),
            clues: [
                { text: clue1, latex: '' },
                { text: clue2, latex: '' },
                { text: clue3, latex: isReduction ? `1 : ${scale}` : `${scale} : 1` }
            ]
        };
    }

    // --- LEVEL 5: NO PICTURES ---
    private level5_NoPictures(lang: string): any {
        const data = this.level3_MixedScenarios(lang);
        data.renderData.geometry = null;
        return data;
    }

    // --- LEVEL 6: AREA SCALE DEEP ---
    private level6_AreaScaleDeep(lang: string): any {
        const variation = Math.random();

        // VARIATION A: Conceptual Squared
        if (variation < 0.25) {
            const L = this.randomChoice([2, 3, 4, 5, 10]);
            const sq = L * L;
            
            const correct = lang==='sv' ? `${sq} g√•nger st√∂rre` : `${sq} times larger`;
            const trap1 = lang==='sv' ? `${L} g√•nger st√∂rre` : `${L} times larger`;
            const trap2 = lang==='sv' ? `${L*2} g√•nger st√∂rre` : `${L*2} times larger`;

            return {
                renderData: {
                    description: lang==='sv' 
                        ? `L√§ngdskalan √§r 1:${L}. Hur mycket st√∂rre blir arean?`
                        : `Length scale is 1:${L}. How much larger does the area become?`,
                    answerType: 'multiple_choice',
                    options: this.shuffle([correct, trap1, trap2]),
                    geometry: { type: 'scale_single', label: `1:${L}`, shape: 'square' }
                },
                token: this.toBase64(correct),
                clues: [{ text: "Area Scale = (Length Scale)¬≤", latex: `${L}^2` }]
            };
        }

        // VARIATION B: Reverse Area
        if (variation < 0.5) {
            const L = this.randomChoice([2, 3, 4, 5]);
            const smallA = this.randomChoice([1, 4, 9, 10]);
            const largeA = smallA * (L * L);

            return {
                renderData: {
                    description: lang==='sv'
                        ? `Lilla arean √§r ${smallA} cm¬≤. Stora arean √§r ${largeA} cm¬≤. Vad √§r l√§ngdskalan? (Svara som X:X)`
                        : `Small area is ${smallA} cm¬≤. Large area is ${largeA} cm¬≤. What is the length scale? (Answer as X:X)`,
                    answerType: 'text',
                    placeholder: '1:X',
                    geometry: {
                        type: 'compare_shapes_area',
                        shapeType: 'square',
                        left: { area: smallA, width: 20, height: 20 }, 
                        right: { area: largeA, width: 40, height: 40 }
                    }
                },
                token: this.toBase64(`1:${L}`),
                clues: [
                    { text: lang==='sv' ? "Hitta areaskalan f√∂rst." : "Find area scale first.", latex: `${largeA} / ${smallA} = ${L*L}` },
                    { text: lang==='sv' ? "Ta roten ur areaskalan." : "Take square root of area scale.", latex: `\\sqrt{${L*L}} = ${L}` }
                ]
            };
        }

        // VARIATION C: Backward Calculation
        if (variation < 0.75) {
            const L = this.randomChoice([2, 3, 4, 5]);
            const smallA = this.getRandomInt(2, 10);
            const largeA = smallA * (L * L);

            return {
                renderData: {
                    description: lang==='sv'
                        ? `L√§ngdskalan √§r 1:${L}. Den stora figuren har arean ${largeA} cm¬≤. Vad √§r den lilla figurens area?`
                        : `Length scale is 1:${L}. The large shape has area ${largeA} cm¬≤. What is the area of the small shape?`,
                    answerType: 'numeric',
                    suffix: 'cm¬≤',
                    geometry: {
                        type: 'compare_shapes_area',
                        shapeType: 'triangle',
                        left: { area: '?', width: 20, height: 20 },
                        right: { area: largeA, width: 40, height: 40 }
                    }
                },
                token: this.toBase64(smallA.toString()),
                clues: [
                    { text: lang==='sv' ? "Areaskalan √§r kvadraten av l√§ngdskalan." : "Area scale is square of length scale.", latex: `${L}^2 = ${L*L}` },
                    { text: lang==='sv' ? "Dela stora arean med areaskalan." : "Divide large area by area scale.", latex: `${largeA} / ${L*L}` }
                ]
            };
        }

        // VARIATION D: Classic Forward
        const shape = this.randomChoice(['rectangle', 'triangle']);
        const L = this.randomChoice([2, 3, 4]);
        const w = this.getRandomInt(2, 4);
        const h = this.getRandomInt(2, 4);
        const baseArea = shape === 'rectangle' ? w * h : (w * h * 0.5) % 1 === 0 ? w * h * 0.5 : w * h;
        const bigArea = baseArea * (L * L);

        return {
            renderData: {
                description: lang==='sv' ? `L√§ngdskala 1:${L}. Lilla arean ${baseArea} cm¬≤. Stora arean?` : `Length scale 1:${L}. Small area ${baseArea} cm¬≤. Large area?`,
                answerType: 'numeric',
                suffix: 'cm¬≤',
                geometry: {
                    type: 'compare_shapes_area',
                    shapeType: shape,
                    left: { area: baseArea, width: 20, height: 20 },
                    right: { area: '?', width: 40, height: 40 }
                }
            },
            token: this.toBase64(bigArea.toString()),
            clues: [{ text: "Scale Area", latex: `${baseArea} \\cdot ${L}^2` }]
        };
    }

    // --- LEVEL 7: MIXED ---
    private level7_Mixed(lang: string): any {
        const subLevel = this.getRandomInt(2, 6);
        return this.generate(subLevel, lang);
    }
}

// FILE END: src\core\generators\ScaleGen.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class SimilarityGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concept(lang);
            case 2: return this.level2_CalcSide(lang);
            case 3: return this.level3_TopTriangle(lang);
            case 4: return this.level4_Pythagoras(lang);
            default: return this.level1_Concept(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    private level1_Concept(lang: string): any {
        const isSimilar = MathUtils.randomInt(0, 1) === 1;
        const type = MathUtils.randomChoice(['rect_sides', 'tri_sides', 'tri_angles']);
        
        let geom: any = { type: 'similarity_compare' };
        let desc = "";
        let steps = [];

        if (type === 'rect_sides') {
            geom.shapeType = 'rectangle';
            const w1 = MathUtils.randomInt(2, 5) * 10;
            const h1 = MathUtils.randomInt(2, 5) * 10;
            
            const k = isSimilar ? MathUtils.randomChoice([1.5, 2, 0.5]) : MathUtils.randomChoice([1.2, 1.8, 0.8]);
            const w2 = Math.round(w1 * k);
            const h2 = isSimilar ? Math.round(h1 * k) : Math.round(h1 * (k + 0.5)); 

            geom.left = { labels: { b: w1, h: h1 } };
            geom.right = { labels: { b: w2, h: h2 } };
            
            desc = lang === 'sv' ? "√Ñr rektanglarna likformiga?" : "Are the rectangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "J√§mf√∂r baserna och h√∂jderna." : "Compare bases and heights.", 
                latex: `\\frac{${w2}}{${w1}} \\text{ vs } \\frac{${h2}}{${h1}}` 
            });
        } 
        else if (type === 'tri_angles') {
            geom.shapeType = 'triangle';
            const a1 = MathUtils.randomInt(40, 75);
            const a2 = MathUtils.randomInt(40, 75);
            
            const b1 = isSimilar ? a1 : a1 + MathUtils.randomChoice([-15, 15]);
            const b2 = isSimilar ? a2 : a2;

            geom.left = { angles: [a1, a2, null], labels: { a1: `${a1}¬∞`, a2: `${a2}¬∞` } };
            geom.right = { angles: [b1, b2, null], labels: { a1: `${b1}¬∞`, a2: `${b2}¬∞` } };

            desc = lang === 'sv' ? "√Ñr trianglarna likformiga?" : "Are the triangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "Likformiga trianglar m√•ste ha exakt samma vinklar." : "Similar triangles must have exactly the same angles.", 
                latex: "" 
            });
        }
        else { 
            geom.shapeType = 'triangle';
            const s1 = MathUtils.randomInt(4, 9);
            const s2 = MathUtils.randomInt(4, 9);
            
            const k = isSimilar ? 2 : 1.5;
            const r1 = s1 * k;
            const r2 = isSimilar ? s2 * k : Math.floor(s2 * (k + 0.4));

            geom.left = { labels: { s1: s1, s2: s2 } };
            geom.right = { labels: { s1: r1, s2: r2 } };
            
            desc = lang === 'sv' ? "√Ñr trianglarna likformiga?" : "Are the triangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "Kolla om b√•da sidorna har v√§xt lika mycket." : "Check if both sides scaled by the same factor.", 
                latex: `\\frac{${r1}}{${s1}} \\text{ vs } \\frac{${r2}}{${s2}}` 
            });
        }

        const correct = isSimilar ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");
        const wrong = isSimilar ? (lang === 'sv' ? "Nej" : "No") : (lang === 'sv' ? "Ja" : "Yes");

        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                options: MathUtils.shuffle([correct, wrong]),
                geometry: geom,
                latex: ""
            },
            token: this.toBase64(correct),
            clues: steps
        };
    }

    private level2_CalcSide(lang: string): any {
        const k = MathUtils.randomChoice([1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]);
        const s1 = MathUtils.randomInt(3, 12);
        const s2 = MathUtils.randomInt(3, 12);
        
        const bigS1 = Math.round(s1 * k * 10) / 10;
        const bigS2 = Math.round(s2 * k * 10) / 10;
        
        const findBig = MathUtils.randomInt(0, 1) === 1;
        let ans = 0, clues = [];

        let lLabels: any = { s1, s2 };
        let rLabels: any = {};

        if (findBig) {
            ans = bigS1;
            lLabels = { s1: s1, s2: s2 };
            rLabels = { s1: 'x', s2: bigS2 };
            
            clues.push({ 
                text: lang === 'sv' ? "1. Hitta skalan." : "1. Find the scale.", 
                latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` 
            });
            clues.push({ 
                text: lang === 'sv' ? "2. Multiplicera den k√§nda sidan med skalan." : "2. Multiply the known side by the scale.", 
                latex: `x = ${s1} \\cdot ${k} = \\mathbf{${ans}}` 
            });
        } else {
            ans = s1;
            lLabels = { s1: 'x', s2: s2 };
            rLabels = { s1: bigS1, s2: bigS2 };
            
            clues.push({ 
                text: lang === 'sv' ? "1. Hitta skalan." : "1. Find the scale.", 
                latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` 
            });
            clues.push({ 
                text: lang === 'sv' ? "2. Dividera den k√§nda sidan med skalan." : "2. Divide the known side by the scale.", 
                latex: `x = \\frac{${bigS1}}{${k}} = \\mathbf{${ans}}` 
            });
        }
        
        return {
            renderData: { 
                geometry: { type: 'similarity_compare', shapeType: 'triangle', left: { labels: lLabels }, right: { labels: rLabels } }, 
                description: lang === 'sv' ? "Figurerna √§r likformiga. Ber√§kna x." : "Shapes are similar. Calculate x.", 
                answerType: 'text',
                latex: ""
            },
            token: this.toBase64(ans.toString()),
            clues: clues
        };
    }

    private level3_TopTriangle(lang: string): any {
        const top = MathUtils.randomInt(4, 10);
        const add = MathUtils.randomInt(2, 6);
        const tot = top + add;
        
        const smallBase = MathUtils.randomInt(5, 12);
        const scale = tot / top;
        const largeBase = scale * smallBase;
        
        if (!Number.isInteger(largeBase)) return this.level3_TopTriangle(lang);

        const scaleStr = Number.isInteger(scale) ? scale.toString() : scale.toFixed(1); 
        const showExtension = MathUtils.randomInt(0, 1) === 1;

        let visualLabels = {};
        let clueSteps = [];

        if (showExtension) {
            // Variation: Give Top and Extension (bottom part). User must sum them.
            // Note: GeometryComponents handles 'left_bot' by drawing it on the segment
            visualLabels = { left_top: top, left_bot: add, base_top: smallBase, base_bot: 'x' };
            
            clueSteps = [
                {
                    text: lang === 'sv' 
                        ? "1. Addera toppens l√§ngd och den nedre delens l√§ngd f√∂r att f√• hela sidans l√§ngd." 
                        : "1. Add the top length and the extension length to get the total side length.",
                    latex: `\\text{Stor Sida} = ${top} + ${add} = ${tot}`
                },
                { 
                    text: lang === 'sv' 
                        ? "2. R√§kna ut skalan (Stor Sida / Liten Sida)." 
                        : "2. Calculate the scale (Big Side / Small Side).", 
                    latex: `\\text{Skala} = \\frac{${tot}}{${top}} = ${scaleStr}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `3. Multiplicera den lilla basen med skalan.` 
                        : `3. Multiply the small base by the scale.`, 
                    latex: `x = ${smallBase} \\cdot ${scaleStr} = \\mathbf{${largeBase}}` 
                }
            ];

        } else {
            // Standard: Give Top and Total Length
            visualLabels = { left_top: top, left_tot: tot, base_top: smallBase, base_bot: 'x' };
            
            clueSteps = [
                { 
                    text: lang === 'sv' 
                        ? "1. R√§kna ut hur m√•nga g√•nger st√∂rre den stora triangeln √§r (Skala)." 
                        : "1. Calculate how many times bigger the large triangle is (Scale Factor).", 
                    latex: `\\text{Skala} = \\frac{\\text{Stor Sida}}{\\text{Liten Sida}} = \\frac{${tot}}{${top}} = ${scaleStr}` 
                },
                { 
                    text: lang === 'sv' 
                        ? `2. Multiplicera den lilla basen med skalan f√∂r att f√• x.` 
                        : `2. Multiply the small base by the scale to get x.`, 
                    latex: `x = ${smallBase} \\cdot ${scaleStr} = \\mathbf{${largeBase}}` 
                }
            ];
        }

        return {
            renderData: { 
                geometry: { type: 'transversal', labels: visualLabels }, 
                description: lang === 'sv' ? "Ber√§kna basen x." : "Calculate base x.", 
                answerType: 'text',
                latex: ""
            },
            token: this.toBase64(largeBase.toString()),
            clues: clueSteps
        };
    }

    private level4_Pythagoras(lang: string): any {
        const [a, b, c] = MathUtils.randomChoice([[3,4,5], [5,12,13], [6,8,10], [8,15,17]]);
        const findHyp = MathUtils.randomInt(0, 1) === 1;
        const orient = MathUtils.randomChoice(['up', 'down', 'left', 'right']);
        
        let ans = 0;
        let labels: any = {};
        let clue = "";
        let desc = "";

        if (findHyp) {
            ans = c;
            labels = { base: a, height: b, hypotenuse: 'x' };
            clue = `x = \\sqrt{${a}^2 + ${b}^2} = \\mathbf{${c}}`;
            desc = lang === 'sv' ? "Ber√§kna hypotenusan (x)." : "Calculate hypotenuse (x).";
        } else {
            ans = a;
            labels = { base: 'x', height: b, hypotenuse: c };
            clue = `x = \\sqrt{${c}^2 - ${b}^2} = \\mathbf{${a}}`;
            desc = lang === 'sv' ? "Ber√§kna kateten (x)." : "Calculate leg (x).";
        }

        return {
            renderData: { 
                geometry: { type: 'triangle', subtype: 'right', width: a, height: b, labels, orientation: orient }, 
                description: desc,
                answerType: 'text',
                latex: ""
            },
            token: this.toBase64(ans.toString()),
            clues: [
                { text: lang === 'sv' ? "Pythagoras sats:" : "Pythagoras theorem:", latex: "a^2 + b^2 = c^2" },
                { text: lang === 'sv' ? (findHyp ? "F√∂r hypotenusan, addera kvadraterna." : "F√∂r en katet, subtrahera.") : (findHyp ? "Add squares." : "Subtract squares."), latex: clue }
            ]
        };
    }
}

// FILE END: src\core\generators\SimilarityGen.ts

// =======================================================
// FILE START: src\core\generators\StatisticsGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class StatisticsGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_ModeRange(lang);
            case 2: return this.level2_Mean(lang);
            case 3: return this.level3_Median(lang);
            case 4: return this.level4_ReverseMean(lang);
            case 5: return this.level5_FrequencyTable(lang);
            case 6: return this.level6_RealWorldMixed(lang);
            default: return this.level1_ModeRange(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // --- LEVEL 1: Mode (Typv√§rde) & Range (Variationsbredd) ---
    private level1_ModeRange(lang: string): any {
        const scenarios = [
            { id: 'shoe', sv: "skostorlekar", en: "shoe sizes", vals: [36, 37, 38, 39, 40, 41, 42] },
            { id: 'goals', sv: "gjorda m√•l", en: "goals scored", vals: [0, 1, 2, 3, 4, 5] },
            { id: 'temp', sv: "temperaturer (¬∞C)", en: "temperatures (¬∞C)", vals: [-5, -2, 0, 1, 3, 5, 8] },
            { id: 'age', sv: "√•ldrar i en grupp", en: "ages in a group", vals: [10, 11, 12, 13, 14, 15] },
            { id: 'dice', sv: "t√§rningsslag", en: "dice rolls", vals: [1, 2, 3, 4, 5, 6] },
            { id: 'points', sv: "po√§ng p√• prov", en: "test points", vals: [5, 6, 7, 8, 9, 10] },
            { id: 'pets', sv: "husdjur per familj", en: "pets per family", vals: [0, 1, 2, 3] }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const len = MathUtils.randomInt(5, 9);
        const list: number[] = [];
        
        // Generate list with a clear Mode
        const modeVal = MathUtils.randomChoice(s.vals);
        for(let i=0; i<3; i++) list.push(modeVal); // Ensure mode exists
        for(let i=0; i<len-3; i++) list.push(MathUtils.randomChoice(s.vals));
        
        // Manual shuffle to avoid dependency
        const shuffled = list.sort(() => Math.random() - 0.5);
        const setStr = shuffled.join(', ');

        const type = MathUtils.randomInt(1, 2); // 1=Mode, 2=Range

        if (type === 1) { // Mode
            const desc = lang === 'sv' 
                ? `H√§r √§r en lista √∂ver ${s.sv}: ${setStr}. Vad √§r typv√§rdet?` 
                : `Here is a list of ${s.en}: ${setStr}. What is the mode?`;
            
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(modeVal.toString()),
                clues: [
                    { text: lang === 'sv' ? "Typv√§rdet √§r det tal som f√∂rekommer flest g√•nger." : "The mode is the number that appears most often." },
                    { text: lang === 'sv' ? `Talet ${modeVal} finns med flest g√•nger.` : `The number ${modeVal} appears most times.` }
                ]
            };
        } else { // Range
            const min = Math.min(...list);
            const max = Math.max(...list);
            const range = max - min;
            const desc = lang === 'sv'
                ? `H√§r √§r en lista √∂ver ${s.sv}: ${setStr}. Vad √§r variationsbredden?`
                : `Here is a list of ${s.en}: ${setStr}. What is the range?`;

            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64(range.toString()),
                clues: [
                    { text: lang === 'sv' ? "Variationsbredd = St√∂rsta v√§rdet - Minsta v√§rdet." : "Range = Max value - Min value." },
                    { latex: `${max} - ${min} = ${range}` }
                ]
            };
        }
    }

    // --- LEVEL 2: Mean (Medelv√§rde) ---
    private level2_Mean(lang: string): any {
        const scenarios = [
            { sv: "sju kompisar", en: "seven friends", unit: "√•r", count: 7 },
            { sv: "fem dagar", en: "five days", unit: "¬∞C", count: 5 },
            { sv: "fyra p√•sar godis", en: "four bags of candy", unit: "g", count: 4 },
            { sv: "tre hopp", en: "three jumps", unit: "m", count: 3 },
            { sv: "sex matcher", en: "six matches", unit: "m√•l", count: 6 },
            { sv: "fem kvitton", en: "five receipts", unit: "kr", count: 5 },
            { sv: "fyra provresultat", en: "four test scores", unit: "po√§ng", count: 4 }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const mean = MathUtils.randomInt(5, 20);
        const targetSum = mean * s.count;
        
        let currentSum = 0;
        const list: number[] = [];
        for(let i=0; i<s.count-1; i++) {
            const val = MathUtils.randomInt(1, mean + 5);
            list.push(val);
            currentSum += val;
        }
        const lastVal = targetSum - currentSum;
        list.push(lastVal);
        
        // Safety check for negatives if context forbids
        if ((s.unit === '√•r' || s.unit === 'kr' || s.unit === 'g') && lastVal < 0) {
            return this.level2_Mean(lang); // Retry
        }

        const setStr = list.sort(() => Math.random() - 0.5).join(', ');
        
        const desc = lang === 'sv'
            ? `Ber√§kna medelv√§rdet f√∂r: ${setStr} (${s.unit}).`
            : `Calculate the mean for: ${setStr} (${s.unit}).`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(mean.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Addera alla talen f√∂rst (Summan)." : "Add all numbers first (The Sum).", 
                    latex: `${list.join('+')} = ${targetSum}` 
                },
                { 
                    text: lang === 'sv' ? `Dela summan med antalet tal (${s.count}).` : `Divide the sum by the count (${s.count}).`, 
                    latex: `${targetSum} / ${s.count} = ${mean}` 
                }
            ]
        };
    }

    // --- LEVEL 3: Median ---
    private level3_Median(lang: string): any {
        const scenarios = [
            { sv: "husnummer", en: "house numbers" },
            { sv: "l√§ngder (cm)", en: "heights (cm)" },
            { sv: "skostorlekar", en: "shoe sizes" },
            { sv: "t√§rningsslag", en: "dice rolls" },
            { sv: "√•ldrar", en: "ages" },
            { sv: "timmar s√∂mn", en: "hours of sleep" },
            { sv: "antal syskon", en: "number of siblings" }
        ];
        const s = MathUtils.randomChoice(scenarios);
        const isOdd = MathUtils.randomInt(0, 1) === 1;
        const len = isOdd ? MathUtils.randomChoice([5, 7, 9]) : MathUtils.randomChoice([4, 6, 8]);
        
        const list: number[] = [];
        for(let i=0; i<len; i++) list.push(MathUtils.randomInt(1, 20));
        
        const shuffled = [...list];
        const sorted = list.sort((a,b) => a-b);
        
        let median = 0;
        let explanation = "";

        if (isOdd) {
            const midIdx = Math.floor(len / 2);
            median = sorted[midIdx];
            explanation = lang === 'sv' 
                ? `Mittenv√§rdet i den sorterade listan √§r ${median}.` 
                : `The middle value in the sorted list is ${median}.`;
        } else {
            const mid1 = sorted[len/2 - 1];
            const mid2 = sorted[len/2];
            median = (mid1 + mid2) / 2;
            explanation = lang === 'sv'
                ? `Mitten best√•r av ${mid1} och ${mid2}. Medelv√§rdet av dem √§r ${median}.`
                : `The middle is ${mid1} and ${mid2}. The average of them is ${median}.`;
        }

        const desc = lang === 'sv'
            ? `Hitta medianen f√∂r dessa ${s.sv}: ${shuffled.sort(() => Math.random() - 0.5).join(', ')}`
            : `Find the median for these ${s.en}: ${shuffled.sort(() => Math.random() - 0.5).join(', ')}`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(median.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂rst m√•ste du sortera talen i storleksordning!" : "First you must sort the numbers in order!",
                    latex: sorted.join(', ')
                },
                { text: explanation }
            ]
        };
    }

    // --- LEVEL 4: Reverse Mean ---
    private level4_ReverseMean(lang: string): any {
        // Scaffolding: 3, 5, or 7 items
        const count = MathUtils.randomChoice([3, 5, 7]);
        
        const mean = MathUtils.randomInt(5, 15);
        const total = mean * count;
        
        // Generate n-1 known numbers
        const knownValues: number[] = [];
        let currentSum = 0;
        
        for (let i = 0; i < count - 1; i++) {
            // Generate numbers relatively close to the mean to stay realistic
            const val = MathUtils.randomInt(Math.max(1, mean - 6), mean + 6);
            knownValues.push(val);
            currentSum += val;
        }
        
        let missing = total - currentSum;

        // Ensure missing value is non-negative. If negative, adjust the last known value.
        if (missing < 0) {
            const adjustment = Math.abs(missing) + MathUtils.randomInt(1, 5);
            // Decrease last value to increase missing value
            knownValues[knownValues.length - 1] -= adjustment;
            // Prevent that value from going negative too?
            if (knownValues[knownValues.length - 1] < 0) {
                 knownValues[knownValues.length - 1] = 1; // Fallback
            }
            // Recalculate sum and missing
            currentSum = knownValues.reduce((a, b) => a + b, 0);
            missing = total - currentSum;
        }
        
        // Just in case it's still weird, simple retry logic is robust here, 
        // but the math above should handle 99% of cases.
        if (missing < 0) return this.level4_ReverseMean(lang);

        const knownStr = knownValues.join(', ');
        
        // Ordinal words for the question
        let ordinalSv = "tredje";
        let ordinalEn = "third";
        if (count === 5) { ordinalSv = "femte"; ordinalEn = "fifth"; }
        if (count === 7) { ordinalSv = "sjunde"; ordinalEn = "seventh"; }

        const desc = lang === 'sv'
            ? `Medelv√§rdet av ${count} tal √§r ${mean}. ${count-1} av talen √§r ${knownStr}. Vilket √§r det ${ordinalSv} talet?`
            : `The mean of ${count} numbers is ${mean}. ${count-1} of the numbers are ${knownStr}. What is the ${ordinalEn} number?`;

        return {
            renderData: { description: desc, answerType: 'numeric' },
            token: this.toBase64(missing.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? `R√§kna ut vad summan av alla ${count} m√•ste vara.` : `Calculate what the sum of all ${count} must be.`,
                    latex: `\\text{Sum} = ${mean} \\cdot ${count} = ${total}`
                },
                { 
                    text: lang === 'sv' ? "Dra bort de tal du vet fr√•n summan." : "Subtract the known numbers from the sum.",
                    latex: `${total} - (${knownValues.join(' + ')}) = ${missing}` 
                }
            ]
        };
    }

    // --- LEVEL 5: Frequency Table (VISUAL) ---
    private level5_FrequencyTable(lang: string): any {
        const vals = [1, 2, 3, 4, 5];
        const freqs = [
            MathUtils.randomInt(1, 3),
            MathUtils.randomInt(2, 5),
            MathUtils.randomInt(2, 5),
            MathUtils.randomInt(1, 3),
            MathUtils.randomInt(0, 2)
        ];
        
        let sumProd = 0;
        let totalCount = 0;
        const rows: any[] = [];
        
        vals.forEach((v, i) => {
            const f = freqs[i];
            if (f > 0) {
                sumProd += v * f;
                totalCount += f;
                rows.push([v, f]);
            }
        });

        // Calculate targets
        const mean = Math.round((sumProd / totalCount) * 10) / 10;
        
        const expanded: number[] = [];
        vals.forEach((v, i) => {
            for(let k=0; k<freqs[i]; k++) expanded.push(v);
        });
        const mid = Math.floor(expanded.length / 2);
        const median = expanded.length % 2 !== 0 ? expanded[mid] : (expanded[mid-1] + expanded[mid])/2;

        const isMean = MathUtils.randomInt(0, 1) === 1;
        const target = isMean ? mean : median;
        const targetName = isMean ? (lang==='sv'?'medelv√§rdet':'the mean') : (lang==='sv'?'medianen':'the median');

        const desc = lang === 'sv'
            ? `Tabellen visar resultat (V√§rde vs Antal). Ber√§kna ${targetName}.`
            : `The table shows results (Value vs Count). Calculate ${targetName}.`;

        const headers = lang === 'sv' ? ["V√§rde", "Antal"] : ["Value", "Count"];

        return {
            renderData: { 
                description: desc, 
                answerType: 'numeric',
                geometry: { 
                    type: 'frequency_table', 
                    headers: headers, 
                    rows: rows 
                }
            },
            token: this.toBase64(target.toString()),
            clues: [
                { 
                    text: isMean 
                        ? (lang==='sv' ? "Multiplicera v√§rde med antal f√∂r att f√• summan." : "Multiply value by count to get sum.")
                        : (lang==='sv' ? "Skriv ut alla talen p√• en rad: 1, 1, 2, 2, 2..." : "Write out all numbers: 1, 1, 2, 2, 2...")
                },
                {
                    latex: isMean 
                        ? `\\frac{${sumProd}}{${totalCount}}` 
                        : `\\text{Mitten} = ${target}`
                }
            ]
        };
    }

    // --- LEVEL 6: Real World Mixed ---
    private level6_RealWorldMixed(lang: string): any {
        const type = MathUtils.randomInt(1, 2);
        
        if (type === 1) {
            const desc = lang === 'sv'
                ? `L√∂ner: 20k, 21k, 22k, 20.5k, 1000k. Vilket m√•tt beskriver "vanlig l√∂n" b√§st: Medelv√§rde eller Median? (Svara med ordet)`
                : `Salaries: 20k, 21k, 22k, 20.5k, 1000k. Which measure fits best: Mean or Median? (Answer with word)`;
            
            return {
                renderData: { description: desc, answerType: 'text' },
                token: this.toBase64("Median"),
                clues: [{ text: lang === 'sv' ? "Medelv√§rdet p√•verkas mycket av det j√§ttestora talet (1000k)." : "The mean is heavily affected by the outlier (1000k)." }]
            };
        } else {
            const desc = lang === 'sv'
                ? `Talserie: 1, 1, 2, 8, 9. Ber√§kna differensen mellan Medelv√§rde och Median.`
                : `List: 1, 1, 2, 8, 9. Calculate the difference between Mean and Median.`;
            
            // Mean = 21/5 = 4.2. Median = 2. Diff = 2.2
            return {
                renderData: { description: desc, answerType: 'numeric' },
                token: this.toBase64("2.2"),
                clues: [
                    { latex: `\\text{Medel} = 21/5 = 4.2` },
                    { latex: `\\text{Median} = 2` },
                    { latex: `4.2 - 2 = 2.2` }
                ]
            };
        }
    }
}   

// FILE END: src\core\generators\StatisticsGen.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class TenPowersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_MultDivBig(lang);
            case 2: return this.level2_Concepts(lang);
            case 3: return this.level3_MixedFactors(lang);
            default: return this.level1_MultDivBig(lang);
        }
    }

    private fixFloat(n: number) { return parseFloat(n.toFixed(6)); }

    // Level 1: Mult/Div by 10, 100, 1000
    private level1_MultDivBig(lang: string): any {
        const power = MathUtils.randomChoice([10, 100, 1000]);
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const num = MathUtils.randomInt(2, 900);
        let ans = 0, latex = "";
        
        const zeros = power.toString().length - 1;
        const stepsText = lang === 'sv' ? "steg" : "steps";
        const dir = isMult 
            ? (lang === 'sv' ? "H√ñGER" : "RIGHT") 
            : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");

        if (isMult) {
            ans = num * power;
            latex = `${num} \\cdot ${power}`;
        } else {
            ans = this.fixFloat(num / power);
            latex = `${num} / ${power}`;
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna." : "Calculate.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [{ 
                text: lang === 'sv' 
                ? `Flytta kommatecknet ${zeros} ${stepsText} √•t ${dir} (l√§gg till nollor).` 
                : `Move decimal ${zeros} ${stepsText} ${dir} (add zeros).`,
                latex: "" 
            }]
        };
    }

    // Level 2: Conceptual Equivalence
    private level2_Concepts(lang: string): any {
        const scenarios = [
            // --- DECIMALS (0.1, 0.01, 0.001) ---
            { 
                op: 'mul', val: 0.1, equivOp: 'div', equivVal: 10,
                clueSv: "Att multiplicera med 0.1 √§r som att ta en tiondel av kakan. Det blir mindre, precis som n√§r man delar med 10.",
                clueEn: "Multiplying by 0.1 is like taking one tenth of a cake. It gets smaller, just like dividing by 10."
            },
            { 
                op: 'div', val: 0.1, equivOp: 'mul', equivVal: 10,
                clueSv: "Att dela med 0.1 betyder: 'Hur m√•nga sm√• 0.1-bitar f√•r plats i 1?' Det f√•r plats 10 stycken. Svaret blir stort.",
                clueEn: "Dividing by 0.1 means: 'How many small 0.1 pieces fit into 1?' It fits 10 times. The answer becomes large."
            },
            { 
                op: 'mul', val: 0.01, equivOp: 'div', equivVal: 100,
                clueSv: "Att multiplicera med 0.01 √§r som att ta en hundradel. Det √§r samma som att dela p√• 100.",
                clueEn: "Multiplying by 0.01 is like taking one hundredth. That's the same as dividing by 100."
            },
            { 
                op: 'div', val: 0.01, equivOp: 'mul', equivVal: 100,
                clueSv: "Att dela med en hundradel (0.01) g√∂r talet mycket st√∂rre. Hur m√•nga hundradelar g√•r det p√• en hel? Jo, 100.",
                clueEn: "Dividing by one hundredth (0.01) makes the number much bigger. How many hundredths fit in a whole? 100."
            },
            { 
                op: 'mul', val: 0.001, equivOp: 'div', equivVal: 1000,
                clueSv: "En tusendel √§r v√§ldigt litet. Att multiplicera med 0.001 √§r som att dela med 1000.",
                clueEn: "A thousandth is very small. Multiplying by 0.001 is like dividing by 1000."
            },
            { 
                op: 'div', val: 0.001, equivOp: 'mul', equivVal: 1000,
                clueSv: "Att dela med en tusendel betyder att vi ser hur m√•nga pyttesm√• bitar som f√•r plats. Det blir 1000 g√•nger fler.",
                clueEn: "Dividing by a thousandth means seeing how many tiny pieces fit. It becomes 1000 times more."
            },
            // --- INTEGERS (10, 100, 1000) ---
            { 
                op: 'mul', val: 10, equivOp: 'div', equivVal: 0.1,
                clueSv: "Att g√∂ra n√•got 10 g√•nger st√∂rre √§r samma som att se hur m√•nga tiondelar som ryms i det (division med 0.1).",
                clueEn: "Making something 10 times bigger is like seeing how many tenths fit inside it (dividing by 0.1)."
            },
            { 
                op: 'div', val: 10, equivOp: 'mul', equivVal: 0.1,
                clueSv: "Att dela upp i 10 h√∂gar √§r samma sak som att ta en tiondel (0.1) av h√∂gen.",
                clueEn: "Splitting into 10 piles is the same as taking one tenth (0.1) of the pile."
            },
            { 
                op: 'mul', val: 100, equivOp: 'div', equivVal: 0.01,
                clueSv: "G√•nger 100 √§r en stor √∂kning. Det √§r matematiskt samma som att dela med det lilla talet 0.01.",
                clueEn: "Times 100 is a big increase. Mathematically, it's the same as dividing by the tiny number 0.01."
            },
            { 
                op: 'div', val: 100, equivOp: 'mul', equivVal: 0.01,
                clueSv: "Att dela med 100 √§r samma som att ta en hundradel (0.01).",
                clueEn: "Dividing by 100 is the same as taking one hundredth (0.01)."
            },
             { 
                op: 'mul', val: 1000, equivOp: 'div', equivVal: 0.001,
                clueSv: "G√•nger 1000 √§r samma som att dela med en tusendel.",
                clueEn: "Times 1000 is the same as dividing by a thousandth."
            },
            { 
                op: 'div', val: 1000, equivOp: 'mul', equivVal: 0.001,
                clueSv: "Att dela med 1000 √§r samma som att ta en tusendel (0.001).",
                clueEn: "Dividing by 1000 is the same as taking one thousandth (0.001)."
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        
        let description = "";
        
        if (lang === 'sv') {
            const opStr = s.op === 'mul' ? "multiplicera med" : "dela med";
            const targetOpStr = s.equivOp === 'mul' ? "multiplicera med..." : "dela med...";
            description = `Att ${opStr} ${s.val} √§r samma sak som att ${targetOpStr}`;
        } else {
            const opStr = s.op === 'mul' ? "multiplying by" : "dividing by";
            const targetOpStr = s.equivOp === 'mul' ? "multiplying by..." : "dividing by...";
            description = `To ${opStr} ${s.val} is the same as ${targetOpStr}`;
        }

        // Fixed set of answer choices
        const choices = ["10", "100", "1000", "0.1", "0.01", "0.001"];
        const clueText = lang === 'sv' ? (s.clueSv || "") : (s.clueEn || "");

        return {
            renderData: { 
                latex: "", 
                description, 
                answerType: 'multiple_choice', 
                choices 
            },
            token: Buffer.from(s.equivVal.toString()).toString('base64'),
            clues: [
                { text: clueText, latex: "" }
            ]
        };
    }

    // Level 3: Mixed Factors (0.1...1000)
    private level3_MixedFactors(lang: string): any {
        const factor = MathUtils.randomChoice([0.1, 0.01, 0.001, 10, 100, 1000]);
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const num = MathUtils.randomFloat(2, 50, 1);
        
        let ans = 0, latex = "";
        let direction = "";
        let steps = 0;
        
        // Count decimal shift
        if (factor >= 10) steps = factor.toString().length - 1;
        else steps = factor.toString().length - 2;

        if (isMult) {
            ans = this.fixFloat(num * factor);
            latex = `${num} \\cdot ${factor}`;
            const isRight = factor >= 10;
            direction = isRight ? (lang === 'sv' ? "H√ñGER" : "RIGHT") : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");
        } else {
            ans = this.fixFloat(num / factor);
            latex = `${num} / ${factor}`;
            const isRight = factor < 1;
            direction = isRight ? (lang === 'sv' ? "H√ñGER" : "RIGHT") : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");
        }

        const clueText = lang === 'sv' 
            ? `Flytta kommatecknet ${steps} steg √•t ${direction}.` 
            : `Move decimal ${steps} steps ${direction}.`;

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna." : "Calculate.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [{ text: clueText, latex: `\\mathbf{${ans}}` }]
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class VolumeGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Cuboid(lang);
            case 2: return this.level2_TriPrism(lang);
            case 3: return this.level3_Cylinder(lang);
            case 4: return this.level4_PyramidCone(lang);
            case 5: return this.level5_SphereComposite(lang);
            case 6: return this.level6_Mixed(lang);
            case 7: return this.level7_Units(lang);
            case 8: return this.level8_SurfaceArea(lang); // New Level
            default: return this.level1_Cuboid(lang);
        }
    }

    private toBase64(str: string): string {
        return Buffer.from(str).toString('base64');
    }

    // Level 1: Rectangular Prism (Cuboid) & Cube
    private level1_Cuboid(lang: string): any {
        const w = MathUtils.randomInt(2, 10);
        const d = MathUtils.randomInt(2, 10);
        const h = MathUtils.randomInt(2, 10);
        const volume = w * d * h;

        return {
            renderData: {
                geometry: { type: 'cuboid', labels: { w, h, d } },
                description: lang === 'sv' ? "Ber√§kna volymen." : "Calculate the volume.",
                answerType: 'text',
                suffix: 'cm¬≥'
            },
            token: this.toBase64(volume.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r ett r√§tblock multiplicerar du alla tre sidorna." : "For a rectangular prism, multiply all three sides.", 
                    latex: `V = \\text{Bredd} \\cdot \\text{Djup} \\cdot \\text{H√∂jd}` 
                },
                { 
                    text: lang === 'sv' ? "S√§tt in siffrorna:" : "Insert the numbers:", 
                    latex: `V = ${w} \\cdot ${d} \\cdot ${h}` 
                }
            ]
        };
    }

    // Level 2: Triangular Prism
    private level2_TriPrism(lang: string): any {
        const b = MathUtils.randomInt(3, 8);
        const hTri = MathUtils.randomInt(2, 6);
        const length = MathUtils.randomInt(5, 12);
        const areaBase = (b * hTri) / 2;
        const volume = areaBase * length;

        return {
            renderData: {
                geometry: { type: 'triangular_prism', labels: { b, h: hTri, l: length } },
                description: lang === 'sv' ? "Ber√§kna prismats volym." : "Calculate the prism's volume.",
                answerType: 'numeric',
                suffix: 'cm¬≥'
            },
            token: this.toBase64(volume.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "1. B√∂rja med att r√§kna ut arean p√• triangeln (basytan)." : "1. Start by calculating the area of the triangle (base).", 
                    latex: `B = \\frac{${b} \\cdot ${hTri}}{2} = ${areaBase}` 
                },
                { 
                    text: lang === 'sv' ? "2. Multiplicera basytan med prismats l√§ngd." : "2. Multiply the base area by the prism's length.", 
                    latex: `V = ${areaBase} \\cdot ${length}` 
                }
            ]
        };
    }

    // Level 3: Cylinder
    private level3_Cylinder(lang: string): any {
        const r = MathUtils.randomInt(2, 6);
        const h = MathUtils.randomInt(5, 15);
        const areaBase = Math.round(Math.PI * r * r * 10) / 10;
        const volume = Math.round(Math.PI * r * r * h);

        return {
            renderData: {
                geometry: { type: 'cylinder', labels: { r, h } },
                description: lang === 'sv' ? "Ber√§kna cylinderns volym (avrunda till heltal)." : "Calculate volume (round to integer).",
                answerType: 'numeric',
                suffix: 'cm¬≥'
            },
            token: this.toBase64(volume.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "1. Ber√§kna bottenplattans area (en cirkel)." : "1. Calculate the area of the base (a circle).", 
                    latex: `A = \\pi \\cdot r^2 \\approx 3.14 \\cdot ${r}^2 \\approx ${areaBase}` 
                },
                { 
                    text: lang === 'sv' ? "2. Multiplicera bottenarean med h√∂jden." : "2. Multiply the base area by the height.", 
                    latex: `V \\approx ${areaBase} \\cdot ${h}` 
                }
            ]
        };
    }

    // Level 4: Pyramid & Cone
    private level4_PyramidCone(lang: string): any {
        const isCone = MathUtils.randomInt(0, 1) === 1;

        if (isCone) {
            const r = MathUtils.randomInt(3, 8);
            const h = MathUtils.randomInt(6, 15);
            const volume = Math.round((Math.PI * r * r * h) / 3);
            const cylinderVol = Math.round(Math.PI * r * r * h);
            
            return {
                renderData: {
                    geometry: { type: 'cone', labels: { r, h } },
                    description: lang === 'sv' ? "Ber√§kna konens volym (avrunda till heltal)." : "Calculate cone volume (round to integer).",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: this.toBase64(volume.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "T√§nk dig f√∂rst att det var en cylinder:" : "Imagine it was a cylinder first:", 
                        latex: `V_{cyl} = \\pi \\cdot ${r}^2 \\cdot ${h} \\approx ${cylinderVol}` 
                    },
                    { 
                        text: lang === 'sv' ? "Eftersom figuren √§r spetsig, dela med 3." : "Since the figure is pointy, divide by 3.", 
                        latex: `V_{kon} = \\frac{${cylinderVol}}{3}` 
                    }
                ]
            };
        } else {
            const w = MathUtils.randomInt(3, 8);
            const d = MathUtils.randomInt(3, 8); 
            const h = MathUtils.randomInt(6, 12);
            const volume = Math.round((w * d * h) / 3);
            const boxVol = w * d * h;

            return {
                renderData: {
                    geometry: { type: 'pyramid', labels: { w, d, h } }, 
                    description: lang === 'sv' ? "Ber√§kna pyramidens volym." : "Calculate pyramid volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: this.toBase64(volume.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "R√§kna ut basytan (botten)." : "Calculate the base area.", 
                        latex: `B = ${w} \\cdot ${d} = ${w * d}` 
                    },
                    { 
                        text: lang === 'sv' ? "Volymen √§r (Basen √ó H√∂jden) delat med 3." : "Volume is (Base √ó Height) divided by 3.", 
                        latex: `V = \\frac{${w*d} \\cdot ${h}}{3} = \\frac{${boxVol}}{3}` 
                    }
                ]
            };
        }
    }

    // Level 5: Sphere & Composite (Basic)
    private level5_SphereComposite(lang: string): any {
        const type = MathUtils.randomChoice(['sphere', 'silo']);

        if (type === 'sphere') {
            const r = MathUtils.randomInt(3, 9);
            const volume = Math.round((4 * Math.PI * Math.pow(r, 3)) / 3);
            return {
                renderData: {
                    geometry: { type: 'sphere', labels: { r } },
                    description: lang === 'sv' ? "Ber√§kna klotets volym." : "Calculate sphere volume.",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: this.toBase64(volume.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Formeln f√∂r ett klot √§r:" : "The formula for a sphere is:", 
                        latex: `V = \\frac{4 \\cdot \\pi \\cdot r^3}{3}` 
                    },
                    { 
                        text: lang === 'sv' ? "B√∂rja med att r√§kna ut r¬≥." : "Start by calculating r¬≥.", 
                        latex: `${r}^3 = ${r} \\cdot ${r} \\cdot ${r} = ${r*r*r}` 
                    }
                ]
            };
        }
        else { // Silo
            const r = MathUtils.randomInt(3, 6);
            const h = MathUtils.randomInt(6, 12);
            const cylVol = Math.round(Math.PI * r * r * h);
            const hemiVol = Math.round(((4 * Math.PI * Math.pow(r, 3)) / 3) / 2);
            const total = cylVol + hemiVol;

            return {
                renderData: {
                    geometry: { type: 'silo', labels: { r, h } }, 
                    description: lang === 'sv' ? "Ber√§kna silons volym (Cylinder + Halvklot)." : "Calculate silo volume (Cylinder + Hemisphere).",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "1. Ber√§kna cylinderns volym." : "1. Calculate cylinder volume.", 
                        latex: `V_{cyl} \\approx ${cylVol}` 
                    },
                    { 
                        text: lang === 'sv' ? "2. Ber√§kna halvklotets volym (Klot / 2)." : "2. Calculate hemisphere volume (Sphere / 2).", 
                        latex: `V_{halv} \\approx ${hemiVol}` 
                    },
                    { 
                        text: lang === 'sv' ? "3. Addera dem." : "3. Add them together.", 
                        latex: `${cylVol} + ${hemiVol}` 
                    }
                ]
            };
        } 
    }

    // Level 6: Mixed with DIAMETER Logic
    private level6_Mixed(lang: string): any {
        const type = MathUtils.randomChoice(['sphere', 'ice_cream']);
        const useDiameter = true; 

        let r = MathUtils.randomInt(3, 8);
        let dLabel = r * 2;
        let h = MathUtils.randomInt(8, 15); 

        if (type === 'sphere') {
            let volume = Math.round((4 * Math.PI * Math.pow(r, 3)) / 3);
            return {
                renderData: {
                    geometry: { type: 'sphere', labels: { d: dLabel }, show: 'diameter' },
                    description: lang === 'sv' ? `Ber√§kna klotets volym (d = ${dLabel}).` : `Calculate sphere volume (d = ${dLabel}).`,
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: this.toBase64(volume.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "F√∂rst m√•ste du hitta radien (h√§lften av diametern)." : "First find the radius (half the diameter).", 
                        latex: `r = \\frac{${dLabel}}{2} = ${r}` 
                    },
                    { 
                        text: lang === 'sv' ? "Anv√§nd nu volymformeln." : "Now use the volume formula.", 
                        latex: `V = \\frac{4 \\cdot \\pi \\cdot ${r}^3}{3}` 
                    }
                ]
            };
        }
        else { // Ice Cream
            const coneVol = Math.round((Math.PI * r * r * h) / 3);
            const hemiVol = Math.round(((4 * Math.PI * Math.pow(r, 3)) / 3) / 2);
            const total = coneVol + hemiVol;

            return {
                renderData: {
                    geometry: { type: 'ice_cream', labels: { d: dLabel, h }, show: 'diameter' },
                    description: lang === 'sv' ? "Ber√§kna volymen (Kon + Halvklot)." : "Calculate volume (Cone + Hemisphere).",
                    answerType: 'numeric',
                    suffix: 'cm¬≥'
                },
                token: this.toBase64(total.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Hitta radien:" : "Find radius:", 
                        latex: `r = ${r}` 
                    },
                    { 
                        text: lang === 'sv' ? "Dela upp i Kon + Halvklot." : "Split into Cone + Hemisphere.", 
                        latex: `V \\approx ${coneVol} + ${hemiVol}` 
                    }
                ]
            };
        }
    }

    // Level 7: Mixed Units Conversion
    private level7_Units(lang: string): any {
        const dim1 = MathUtils.randomInt(2, 8) * 10; // e.g., 20 cm
        const dim2 = MathUtils.randomInt(2, 8) * 10;
        const dim3 = MathUtils.randomInt(2, 8) * 10;

        const val1_dm = dim1 / 10;
        const val2_dm = dim2 / 10;
        const val3_dm = dim3 / 10;

        const volume = val1_dm * val2_dm * val3_dm; // dm¬≥ = liters

        return {
            renderData: {
                geometry: { type: 'cuboid', labels: { w: `${dim1} cm`, d: `${dim2} cm`, h: `${dim3} cm` } },
                description: lang === 'sv' 
                    ? "Hur m√•nga liter rymmer akvariet? (1 liter = 1 dm¬≥)" 
                    : "How many liters does the tank hold? (1 liter = 1 dm¬≥)",
                answerType: 'numeric',
                suffix: 'liter'
            },
            token: this.toBase64(volume.toString()),
            clues: [
                { 
                    text: lang === 'sv' ? "Eftersom vi vill ha svar i liter (dm¬≥), √§r det smartast att omvandla sidorna till dm f√∂rst." : "Since we want liters (dm¬≥), convert sides to dm first.", 
                    latex: `10 \\text{ cm} = 1 \\text{ dm}` 
                },
                { 
                    text: lang === 'sv' ? "Nya m√•tt:" : "New dimensions:", 
                    latex: `${val1_dm} \\cdot ${val2_dm} \\cdot ${val3_dm}` 
                }
            ]
        };
    }

    // --- LEVEL 8: Surface Area ---
    private level8_SurfaceArea(lang: string): any {
        const type = MathUtils.randomChoice(['cuboid', 'cylinder', 'cone', 'sphere']);

        if (type === 'cuboid') {
            const w = MathUtils.randomInt(2, 6);
            const d = MathUtils.randomInt(2, 6);
            const h = MathUtils.randomInt(2, 6);
            const area = 2 * (w*d + w*h + d*h);

            return {
                renderData: {
                    geometry: { type: 'cuboid', labels: { w, d, h } },
                    description: lang === 'sv' ? "Ber√§kna begr√§nsningsarean:" : "Calculate the total surface area:",
                    answerType: 'numeric',
                    suffix: 'cm¬≤'
                },
                token: this.toBase64(area.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Ett r√§tblock har 6 sidor (3 par). Ber√§kna arean f√∂r botten, framsida och kortsida." : "A cuboid has 6 faces (3 pairs). Calculate area for bottom, front, and side.",
                        latex: `A_{tot} = 2(wd + wh + dh)`
                    },
                    {
                        text: lang === 'sv' ? "Addera areorna och dubblera." : "Add the areas and double.",
                        latex: `2(${w}\\cdot${d} + ${w}\\cdot${h} + ${d}\\cdot${h})`
                    }
                ]
            };
        }
        else if (type === 'cylinder') {
            const r = MathUtils.randomInt(2, 5);
            const h = MathUtils.randomInt(4, 10);
            const baseArea = Math.PI * r * r;
            const mantleArea = 2 * Math.PI * r * h;
            const totalArea = Math.round(2 * baseArea + mantleArea);

            return {
                renderData: {
                    geometry: { type: 'cylinder', labels: { r, h } },
                    description: lang === 'sv' ? "Ber√§kna cylinderns begr√§nsningsyta (avrunda till heltal):" : "Calculate cylinder surface area (round to integer):",
                    answerType: 'numeric',
                    suffix: 'cm¬≤'
                },
                token: this.toBase64(totalArea.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "1. Ber√§kna arean av de tv√• cirklarna (botten och lock)." : "1. Calculate area of the two circles (base and top).", 
                        latex: `2 \\cdot \\pi r^2 \\approx ${Math.round(2*baseArea)}`
                    },
                    { 
                        text: lang === 'sv' ? "2. Ber√§kna mantelytan (sidan). Det √§r omkretsen g√•nger h√∂jden." : "2. Calculate the lateral area (mantle). It is circumference times height.", 
                        latex: `M = 2 \\pi r \\cdot h \\approx ${Math.round(mantleArea)}` 
                    },
                    {
                        text: lang === 'sv' ? "3. Addera delarna." : "3. Add the parts.",
                        latex: `${Math.round(2*baseArea)} + ${Math.round(mantleArea)}`
                    }
                ]
            };
        }
        else if (type === 'cone') {
            // Generate Pythagorean triple for clean slant height (s)
            // 3-4-5 or 5-12-13 or 6-8-10
            const triples = [{r:3, h:4, s:5}, {r:5, h:12, s:13}, {r:6, h:8, s:10}, {r:8, h:15, s:17}];
            const dims = MathUtils.randomChoice(triples);
            
            const baseArea = Math.PI * dims.r * dims.r;
            const mantleArea = Math.PI * dims.r * dims.s;
            const totalArea = Math.round(baseArea + mantleArea);

            return {
                renderData: {
                    geometry: { type: 'cone', labels: { r: dims.r, h: dims.h, s: dims.s } },
                    description: lang === 'sv' ? "Ber√§kna konens begr√§nsningsyta (avrunda till heltal):" : "Calculate cone surface area (round to integer):",
                    answerType: 'numeric',
                    suffix: 'cm¬≤'
                },
                token: this.toBase64(totalArea.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "1. Ber√§kna bottenarean (cirkel)." : "1. Calculate base area (circle).", 
                        latex: `B = \\pi r^2 \\approx ${Math.round(baseArea)}`
                    },
                    { 
                        text: lang === 'sv' ? "2. Ber√§kna mantelytan. Anv√§nd radien och sidolinjen (s)." : "2. Calculate lateral area. Use radius and slant height (s).", 
                        latex: `M = \\pi \\cdot r \\cdot s = \\pi \\cdot ${dims.r} \\cdot ${dims.s}` 
                    },
                    {
                        text: lang === 'sv' ? "3. Addera botten och mantel." : "3. Add base and mantle.",
                        latex: `A_{tot} = B + M`
                    }
                ]
            };
        }
        else { // Sphere
            const r = MathUtils.randomInt(3, 8);
            const area = Math.round(4 * Math.PI * r * r);
            
            return {
                renderData: {
                    geometry: { type: 'sphere', labels: { r } },
                    description: lang === 'sv' ? "Ber√§kna klotets area (avrunda till heltal):" : "Calculate sphere surface area (round to integer):",
                    answerType: 'numeric',
                    suffix: 'cm¬≤'
                },
                token: this.toBase64(area.toString()),
                clues: [
                    { 
                        text: lang === 'sv' ? "Formeln f√∂r klotets area √§r:" : "Formula for sphere area is:", 
                        latex: `A = 4 \\pi r^2` 
                    },
                    {
                        text: lang === 'sv' ? "S√§tt in radien och ber√§kna." : "Insert radius and calculate.",
                        latex: `4 \\cdot \\pi \\cdot ${r}^2`
                    }
                ]
            };
        }
    }
}

// FILE END: src\core\generators\VolumeGen.ts

// =======================================================
// FILE START: src\core\interfaces\Generator.ts
// =======================================================

export interface QuestionData {
    text?: string;
    renderData?: any; // Preferred
    visual?: any;     // Legacy
    answer: string | number;
    clues: string[];
}

export interface Generator {
    /**
     * Generates a new question.
     * @param level Difficulty level (1-9)
     * @param lang Language code ('sv' | 'en')
     */
    generate(level: number, lang: string): QuestionData;

    /**
     * Optional: Custom validation logic for answers.
     * @param userAnswer The user's input
     * @param systemAnswer The generated correct answer
     */
    validate?(userAnswer: string, systemAnswer: string): boolean;
}

// FILE END: src\core\interfaces\Generator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        exponents: 6,
        fraction_basics: 5,
        fraction_arith: 5,
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 6,
        volume: 8,
        graph: 5,
        similarity: 4,
        percent: 6,
        probability: 8,
        statistics: 6,
        pythagoras: 6,
        change_factor: 5,
        angles: 6,
        patterns: 5
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        // Fallback to 5 if topic not found, but we aim to list all
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export const UI_STRINGS = {
    sv: {
        // --- General UI ---
        submit: "Svara",
        next: "N√§sta fr√•ga",
        correct: "R√§tt!",
        incorrect: "Inte riktigt, f√∂rs√∂k igen",
        try_again: "F√∂rs√∂k igen",
        score: "Po√§ng",
        streak: "Svit",
        level: "Niv√•",
        loading: "Laddar...",
        error: "Fel vid laddning",
        dashboard_title: "V√§lj omr√•de att √∂va p√•",
        backBtn: "Meny",
        history: "Historik",
        noHistory: "Inga svar √§n.",
        btnHint: "Ledtr√•d",
        btnSolution: "Visa l√∂sning",
        btnSkip: "Hoppa √∂ver",
        btnNext: "N√§sta ‚û°",
        placeholder: "Skriv ditt svar...",
        hintsTitle: "Ledtr√•dar",
        clueUsed: "Hj√§lp",
        donow: "Startuppgift",
        donow_title: "Uppstart (Do Now)",
        donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
        donow_gen: "Generera",
        donow_show_all: "Visa alla",
        donow_hide_all: "D√∂lj alla",
        donow_regenerate: "Nytt Set",
        aboutBtn: "Om skaparen",
        levelUpTitle: "Niv√• upp?", 
        levelUpDesc: "Du verkar ha koll p√• detta! Vill du hoppa till n√§sta niv√•?", 
        levelUpYes: "Ja, k√∂r!", 
        levelUpNo: "Nej, stanna h√§r",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Aritmetik",
            negative: "Negativa Tal",
            simplification: "F√∂renkling",
            linear_eq: "Ekvationer",
            linear_eq_prob: "Probleml√∂sning",
            geometry: "Geometri",
            volume: "Volym & Area",
            similarity: "Likformighet",
            scale: "Skala",
            linear_graph: "R√§ta Linjen",
            ten_powers: "Tiopotenser",
            percent: "Procent",           // NEW
            exponents: "Potenser",        // NEW
            probability: "Sannolikhet",   // NEW
            statistics: "Statistik",      // NEW
            pythagoras: "Pythagoras Sats" // NEW
        },

        // --- Math Vocabulary (Common) ---
        common: {
            calculate: "Ber√§kna",
            equation: "Ekvation",
            simplify: "F√∂renkla",
            solve: "L√∂s ut x",
            evaluate: "Ber√§kna",
            find_k: "Best√§m k-v√§rdet",
            find_m: "Best√§m m-v√§rdet",
            find_equation: "Best√§m linjens ekvation",
            match_graph: "Vilken ekvation h√∂r till grafen?",
            determine_equation: "Best√§m ekvationen f√∂r linjen som g√•r genom:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Ber√§kna summan",
            sub: "Ber√§kna differensen",
            mul: "Ber√§kna produkten",
            div: "Ber√§kna kvoten",
            mixed: "Ber√§kna",
            missing_term: "Hitta det saknade talet"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Vi har ekvationen: $${eq}$`,
            multiply: (k: any) => `Multiplicera b√•da sidor med $${k}$ f√∂r att bli av med divisionen.`,
            divide: (k: any) => `Dividera b√•da sidor med $${k}$ f√∂r att f√• $x$ ensamt.`,
            add: (k: any) => `Addera $${k}$ p√• b√•da sidor.`,
            subtract: (k: any) => `Subtrahera $${k}$ p√• b√•da sidor.`,
            distribute: (k: any) => `Multiplicera in $${k}$ i parentesen.`,
            sub_var: (term: string) => `Subtrahera $${term}$ fr√•n b√•da sidor f√∂r att samla $x$ p√• en sida.`,
            collect: "Samla lika termer",
            expand: "Utveckla parentesen",
            factorise: "Faktorisera uttrycket",
            substitute: "Ers√§tt och ber√§kna"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Att addera ett negativt tal √§r samma som subtraktion.",
            sub_neg: "Tv√• minus blir plus (‚Äì ‚Äì blir +).",
            mul_neg_neg: "Minus g√•nger minus blir plus.",
            mul_pos_neg: "Plus g√•nger minus blir minus.",
            div_sign_same: "Lika tecken ger positivt svar.",
            div_sign_diff: "Olika tecken ger negativt svar.",
            simple_calc: "Ber√§kna:", 
            step_calc: "Ber√§kna:",
            plus_plus: "Positivt + Positivt",
            plus_minus: "Positivt + Negativt",
            minus_plus: "Negativt + Positivt",
            minus_minus: "Negativt - Negativt",
            mixed: "Blandat",
            multiplication: "Multiplikation",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "Best√§m m-v√§rdet (d√§r linjen sk√§r y-axeln).", en: "Find the intercept (m)." },
            q_slope: { sv: "Best√§m k-v√§rdet (lutningen).", en: "Find the slope (k)." },
            q_func: { sv: "Best√§m linjens ekvation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Titta p√• grafen: Var sk√§r linjen y-axeln (d√§r $x=0$)?",
            step_intercept: (m:any) => `Linjen sk√§r y-axeln vid $y = ${m}$.`,
            step_delta: "Lutningen $k$ √§r skillnaden i $y$ delat med skillnaden i $x$.",
            step_slope_calc: "R√§kna rutor: Hur mycket √§ndras $y$ n√§r vi g√•r 1 steg √•t h√∂ger?",
            find_m: "Hitta m-v√§rdet (sk√§rning med y-axeln).",
            find_k: "Hitta k-v√§rdet (lutningen).",
            parallel: "Best√§m lutningen f√∂r en linje som √§r parallell med:",
            perpendicular: "Best√§m lutningen f√∂r en linje som √§r vinkelr√§t mot:",
            find_gradient: "Ber√§kna lutningen (k)",
            find_intercept: "Hitta y-axelsk√§rningen (m)"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Skala",
            real: "Verklig str√§cka",
            map_dist: "Avst√•nd p√• kartan",
            ratio: "Skala",
            problem_map_to_real: "Ber√§kna det verkliga avst√•ndet.",
            problem_real_to_map: "Ber√§kna avst√•ndet p√• kartan.",
            problem_find_scale: "Best√§m kartans skala.",
            reduction: "F√∂rminskning",
            enlargement: "F√∂rstoring",
            reality: "Verkligheten",
            drawing: "Bilden",
            rule_reduction: "N√§r skalan √§r 1:X √§r bilden mindre √§n verkligheten.",
            rule_enlargement: "N√§r skalan √§r X:1 √§r bilden st√∂rre √§n verkligheten.",
            step_plug_in: "S√§tt in v√§rdena i formeln: $\\frac{\\text{Bild}}{\\text{Verklighet}}$",
            calc_cm: "R√§kna f√∂rst ut det i cm.",
            conv_m: "Omvandla till meter (1 m = 100 cm).",
            conv_same: "Se till att b√•da m√•tten har samma enhet.",
            setup_ratio: "St√§ll upp f√∂rh√•llandet Bild : Verklighet.",
            step_simplify: "F√∂renkla br√•ket.",
            calc_area_img: "Ber√§kna bildens area.",
            calc_area_real: "Ber√§kna verklighetens area.",
            calc_area_scale: "Areaskalan √§r l√§ngdskalan i kvadrat."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "L√∂s ekvationen och ber√§kna $x$.",
            task_write: "Skriv en ekvation som beskriver situationen (du beh√∂ver inte l√∂sa den).",
            clue_var: "L√•t $x$ vara det vi s√∂ker.",
            clue_total: "S√§tt uttrycket lika med totalen.",
            expl_rate_val: "Pris per styck g√•nger antal.",
            expl_fixed_val: "L√§gg till den fasta avgiften.",
            expl_item_cost: "Kostnaden f√∂r varorna innan rabatt.",
            expl_discount_sub: "Subtrahera rabatten.",
            expl_person1: "Person 1 har $x$.",
            expl_person2_more: "Person 2 har mer.",
            expl_person2_less: "Person 2 har mindre.",
            expl_compare_sum: "Summan av b√•da √§r totalen.",
            a_buy: { sv: "Du k√∂per $a$ st {item} f√∂r $x$ kr/st och en p√•se f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $a$ {item} for $x$ kr each and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "En taxiresa kostar $b$ kr i startavgift och $a$ kr per km. Resan kostar totalt $c$ kr. Hur m√•nga km ($x$) √•kte du?", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "Du k√∂per $a$ st {item} som kostar $x$ kr/st. Du har en rabattkupong p√• $b$ kr. Du betalar totalt $c$ kr.", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "{name1} och {name2} samlar p√• {item}. {name2} har $a$ fler √§n {name1}. Tillsammans har de $c$ st. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "{name1} och {name2} har $c$ {item} tillsammans. {name2} har $b$ f√§rre √§n {name1}. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Ber√§kna arean",
            perimeter: "Ber√§kna omkretsen",
            circumference: "Ber√§kna omkretsen",
            volume: "Ber√§kna volymen",
            surface_area: "Ber√§kna begr√§nsningsarean",
            similarity: "Likformighet",
            scale_factor: "Hitta skalfaktorn (k)",
            missing_side: "Ber√§kna den saknade sidan",
            shape: "Figur",
            cube: "Kub",
            cuboid: "R√§tblock",
            cylinder: "Cylinder",
            sphere: "Klot",
            cone: "Kon",
            triangle: "Triangel",
            rectangle: "Rektangel",
            circle: "Cirkel",
            parallelogram: "Parallellogram",
            trapezium: "Trapets"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplikation med tiopotenser",
            div: "Division med tiopotenser",
            standard_form: "Grundpotensform",
            prefix: "Prefix"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Ber√§kna delen",
            find_whole: "Hitta det hela",
            change: "F√∂r√§ndring",
            visual: "Andel (Bild)"
        },
        statistics: {
            mean: "Medelv√§rde",
            median: "Median",
            mode: "Typv√§rde",
            range: "Variationsbredd",
            table: "Frekvenstabell"
        },
        probability: {
            chance: "Sannolikhet",
            complement: "Komplementh√§ndelse",
            compound: "Sammansatt h√§ndelse",
            marbles: "Kulor",
            spinner: "Snurrhjul"
        },
        pythagoras: {
            theorem: "Pythagoras sats",
            hypotenuse: "Hypotenusa",
            leg: "Katet",
            distance: "Avst√•nd"
        },
        exponents: {
            power: "Potens",
            base: "Bas",
            exponent: "Exponent",
            root: "Kvadratrot",
            sci_not: "Grundpotensform",
            zero_rule: "Nollregeln"
        },

        // --- Shapes ---
        shapes: {
            square: "kvadrat",
            rectangle: "rektangel",
            circle: "cirkel",
            triangle: "triangel",
            rhombus: "romb",
            parallelogram: "parallellogram",
            pentagon: "femh√∂rning",
            hexagon: "sexh√∂rning",
            octagon: "√•ttah√∂rning",
            star: "stj√§rna",
            arrow: "pil",
            heart: "hj√§rta",
            cross: "kors",
            lightning: "blixt",
            kite: "drake",
            cube: "kub",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "kon",
            sphere: "klot"
        },
        shapes_plural: {
            rectangle: "rektanglar",
            triangle: "trianglar",
            circle: "cirklar",
            semicircle: "halvcirklar",
            parallelogram: "parallellogram"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    },

    en: {
        // --- General UI ---
        submit: "Submit Answer",
        next: "Next Question",
        correct: "Correct!",
        incorrect: "Incorrect.",
        try_again: "Try Again",
        score: "Score",
        streak: "Streak",
        level: "Level",
        loading: "Loading...",
        error: "Error loading question",
        dashboard_title: "Choose a topic to practice",
        backBtn: "Menu",
        history: "History",
        noHistory: "No answers yet.",
        btnHint: "Hint",
        btnSolution: "Show Solution",
        btnSkip: "Skip",
        btnNext: "Next ‚û°",
        placeholder: "Enter your answer...",
        hintsTitle: "Hints",
        clueUsed: "Clue",
        donow: "Do Now",
        donow_title: "Do Now Activity",
        donow_desc: "Select up to 3 levels. System generates 6 questions total.",
        donow_gen: "Generate",
        donow_show_all: "Show All",
        donow_hide_all: "Hide All",
        donow_regenerate: "New Set",
        aboutBtn: "About",
        levelUpTitle: "Level Up?", 
        levelUpDesc: "You seem to know this! Do you want to skip to the next level?", 
        levelUpYes: "Yes, let's go!", 
        levelUpNo: "No, stay here",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Arithmetic",
            negative: "Negative Numbers",
            simplification: "Simplification",
            linear_eq: "Linear Equations",
            linear_eq_prob: "Equation Problems",
            geometry: "Geometry",
            volume: "Volume & Surface Area",
            similarity: "Similarity",
            scale: "Scale & Maps",
            linear_graph: "Linear Graphs",
            ten_powers: "Powers of 10",
            percent: "Percentage",
            exponents: "Exponents & Roots",
            probability: "Probability",
            statistics: "Statistics",
            pythagoras: "Pythagoras"
        },

        // --- Math Vocabulary ---
        common: {
            calculate: "Calculate",
            equation: "Equation",
            simplify: "Simplify",
            solve: "Solve for x",
            evaluate: "Evaluate",
            find_k: "Find the gradient (k)",
            find_m: "Find the y-intercept (m)",
            find_equation: "Find the equation of the line",
            match_graph: "Which equation matches the graph?",
            determine_equation: "Determine the equation of the line passing through:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Calculate the sum",
            sub: "Calculate the difference",
            mul: "Calculate the product",
            div: "Calculate the quotient",
            mixed: "Evaluate the expression",
            missing_term: "Find the missing number"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Equation: $${eq}$`,
            multiply: (k: any) => `Multiply both sides by $${k}$ to remove the division.`,
            divide: (k: any) => `Divide both sides by $${k}$ to isolate $x$.`,
            add: (k: any) => `Add $${k}$ to both sides.`,
            subtract: (k: any) => `Subtract $${k}$ from both sides.`,
            distribute: (k: any) => `Distribute $${k}$ into the parentheses.`,
            sub_var: (term: string) => `Subtract $${term}$ from both sides to collect $x$ on one side.`,
            collect: "Collect like terms",
            expand: "Expand the brackets",
            factorise: "Factorise the expression",
            substitute: "Substitute and evaluate"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Adding a negative number is the same as subtraction.",
            sub_neg: "Subtracting a negative number is the same as addition (‚Äì ‚Äì becomes +).",
            mul_neg_neg: "Negative times negative becomes positive.",
            mul_pos_neg: "Positive times negative becomes negative.",
            div_sign_same: "Same signs give a positive result.",
            div_sign_diff: "Different signs give a negative result.",
            simple_calc: "Calculate:",
            step_calc: "Calculate:",
            plus_plus: "Positive + Positive",
            plus_minus: "Positive + Negative",
            minus_plus: "Negative + Positive",
            minus_minus: "Negative - Negative",
            mixed: "Mixed",
            multiplication: "Multiplication",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "", en: "Find the intercept (m)." },
            q_slope: { sv: "", en: "Find the slope (k)." },
            q_func: { sv: "", en: "Find the line equation ($y = kx + m$)."},
            look_x0: "Look at the graph: Where does the line cross the y-axis (where $x=0$)?",
            step_intercept: (m:any) => `The line crosses the y-axis at $y = ${m}$.`,
            step_delta: "The slope $k$ is the change in $y$ divided by the change in $x$.",
            step_slope_calc: "Count squares: How much does $y$ change when we go 1 step to the right?",
            find_m: "Find the m-value (y-intercept).",
            find_k: "Find the k-value (slope).",
            parallel: "Find the slope of a line parallel to:",
            perpendicular: "Find the slope of a line perpendicular to:",
            find_gradient: "Calculate the gradient",
            find_intercept: "Find the intercept"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Map Scale",
            real: "Real Distance",
            map_dist: "Map Distance",
            ratio: "Ratio",
            problem_map_to_real: "Calculate the real world distance.",
            problem_real_to_map: "Calculate the distance on the map.",
            problem_find_scale: "Determine the scale of the map.",
            reduction: "Reduction",
            enlargement: "Enlargement",
            reality: "Reality",
            drawing: "Drawing",
            rule_reduction: "When the scale is 1:X, the image is smaller than reality.",
            rule_enlargement: "When the scale is X:1, the image is larger than reality.",
            step_plug_in: "Insert the values into the formula: $\\frac{\\text{Image}}{\\text{Reality}}$",
            calc_cm: "Calculate it in cm first.",
            conv_m: "Convert to meters (1 m = 100 cm).",
            conv_same: "Ensure both measurements have the same unit.",
            setup_ratio: "Set up the ratio Image : Reality.",
            step_simplify: "Simplify the fraction.",
            calc_area_img: "Calculate the area of the image.",
            calc_area_real: "Calculate the area of reality.",
            calc_area_scale: "The area scale is the length scale squared."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "Solve the equation and calculate $x$.",
            task_write: "Write an equation that describes the situation (you don't need to solve it).",
            clue_var: "Let $x$ be what we are looking for.",
            clue_total: "Set the expression equal to the total.",
            expl_rate_val: "Price per item times quantity.",
            expl_fixed_val: "Add the fixed fee.",
            expl_item_cost: "The cost of items before discount.",
            expl_discount_sub: "Subtract the discount.",
            expl_person1: "Person 1 has $x$.",
            expl_person2_more: "Person 2 has more.",
            expl_person2_less: "Person 2 has less.",
            expl_compare_sum: "The sum of both is the total.",
            a_buy: { sv: "", en: "You buy $a$ {item} for $x$ kr/st and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Calculate the Area",
            perimeter: "Calculate the Perimeter",
            circumference: "Calculate the Circumference",
            volume: "Calculate the Volume",
            surface_area: "Calculate the Surface Area",
            similarity: "Similarity",
            scale_factor: "Find the Scale Factor",
            missing_side: "Find the missing side length",
            shape: "Shape",
            cube: "Cube",
            cuboid: "Rectangular Prism",
            cylinder: "Cylinder",
            sphere: "Sphere",
            cone: "Cone",
            triangle: "Triangle",
            rectangle: "Rectangle",
            circle: "Circle",
            parallelogram: "Parallelogram",
            trapezium: "Trapezium"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplication by powers of 10",
            div: "Division by powers of 10",
            standard_form: "Standard Form (Scientific Notation)",
            prefix: "Unit Prefixes"
        },

        // --- Percent & Statistics (NEW) ---
        percent: {
            find_part: "Calculate Part",
            find_whole: "Find Whole",
            change: "Change",
            visual: "Proportion (Visual)"
        },
        statistics: {
            mean: "Mean",
            median: "Median",
            mode: "Mode",
            range: "Range",
            table: "Frequency Table"
        },
        probability: {
            chance: "Probability",
            complement: "Complementary Event",
            compound: "Compound Event",
            marbles: "Marbles",
            spinner: "Spinner"
        },
        pythagoras: {
            theorem: "Pythagorean Theorem",
            hypotenuse: "Hypotenuse",
            leg: "Leg",
            distance: "Distance"
        },
        exponents: {
            power: "Power",
            base: "Base",
            exponent: "Exponent",
            root: "Square Root",
            sci_not: "Scientific Notation",
            zero_rule: "Zero Rule"
        },

        // --- Shapes ---
        shapes: {
            square: "square",
            rectangle: "rectangle",
            circle: "circle",
            triangle: "triangle",
            rhombus: "rhombus",
            parallelogram: "parallelogram",
            pentagon: "pentagon",
            hexagon: "hexagon",
            octagon: "octagon",
            star: "star",
            arrow: "arrow",
            heart: "heart",
            cross: "cross",
            lightning: "lightning",
            kite: "kite",
            cube: "cube",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "cone",
            sphere: "sphere"
        },
        shapes_plural: {
            rectangle: "rectangles",
            triangle: "triangles",
            circle: "circles",
            semicircle: "semicircles",
            parallelogram: "parallelograms"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    }
};

export const TERMS = UI_STRINGS;

// Helper to handle both string and object keys safely
export function t(lang: Language, keyOrObj: string | { sv: string, en: string }): string {
    const l = (lang === 'en') ? 'en' : 'sv';
    
    // Check if input is a localized object {sv:..., en:...}
    if (typeof keyOrObj === 'object' && keyOrObj !== null) {
        // @ts-ignore
        return keyOrObj[l] || keyOrObj['sv'] || "";
    }
    
    // Check if input is a dot-notation string "geometry.area"
    if (typeof keyOrObj === 'string') {
        if (keyOrObj.includes('.')) {
            const keys = keyOrObj.split('.');
            let value: any = UI_STRINGS[l];
            for (const k of keys) {
                if (value && value[k]) {
                    value = value[k];
                } else {
                    return keyOrObj; // Return key if missing
                }
            }
            return typeof value === 'string' ? value : keyOrObj;
        }
        
        // Direct key lookup in UI root
        // @ts-ignore
        return UI_STRINGS[l][keyOrObj] || keyOrObj;
    }
    
    return String(keyOrObj);
}

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\MathUtils.ts
// =======================================================

export class MathUtils {
    static randomInt(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static randomFloat(min: number, max: number, decimals: number = 1): number {
        const val = Math.random() * (max - min) + min;
        return Number(val.toFixed(decimals));
    }

    static randomChoice<T>(arr: T[]): T {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    static gcd(a: number, b: number): number {
        return b === 0 ? a : MathUtils.gcd(b, a % b);
    }

    // FIX: This method is required by PythagorasGen and others
    static shuffle<T>(array: T[]): T[] {
        const arr = [...array]; // Create a copy to avoid mutating original
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }
}

// FILE END: src\core\utils\MathUtils.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: src\index.css
// =======================================================

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
  -webkit-font-smoothing: antialiased;
  @apply bg-gray-50 text-gray-800;
}

/* Legacy Animations */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Custom Scrollbar from Legacy Code */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Print Styles for Do Now Grid */
.print-break-inside-avoid {
  break-inside: avoid;
}

/* Katex Adjustments */
.katex {
  font-size: 1.1em;
}

// FILE END: src\index.css

// =======================================================
// FILE START: src\main.jsx
// =======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// FILE END: src\main.jsx

// =======================================================
// FILE START: tailwind.config.js
// =======================================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Legacy Color Palette
        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
      },
      fontFamily: { 
        sans: ['Inter', 'sans-serif'] 
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      }
    },
  },
  plugins: [],
}

// FILE END: tailwind.config.js

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    
    "strict": false,               
    "noImplicitAny": false,        
    "strictNullChecks": false,     
    "suppressImplicitAnyIndexErrors": true, 
    
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["src", "api"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/$1" },
    { "source": "/(.*)", "destination": "/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json

// =======================================================
// FILE START: vite.config.js
// =======================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@core': path.resolve(__dirname, './src/core'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  }
})

// FILE END: vite.config.js
