PROJECT EXPORT GENERATED AT 2026-01-29T09:10:41.949Z

--- FILE STRUCTURE ---
.vercel\project.json
api\answer.ts
api\batch.ts
api\curriculum.ts
api\debug.ts
api\question.ts
backup_UI.html
bundle_project.ts
create_context.js
dev-server.ts
index.html
package-lock.json
package.json
postcss.config.js
src\App.jsx
src\components\modals\AboutModal.jsx
src\components\modals\LevelUpModal.jsx
src\components\modals\LgrModal.jsx
src\components\modals\StatsModal.jsx
src\components\modals\StreakModal.jsx
src\components\practice\CluePanel.jsx
src\components\practice\HistoryList.jsx
src\components\practice\MobileDrawer.jsx
src\components\ui\Button.jsx
src\components\ui\MathText.jsx
src\components\views\Dashboard.jsx
src\components\views\DoNowConfig.jsx
src\components\views\DoNowGrid.jsx
src\components\views\PracticeView.jsx
src\components\visuals\GeometryComponents.jsx
src\components\visuals\GeometryVisual.jsx
src\components\visuals\GraphCanvas.jsx
src\components\visuals\SimpleTextLevel.jsx
src\components\visuals\VolumeVisualization.jsx
src\constants\curriculum.js
src\constants\localization.js
src\core\generators\BasicArithmeticGen.ts
src\core\generators\ExpressionSimplificationGen.ts
src\core\generators\GeometryGenerator.ts
src\core\generators\LinearEquationGen.ts
src\core\generators\LinearEquationProblemGen.ts
src\core\generators\LinearGraphGenerator.ts
src\core\generators\NegativeNumbersGen.ts
src\core\generators\ScaleGen.ts
src\core\generators\SimilarityGen.ts
src\core\generators\TenPowersGen.ts
src\core\generators\VolumeGen.ts
src\core\interfaces\Generator.ts
src\core\rules\ProgressionRules.ts
src\core\types\generator.ts
src\core\utils\i18n.ts
src\core\utils\MathUtils.ts
src\core\utils\random.ts
src\core\utils\security.ts
src\core\utils\textEngine.ts
src\index.css
src\main.jsx
tailwind.config.js
tsconfig.json
vercel.json
vite.config.js

==================================================


// =======================================================
// FILE START: .vercel\project.json
// =======================================================

{"projectId":"prj_bAZRO01XQ7DU9a8O2vZDClzTSTHd","orgId":"team_HTxUb7ZViM2LYhSuJ6qkKEDI","projectName":"anpassa-math-platform"}

// FILE END: .vercel\project.json

// =======================================================
// FILE START: api\answer.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: "Method not allowed. Use POST." });
    }

    try {
        const { answer, token, streak = 0 } = req.body;

        if (!token) {
            return res.status(400).json({ error: "Missing token" });
        }

        // 1. Decode the correct answer from the Base64 token
        const correctAnswer = Buffer.from(token, 'base64').toString('utf-8');

        // 2. Normalize inputs for comparison
        // We remove spaces and convert to lowercase to be forgiving
        // e.g. "x + 5" should match "x+5"
        const normalize = (str: any) => String(str).toLowerCase().replace(/\s+/g, '').replace(',', '.');
        
        const userClean = normalize(answer);
        const correctClean = normalize(correctAnswer);

        const isCorrect = userClean === correctClean;

        let newStreak = streak;
        let levelUp = false;

        // 3. Update Streak Logic
        if (isCorrect) {
            newStreak++;
            // Propose level up every 8 correct answers
            if (newStreak > 0 && newStreak % 8 === 0) {
                levelUp = true;
            }
        } else {
            newStreak = 0;
        }

        return res.status(200).json({
            correct: isCorrect,
            correctAnswer, // Send back correct answer so UI can display it if wrong
            newStreak,
            levelUp
        });

    } catch (error) {
        console.error("Answer Validation Error:", error);
        return res.status(500).json({ error: "Validation failed." });
    }
}

// FILE END: api\answer.ts

// =======================================================
// FILE START: api\batch.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
// Static imports ensure code is bundled into the function
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';

// Helper to instantiate
const getGenerator = (topic: string) => {
    switch (topic) {
        case 'equation': return new LinearEquationGen();
        case 'simplify': return new ExpressionSimplificationGen();
        case 'geometry': return new GeometryGenerator();
        case 'scale': return new ScaleGen();
        case 'volume': return new VolumeGen();
        case 'similarity': return new SimilarityGen();
        case 'arithmetic': return new BasicArithmeticGen();
        case 'negative': return new NegativeNumbersGen();
        case 'ten_powers': return new TenPowersGen();
        case 'graph': return new LinearGraphGenerator();
        default: return null;
    }
};

export default function handler(req: VercelRequest, res: VercelResponse) {
    // CORS Headers
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') return res.status(200).end();
    if (req.method !== 'POST') return res.status(405).json({ error: "Method not allowed" });

    try {
        let body = req.body;
        if (typeof body === 'string') {
            try { body = JSON.parse(body); } catch (e) {}
        }

        const config = body?.config; 
        const lang = body?.lang || 'sv';

        if (!config || !Array.isArray(config)) {
            return res.status(400).json({ error: "Invalid config format." });
        }

        const results = [];

        for (const item of config) {
            const { topic, level } = item;
            const generator = getGenerator(topic);

            if (generator) {
                try {
                    const questionData = generator.generate(parseInt(level), lang);
                    
                    let displayAnswer = "";
                    try {
                        const rawAnswer = Buffer.from(questionData.token, 'base64').toString('utf-8');
                        displayAnswer = rawAnswer;
                    } catch (e) { displayAnswer = "Error"; }

                    results.push({ ...questionData, topic, level, displayAnswer });
                } catch (genError) {
                    console.error(`Error generating ${topic}:`, genError);
                    results.push({ renderData: { description: "Error generating question" }, displayAnswer: "Err", topic, level });
                }
            } else {
                results.push({
                    renderData: { description: `Generator not found: ${topic}`, latex: topic, answerType: 'text' },
                    displayAnswer: "-", topic, level
                });
            }
        }

        return res.status(200).json({ questions: results });

    } catch (error) {
        console.error("Batch Fatal Error:", error);
        return res.status(500).json({ error: "Batch process failed", details: String(error) });
    }
}

// FILE END: api\batch.ts

// =======================================================
// FILE START: api\curriculum.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';

export default function handler(req: VercelRequest, res: VercelResponse) {
  // CORS Headers
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  // Data derived directly from Lgr22 Kursplan i Matematik (√Örskurs 7-9)
  const curriculumData = {
    title: "Koppling till Lgr22",
    description: "Anpassa √§r utformad f√∂r att direkt st√∂dja undervisningen enligt Skolverkets l√§roplan (Lgr22) f√∂r √•rskurs 7-9.",
    
    // Syfte (Purpose) from Lgr22
    syfte: [
      "F√∂rm√•ga att anv√§nda och analysera matematiska begrepp och samband mellan begrepp.",
      "F√∂rm√•ga att v√§lja och anv√§nda l√§mpliga matematiska metoder f√∂r att g√∂ra ber√§kningar och l√∂sa rutinuppgifter.",
      "F√∂rm√•ga att formulera och l√∂sa problem med hj√§lp av matematik samt v√§rdera valda strategier och metoder.",
      "F√∂rm√•ga att f√∂ra och f√∂lja matematiska resonemang."
    ],

    // Mapping modules to "Centralt Inneh√•ll" (Core Content)
    mapping: {
      taluppfattning: {
        category: "Taluppfattning och tals anv√§ndning",
        modules: ["arithmetic", "negative"],
        content: [
          "Reella tal och deras egenskaper samt deras anv√§ndning i vardagliga och matematiska situationer.",
          "Centrala metoder f√∂r ber√§kningar med tal i br√•k- och decimalform vid √∂verslagsr√§kning, huvudr√§kning samt vid ber√§kningar med skriftliga metoder.",
          "Tal i potensform. Grundpotensform."
        ]
      },
      algebra: {
        category: "Algebra",
        modules: ["equation", "simplify"],
        content: [
          "Inneb√∂rden av variabelbegreppet och dess anv√§ndning i algebraiska uttryck, formler och ekvationer.",
          "Algebraiska uttryck, formler och ekvationer i situationer som √§r relevanta f√∂r eleven.",
          "Metoder f√∂r ekvationsl√∂sning."
        ]
      },
      geometri: {
        category: "Geometri",
        modules: ["geometry", "scale", "volume"],
        content: [
          "Geometriska objekt och deras egenskaper.",
          "Avbildning och konstruktion av geometriska objekt, s√•v√§l med som utan digitala verktyg. Skala och dess anv√§ndning i vardagliga situationer.",
          "Metoder f√∂r ber√§kning av area, omkrets och volym hos geometriska objekt, samt enhetsbyten i samband med detta."
        ]
      },
      samband: {
        category: "Samband och f√∂r√§ndring",
        modules: ["graph"],
        content: [
          "Proportionalitet och linj√§ra samband samt hur de kan beskrivas med tabeller, grafer, ekvationer och ord.",
          "R√§ta linjens ekvation."
        ]
      },
      problem: {
        category: "Probleml√∂sning",
        modules: ["equation"], // Specifically word problems in equations
        content: [
          "Strategier f√∂r probleml√∂sning i vardagliga situationer och inom olika √§mnesomr√•den.",
          "V√§rdering av valda strategier och metoder."
        ]
      }
    }
  };

  return res.status(200).json(curriculumData);
}

// FILE END: api\curriculum.ts

// =======================================================
// FILE START: api\debug.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import fs from 'fs';
import path from 'path';

export default function handler(req: VercelRequest, res: VercelResponse) {
    try {
        // Look for the generators folder relative to this executing function
        const generatorsPath = path.join(process.cwd(), 'src/core/generators');
        
        let files: string[] = [];
        if (fs.existsSync(generatorsPath)) {
            files = fs.readdirSync(generatorsPath);
        } else {
            files = ["Generators folder not found at: " + generatorsPath];
        }

        res.status(200).json({
            status: "Debug Online",
            cwd: process.cwd(),
            foundFiles: files
        });
    } catch (error) {
        res.status(500).json({ error: String(error) });
    }
}

// FILE END: api\debug.ts

// =======================================================
// FILE START: api\question.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
// Static imports with .js extension for TS resolution
import { LinearEquationGen } from '../src/core/generators/LinearEquationGen.js';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator.js';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen.js';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen.js';
import { TenPowersGen } from '../src/core/generators/TenPowersGen.js';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen.js';
import { ScaleGen } from '../src/core/generators/ScaleGen.js';
import { VolumeGen } from '../src/core/generators/VolumeGen.js';
import { SimilarityGen } from '../src/core/generators/SimilarityGen.js';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator.js';

export default function handler(req: VercelRequest, res: VercelResponse) {
    const { topic, level, lang } = req.query;

    if (!topic || !level) {
        return res.status(400).json({ error: "Missing topic or level" });
    }

    const levelNum = parseInt(level as string);
    const language = (lang as string) || 'sv';

    try {
        let generator;

        switch (topic) {
            case 'equation': generator = new LinearEquationGen(); break;
            case 'simplify': generator = new ExpressionSimplificationGen(); break;
            case 'geometry': generator = new GeometryGenerator(); break;
            case 'scale': generator = new ScaleGen(); break;
            case 'volume': generator = new VolumeGen(); break;
            case 'similarity': generator = new SimilarityGen(); break;
            case 'arithmetic': generator = new BasicArithmeticGen(); break;
            case 'negative': generator = new NegativeNumbersGen(); break;
            case 'ten_powers': generator = new TenPowersGen(); break;
            case 'graph': generator = new LinearGraphGenerator(); break;
            default:
                return res.status(404).json({ error: `Generator for topic '${topic}' not found.` });
        }

        if (generator) {
            const questionData = generator.generate(levelNum, language);
            const response = { ...questionData, topic, level: levelNum };
            return res.status(200).json(response);
        }

    } catch (error) {
        console.error("Generator Load Error:", error);
        return res.status(500).json({ error: "Failed to load generator.", details: String(error) });
    }
}

// FILE END: api\question.ts

// =======================================================
// FILE START: backup_UI.html
// =======================================================

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
        
        /* Scrollbar hiding for timer selector */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"", // Removed text
                loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Meny",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt",
                
                timer_title: "√ñvningstimer",
                timer_off: "Av",
                timer_min: "min",
                timer_reset: "√Öterst√§ll",
                timer_paused: "Pausad",
                
                stats_title: "Statistik",
                stats_times_up: "Tiden √§r ute!",
                stats_longest_streak: "L√§ngsta streak",
                stats_attempted: "F√∂rs√∂kta fr√•gor",
                stats_correct_no_help: "R√§tt (utan hj√§lp)",
                stats_correct_help: "R√§tt (med hj√§lp)",
                stats_incorrect: "Fel",
                stats_skipped: "Hoppade √∂ver",
                stats_close: "St√§ng"
            },
            en:{
                streak:"", // Removed text
                loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue",
                
                timer_title: "Practice Timer",
                timer_off: "Off",
                timer_min: "min",
                timer_reset: "Reset",
                timer_paused: "Paused",
                
                stats_title: "Statistics",
                stats_times_up: "Time's up!",
                stats_longest_streak: "Longest streak",
                stats_attempted: "Problems attempted",
                stats_correct_no_help: "Correct (no help)",
                stats_correct_help: "Correct (with help)",
                stats_incorrect: "Incorrect",
                stats_skipped: "Skipped",
                stats_close: "Close"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) { return<span key={index}>{part}</span>; }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        const StaticGeometryVisual=({description})=>{if(!description)return null;const d=description.toLowerCase();if(d.includes("rect")||d.includes("rektangel"))return<div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>;return null;};

        // --- COMPONENTS ---
        // ADDED: Dashboard component defined BEFORE App
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- SUB-COMPONENTS (LIFTED OUT) ---
        // Pass ui as prop to all of them
        
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };
        
        // NEW STATS MODAL 
        const StatsModal = ({ visible, stats, ui, onClose, title }) => {
            if (!visible) return null;
            const attemptCount = stats.attempted || 0;
            const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;
            
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-8 relative animate-bounce-in border-4 border-blue-500 text-center">
                        <h3 className="text-2xl font-bold text-gray-900 mb-4">{title || ui.stats_title}</h3>
                        <div className="grid grid-cols-2 gap-4 text-left text-sm mb-6">
                            <div className="text-gray-500">{ui.stats_longest_streak}</div>
                            <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                            <div className="text-gray-500">{ui.stats_attempted}</div>
                            <div className="font-bold text-right">{stats.attempted}</div>
                            <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                            <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_correct_help}</div>
                            <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                            <div className="text-gray-500">{ui.stats_incorrect}</div>
                            <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                            <div className="text-gray-500">{ui.stats_skipped}</div>
                            <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.stats_close}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        const HistoryList=({history, ui})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);

        const MobileDrawer=({open, onClose, history, ui})=>(<>{open&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={onClose} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={history} ui={ui}/></div></div></>);

        const CluePanel=({revealedClues, question, ui, isSolutionRevealed})=>{
            if(!revealedClues || revealedClues.length===0) return null;
            return(
                <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                    <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                        <span>üí° {ui.hintsTitle} ({revealedClues.length}/{question.clues.length})</span>
                    </div>
                    <div className="space-y-6">
                        {revealedClues.map((clue,i)=>{
                            const isLast = i === question.clues.length - 1;
                            const showLatex = !isLast || isSolutionRevealed;
                            return (
                                <div key={i} className="group animate-slide-down">
                                    <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                        <MathText text={clue.text}/>
                                    </div>
                                    {clue.latex && showLatex && (
                                        <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                            <MathText text={`$${clue.latex}$`} large={true}/>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- PRACTICE VIEW (MOVED OUTSIDE APP) ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    // Important: Don't setInput(combined) here because 'input' is controlled by App. 
                    // Instead just pass it. But we need to update the UI too? 
                    // Actually, 'input' prop is for the single text box.
                    // For scale, we use local state scaleInputLeft/Right which is fine.
                    // We just pass combined to handleSubmit.
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Re-defined HistoryList here to ensure scope access or pass as prop? 
            // Better to use the one defined above.
            
            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={uiState.history} ui={ui}/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} 
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                    </div>
                    <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                        <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                        <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui}/></div>
                    </div>
                </div>
            );
        };

        // --- APP CONTROLLER ---
        function App(){
            const[view,setView]=useState('dashboard');
            const[lang,setLang]=useState('sv');
            const[topic,setTopic]=useState('');
            const[level,setLevel]=useState(0);
            
            const[question,setQuestion]=useState(null);
            const[input,setInput]=useState('');
            const[feedback,setFeedback]=useState(null);
            const[loading,setLoading]=useState(false);
            
            // Session Stats
            const[streak,setStreak]=useState(0);
            const[totalCorrect, setTotalCorrect] = useState(0); 
            const[sessionStats, setSessionStats] = useState({
                attempted: 0,
                correctNoHelp: 0,
                correctHelp: 0,
                incorrect: 0,
                skipped: 0,
                maxStreak: 0
            });

            const[history,setHistory]=useState([]);
            const[revealedClues,setRevealedClues]=useState([]); // Fixed type to array
            const[levelUpAvailable,setLevelUpAvailable]=useState(false);
            const[aboutOpen,setAboutOpen]=useState(false);
            const[statsOpen, setStatsOpen] = useState(false);
            const[timeUpOpen, setTimeUpOpen] = useState(false);

            // Modals State
            const[showStreakModal, setShowStreakModal] = useState(false);
            const[showTotalModal, setShowTotalModal] = useState(false);
            
            const[usedHelp, setUsedHelp] = useState(false);
            const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);
            const[mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            
            // Timer State
            const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

            const ui=UI_TEXT[lang];

            // Timer Logic
            useEffect(() => {
                let interval = null;
                if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
                    interval = setInterval(() => {
                        setTimerSettings(prev => {
                            if (prev.remaining <= 1) {
                                clearInterval(interval);
                                setTimeUpOpen(true);
                                return { ...prev, remaining: 0, isActive: false };
                            }
                            return { ...prev, remaining: prev.remaining - 1 };
                        });
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [timerSettings.isActive, view, timerSettings.remaining]);

            const toggleTimer = (minutes) => {
                const seconds = minutes * 60;
                setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
            };
            
            const resetTimer = () => {
                setTimerSettings({ duration: 0, remaining: 0, isActive: false });
            };

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            useEffect(() => {
                if (streak > sessionStats.maxStreak) {
                    setSessionStats(prev => ({...prev, maxStreak: streak}));
                }
            }, [streak]);

            const fetchQuestion=async(t=topic,l=level,lg=lang)=>{
                if (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen) return;
                if(!t||!l)return;
                setLoading(true);
                setFeedback(null);
                setInput('');
                setRevealedClues([]); // Fixed reset
                setUsedHelp(false);
                setIsSolutionRevealed(false);
                setLevelUpAvailable(false);
                try{
                    const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
                    const data=await res.json();
                    if(data.error)throw new Error(data.error);
                    setQuestion(data);
                }catch(e){
                    console.error(e);
                    setQuestion(null);
                }finally{
                    setLoading(false);
                }
            };

            const startPractice=()=>{
                if(topic&&level){
                    setStreak(0);
                    setView('practice');
                    if (timerSettings.duration > 0) {
                        setTimerSettings(prev => ({ ...prev, isActive: true }));
                    }
                    fetchQuestion(topic,level,lang);
                }
            };

            const quitPractice=()=>{
                setStreak(0);
                setView('dashboard');
                setQuestion(null);
            };

            const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};
            const handleHint=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    // Add next clue to revealed list
                    const currentLen = revealedClues.length;
                    if(currentLen < question.clues.length) {
                         setRevealedClues([...revealedClues, question.clues[currentLen]]);
                    }
                }
            };
            const handleSolution=()=>{
                if(question?.clues){
                    setUsedHelp(true);
                    setRevealedClues(question.clues); // Reveal all
                    setIsSolutionRevealed(true);
                    setStreak(0);
                }
            };
            
            const updateStats = (type) => { 
                setSessionStats(prev => ({
                    ...prev,
                    attempted: prev.attempted + 1,
                    [type]: prev[type] + 1
                }));
            };

            const handleSkip=()=>{
                const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues.length>0||isSolutionRevealed,time:Date.now()},...prev]);
                setStreak(0);
                updateStats('skipped');
                fetchQuestion(topic,level,lang);
            };

            const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};

            const handleSubmit=async(e,directInput)=>{
                e.preventDefault();
                if (showStreakModal || showTotalModal || timeUpOpen) return;

                // Handle composite scale input if needed
                let finalInput = directInput !== undefined ? directInput : input;
                // NOTE: Scale input logic handled in PracticeView, it calls this with combined string

                if(!question||!finalInput)return;
                
                const helpUsed=revealedClues.length>0||isSolutionRevealed;
                
                try{
                    const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:finalInput,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});
                    const result=await res.json();
                    const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;
                    
                    if(result.correct){
                        setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);
                        setFeedback('correct');
                        setStreak(result.newStreak);
                        
                        if (!helpUsed) updateStats('correctNoHelp');
                        else updateStats('correctHelp');
                        
                        if (!isSolutionRevealed) {
                            const newTotal = totalCorrect + 1;
                            setTotalCorrect(newTotal);
                            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                                setShowTotalModal(true);
                            }
                        }

                        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
                            setShowStreakModal(true);
                        } else {
                             if(result.levelUp) setLevelUpAvailable(true);
                             setTimeout(()=>{
                                 if (!showTotalModal && !showStreakModal) {
                                    if(!result.levelUp) fetchQuestion(topic,level,lang);
                                 }
                             },1500);
                        }
                    
                    } else {
                        // Incorrect
                        question.attempts=(question.attempts||0)+1; // Local mutation for immediate feedback loop
                        if(result.action==='next_clue'){
                            handleHint();
                        } else if(result.action==='show_solution'){
                            handleSolution();
                            updateStats('incorrect');
                            setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);
                        }
                        setFeedback('incorrect');
                        setStreak(0);
                    }
                } catch(e){console.error(e);}
            };

            const closeStreakModal = () => {
                setShowStreakModal(false);
                if (!showTotalModal && !timeUpOpen && !levelUpAvailable) {
                    fetchQuestion(topic, level, lang);
                }
            };

            const closeTotalModal = () => {
                setShowTotalModal(false);
                if (!showStreakModal && !timeUpOpen && !levelUpAvailable && feedback === 'correct') {
                     fetchQuestion(topic, level, lang);
                }
            };
            
            const closeTimeUp = () => {
                setTimeUpOpen(false);
            };

            return(
                <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
                    <AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/>
                    <StatsModal visible={statsOpen} stats={sessionStats} ui={ui} onClose={()=>setStatsOpen(false)} title={ui.stats_title} />
                    <StatsModal visible={timeUpOpen} stats={sessionStats} ui={ui} onClose={closeTimeUp} title={ui.stats_times_up} />
                    
                    <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                        <div className="max-w-7xl mx-auto flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                                {view === 'dashboard' && timerSettings.remaining > 0 && (
                                    <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                        <span>‚è∏ {ui.timer_paused}</span>
                                        <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                                    </div>
                                )}
                            </div>
                            <div className="flex items-center gap-3">
                                {totalCorrect > 0 && <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>}
                                {streak > 0 && <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>}
                                <button onClick={()=>setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                                </button>
                                <button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                            </div>
                        </div>
                    </header>
                    
                    <div className="flex-1 flex flex-col">
                        {view==='dashboard'?(
                            <div className="w-full">
                                <Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>
                                <div className="max-w-md mx-auto px-4 mb-8">
                                    <div className="bg-white rounded-xl p-4 shadow-sm border border-gray-100 flex items-center justify-between">
                                        <span className="font-bold text-gray-700 text-sm">{ui.timer_title}</span>
                                        <div className="flex items-center gap-3">
                                            <div className="relative group">
                                                <select 
                                                    value={timerSettings.duration / 60} 
                                                    onChange={(e) => toggleTimer(Number(e.target.value))}
                                                    className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-primary-500 cursor-pointer"
                                                >
                                                    <option value="0">{ui.timer_off}</option>
                                                    {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                                </div>
                                            </div>
                                            {timerSettings.duration > 0 && (
                                                <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ):(
                            <>
                                <div className="max-w-7xl mx-auto w-full px-4 sm:px-6 pt-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <button onClick={quitPractice} className="bg-orange-500 hover:bg-orange-600 text-white font-bold text-sm px-4 py-2 rounded-lg shadow-sm transition-all active:scale-95 flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                                            {ui.menu_btn}
                                        </button>
                                        
                                        {timerSettings.duration > 0 && (
                                            <div className={`font-mono text-lg font-bold px-3 py-1 rounded-lg border ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                                {formatTime(timerSettings.remaining)}
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>
                                </div>
                                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                                     <MobileDrawer open={mobileHistoryOpen} onClose={()=>setMobileHistoryOpen(false)} history={history} ui={ui}/>
                                     
                                     <div className="flex-1 w-full min-w-0">
                                         <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                                             <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                                             <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div></div>
                                         </div>
                                         <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                                    {question.renderData.graph ? (
                                                        <GraphCanvas data={question.renderData.graph}/>
                                                    ) : question.renderData.geometry ? (
                                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                                        : <GeometryVisual data={question.renderData.geometry}/>
                                                    ) : (
                                                        <div className="flex flex-col items-center justify-center w-full">
                                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                                {question.renderData.answerType === 'scale' ? (
                                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                                ) : (
                                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                                )}
                                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues.length>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main>
                                     </div>
                                     <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                                         <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed}/>
                                         <div className="flex-1 min-h-0"><HistoryList history={history} ui={ui}/></div>
                                     </div>
                                </div>
                                <LevelUpModal visible={levelUpAvailable} ui={ui} onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }} onStay={() => setLevelUpAvailable(false)} />
                                <StreakModal visible={showStreakModal} streak={streak} ui={ui} onClose={closeStreakModal} />
                                <TotalCorrectModal visible={showTotalModal} total={totalCorrect} ui={ui} onClose={closeTotalModal} />
                            </>
                        )}
                    </div>
                </div>
            );
        }
        
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>



// Back code starts here //

<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anpassa | Math Platform</title>
    
    <!-- React & Core Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Styling & Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
                        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] }
                }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .katex { font-size: 1.1em; } 
        .drawer-enter { transform: translateX(-100%); }
        .drawer-enter-active { transform: translateX(0); transition: transform 300ms; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Modal Animation */
        .modal-enter { opacity: 0; transform: scale(0.95); }
        .modal-enter-active { opacity: 1; transform: scale(1); transition: opacity 300ms, transform 300ms; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-x-hidden flex flex-col min-h-screen">
    <div id="root" class="flex-grow flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATA & CONSTANTS ---
        const CATEGORIES={
            arithmetic: {
                label: { sv: "Taluppfattning", en: "Number Theory" },
                color: "pink", 
                topics: [
                    { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
                    { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } }
                ]
            },
            algebra:{
                label:{sv:"Algebra",en:"Algebra"},
                color:"indigo",
                topics:[
                    {id:'equation',label:{sv:"Ekvationer",en:"Equations"}},
                    {id:'simplify',label:{sv:"Uttryck",en:"Expressions"}}
                ]
            },
            geometry:{
                label:{sv:"Geometri",en:"Geometry"},
                color:"emerald",
                topics:[
                    {id:'geometry',label:{sv:"Area & Omkrets",en:"Area & Perimeter"}},
                    {id:'scale',label:{sv:"Skala",en:"Scale"}},
                    {id:'volume',label:{sv:"Volym",en:"Volume"}}
                ]
            },
            functions:{
                label:{sv:"Samband",en:"Functions"},
                color:"purple",
                topics:[
                    {id:'graph',label:{sv:"R√§ta Linjen",en:"Linear Graphs"}}
                ]
            }
        };

        const LEVEL_DESCRIPTIONS={
            arithmetic: {
                1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
                2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
                3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
                4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
                5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
                6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
                7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
                8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
                9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
            },
            negative: {
                1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
                2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
                3: { sv: "Multiplikation", en: "Multiplication" },
                4: { sv: "Division", en: "Division" },
                5: { sv: "Blandat", en: "Mixed" }
            },
            equation:{
                1:{sv:"Enstegsekvationer",en:"One-step equations"},
                2:{sv:"Tv√•stegsekvationer",en:"Two-step equations"},
                3:{sv:"X p√• b√•da sidor",en:"X on both sides"},
                4:{sv:"Multiplikation med parentes",en:"Multiplication with parentheses"},
                5:{sv:"Probleml√∂sning (Skriv)",en:"Word Problems (Write)"},
                6:{sv:"Probleml√∂sning (L√∂s)",en:"Word Problems (Solve)"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            simplify:{
                1:{sv:"F√∂renkla uttryck",en:"Combine like terms"},
                2:{sv:"Parenteser",en:"Distribute into parentheses"},
                3:{sv:"Distribuera & f√∂renkla",en:"Distribute and combine"},
                4:{sv:"Subtrahera parenteser",en:"Subtracting parentheses"},
                5:{sv:"Textuppgifter",en:"Word Problems"},
                6:{sv:"Blandat",en:"Mixed"}
            },
            geometry:{
                1:{sv:"Omkrets (Rektangel)",en:"Perimeter (Rectangle)"},
                2:{sv:"Area (Rektangel)",en:"Area (Rectangle)"},
                3:{sv:"Area (Triangel)",en:"Area (Triangle)"},
                4:{sv:"Cirklar (Omkrets & Area)",en:"Circles (Perimeter & Area)"},
                5:{sv:"Sammansatta figurer",en:"Composite shapes"}
            },
            scale:{
                1:{sv:"Begreppsf√∂rst√•else",en:"Concepts"},
                2:{sv:"Ber√§kna l√§ngd (Enkel)",en:"Calc Length (Simple)"},
                3:{sv:"Ber√§kna l√§ngd (Sv√•r)",en:"Calc Length (Hard)"},
                4:{sv:"Ange skala",en:"Determine Scale"},
                5:{sv:"Utan bilder",en:"No Pictures"},
                6:{sv:"Areaskala",en:"Area Scale"},
                7:{sv:"Blandat",en:"Mixed"}
            },
            volume: {
                1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
                2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
                3: { sv: "Cylinder", en: "Cylinder" },
                4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
                5: { sv: "Klot", en: "Sphere" },
                6: { sv: "Blandat", en: "Mixed" },
                7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
            },
            graph:{
                1:{sv:"Hitta m (sk√§rning)",en:"Find y-intercept (m)"},
                2:{sv:"Hitta k (positiv)",en:"Find slope (Positive)"},
                3:{sv:"Hitta k (negativ)",en:"Find slope (Negative)"},
                4:{sv:"Hitta funktion (y=kx+m)",en:"Find equation (y=kx+m)"},
                5:{sv:"Blandat",en:"Mixed graphs"}
            }
        };

        const UI_TEXT={
            sv:{
                streak:"Streak",loading:"Laddar fr√•ga...",error:"Kunde inte ladda fr√•gan.",
                btnHint:"Ledtr√•d",btnSolution:"Visa l√∂sning",btnSkip:"Hoppa √∂ver",
                submit:"Svara",correct:"R√§tt! N√§sta...",incorrect:"Inte riktigt, f√∂rs√∂k igen",placeholder:"Skriv ditt svar...",
                level:"Niv√•",history:"Historik",noHistory:"Inga svar √§n.",clueUsed:"Hj√§lp",
                dashboardTitle:"V√§lj omr√•de att √∂va p√•",
                progressionInfo:"V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
                startBtn:"B√∂rja √∂va",backBtn:"Tillbaka till menyn",selectLevel:"V√§lj niv√•:",
                hintsTitle:"Ledtr√•dar",prevLevel:"F√∂reg√•ende",nextLevel:"N√§sta",
                levelUpTitle:"Bra jobbat! üî•",levelUpDesc:"Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?",levelUpYes:"N√§sta niv√•",levelUpNo:"Stanna p√• samma niv√•",levelUpHint:"Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
                aboutBtn:"Om skaparen",aboutTitle:"Om skaparen",aboutText:"Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
                contactLink:"F√∂lj mig p√• LinkedIn",
                tagline:"R√§tt st√∂d. Direkt.",
                tagCorrect: "R√§tt",
                tagWrong: "Fel",
                tagSkipped: "Hoppad",
                streak_modal_title: "Fantastiskt! üî•",
                streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
                total_modal_title: "Snyggt jobbat! ‚úÖ",
                total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
                btn_close_streak: "Bra jobbat!",
                btn_close_total: "Forts√§tt"
            },
            en:{
                streak:"Streak",loading:"Loading question...",error:"Could not load question.",
                btnHint:"Hint",btnSolution:"Show Solution",btnSkip:"Skip",
                submit:"Submit",correct:"Correct! Next...",incorrect:"Not quite, try again",placeholder:"Enter your answer...",
                level:"Level",history:"History",noHistory:"No answers yet.",clueUsed:"Clue",
                dashboardTitle:"Choose a topic to practice",
                progressionInfo:"Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
                startBtn:"Start Practice",backBtn:"Back to Menu",selectLevel:"Select Level:",
                hintsTitle:"Hints",prevLevel:"Previous",nextLevel:"Next",
                levelUpTitle:"Great Job! üî•",levelUpDesc:"You've answered 8 in a row! Do you want to try the next level?",levelUpYes:"Next Level",levelUpNo:"Stay Here",levelUpHint:"Remember, you can always change difficulty manually at the top.",
                aboutBtn:"About the creator",aboutTitle:"About the creator",aboutText:"Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
                contactLink:"Follow me on LinkedIn",
                tagline:"Right support. Instantly.",
                tagCorrect: "Correct",
                tagWrong: "Wrong",
                tagSkipped: "Skipped",
                streak_modal_title: "Awesome! üî•",
                streak_modal_msg: "You hit a streak of {streak}!",
                total_modal_title: "Great work! ‚úÖ",
                total_modal_msg: "You answered {total} questions correctly! Great job!",
                btn_close_streak: "Great job!",
                btn_close_total: "Continue"
            }
        };

        const MathText=({text,className="",large=false})=>{
            if(!text)return null;
            // Clean up potentially already escaped backslashes for textcolor
            const cleanText = text.replace(/\\\\/g, '\\');
            const patchedText = cleanText.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');
            
            // Format fractions cleanly in history or descriptions if they appear raw like \frac{x}{6}
            // We wrap them in $...$ if they aren't already, but carefully
            // This regex finds latex commands not inside $...$ and wraps them (simplified)
            // Ideally generators send $...$, but for history we wrap the whole text if it looks like math
            
            const parts=patchedText.split(/(\$[^\$]+\$)/g);
            return(<span className={className}>{parts.map((part,index)=>{
                if(part.startsWith('$')&&part.endsWith('$')){
                    const tex=part.slice(1,-1);
                    try{
                        const html=katex.renderToString(tex,{throwOnError:false,displayMode:large});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    }catch(e){return<span key={index} className="text-red-500">{part}</span>;}
                } else if (part.includes('\\')) { 
                    // Fallback for un-dollar-sign-wrapped latex in history
                    try {
                        const html=katex.renderToString(part,{throwOnError:false,displayMode:false});
                        return<span key={index} dangerouslySetInnerHTML={{__html:html}}/>;
                    } catch(e) {
                         return<span key={index}>{part}</span>;
                    }
                }
                return<span key={index}>{part}</span>;
            })}</span>);
        };
        
        const GraphCanvas=({data})=>{const canvasRef=useRef(null);useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!data)return;const ctx=canvas.getContext('2d');const width=canvas.width;const height=canvas.height;const range=data.range||10;ctx.clearRect(0,0,width,height);ctx.font='10px Inter, sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';const toX=(val)=>(val+range)*(width/(range*2));const toY=(val)=>height-(val+range)*(height/(range*2));ctx.strokeStyle='#e5e7eb';ctx.lineWidth=1;for(let i=-range;i<=range;i+=data.gridStep||1){ctx.beginPath();ctx.moveTo(toX(i),0);ctx.lineTo(toX(i),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(i));ctx.lineTo(width,toY(i));ctx.stroke();}ctx.strokeStyle='#374151';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(toX(0),0);ctx.lineTo(toX(0),height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,toY(0));ctx.lineTo(width,toY(0));ctx.stroke();ctx.fillStyle='#6b7280';const tickSize=3;const step=data.labelStep||2;for(let i=-range;i<=range;i+=step){if(i===0)continue;const xPos=toX(i);const yOrigin=toY(0);ctx.beginPath();ctx.moveTo(xPos,yOrigin-tickSize);ctx.lineTo(xPos,yOrigin+tickSize);ctx.stroke();ctx.fillText(i.toString(),xPos,yOrigin+12);const yPos=toY(i);const xOrigin=toX(0);ctx.beginPath();ctx.moveTo(xOrigin-tickSize,yPos);ctx.lineTo(xOrigin+tickSize,yPos);ctx.stroke();ctx.fillText(i.toString(),xOrigin-12,yPos);}data.lines.forEach(line=>{ctx.strokeStyle=line.color||'#dc2626';ctx.lineWidth=3;ctx.beginPath();const x1=-range;const y1=line.slope*x1+line.intercept;const x2=range;const y2=line.slope*x2+line.intercept;ctx.moveTo(toX(x1),toY(y1));ctx.lineTo(toX(x2),toY(y2));ctx.stroke();});},[data]);return<div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm"/></div>;};
        
        const VolumeVisualization = ({ data }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = '#374151'; ctx.fillStyle = '#e5e7eb'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.font = "bold 16px Inter"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                const cx = w / 2; const cy = h / 2;
                const drawLabel = (text, x, y, color='#ef4444') => { ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 4; ctx.lineJoin = 'round'; ctx.miterLimit = 2; ctx.strokeText(text, x, y); ctx.restore(); ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.fillStyle = '#e5e7eb'; };
                const drawDashedLine = (x1, y1, x2, y2) => { ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.restore(); };

                if (data.type === 'cuboid') { const s = 120; const hw = s * 0.6; const hh = s * 0.5; const depthX = 40; const depthY = -30; const x0 = cx - hw/2 - depthX/2; const y0 = cy + hh/2 + depthY/2; ctx.strokeRect(x0, y0 - hh, hw, hh); ctx.beginPath(); ctx.moveTo(x0, y0 - hh); ctx.lineTo(x0 + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw, y0 - hh); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x0 + hw + depthX, y0 - hh + depthY); ctx.lineTo(x0 + hw + depthX, y0 + depthY); ctx.lineTo(x0 + hw, y0); ctx.stroke(); drawLabel(data.labels.w, x0 + hw/2, y0 + 20); drawLabel(data.labels.h, x0 - 20, y0 - hh/2); drawLabel(data.labels.d, x0 + hw + depthX/2 + 5, y0 + depthY/2 + 15); }
                else if (data.type === 'triangular_prism') { const scale = 14; const baseW = data.b * scale; const triH = data.h_tri * scale; const len = data.len * scale * 0.8; const startX = cx - baseW/2 - len/4; const startY = cy + triH/2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + baseW, startY); ctx.lineTo(startX + baseW/2, startY - triH); ctx.closePath(); ctx.stroke(); const offX = len * 0.8; const offY = -len * 0.5; ctx.beginPath(); ctx.moveTo(startX + baseW/2, startY - triH); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(startX + baseW, startY); ctx.lineTo(startX + baseW + offX, startY + offY); ctx.lineTo(startX + baseW/2 + offX, startY - triH + offY); ctx.stroke(); drawDashedLine(startX + baseW/2, startY, startX + baseW/2, startY - triH); drawLabel(data.labels.b, startX + baseW/2, startY + 20); drawLabel(data.labels.h, startX + baseW/2 + 15, startY - triH/2); drawLabel(data.labels.l, startX + baseW + offX/2 + 10, startY + offY/2); }
                else if (data.type === 'pyramid') { const h = 130; const cBaseX = cx; const cBaseY = cy + 50; const dx = 80; const dy = 30; const vFront = { x: cBaseX, y: cBaseY + dy }; const vBack  = { x: cBaseX, y: cBaseY - dy }; const vLeft  = { x: cBaseX - dx, y: cBaseY }; const vRight = { x: cBaseX + dx, y: cBaseY }; const vApex  = { x: cBaseX, y: cBaseY - h }; ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vFront.x, vFront.y); ctx.lineTo(vRight.x, vRight.y); ctx.lineTo(vBack.x, vBack.y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(vLeft.x, vLeft.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vRight.x, vRight.y); ctx.lineTo(vApex.x, vApex.y); ctx.moveTo(vFront.x, vFront.y); ctx.lineTo(vApex.x, vApex.y); ctx.stroke(); drawDashedLine(vBack.x, vBack.y, vApex.x, vApex.y); drawDashedLine(cBaseX, cBaseY, vApex.x, vApex.y); drawLabel(data.labels.s, cBaseX + dx/2, cBaseY + dy/2 + 20); drawLabel(data.labels.h, cBaseX + 15, cBaseY - h/2); }
                else if (data.type === 'sphere' || data.type === 'hemisphere' || data.type === 'ice_cream' || data.type === 'silo') { const r = 70; if (data.type === 'silo') { const cylH = 100; const topY = cy - cylH/2 + 20; const bottomY = cy + cylH/2 + 20; ctx.beginPath(); ctx.moveTo(cx - r, topY); ctx.lineTo(cx - r, bottomY); ctx.moveTo(cx + r, topY); ctx.lineTo(cx + r, bottomY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, 0, Math.PI); ctx.stroke(); ctx.save(); ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.ellipse(cx, bottomY, r, r/3, 0, Math.PI, 2 * Math.PI); ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.ellipse(cx, topY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + r + 20, cy + 20); if (data.show === 'd') { drawDashedLine(cx - r, topY, cx + r, topY); drawLabel(data.labels.val, cx, topY - 10); } else { drawDashedLine(cx, topY, cx + r, topY); drawLabel(data.labels.val, cx + r/2, topY - 10); } } else if (data.type === 'ice_cream') { const coneH = 120; const tipY = cy + coneH/2; const baseY = tipY - coneH; ctx.beginPath(); ctx.moveTo(cx - r, baseY); ctx.lineTo(cx, tipY); ctx.lineTo(cx + r, baseY); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); drawLabel(data.labels.h, cx + 20, tipY - coneH/2); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY - 20); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY - 15); } } else if (data.type === 'hemisphere') { const baseY = cy + 20; ctx.beginPath(); ctx.ellipse(cx, baseY, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(cx, baseY, r, Math.PI, 0); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, baseY, cx + r, baseY); drawLabel(data.labels.val, cx, baseY + 40); } else { drawDashedLine(cx, baseY, cx + r, baseY); drawLabel(data.labels.val, cx + r/2, baseY + 10); } } else { ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx, cy, r, r/3, 0, 0, 2 * Math.PI); ctx.stroke(); if (data.show === 'd') { drawDashedLine(cx - r, cy, cx + r, cy); drawLabel(data.labels.val, cx, cy - 15); } else { drawDashedLine(cx, cy, cx + r, cy); drawLabel(data.labels.val, cx + r/2, cy - 15); } } }
                else if (data.type === 'cylinder' || data.type === 'cone') { const w = 100; const hShape = 120; const isCone = data.type === 'cone'; ctx.beginPath(); ctx.ellipse(cx, cy + hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); if (isCone) { ctx.beginPath(); ctx.moveTo(cx - w/2, cy + hShape/2); ctx.lineTo(cx, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawDashedLine(cx, cy - hShape/2, cx, cy + hShape/2); drawLabel(data.labels.h, cx + 15, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } else { ctx.beginPath(); ctx.ellipse(cx, cy - hShape/2, w/2, 15, 0, 0, 2 * Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx - w/2, cy - hShape/2); ctx.lineTo(cx - w/2, cy + hShape/2); ctx.moveTo(cx + w/2, cy - hShape/2); ctx.lineTo(cx + w/2, cy + hShape/2); ctx.stroke(); drawLabel(data.labels.h, cx + w/2 + 20, cy); drawLabel(data.labels.r, cx + 10, cy + hShape/2 + 25); } }
            }, [data]);
            return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
        };

        const GeometryVisual = ({ data }) => {
            if (!data) return null;
            const SvgContainer = ({ children, w=240, h=200, viewBox="0 0 200 200" }) => <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full max-w-[240px] mx-auto">{children}</svg>;
            const Label = ({ x, y, text, align="middle" }) => ( <text x={x} y={y} textAnchor={align} className="fill-gray-700 text-sm font-bold" style={{fontSize: '14px'}}> {text} </text> );
            const RenderShape = ({ type, dims, labels, areaText }) => {
                const w = dims.width || 0, h = dims.height || 0, r = dims.radius || 0;
                const size = Math.max(w, h, r*2);
                const scale = 120 / (size || 1); 
                let sw = w * scale, sh = h * scale, sr = r * scale;
                const cx = 90, cy = 90;
                const content = () => {
                    if (type === 'rectangle' || type === 'square' || type === 'parallelogram') return (<><rect x={cx-sw/2} y={cy-sh/2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><text x={cx+sw/2+10} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'triangle') return (<><polygon points={`${cx-sw/2},${cy+sh/2} ${cx+sw/2},${cy+sh/2} ${cx},${cy-sh/2}`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><text x={cx} y={cy+sh/2+20} textAnchor="middle" fontWeight="bold" fill="#374151">{dims.width}</text><line x1={cx} y1={cy-sh/2} x2={cx} y2={cy+sh/2} stroke="#6b7280" strokeDasharray="4" /><text x={cx+5} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{dims.height}</text></>)}</>);
                    if (type === 'circle') return (<><circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    if (type === 'semicircle') return (<><path d={`M ${cx-sr} ${cy} A ${sr} ${sr} 0 0 1 ${cx+sr} ${cy} Z`} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{labels && (<><line x1={cx} y1={cy} x2={cx+sr} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+sr/2} y={cy-5} textAnchor="middle" fontWeight="bold" fill="#374151">r={dims.radius}</text></>)}</>);
                    return null;
                };
                return (<svg width="180" height="180" viewBox="0 0 180 180" className="border border-gray-100 rounded-lg bg-white shadow-sm w-full max-w-[200px]">{content()}{areaText && <text x="90" y="90" textAnchor="middle" dominantBaseline="middle" fontSize="16" fontWeight="bold" fill="#064e3b">{areaText} cm¬≤</text>}</svg>);
            };
            if (data.type === 'triangle') { const w = data.width || 0, h = data.height || 0; const maxDim = Math.max(w, h); const scale = 140 / (maxDim || 1); const bVal = w * scale; const hVal = h * scale; const cx = 100, cy = 100; let points = "", hLine = null, bLabel = null, hLabel = null; const orient = data.orientation || 'up'; const isRight = data.subtype === 'right'; if (orient === 'up') { const x1 = cx - bVal/2, y1 = cy + hVal/2; const x2 = cx + bVal/2, y2 = cy + hVal/2; const x3 = isRight ? x1 : cx, y3 = cy - hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 + 20} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'down') { const x1 = cx - bVal/2, y1 = cy - hVal/2; const x2 = cx + bVal/2, y2 = cy - hVal/2; const x3 = isRight ? x1 : cx, y3 = cy + hVal/2; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x3} y2={y1} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x1} y1={y1} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={cx} y={y1 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={isRight ? x1 - 15 : cx + 5} y={cy} textAnchor={isRight ? "end" : "start"} fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else if (orient === 'left') { const x1 = cx + hVal/2, y1 = cy - bVal/2; const x2 = cx + hVal/2, y2 = cy + bVal/2; const x3 = cx - hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 + 15} y={cy} textAnchor="start" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } else { const x1 = cx - hVal/2, y1 = cy - bVal/2; const x2 = cx - hVal/2, y2 = cy + bVal/2; const x3 = cx + hVal/2, y3 = isRight ? y2 : cy; points = `${x1},${y1} ${x2},${y2} ${x3},${y3}`; hLine = !isRight ? <line x1={x3} y1={y3} x2={x1} y2={y3} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /> : <line x1={x2} y1={y2} x2={x3} y2={y3} stroke="#10b981" strokeWidth="3" />; bLabel = <text x={x1 - 15} y={cy} textAnchor="end" fontWeight="bold" fill="#374151">{data.labels.base}</text>; hLabel = <text x={cx} y={isRight ? y2 + 20 : y3 - 10} textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.height}</text>; } return ( <SvgContainer><polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{hLine}{bLabel}{hLabel}</SvgContainer> ); } if (data.type === 'circle') { const cx=100, cy=100, r=70; return ( <SvgContainer><circle cx={cx} cy={cy} r={r} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />{data.show === 'diameter' ? (<><line x1={cx-r} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">d = {data.value}</text></>) : (<><line x1={cx} y1={cy} x2={cx+r} y2={cy} stroke="#374151" strokeWidth="2" /><text x={cx+r/2} y={cy-10} textAnchor="middle" fontWeight="bold" fill="#374151">r = {data.value}</text></>)}</SvgContainer> ); } if (data.type === 'composite') { const subtype = data.subtype; if (subtype === 'house') { return ( <SvgContainer><rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="160" y="120" fontWeight="bold" fill="#374151">{data.labels.h}</text><text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text><text x="130" y="50" fontWeight="bold" fill="#374151">{data.labels.h_roof}</text></SvgContainer> ); } if (subtype === 'portal') { return ( <SvgContainer><rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151">{data.labels.w}</text></SvgContainer> ); } return ( <SvgContainer><polygon points="50,70 150,70 100,190" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" /><line x1="50" y1="70" x2="150" y2="70" stroke="#6b7280" strokeWidth="2" strokeDasharray="4" /><text x="100" y="60" textAnchor="middle" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.top}</text><text x="140" y={130} textAnchor="start" fill="#374151" fontSize="14" fontWeight="bold">{data.labels.side}</text></SvgContainer> ); } if (data.type === 'scale_single' || data.type === 'scale_compare') { const shapeEmojis = { square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', rhombus: 'üî∂', parallelogram: '‚ñ∞', pentagon: '‚¨ü', hexagon: 'üõë', octagon: 'üõë', star: '‚≠ê', arrow: '‚û°', heart: '‚ù§Ô∏è', cross: '‚ûï', lightning: '‚ö°', kite: 'ü™Å', cube: 'üßä', cylinder: 'üõ¢Ô∏è', pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ' }; const emoji = shapeEmojis[data.shape] || 'üì¶'; const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl" style={{width:size,height:size}}>{emoji}</div>; if (data.type === 'scale_single') return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="120px" /><span className="bg-white px-3 py-1 rounded shadow text-sm font-mono border border-gray-200">{data.label}</span></div>; return <div className="flex items-end justify-center gap-6 sm:gap-12 my-6"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="80px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.leftValue}</span></div><div className="pb-8 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="120px" /><span className="text-sm font-mono bg-white px-2 rounded border mt-2">{data.rightValue}</span></div></div>; } if (data.type === 'compare_shapes' || data.type === 'compare_shapes_area') { const showLabels = data.type === 'compare_shapes'; const showArea = data.type === 'compare_shapes_area'; return (<div className="flex flex-wrap justify-center gap-8 items-end my-4"><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.left.label}</span><RenderShape type={data.shapeType} dims={data.left} labels={showLabels} areaText={showArea ? data.left.area : null} /></div><div className="pb-20 text-gray-300 text-3xl">‚Üí</div><div className="flex flex-col items-center gap-2"><span className="text-xs font-bold uppercase text-gray-400">{data.right.label}</span><RenderShape type={data.shapeType} dims={data.right} labels={showLabels} areaText={showArea ? data.right.area : null} /></div></div>); }
            return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>; 
        };

        // --- DEFINED BEFORE USAGE ---
        const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
            if(!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <div className="text-center mb-6"><div className="text-5xl mb-4">üî•</div><h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3><p className="text-gray-600">{ui.levelUpDesc}</p></div>
                        <div className="flex flex-col gap-3"><button onClick={onNext} className="w-full py-4 bg-primary-600 hover:bg-primary-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.levelUpYes}</button><button onClick={onStay} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95">{ui.levelUpNo}</button></div>
                        <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
                    </div>
                </div>
            );
        };

        const StreakModal = ({ visible, streak, ui, onClose }) => {
            if (!visible) return null;
            let icon = "ü•â";
            if (streak >= 50) icon = "üëë";
            else if (streak >= 40) icon = "üèÜ";
            else if (streak >= 30) icon = "ü•á";
            else if (streak >= 20) icon = "ü•à";
            else if (streak >= 15) icon = "ü•â";
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                        <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_streak}</button>
                    </div>
                </div>
            );
        };

        const TotalCorrectModal = ({ visible, total, ui, onClose }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-green-500 text-center">
                        <div className="text-6xl mb-4">‚úÖ</div>
                        <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.total_modal_title}</h3>
                        <p className="text-lg text-gray-600 mb-6">{ui.total_modal_msg.replace('{total}', total)}</p>
                        <button onClick={onClose} className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg">{ui.btn_close_total}</button>
                    </div>
                </div>
            );
        };

        const AboutModal = ({ visible, onClose, ui }) => {
            if (!visible) return null;
            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">‚úï</button>
                        <div className="text-center mb-6">
                            <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                            <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                            <hr className="my-4 border-gray-200" />
                            <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/></svg>
                                {ui.contactLink}
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DASHBOARD COMPONENT ---
        const Dashboard=({lang,onStart,selectedTopic,selectedLevel,onSelect})=>{const ui=UI_TEXT[lang];const getCategoryColorClass=(category,type)=>{const colorMap={pink:'pink',indigo:'indigo',emerald:'emerald',purple:'purple'};const color=colorMap[category.color]||'primary';if(type==='bg-light')return `bg-${color}-50`;if(type==='bg-dark')return `bg-${color}-500`;if(type==='border')return `border-${color}-100`;if(type==='text')return `text-${color}-700`;if(type==='ring')return `ring-${color}-500`;if(type==='border-solid')return `border-${color}-500`;return '';};return(<div className="max-w-6xl mx-auto w-full p-4 fade-in">
        <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-primary-50 rounded-3xl mx-4"><h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight">Anpassa</h1><p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide">{ui.tagline}</p></div>
        <div className="text-center mb-10"><p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p></div><div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">{Object.entries(CATEGORIES).map(([catKey,category])=>{const bgLight=getCategoryColorClass(category,'bg-light');const border=getCategoryColorClass(category,'border');const text=getCategoryColorClass(category,'text');const bgDark=getCategoryColorClass(category,'bg-dark');return(<div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}><div className={`${bgLight} p-4 border-b ${border}`}><h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}><span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}</h3></div><div className="p-4 space-y-4 flex-1">{category.topics.map(topic=>{const ring=getCategoryColorClass(category,'ring');const borderSolid=getCategoryColorClass(category,'border-solid');return(<div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100"><div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div><div className="relative"><select value={selectedTopic===topic.id?selectedLevel:0} onChange={(e)=>onSelect(topic.id,Number(e.target.value))} className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic===topic.id?`ring-2 ${ring} ${borderSolid}`:`focus:${ring}`}`}><option value={0} disabled>{ui.selectLevel}</option>{[1,2,3,4,5,6,7,8,9].map(lvl=>{if(!LEVEL_DESCRIPTIONS[topic.id]?.[lvl])return null;return<option key={lvl} value={lvl}>{lang==='sv'?`Niv√• ${lvl}`:`Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang]||""}</option>;})}</select><div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500"><svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div></div></div>);})}</div></div>);})}</div><div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20"><button onClick={onStart} className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic?'bg-accent-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-accent-600 shadow-accent-200':'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}>{ui.startBtn} <span>üöÄ</span></button></div></div>);};

        // --- PRACTICE VIEW ---
        const PracticeView=({lang,ui,question,loading,feedback,streak,input,setInput,handleSubmit,handleHint,handleSolution,handleSkip,handleChangeLevel,revealedClues,uiState,actions,levelUpAvailable,setLevelUpAvailable,isSolutionRevealed, showStreakModal, setShowStreakModal, showTotalModal, setShowTotalModal, totalCorrect})=>{
            const [mobileHistoryOpen,setMobileHistoryOpen]=useState(false);
            const [scaleInputLeft, setScaleInputLeft] = useState('');
            const [scaleInputRight, setScaleInputRight] = useState('');
            const [attempts, setAttempts] = useState(0);

            const descriptionText=typeof question?.renderData?.description==='object'?question.renderData.description[lang]:question?.renderData?.description;
            const handleChoiceClick=(choice)=>{if(feedback==='correct')return;setInput(choice);handleSubmit({preventDefault:()=>{}},choice);};
            const handleFormSubmit=(e)=>{
                if(question.renderData.answerType === 'scale') {
                    const combined = `${scaleInputLeft}:${scaleInputRight}`;
                    setInput(combined);
                    handleSubmit(e, combined);
                } else {
                    handleSubmit(e, input);
                }
            };
            
            // Reset attempts when question changes
            useEffect(() => { 
                setScaleInputLeft(''); 
                setScaleInputRight(''); 
                setAttempts(0);
            }, [question]);

            const maxLevels=Object.keys(LEVEL_DESCRIPTIONS[uiState.topic]||{}).length;
            
            // Enhanced History with Tags (Right/Wrong/Skipped)
            // Added correct answer display for failed questions
            const HistoryList=({history})=>(<div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden"><div className="p-4 border-b bg-gray-50 flex justify-between items-center"><h2 className="font-bold text-gray-700">{ui.history}</h2><span className="text-xs text-gray-400">{history.length}</span></div><div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px]">{history.length===0?<p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>:history.map((entry,i)=>(<div key={i} className={`p-3 rounded-lg border-l-4 text-sm ${entry.correct?'border-primary-500 bg-primary-50': (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')}`}><div className="flex justify-between items-start mb-1"><span className="font-semibold capitalize text-gray-700">{entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span></span><span className="text-xs text-gray-400">{new Date(entry.time).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div><div className="text-gray-600 mb-1 line-clamp-2"><MathText text={entry.text}/></div>{!entry.correct && !entry.skipped && entry.correctAnswer && <div className="text-xs text-red-600 mt-1 font-medium"><MathText text={`Correct: ${entry.correctAnswer}`}/></div>}<div>{entry.clueUsed&&<span className="inline-block px-1.5 py-0.5 bg-accent-100 text-accent-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">{ui.clueUsed}</span>} <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${entry.correct ? 'bg-green-100 text-green-700' : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')}`}>{entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}</span></div></div>))}</div></div>);
            
            const MobileDrawer=()=>(<>{mobileHistoryOpen&&<div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={()=>setMobileHistoryOpen(false)}></div>}<div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${mobileHistoryOpen?'translate-x-0':'-translate-x-full'}`}><div className="p-4 border-b flex justify-between items-center bg-gray-50"><h2 className="font-bold text-gray-700">{ui.history}</h2><button onClick={()=>setMobileHistoryOpen(false)} className="text-gray-400">‚úï</button></div><div className="flex-1 overflow-y-auto p-4"><HistoryList history={uiState.history}/></div></div></>);
            const CluePanel=()=>{
                if(revealedClues===0)return null;
                const visibleClues=question.clues.slice(0,revealedClues);
                return(
                    <div className="bg-accent-50 border border-accent-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
                        <div className="flex items-center gap-2 mb-4 text-accent-800 font-bold border-b border-accent-200 pb-2">
                            <span>üí° {ui.hintsTitle} ({revealedClues}/{question.clues.length})</span>
                        </div>
                        <div className="space-y-6">
                            {visibleClues.map((clue,i)=>{
                                const isLast = i === question.clues.length - 1;
                                const showLatex = !isLast || isSolutionRevealed;
                                return (
                                    <div key={i} className="group animate-slide-down">
                                        <div className="text-sm text-accent-900 mb-2 font-medium leading-relaxed">
                                            <MathText text={clue.text}/>
                                        </div>
                                        {clue.latex && showLatex && (
                                            <div className="bg-white p-3 rounded-lg border border-accent-200 text-center shadow-sm overflow-x-auto">
                                                <MathText text={`$${clue.latex}$`} large={true}/>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            return(
                <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
                    <MobileDrawer/>
                    <LevelUpModal 
                        visible={levelUpAvailable} 
                        ui={ui} 
                        onNext={() => { handleChangeLevel(1); setLevelUpAvailable(false); }}
                        onStay={() => setLevelUpAvailable(false)}
                    />
                    <StreakModal 
                        visible={showStreakModal}
                        streak={streak}
                        ui={ui}
                        onClose={() => { setShowStreakModal(false); actions.retry(); }} // Generate next question on close
                    />
                    <TotalCorrectModal
                        visible={showTotalModal}
                        total={totalCorrect}
                        ui={ui}
                        onClose={() => { setShowTotalModal(false); }}
                    />
                    <div className="flex-1 w-full min-w-0">
                        <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                            <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>
                            <div className="flex items-center gap-3"><div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200"><button onClick={()=>handleChangeLevel(-1)} disabled={uiState.level<=1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button><span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span><button onClick={()=>handleChangeLevel(1)} disabled={uiState.level>=maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button></div><button onClick={()=>setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500"><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button></div>
                        </div>
                        <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                            {/* REDUCED PADDING & SPACING IN MAIN CONTENT */}
                            {loading?(<div className="p-20 text-center flex flex-col items-center gap-4"><div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div></div>):question?(<div className="p-4 sm:p-6">
                                <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                    {question.renderData.graph ? (
                                        <GraphCanvas data={question.renderData.graph}/>
                                    ) : question.renderData.geometry ? (
                                        ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type) 
                                        ? <VolumeVisualization data={question.renderData.geometry}/> 
                                        : <GeometryVisual data={question.renderData.geometry}/>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center w-full">
                                            {uiState.topic==='geometry' && <StaticGeometryVisual description={descriptionText}/>}
                                            {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true}/></div>}
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText}/></h2></div>
                                {question.renderData.answerType==='multiple_choice'?(<div className="max-w-md mx-auto grid grid-cols-2 gap-4">{question.renderData.choices.map((choice,idx)=>(<button key={idx} onClick={()=>handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback==='correct'&&choice===input?'bg-green-500 border-green-500 text-white':feedback==='incorrect'&&choice===input?'bg-red-500 border-red-500 text-white':'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback==='correct'}>{choice}</button>))}</div>):(<form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2"><input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" autoFocus disabled={feedback === 'correct'} /><span className="text-2xl font-bold text-gray-400">:</span><input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} /></div>
                                ) : (
                                    <div className="relative"><input type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback==='correct'?'border-primary-500 bg-primary-50 text-primary-700':feedback==='incorrect'?'border-red-500 bg-red-50 text-red-700':'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} autoFocus disabled={feedback === 'correct'}/></div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback==='correct'?'bg-primary-500 shadow-green-200 cursor-default':'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback==='correct'?ui.correct:feedback==='incorrect'?ui.incorrect:ui.submit}</button></form>)}<div className="mt-6 flex gap-3 justify-center flex-wrap"><button type="button" onClick={handleHint} disabled={!question.clues||revealedClues>=question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button><button type="button" onClick={handleSolution} disabled={!question.clues||isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button><button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button></div></div>):(<div className="p-12 text-center text-red-400"><p>{ui.error}</p><button onClick={actions.retry} className="text-indigo-600 underline text-sm mt-2">Retry</button></div>)}</main></div><div className="lg:w-80 w-full shrink-0 flex flex-col gap-4"><CluePanel/><div className="hidden lg:block flex-1 min-h-0"><HistoryList history={uiState.history}/></div></div></div>);};

        function App(){const[view,setView]=useState('dashboard');const[lang,setLang]=useState('sv');const[topic,setTopic]=useState('');const[level,setLevel]=useState(0);const[question,setQuestion]=useState(null);const[input,setInput]=useState('');const[feedback,setFeedback]=useState(null);const[loading,setLoading]=useState(false);const[streak,setStreak]=useState(0);const[totalCorrect, setTotalCorrect] = useState(0); // Total correct answers
        const[history,setHistory]=useState([]);const[revealedClues,setRevealedClues]=useState(0);const[levelUpAvailable,setLevelUpAvailable]=useState(false);const[aboutOpen,setAboutOpen]=useState(false);const[usedHelp, setUsedHelp] = useState(false);const[isSolutionRevealed, setIsSolutionRevealed] = useState(false);const[showStreakModal, setShowStreakModal] = useState(false);const[showTotalModal, setShowTotalModal] = useState(false);const ui=UI_TEXT[lang];const fetchQuestion=async(t=topic,l=level,lg=lang)=>{if(!t||!l)return;setLoading(true);setFeedback(null);setInput('');setRevealedClues(0);setUsedHelp(false);setIsSolutionRevealed(false);setLevelUpAvailable(false);try{const res=await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);const data=await res.json();if(data.error)throw new Error(data.error);setQuestion(data);}catch(e){console.error(e);setQuestion(null);}finally{setLoading(false);}};const startPractice=()=>{if(topic&&level){setStreak(0);setView('practice');fetchQuestion(topic,level,lang);}};const quitPractice=()=>{setStreak(0);setView('dashboard');setQuestion(null);};const handleSelection=(t,l)=>{setTopic(t);setLevel(l);};const handleHint=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(p=>Math.min(p+1,question.clues.length));}};const handleSolution=()=>{if(question?.clues){setUsedHelp(true);setRevealedClues(question.clues.length);setIsSolutionRevealed(true);setStreak(0);}};const handleSkip=()=>{const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;setHistory(prev=>[{topic,level,correct:false,skipped:true,text:descText||question.renderData.latex,clueUsed:revealedClues>0||isSolutionRevealed,time:Date.now()},...prev]);setStreak(0);fetchQuestion(topic,level,lang);};const handleChangeLevel=(delta)=>{const newLevel=level+delta;const max=Object.keys(LEVEL_DESCRIPTIONS[topic]||{}).length;if(newLevel>=1&&newLevel<=max){setStreak(0);setLevel(newLevel);fetchQuestion(topic,newLevel,lang);}};const handleSubmit=async(e,directInput)=>{e.preventDefault();const answerToSubmit=directInput!==undefined?directInput:input;if(!question||!answerToSubmit)return;const helpUsed=revealedClues>0||isSolutionRevealed;try{const res=await fetch('/api/answer',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({answer:answerToSubmit,token:question.token,streak:streak,level:level,topic:topic,usedHelp:helpUsed,solutionUsed:isSolutionRevealed,attempts:question.attempts})});const result=await res.json();const descText=typeof question.renderData.description==='object'?question.renderData.description[lang]:question.renderData.description;if(result.correct){setHistory(prev=>[{topic,level,correct:true,text:descText||question.renderData.latex,clueUsed:helpUsed,time:Date.now()},...prev]);setFeedback('correct');setStreak(result.newStreak);
        
        // Handle Total Correct (Independent of streak, but not if solution used)
        if (!isSolutionRevealed) {
            const newTotal = totalCorrect + 1;
            setTotalCorrect(newTotal);
            if ([10, 20, 30, 40, 50].includes(newTotal)) {
                setShowTotalModal(true);
            }
        }

        // Handle Streak Milestones
        if ([15, 20, 30, 40, 50].includes(result.newStreak)) {
            setShowStreakModal(true);
            // Don't auto-fetch question if showing modal
        } else {
             if(result.levelUp)setLevelUpAvailable(true);
             setTimeout(()=>{if(!result.levelUp)fetchQuestion(topic,level,lang);},1500);
        }
        
        }else{question.attempts=(question.attempts||0)+1;if(result.action==='next_clue'){handleHint();}else if(result.action==='show_solution'){handleSolution();setHistory(prev=>[{topic,level,correct:false,text:descText||question.renderData.latex,clueUsed:true,correctAnswer:result.correctAnswer,time:Date.now()},...prev]);}setFeedback('incorrect');setStreak(0);}}catch(e){console.error(e);}};return(<div className="min-h-screen flex flex-col bg-gray-50"><AboutModal visible={aboutOpen} onClose={()=>setAboutOpen(false)} ui={ui}/><header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm"><div className="max-w-7xl mx-auto flex justify-between items-center"><div className="flex items-center gap-4"><h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={()=>setView('dashboard')}>Anpassa</h1></div><div className="flex items-center gap-4"><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">‚úÖ {totalCorrect}</div><div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1">{ui.streak}: {streak} üî•</div><button onClick={()=>setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button></div></div></header><div className="flex-1 flex flex-col">{view==='dashboard'?(<Dashboard lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice}/>):(<PracticeView lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{history,topic,level}} actions={{goBack:quitPractice,retry:()=>fetchQuestion(topic,level,lang)}} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect}/>)}</div><footer className="w-full py-6 text-gray-400 text-xs text-center border-t border-gray-200 font-medium flex justify-center items-center gap-4"><span>Created by: Charles Mejilla, 2026</span><button onClick={()=>setLang(l=>l==='sv'?'en':'sv')} className="text-sm font-semibold text-gray-600 hover:text-primary-600 transition-colors">{lang==='sv'?'üá∏üá™ Svenska':'üá¨üáß English'}</button></footer></div>);}
        const root=ReactDOM.createRoot(document.getElementById('root'));root.render(<App/>);
    </script>
</body>
</html>

// FILE END: backup_UI.html

// =======================================================
// FILE START: bundle_project.ts
// =======================================================

/**
 * AI CONTEXT BUNDLER
 * Purpose: Flattens a React project into a single text file for AI analysis.
 * Usage: node bundle_project.js
 * Output: project_context.txt
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration: Folders and Extensions to include
const CONFIG = {
  rootDir: '.',
  outputFile: 'project_context.txt',
  includeExtensions: ['.js', '.jsx', '.ts', '.tsx', '.css', '.html', '.json'],
  excludeDirs: ['node_modules', '.git', 'dist', 'build', '.vscode']
};

function getFiles(dir) {
  const subdirs = fs.readdirSync(dir);
  const files = [];

  subdirs.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (!CONFIG.excludeDirs.includes(file)) {
        files.push(...getFiles(fullPath));
      }
    } else {
      if (CONFIG.includeExtensions.includes(path.extname(file))) {
        files.push(fullPath);
      }
    }
  });

  return files;
}

function bundle() {
  console.log('üì¶ Starting Project Bundle...');
  const allFiles = getFiles(CONFIG.rootDir);
  let output = `PROJECT EXPORT GENERATED AT ${new Date().toISOString()}\n\n`;

  // 1. Generate File Tree
  output += "--- FILE STRUCTURE ---\n";
  allFiles.forEach(f => {
    // Only show relative paths
    output += `${path.relative(CONFIG.rootDir, f)}\n`;
  });
  output += "\n" + "=".repeat(50) + "\n\n";

  // 2. Dump File Contents
  allFiles.forEach(filePath => {
    // Skip the bundle script itself and the output file
    if (filePath.includes('bundle_project.js') || filePath.includes(CONFIG.outputFile)) return;
    if (filePath.includes('package-lock.json')) return; // Too verbose

    const relativePath = path.relative(CONFIG.rootDir, filePath);
    const content = fs.readFileSync(filePath, 'utf8');

    output += `\n// =======================================================\n`;
    output += `// FILE START: ${relativePath}\n`;
    output += `// =======================================================\n\n`;
    output += content;
    output += `\n\n// FILE END: ${relativePath}\n`;
  });

  fs.writeFileSync(CONFIG.outputFile, output);
  console.log(`‚úÖ Success! Bundled ${allFiles.length} files into '${CONFIG.outputFile}'`);
  console.log(`üöÄ Upload this file to your AI assistant.`);
}

bundle();

// FILE END: bundle_project.ts

// =======================================================
// FILE START: create_context.js
// =======================================================

const fs = require('fs');
const path = require('path');

// List of all critical files to include in the context
const files = [
    'README.md',
    'package.json',
    'tsconfig.json',
    'vercel.json',
    'api/answer.ts',
    'api/question.ts',
    'public/index.html',
    'src/core/types/generator.ts',
    'src/core/utils/i18n.ts',
    'src/core/utils/random.ts',
    'src/core/utils/security.ts',
    'src/core/utils/textEngine.ts',
    'src/core/rules/ProgressionRules.ts',
    'src/core/generators/ScaleGenerator.ts',
    'src/core/generators/GeometryGenerator.ts',
    'src/core/generators/LinearEquationGen.ts',
    'src/core/generators/LinearGraphGenerator.ts',
    'src/core/generators/ExpressionSimplificationGen.ts',
    'src/core/generators/LinearEquationProblemGen.ts'
];

const outputFile = 'AI_CONTEXT.md';
let output = "# Anpassa Project Context\n\n";

output += content;
            output += "\n```\n\n";
            console.log(`‚úÖ Added ${filePath}`);
        } else {
            console.warn(`‚ö†Ô∏è  File not found: ${filePath}`);
        }
    } catch (err) {
        console.error(`‚ùå Error reading ${filePath}:`, err.message);
    }
});

// Write the result to AI_CONTEXT.md
fs.writeFileSync(outputFile, output);
console.log(`\nüéâ Success! All files concatenated into ${outputFile}`);

// FILE END: create_context.js

// =======================================================
// FILE START: dev-server.ts
// =======================================================

import express, { Request, Response } from 'express';
import cors from 'cors';
import { register } from 'tsconfig-paths';
import path from 'path';

// 1. Register Path Aliases (@core/*) from tsconfig
// This ensures the backend logic can find files in src/core
import tsConfig from './tsconfig.json' assert { type: "json" };

const baseUrl = path.resolve(process.cwd(), tsConfig.compilerOptions.baseUrl || '.');
const cleanup = register({
  baseUrl,
  paths: tsConfig.compilerOptions.paths,
});

// 2. Import API Handlers
// We import these AFTER registering paths so they resolve correctly
import questionHandler from './api/question';
import answerHandler from './api/answer';
import curriculumHandler from './api/curriculum';

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// 3. Vercel -> Express Adapter
// Vercel functions are (req, res) => void, which matches Express,
// but we wrap them to ensure errors are caught.
const adapter = (handler: any) => async (req: Request, res: Response) => {
    try {
        await handler(req, res);
    } catch (err) {
        console.error("API Error:", err);
        res.status(500).json({ error: 'Internal Server Error', details: String(err) });
    }
};

// 4. Define Routes
// These must match the filenames in your /api folder
app.get('/api/question', adapter(questionHandler));
app.post('/api/answer', adapter(answerHandler));
app.get('/api/curriculum', adapter(curriculumHandler));

// 5. Start Server
app.listen(PORT, () => {
    console.log(`\nüöÄ Backend Simulation running at http://localhost:${PORT}`);
    console.log(`   - /api/question`);
    console.log(`   - /api/answer`);
    console.log(`   - /api/curriculum`);
    console.log(`\nüé® Frontend running at http://localhost:5173 (Proxy active)\n`);
});

// FILE END: dev-server.ts

// =======================================================
// FILE START: index.html
// =======================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <title>Anpassa | Math Platform</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// FILE END: index.html

// =======================================================
// FILE START: package.json
// =======================================================

{
  "name": "anpassa-math-platform",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"vite\"",
    "dev:frontend": "vite",
    "dev:server": "tsx watch dev-server.ts",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "katex": "^0.16.9",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.24",
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vercel/node": "^5.5.28",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "concurrently": "^8.2.2",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.7.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.6"
  }
}


// FILE END: package.json

// =======================================================
// FILE START: postcss.config.js
// =======================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// FILE END: postcss.config.js

// =======================================================
// FILE START: src\App.jsx
// =======================================================

import React, { useState, useEffect } from 'react';
import Dashboard from './components/views/Dashboard';
import PracticeView from './components/views/PracticeView';
import DoNowConfig from './components/views/DoNowConfig';
import DoNowGrid from './components/views/DoNowGrid';
import AboutModal from './components/modals/AboutModal';
import LgrModal from './components/modals/LgrModal';
import StatsModal from './components/modals/StatsModal';
import StreakModal from './components/modals/StreakModal'; // Ensure this exists
import MobileDrawer from './components/practice/MobileDrawer';
import { UI_TEXT, CATEGORIES, LEVEL_DESCRIPTIONS } from './constants/localization';

function App() {
    const [view, setView] = useState('dashboard'); // 'dashboard', 'practice', 'donow_config', 'donow_grid'
    const [lang, setLang] = useState('sv');
    const [topic, setTopic] = useState('');
    const [level, setLevel] = useState(0);

    const [question, setQuestion] = useState(null);
    const [input, setInput] = useState('');
    const [feedback, setFeedback] = useState(null);
    const [loading, setLoading] = useState(false);

    // Session Stats
    const [streak, setStreak] = useState(0);
    const [totalCorrect, setTotalCorrect] = useState(0);
    const [sessionStats, setSessionStats] = useState({
        attempted: 0,
        correctNoHelp: 0,
        correctHelp: 0,
        incorrect: 0,
        skipped: 0,
        maxStreak: 0
    });
    
    const [granularStats, setGranularStats] = useState({});
    const [history, setHistory] = useState([]);
    const [revealedClues, setRevealedClues] = useState([]);
    const [levelUpAvailable, setLevelUpAvailable] = useState(false);
    const [aboutOpen, setAboutOpen] = useState(false);
    const [statsOpen, setStatsOpen] = useState(false);
    const [timeUpOpen, setTimeUpOpen] = useState(false);
    const [lgrOpen, setLgrOpen] = useState(false);

    // Do Now State
    const [doNowQuestions, setDoNowQuestions] = useState([]);

    // Modals State
    const [showStreakModal, setShowStreakModal] = useState(false);
    const [showTotalModal, setShowTotalModal] = useState(false);
    const [mobileHistoryOpen, setMobileHistoryOpen] = useState(false);

    const [usedHelp, setUsedHelp] = useState(false);
    const [isSolutionRevealed, setIsSolutionRevealed] = useState(false);

    // Timer State
    const [timerSettings, setTimerSettings] = useState({ duration: 0, remaining: 0, isActive: false });

    const ui = UI_TEXT[lang];

    // Timer Logic
    useEffect(() => {
        let interval = null;
        if (timerSettings.isActive && timerSettings.remaining > 0 && view === 'practice') {
            interval = setInterval(() => {
                setTimerSettings(prev => {
                    if (prev.remaining <= 1) {
                        clearInterval(interval);
                        setTimeUpOpen(true);
                        return { ...prev, remaining: 0, isActive: false };
                    }
                    return { ...prev, remaining: prev.remaining - 1 };
                });
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [timerSettings.isActive, view, timerSettings.remaining]);

    const toggleTimer = (minutes) => {
        const seconds = minutes * 60;
        setTimerSettings({ duration: seconds, remaining: seconds, isActive: minutes > 0 });
    };

    const resetTimer = () => {
        setTimerSettings({ duration: 0, remaining: 0, isActive: false });
    };

    const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    };

    useEffect(() => {
        if (streak > sessionStats.maxStreak) {
            setSessionStats(prev => ({ ...prev, maxStreak: streak }));
        }
    }, [streak]);

    const fetchQuestion = async (t = topic, l = level, lg = lang, force = false) => {
        if (!force && (showStreakModal || showTotalModal || levelUpAvailable || timeUpOpen)) return;
        if (!t || !l) return;
        setLoading(true);
        setFeedback(null);
        setInput('');
        setRevealedClues([]);
        setUsedHelp(false);
        setIsSolutionRevealed(false);
        setLevelUpAvailable(false);
        try {
            const res = await fetch(`/api/question?topic=${t}&level=${l}&lang=${lg}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error);
            setQuestion(data);
        } catch (e) {
            console.error(e);
            setQuestion(null);
        } finally {
            setLoading(false);
        }
    };

    const startPractice = () => {
        if (topic && level) {
            setStreak(0);
            setView('practice');
            if (timerSettings.duration > 0) {
                setTimerSettings(prev => ({ ...prev, isActive: true }));
            }
            fetchQuestion(topic, level, lang);
        }
    };

    const quitPractice = () => {
        setStreak(0);
        setView('dashboard');
        setQuestion(null);
    };

    const handleDoNowGenerate = async (selected) => {
        if (selected.length === 0) return;
        setLoading(true);
        const fullConfig = [];
        for (let i = 0; i < 6; i++) {
            fullConfig.push(selected[i % selected.length]);
        }
        try {
            const res = await fetch('/api/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ config: fullConfig, lang })
            });
            const data = await res.json();
            if (data.questions) {
                setDoNowQuestions(data.questions);
                setView('donow_grid');
            }
        } catch (e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    };

    const handleSelection = (t, l) => { setTopic(t); setLevel(l); };

    const handleHint = () => {
        if (question?.clues) {
            setUsedHelp(true);
            const currentLen = revealedClues.length;
            if (currentLen < question.clues.length) {
                setRevealedClues([...revealedClues, question.clues[currentLen]]);
            }
        }
    };

    const handleSolution = () => {
        if (question?.clues) {
            setUsedHelp(true);
            setRevealedClues(question.clues);
            setIsSolutionRevealed(true);
            setStreak(0);
        }
    };

    const updateStats = (type) => {
        setSessionStats(prev => ({
            ...prev,
            attempted: prev.attempted + 1,
            [type]: prev[type] + 1
        }));
    };

    const updateGranularStats = (topicId, levelId, resultType) => {
        setGranularStats(prev => {
            const topicData = prev[topicId] || {};
            const levelData = topicData[levelId] || { skipped: 0, incorrect: 0, correctHelp: 0, correctNoHelp: 0 };
            return {
                ...prev,
                [topicId]: {
                    ...topicData,
                    [levelId]: {
                        ...levelData,
                        [resultType]: (levelData[resultType] || 0) + 1
                    }
                }
            };
        });
    };

    const handleSkip = () => {
        const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
        const historyText = question.renderData.latex || descText;
        setHistory(prev => [{ topic, level, correct: false, skipped: true, text: historyText, clueUsed: revealedClues.length > 0 || isSolutionRevealed, time: Date.now() }, ...prev]);
        setStreak(0);
        updateStats('skipped');
        updateGranularStats(topic, level, 'skipped');
        fetchQuestion(topic, level, lang);
    };

    const handleChangeLevel = (delta) => { 
        const newLevel = level + delta; 
        const max = Object.keys(LEVEL_DESCRIPTIONS[topic] || {}).length; 
        if (newLevel >= 1 && newLevel <= max) { 
            setStreak(0); 
            setLevel(newLevel); 
            fetchQuestion(topic, newLevel, lang, true); 
        } 
    };

    const handleSubmit = async (e, directInput) => {
        e.preventDefault();
        if (showStreakModal || showTotalModal || timeUpOpen) return;
        if (feedback === 'correct') return;
        let finalInput = directInput !== undefined ? directInput : input;
        if (!question || !finalInput) return;

        const isStatsLocked = isSolutionRevealed;
        const helpUsed = revealedClues.length > 0 || isSolutionRevealed;

        try {
            const res = await fetch('/api/answer', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ 
                    answer: finalInput, 
                    token: question.token, 
                    streak: streak, 
                    level: level, 
                    topic: topic, 
                    usedHelp: helpUsed, 
                    solutionUsed: isSolutionRevealed, 
                    attempts: question.attempts 
                }) 
            });
            const result = await res.json();
            const descText = typeof question.renderData.description === 'object' ? question.renderData.description[lang] : question.renderData.description;
            const historyText = question.renderData.latex || descText;

            if (result.correct) {
                if (!isStatsLocked) {
                    setHistory(prev => [{ topic, level, correct: true, text: historyText, clueUsed: helpUsed, time: Date.now() }, ...prev]);
                    setStreak(result.newStreak);
                    if (!helpUsed) {
                        updateStats('correctNoHelp');
                        updateGranularStats(topic, level, 'correctNoHelp');
                    } else {
                        updateStats('correctHelp');
                        updateGranularStats(topic, level, 'correctHelp');
                    }

                    const newTotal = totalCorrect + 1;
                    setTotalCorrect(newTotal);
                    if ([10, 20, 30, 40, 50].includes(newTotal)) setShowTotalModal(true);
                    if ([15, 20, 30, 40, 50].includes(result.newStreak)) setShowStreakModal(true);
                    else {
                        if (result.levelUp) setLevelUpAvailable(true);
                        setTimeout(() => {
                            if (!showTotalModal && !showStreakModal) {
                                if (!result.levelUp) fetchQuestion(topic, level, lang);
                            }
                        }, 1500);
                    }
                }
                setFeedback('correct');
            } else {
                question.attempts = (question.attempts || 0) + 1;
                if (question.attempts >= 2) {
                    handleSolution();
                    if (!isStatsLocked) {
                        updateStats('incorrect');
                        updateGranularStats(topic, level, 'incorrect');
                        setHistory(prev => [{
                            topic, level, correct: false, text: historyText, clueUsed: true, correctAnswer: result.correctAnswer || "See Solution", time: Date.now()
                        }, ...prev]);
                    }
                } else {
                    handleHint();
                }
                setFeedback('incorrect');
                setStreak(0);
            }
        } catch (e) { console.error(e); }
    };

    const toggleLang = () => setLang(prev => prev === 'sv' ? 'en' : 'sv');

    // RENDER LOGIC
    if (view === 'donow_config') {
        return <div className="min-h-screen bg-gray-50 font-sans"><DoNowConfig ui={ui} lang={lang} onBack={() => setView('dashboard')} onGenerate={handleDoNowGenerate} /></div>;
    }
    if (view === 'donow_grid') {
        return <DoNowGrid questions={doNowQuestions} ui={ui} onBack={() => setView('donow_config')} lang={lang} />;
    }

    return (
        <div className="min-h-screen flex flex-col bg-gray-50 font-sans">
            <AboutModal visible={aboutOpen} onClose={() => setAboutOpen(false)} ui={ui} />
            <LgrModal visible={lgrOpen} onClose={() => setLgrOpen(false)} ui={ui} />
            <MobileDrawer open={mobileHistoryOpen} onClose={() => setMobileHistoryOpen(false)} history={history} ui={ui} />
            <StatsModal visible={statsOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setStatsOpen(false)} title={ui.stats_title} />
            <StatsModal visible={timeUpOpen} stats={sessionStats} granularStats={granularStats} lang={lang} ui={ui} onClose={() => setTimeUpOpen(false)} title={ui.stats_times_up} />

            <header className="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3 shadow-sm">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                    <div className="flex items-center gap-4">
                        <h1 className="text-xl font-bold text-primary-700 tracking-tight cursor-pointer" onClick={quitPractice}>Anpassa</h1>
                        {view === 'dashboard' && timerSettings.remaining > 0 && (
                            <div className="hidden sm:flex bg-orange-100 text-orange-700 px-3 py-1 rounded-full text-xs font-bold items-center gap-2 border border-orange-200">
                                <span>‚è∏ {ui.timer_paused}</span>
                                <span className="font-mono text-sm">{formatTime(timerSettings.remaining)}</span>
                            </div>
                        )}
                    </div>
                    <div className="flex items-center gap-3">
                        <div className="bg-primary-100 text-primary-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-primary-200">‚úÖ {totalCorrect}</div>
                        <div className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-yellow-200">üî• {streak}</div>
                        <button onClick={toggleLang} className="px-3 py-1 rounded-md text-xs font-bold border border-slate-200 bg-white text-slate-600 hover:bg-slate-50 transition-all shadow-sm flex items-center gap-1.5" title={lang === 'sv' ? "Byt spr√•k" : "Switch Language"}>
                            <span className="text-sm">{lang === 'sv' ? 'üá∏üá™' : 'üá¨üáß'}</span><span>{lang === 'sv' ? 'SE' : 'ENG'}</span>
                        </button>
                        <button onClick={() => setStatsOpen(true)} className="p-2 text-gray-400 hover:text-primary-600 transition-colors" title={ui.stats_title}>
                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                        </button>
                        <button onClick={() => setAboutOpen(true)} className="bg-accent-500 hover:bg-accent-600 text-white font-bold py-1 px-4 text-xs rounded-full shadow-sm transition-transform transform active:scale-95">{ui.aboutBtn}</button>
                    </div>
                </div>
            </header>

            <div className="flex-1 flex flex-col">
                {view === 'dashboard' ? (
                    <Dashboard
                        lang={lang} selectedTopic={topic} selectedLevel={level} onSelect={handleSelection} onStart={startPractice} timerSettings={timerSettings} toggleTimer={toggleTimer} resetTimer={resetTimer} ui={ui} onLgrOpen={() => setLgrOpen(true)} onDoNowOpen={() => setView('donow_config')} toggleLang={toggleLang}
                    />
                ) : (
                    <PracticeView
                        lang={lang} ui={ui} question={question} loading={loading} feedback={feedback} streak={streak} input={input} setInput={setInput} handleSubmit={handleSubmit} handleHint={handleHint} handleSolution={handleSolution} handleSkip={handleSkip} handleChangeLevel={handleChangeLevel} revealedClues={revealedClues} uiState={{ history, topic, level }} actions={{ retry: (force) => fetchQuestion(topic, level, lang, force), goBack: quitPractice }} levelUpAvailable={levelUpAvailable} setLevelUpAvailable={setLevelUpAvailable} isSolutionRevealed={isSolutionRevealed} showStreakModal={showStreakModal} setShowStreakModal={setShowStreakModal} showTotalModal={showTotalModal} setShowTotalModal={setShowTotalModal} totalCorrect={totalCorrect} timerSettings={timerSettings} formatTime={formatTime} setMobileHistoryOpen={setMobileHistoryOpen}
                    />
                )}
            </div>
        </div>
    );
}

export default App;

// FILE END: src\App.jsx

// =======================================================
// FILE START: src\components\modals\AboutModal.jsx
// =======================================================

import React from 'react';

const AboutModal = ({ visible, onClose, ui }) => {
    if (!visible) return null;
    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 z-10 bg-white/80 rounded-full p-1">‚úï</button>

                <div className="mb-4 flex justify-center">
                    <div className="w-24 h-24 rounded-full overflow-hidden shadow-lg border-4 border-white ring-1 ring-gray-100">
                        <img
                            src="https://lh3.googleusercontent.com/pw/AP1GczNVvq27uV0cE5nPctXb-5OET-vV57DYHQdI9CX4ODcthn4Dw-fxwULnK5G4u2Yy_7zzmo-SPNbsYglcKsiw_Omz7Q_rWwaiVCnL3e3tgge8hpoVypu8=w2400"
                            alt="Creator"
                            className="w-full h-full object-cover"
                        />
                    </div>
                </div>

                <div className="text-center mb-6">
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.aboutTitle}</h3>
                    <p className="text-gray-600 text-sm leading-relaxed mb-6">{ui.aboutText}</p>
                    <hr className="my-4 border-gray-200" />
                    <a href="https://www.linkedin.com/in/charles-mejilla-4a2ba22b" target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 font-bold transition-colors">
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" /></svg>
                        {ui.contactLink}
                    </a>
                </div>
            </div>
        </div>
    );
};

export default AboutModal;

// FILE END: src\components\modals\AboutModal.jsx

// =======================================================
// FILE START: src\components\modals\LevelUpModal.jsx
// =======================================================

import React from 'react';

const LevelUpModal = ({ visible, ui, onNext, onStay }) => {
    if (!visible) return null;

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 relative animate-bounce-in border border-gray-100">
                <div className="text-center mb-6">
                    <div className="text-5xl mb-4">üî•</div>
                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{ui.levelUpTitle}</h3>
                    <p className="text-gray-600">{ui.levelUpDesc}</p>
                </div>
                <div className="flex flex-col gap-3">
                    <button 
                        onClick={onNext} 
                        className="w-full py-4 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                    >
                        {ui.levelUpYes}
                    </button>
                    <button 
                        onClick={onStay} 
                        className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl font-bold transition-all active:scale-95"
                    >
                        {ui.levelUpNo}
                    </button>
                </div>
                <p className="text-xs text-gray-400 text-center mt-6 italic">{ui.levelUpHint}</p>
            </div>
        </div>
    );
};

export default LevelUpModal;

// FILE END: src\components\modals\LevelUpModal.jsx

// =======================================================
// FILE START: src\components\modals\LgrModal.jsx
// =======================================================

import React, { useState, useEffect } from 'react';

const LgrModal = ({ visible, onClose, ui }) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (visible && !data) {
            setLoading(true);
            fetch('/api/curriculum')
                .then(res => res.json())
                .then(d => { setData(d); setLoading(false); })
                .catch(err => { console.error(err); setLoading(false); });
        }
    }, [visible, data]);

    if (!visible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm fade-in">
            <div className="bg-white w-full max-w-2xl max-h-[90vh] rounded-2xl shadow-2xl p-6 relative flex flex-col border-t-8 border-sky-200 overflow-hidden">
                <div className="flex justify-between items-start mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-slate-800">{data ? data.title : "Lgr22"}</h3>
                    <button onClick={onClose} className="p-2 text-slate-400 hover:text-slate-600">‚úï</button>
                </div>

                <div className="overflow-y-auto custom-scrollbar flex-1 pr-2">
                    {loading ? (
                        <div className="py-10 text-center text-slate-400">Laddar l√§roplan...</div>
                    ) : data ? (
                        <div className="space-y-8">
                            <p className="text-slate-600 italic">{data.description}</p>
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Syfte</h4>
                                <ul className="list-disc pl-5 space-y-2 text-sm text-slate-700">
                                    {data.syfte.map((s, i) => <li key={i}>{s}</li>)}
                                </ul>
                            </div>
                            <div>
                                <h4 className="font-bold text-sky-800 border-b border-sky-100 pb-2 mb-3">Centralt Inneh√•ll (√•k 7-9)</h4>
                                <div className="grid gap-6">
                                    {Object.entries(data.mapping).map(([key, section]) => (
                                        <div key={key} className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                            <h5 className="font-bold text-slate-900 mb-2 text-sm">{section.category}</h5>
                                            <ul className="list-disc pl-5 space-y-1 text-xs text-slate-600">
                                                {section.content.map((c, i) => <li key={i}>{c}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="text-center text-red-400">Kunde inte ladda informationen.</div>
                    )}
                </div>

                <div className="mt-6 pt-4 border-t border-slate-100 text-center">
                    <a href="https://www.skolverket.se" target="_blank" className="text-xs text-sky-600 hover:underline">K√§lla: Skolverket (Lgr22)</a>
                </div>
            </div>
        </div>
    );
};

export default LgrModal;

// FILE END: src\components\modals\LgrModal.jsx

// =======================================================
// FILE START: src\components\modals\StatsModal.jsx
// =======================================================

import React from 'react';
import { CATEGORIES } from '../../constants/localization';

const LevelBreakdown = ({ granularStats, ui, lang }) => {
    const topics = Object.keys(granularStats);
    if (topics.length === 0) return null;

    return (
        <div className="mt-6 border-t border-gray-100 pt-4 w-full">
            <h4 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-4">
                {ui.level_breakdown}
            </h4>
            <div className="space-y-4">
                {topics.map(topicKey => {
                    const topicLevels = granularStats[topicKey];
                    const levels = Object.keys(topicLevels).sort((a, b) => Number(a) - Number(b));

                    let topicLabel = topicKey;
                    for (const catKey in CATEGORIES) {
                        const found = CATEGORIES[catKey].topics.find(t => t.id === topicKey);
                        if (found) {
                            topicLabel = found.label[lang];
                            break;
                        }
                    }

                    return (
                        <div key={topicKey} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                            <h5 className="font-bold text-gray-700 text-sm mb-2 capitalize">{topicLabel}</h5>
                            <div className="space-y-2">
                                {levels.map(lvl => {
                                    const stats = topicLevels[lvl];
                                    const total = stats.skipped + stats.incorrect + stats.correctHelp + stats.correctNoHelp;
                                    if (total === 0) return null;

                                    const pSkip = (stats.skipped / total) * 100;
                                    const pWrong = (stats.incorrect / total) * 100;
                                    const pHelp = (stats.correctHelp / total) * 100;
                                    const pCorrect = (stats.correctNoHelp / total) * 100;
                                    const unassistedPct = Math.round(pCorrect);

                                    return (
                                        <div key={lvl} className="flex flex-col gap-1 mb-3 last:mb-0">
                                            <div className="flex justify-between items-center text-xs font-medium text-gray-500 mb-1">
                                                <span>{lang === 'sv' ? 'Niv√•' : 'Level'} {lvl}</span>
                                            </div>
                                            <div className="flex w-full h-3 rounded-full overflow-hidden bg-gray-200">
                                                {pSkip > 0 && <div style={{ width: `${pSkip}%` }} className="bg-gray-400" />}
                                                {pWrong > 0 && <div style={{ width: `${pWrong}%` }} className="bg-red-500" />}
                                                {pHelp > 0 && <div style={{ width: `${pHelp}%` }} className="bg-yellow-400" />}
                                                {pCorrect > 0 && <div style={{ width: `${pCorrect}%` }} className="bg-green-500" />}
                                            </div>
                                            <div className="flex flex-wrap gap-x-3 text-[10px] text-gray-500 mt-1">
                                                <span className="text-gray-500 font-semibold">{ui.stat_skip}: {stats.skipped}</span>
                                                <span className="text-red-600 font-semibold">{ui.stat_wrong}: {stats.incorrect}</span>
                                                <span className="text-yellow-600 font-semibold">{ui.stat_help}: {stats.correctHelp}</span>
                                                <span className="text-green-600 font-semibold">{ui.stat_correct}: {stats.correctNoHelp}</span>
                                            </div>
                                            <div className="text-[10px] text-gray-400 italic">
                                                {ui.stat_total}: {total} ({unassistedPct}% unassisted)
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

const StatsModal = ({ visible, stats, granularStats, ui, onClose, title, lang }) => {
    if (!visible) return null;
    const attemptCount = stats.attempted || 0;
    const getPct = (val) => attemptCount > 0 ? Math.round((val / attemptCount) * 100) : 0;

    return (
        <div className="fixed inset-0 z-[100] flex sm:items-center justify-center sm:p-4 bg-white sm:bg-black/50 sm:backdrop-blur-sm fade-in">
            <div className="bg-white w-full h-full sm:h-auto sm:max-h-[90vh] sm:rounded-2xl sm:shadow-2xl sm:max-w-md p-6 relative flex flex-col sm:border-4 sm:border-blue-500 overflow-y-auto custom-scrollbar">
                <div className="flex justify-between items-center mb-6 shrink-0">
                    <h3 className="text-2xl font-bold text-gray-900">{title || ui.stats_title}</h3>
                    <button onClick={onClose} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 sm:hidden">‚úï</button>
                </div>

                <div className="shrink-0 grid grid-cols-2 gap-4 text-left text-sm mb-6">
                    <div className="text-gray-500">{ui.stats_longest_streak}</div>
                    <div className="font-bold text-right">{stats.maxStreak} üî•</div>
                    <div className="text-gray-500">{ui.stats_attempted}</div>
                    <div className="font-bold text-right">{stats.attempted}</div>
                    <div className="text-gray-500">{ui.stats_correct_no_help}</div>
                    <div className="font-bold text-right text-green-600">{stats.correctNoHelp} ({getPct(stats.correctNoHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_correct_help}</div>
                    <div className="font-bold text-right text-yellow-600">{stats.correctHelp} ({getPct(stats.correctHelp)}%)</div>
                    <div className="text-gray-500">{ui.stats_incorrect}</div>
                    <div className="font-bold text-right text-red-600">{stats.incorrect} ({getPct(stats.incorrect)}%)</div>
                    <div className="text-gray-500">{ui.stats_skipped}</div>
                    <div className="font-bold text-right text-gray-400">{stats.skipped}</div>
                </div>

                <LevelBreakdown granularStats={granularStats} ui={ui} lang={lang} />

                <button onClick={onClose} className="mt-8 w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg shrink-0 hidden sm:block">
                    {ui.stats_close}
                </button>
            </div>
        </div>
    );
};

export default StatsModal;

// FILE END: src\components\modals\StatsModal.jsx

// =======================================================
// FILE START: src\components\modals\StreakModal.jsx
// =======================================================

import React from 'react';

const StreakModal = ({ visible, streak, ui, onClose }) => {
    if (!visible) return null;

    let icon = "ü•â";
    if (streak >= 50) icon = "üëë";
    else if (streak >= 40) icon = "üèÜ";
    else if (streak >= 30) icon = "ü•á";
    else if (streak >= 20) icon = "ü•à";
    else if (streak >= 15) icon = "ü•â";

    return (
        <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
            <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full p-8 relative animate-bounce-in border-4 border-yellow-400 text-center">
                <div className="text-6xl mb-4 animate-pulse">{icon}</div>
                <h3 className="text-2xl font-bold text-gray-900 mb-2">{ui.streak_modal_title}</h3>
                <p className="text-lg text-gray-600 mb-6">{ui.streak_modal_msg.replace('{streak}', streak)}</p>
                <button 
                    onClick={onClose} 
                    className="w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-white rounded-xl font-bold shadow-md transition-all active:scale-95 text-lg"
                >
                    {ui.btn_close_streak}
                </button>
            </div>
        </div>
    );
};

export default StreakModal;

// FILE END: src\components\modals\StreakModal.jsx

// =======================================================
// FILE START: src\components\practice\CluePanel.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const CluePanel = ({ revealedClues, question, ui, isSolutionRevealed }) => {
    if (!revealedClues || revealedClues.length === 0) return null;

    // We need the total count to identify which clue is the "final" one
    const totalCluesCount = question.clues ? question.clues.length : 0;

    return (
        <div className="bg-orange-50 border border-orange-200 rounded-xl p-5 shadow-sm mb-4 animate-fade-in">
            <div className="flex items-center gap-2 mb-4 text-orange-800 font-bold border-b border-orange-200 pb-2">
                <span>üí° {ui.hintsTitle} ({revealedClues.length}/{totalCluesCount})</span>
            </div>
            <div className="space-y-6">
                {revealedClues.map((clue, i) => {
                    // Identify if this is the absolute last clue in the sequence
                    const isTheFinalClue = i === totalCluesCount - 1;
                    
                    // RESTORED LOGIC: 
                    // Hide the latex box for the final clue unless the solution is unlocked.
                    // This forces the student to perform the final step themselves.
                    const showLatex = !isTheFinalClue || isSolutionRevealed;

                    return (
                        <div key={i} className="group animate-slide-down">
                            {/* 1. Text Description (Always shown) */}
                            <div className="text-sm text-orange-900 mb-2 font-medium leading-relaxed">
                                <MathText text={clue.text} />
                            </div>
                            
                            {/* 2. Math Box (Conditional) */}
                            {clue.latex && showLatex && (
                                <div className="bg-white p-3 rounded-lg border border-orange-200 text-center shadow-sm overflow-x-auto mt-2">
                                    <MathText text={`$${clue.latex}$`} large={true} />
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default CluePanel;

// FILE END: src\components\practice\CluePanel.jsx

// =======================================================
// FILE START: src\components\practice\HistoryList.jsx
// =======================================================

import React from 'react';
import MathText from '../ui/MathText';

const HistoryList = ({ history, ui }) => {
    return (
        <div className="flex flex-col h-full bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                <h2 className="font-bold text-gray-700">{ui.history}</h2>
                <span className="text-xs text-gray-400">{history.length}</span>
            </div>
            <div className="flex-1 overflow-y-auto p-4 space-y-3 max-h-[500px] custom-scrollbar">
                {history.length === 0 ? (
                    <p className="text-gray-400 text-center text-sm py-4">{ui.noHistory}</p>
                ) : (
                    history.map((entry, i) => (
                        <div 
                            key={i} 
                            className={`p-3 rounded-lg border-l-4 text-sm ${
                                entry.correct 
                                    ? 'border-emerald-500 bg-emerald-50' 
                                    : (entry.skipped ? 'border-gray-400 bg-gray-50' : 'border-red-500 bg-red-50')
                            }`}
                        >
                            <div className="flex justify-between items-start mb-1">
                                <span className="font-semibold capitalize text-gray-700">
                                    {entry.topic} <span className="text-xs font-normal text-gray-500">(Lvl {entry.level})</span>
                                </span>
                                <span className="text-xs text-gray-400">
                                    {new Date(entry.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                            </div>
                            
                            <div className="text-gray-600 mb-1 line-clamp-2">
                                <MathText text={entry.text} />
                            </div>

                            {!entry.correct && !entry.skipped && entry.correctAnswer && (
                                <div className="text-xs text-red-600 mt-1 font-medium">
                                    <MathText text={`Correct: ${entry.correctAnswer}`} />
                                </div>
                            )}

                            <div className="mt-2">
                                {entry.clueUsed && (
                                    <span className="inline-block px-1.5 py-0.5 bg-orange-100 text-orange-700 text-[10px] rounded uppercase font-bold tracking-wider mr-1">
                                        {ui.clueUsed}
                                    </span>
                                )} 
                                <span className={`inline-block px-1.5 py-0.5 rounded uppercase font-bold tracking-wider text-[10px] ${
                                    entry.correct 
                                        ? 'bg-emerald-100 text-emerald-700' 
                                        : (entry.skipped ? 'bg-gray-200 text-gray-600' : 'bg-red-100 text-red-700')
                                }`}>
                                    {entry.correct ? ui.tagCorrect : (entry.skipped ? ui.tagSkipped : ui.tagWrong)}
                                </span>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default HistoryList;

// FILE END: src\components\practice\HistoryList.jsx

// =======================================================
// FILE START: src\components\practice\MobileDrawer.jsx
// =======================================================

import React from 'react';
import HistoryList from './HistoryList';

const MobileDrawer = ({ open, onClose, history, ui }) => {
    return (
        <>
            {open && <div className="fixed inset-0 bg-black/20 z-40 backdrop-blur-sm lg:hidden" onClick={onClose}></div>}
            <div className={`fixed inset-y-0 left-0 w-80 bg-white shadow-2xl transform transition-transform duration-300 z-50 flex flex-col lg:hidden ${open ? 'translate-x-0' : '-translate-x-full'}`}>
                <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                    <h2 className="font-bold text-gray-700">{ui.history}</h2>
                    <button onClick={onClose} className="text-gray-400">‚úï</button>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                    <HistoryList history={history} ui={ui} />
                </div>
            </div>
        </>
    );
};

export default MobileDrawer;

// FILE END: src\components\practice\MobileDrawer.jsx

// =======================================================
// FILE START: src\components\ui\Button.jsx
// =======================================================

import React from 'react';

export const Button = ({ 
  children, 
  onClick, 
  variant = 'primary', 
  className = '', 
  disabled = false,
  fullWidth = false 
}) => {
  const baseStyles = "px-4 py-2 rounded-lg font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-math-blue text-white hover:bg-blue-600 focus:ring-math-blue shadow-sm",
    secondary: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-gray-500",
    success: "bg-math-green text-white hover:bg-green-600 focus:ring-math-green shadow-sm",
    danger: "bg-math-red text-white hover:bg-red-600 focus:ring-math-red shadow-sm",
    ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
    >
      {children}
    </button>
  );
};

// FILE END: src\components\ui\Button.jsx

// =======================================================
// FILE START: src\components\ui\MathText.jsx
// =======================================================

import React from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css'; // Ensure CSS is imported

const MathText = ({ text, className = "", large = false }) => {
    if (!text) return null;

    // 1. Patch common LaTeX color syntax differences if necessary
    const patchedText = text.replace(/\\mathbf\{\\?textcolor\{([^}]+)\}\{([^}]+)\}\}/g, '{\\color{$1}\\mathbf{$2}}');

    // 2. Split by $ delimiters
    const parts = patchedText.split(/(\$[^\$]+\$)/g);

    return (
        <span className={className}>
            {parts.map((part, index) => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const tex = part.slice(1, -1);
                    try {
                        const html = katex.renderToString(tex, { 
                            throwOnError: false, 
                            displayMode: large 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index} className="text-red-500">{part}</span>;
                    }
                } else if (part.includes('\\')) {
                    // Catch-all for stray LaTeX without $ delimiters (legacy support)
                    try {
                        const html = katex.renderToString(part, { 
                            throwOnError: false, 
                            displayMode: false 
                        });
                        return <span key={index} dangerouslySetInnerHTML={{ __html: html }} />;
                    } catch (e) {
                        return <span key={index}>{part}</span>;
                    }
                }
                return <span key={index}>{part}</span>;
            })}
        </span>
    );
};

export default MathText;

// FILE END: src\components\ui\MathText.jsx

// =======================================================
// FILE START: src\components\views\Dashboard.jsx
// =======================================================

import React from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const Dashboard = ({ 
    lang, 
    selectedTopic, 
    selectedLevel, 
    onSelect, 
    onStart, 
    timerSettings, 
    toggleTimer, 
    resetTimer, 
    ui, 
    onLgrOpen, 
    onDoNowOpen, 
    toggleLang 
}) => {
    
    // Helper for Tailwind dynamic classes based on category color
    const getCategoryColorClass = (category, type) => {
        const colorMap = { pink: 'pink', indigo: 'indigo', emerald: 'emerald', purple: 'purple' };
        const color = colorMap[category.color] || 'emerald';
        
        switch (type) {
            case 'bg-light': return `bg-${color}-50`;
            case 'bg-dark': return `bg-${color}-500`;
            case 'border': return `border-${color}-100`;
            case 'text': return `text-${color}-700`;
            case 'ring': return `ring-${color}-500`;
            case 'border-solid': return `border-${color}-500`;
            default: return '';
        }
    };

    return (
        <div className="max-w-6xl mx-auto w-full p-4 fade-in flex flex-col min-h-[calc(100vh-80px)]">
            <div className="text-center py-10 md:py-16 border-b border-gray-200 mb-12 bg-emerald-50/50 rounded-3xl mx-4 relative overflow-hidden">
                <h1 className="text-5xl md:text-7xl font-extrabold text-gray-900 mb-4 tracking-tight relative z-10">Anpassa</h1>
                <p className="text-xl md:text-2xl text-gray-500 font-medium tracking-wide relative z-10">{ui.tagline}</p>

                {/* Timer Control */}
                <div className="mt-8 flex justify-center relative z-10">
                    <div className="bg-white/80 backdrop-blur-sm rounded-xl p-2 px-4 shadow-sm border border-gray-100 flex items-center gap-3">
                        <span className="font-bold text-gray-700 text-xs uppercase tracking-wider">{ui.timer_title}</span>
                        <div className="relative group">
                            <select
                                value={timerSettings.duration / 60}
                                onChange={(e) => toggleTimer(Number(e.target.value))}
                                className="appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-1 pl-3 pr-8 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-emerald-500 cursor-pointer"
                            >
                                <option value="0">{ui.timer_off}</option>
                                {[5, 10, 15, 20, 30, 45, 60].map(m => <option key={m} value={m}>{m} {ui.timer_min}</option>)}
                            </select>
                            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                        </div>
                        {timerSettings.duration > 0 && (
                            <button onClick={resetTimer} className="text-xs text-red-500 hover:text-red-700 font-medium underline">{ui.timer_reset}</button>
                        )}
                    </div>
                </div>
            </div>

            <div className="text-center mb-10">
                <p className="text-gray-500 text-lg leading-relaxed max-w-2xl mx-auto">{ui.progressionInfo}</p>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-20">
                {Object.entries(CATEGORIES).map(([catKey, category]) => {
                    const bgLight = getCategoryColorClass(category, 'bg-light');
                    const border = getCategoryColorClass(category, 'border');
                    const text = getCategoryColorClass(category, 'text');
                    const bgDark = getCategoryColorClass(category, 'bg-dark');
                    
                    return (
                        <div key={catKey} className={`bg-white rounded-2xl shadow-lg border border-gray-100 overflow-hidden hover:shadow-xl transition-shadow duration-300 flex flex-col h-full`}>
                            <div className={`${bgLight} p-4 border-b ${border}`}>
                                <h3 className={`text-lg font-bold ${text} uppercase tracking-wide flex items-center gap-2`}>
                                    <span className={`w-3 h-3 rounded-full ${bgDark}`}></span>{category.label[lang]}
                                </h3>
                            </div>
                            <div className="p-4 space-y-4 flex-1">
                                {category.topics.map(topic => {
                                    const ring = getCategoryColorClass(category, 'ring');
                                    const borderSolid = getCategoryColorClass(category, 'border-solid');
                                    
                                    return (
                                        <div key={topic.id} className="bg-gray-50 rounded-xl p-3 border border-gray-100">
                                            <div className="font-semibold text-gray-700 mb-3 ml-1">{topic.label[lang]}</div>
                                            <div className="relative">
                                                <select 
                                                    value={selectedTopic === topic.id ? selectedLevel : 0} 
                                                    onChange={(e) => onSelect(topic.id, Number(e.target.value))} 
                                                    className={`w-full p-2 pl-3 bg-white border border-gray-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 appearance-none cursor-pointer ${selectedTopic === topic.id ? `ring-2 ${ring} ${borderSolid}` : `focus:${ring}`}`}
                                                >
                                                    <option value={0} disabled>{ui.selectLevel}</option>
                                                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                                        if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                                        return <option key={lvl} value={lvl}>{lang === 'sv' ? `Niv√• ${lvl}` : `Level ${lvl}`} - {LEVEL_DESCRIPTIONS[topic.id]?.[lvl]?.[lang] || ""}</option>;
                                                    })}
                                                </select>
                                                <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                                                    <svg className="fill-current h-4 w-4" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" /></svg>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>

            <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none z-20">
                <button 
                    onClick={onStart} 
                    className={`px-8 py-4 rounded-full font-bold text-lg shadow-2xl transition-all transform pointer-events-auto flex items-center gap-3 ${selectedTopic ? 'bg-orange-500 text-white translate-y-0 opacity-100 hover:scale-105 hover:bg-orange-600 shadow-orange-200' : 'bg-gray-300 text-gray-500 translate-y-20 opacity-0 cursor-not-allowed'}`}
                >
                    {ui.startBtn} <span>üöÄ</span>
                </button>
            </div>

            <footer className="mt-auto py-6 border-t border-gray-200 flex flex-col md:flex-row justify-between items-center px-4 gap-4">
                <button onClick={onDoNowOpen} className="w-full md:w-auto bg-slate-800 hover:bg-slate-900 text-white font-bold py-2 px-6 rounded-full text-sm transition-colors shadow-sm order-2 md:order-1">
                    {ui.donow_btn}
                </button>

                <div className="flex items-center gap-3 order-1 md:order-2 w-full md:w-auto justify-center md:justify-end">
                    <button onClick={onLgrOpen} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-6 rounded-full text-sm transition-colors border border-sky-200 shadow-sm">
                        {ui.lgr_btn}
                    </button>
                </div>
            </footer>
        </div>
    );
};

export default Dashboard;

// FILE END: src\components\views\Dashboard.jsx

// =======================================================
// FILE START: src\components\views\DoNowConfig.jsx
// =======================================================

import React, { useState } from 'react';
import { CATEGORIES, LEVEL_DESCRIPTIONS } from '../../constants/localization';

const DoNowConfig = ({ ui, onBack, onGenerate, lang }) => {
    const [selected, setSelected] = useState([]);

    const handleToggle = (topicId, level) => {
        setSelected(prev => {
            const exists = prev.find(p => p.topic === topicId && p.level === level);
            if (exists) {
                return prev.filter(p => !(p.topic === topicId && p.level === level));
            } else {
                if (prev.length >= 3) return prev; // Max 3
                return [...prev, { topic: topicId, level }];
            }
        });
    };

    return (
        <div className="max-w-5xl mx-auto p-6 h-full flex flex-col">
            <div className="flex justify-between items-center mb-6">
                <button onClick={onBack} className="text-slate-500 hover:text-slate-800 font-bold flex items-center gap-2">
                    <span>‚Üê</span> {ui.backBtn}
                </button>
                <h2 className="text-2xl font-bold text-slate-800">{ui.donow_title}</h2>
                <button
                    onClick={() => onGenerate(selected)}
                    disabled={selected.length === 0}
                    className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all active:scale-95"
                >
                    {ui.donow_gen} ({selected.length}/3)
                </button>
            </div>

            <p className="text-slate-500 mb-6 text-center">{ui.donow_desc}</p>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-6 overflow-y-auto custom-scrollbar pb-10">
                {Object.entries(CATEGORIES).map(([catKey, category]) => (
                    <div key={catKey} className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                        <h3 className="font-bold text-slate-700 mb-3 border-b pb-2">{category.label[lang]}</h3>
                        <div className="space-y-4">
                            {category.topics.map(topic => (
                                <div key={topic.id}>
                                    <div className="text-xs font-bold text-slate-400 uppercase mb-2">{topic.label[lang]}</div>
                                    <div className="flex flex-col gap-2">
                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(lvl => {
                                            if (!LEVEL_DESCRIPTIONS[topic.id]?.[lvl]) return null;
                                            const isSelected = selected.some(s => s.topic === topic.id && s.level === lvl);
                                            return (
                                                <button
                                                    key={lvl}
                                                    onClick={() => handleToggle(topic.id, lvl)}
                                                    className={`text-sm py-2 px-3 rounded border transition-all text-left flex items-center gap-2 ${isSelected ? 'bg-indigo-100 border-indigo-500 text-indigo-700 font-bold ring-1 ring-indigo-500' : 'bg-slate-50 border-slate-200 text-slate-600 hover:border-indigo-300'}`}
                                                >
                                                    <span className="font-mono font-bold w-6 text-center bg-white/50 rounded">{lvl}</span>
                                                    <span className="truncate">{LEVEL_DESCRIPTIONS[topic.id][lvl][lang]}</span>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default DoNowConfig;

// FILE END: src\components\views\DoNowConfig.jsx

// =======================================================
// FILE START: src\components\views\DoNowGrid.jsx
// =======================================================

import React, { useState } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual, StaticGeometryVisual } from '../visuals/GeometryComponents';

const DoNowCard = ({ q, index, showAnswer, onToggle, lang }) => {
    const desc = typeof q.renderData.description === 'object' ? q.renderData.description[lang] : q.renderData.description;
    const latex = q.renderData.latex;

    // --- Adaptive Layout Logic ---
    // Hide visuals for word problems to maximize text space
    const isTextOnly = 
        (q.topic === 'equation' && (q.level === 5 || q.level === 6)) ||
        (q.topic === 'simplify' && q.level === 5);

    // --- Dynamic Text Scaling Logic (Boosted Sizes) ---
    const getDescSize = (text) => {
        if (!text) return 'text-xl md:text-3xl';
        const len = text.length;

        // Strategy: If no visual, go HUGE. If visual, go LARGE.
        if (isTextOnly) {
            if (len > 200) return 'text-base md:text-xl leading-relaxed'; // Very long story
            if (len > 100) return 'text-lg md:text-2xl leading-relaxed';  // Standard word problem
            if (len > 50) return 'text-xl md:text-3xl leading-relaxed';   // Short sentence
            return 'text-2xl md:text-4xl leading-relaxed';                 // Very short
        } else {
            if (len > 120) return 'text-sm md:text-base leading-tight';   // Tight fit with image
            if (len > 60) return 'text-base md:text-lg leading-snug';     // Medium fit
            return 'text-lg md:text-2xl leading-normal';                  // Good fit
        }
    };

    const getLatexSize = (str) => {
        if (!str) return 'text-3xl md:text-5xl';
        const len = str.length;
        
        // Equations generally need to be big to be readable from back of class
        if (len > 35) return 'text-lg md:text-2xl';   // Complex algebraic expression
        if (len > 20) return 'text-2xl md:text-4xl';  // Medium equation
        return 'text-4xl md:text-6xl';                // Short like "x + 5 = 10"
    };

    return (
        <div className="bg-white rounded-xl shadow-sm border border-slate-200 flex flex-col h-full overflow-hidden print-break-inside-avoid relative">
            <div className="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center shrink-0">
                <span className="text-xs font-bold text-slate-400 uppercase">Q{index + 1} ‚Ä¢ {q.topic} L{q.level}</span>
            </div>

            <div className={`p-4 flex-1 flex flex-col gap-2 relative min-h-0 ${isTextOnly ? 'justify-center' : ''}`}>
                
                {/* Visuals Zone - Hidden for text-only word problems */}
                {!isTextOnly && (
                    <div className="flex-1 bg-slate-50/50 rounded-lg border border-slate-100 flex items-center justify-center min-h-[120px] p-2 relative overflow-hidden">
                        <div className="scale-90 origin-center w-full flex justify-center">
                            {q.renderData.graph ? (
                                <GraphCanvas data={q.renderData.graph} />
                            ) : q.renderData.geometry ? (
                                ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(q.renderData.geometry.type)
                                    ? <VolumeVisualization data={q.renderData.geometry} />
                                    : <GeometryVisual data={q.renderData.geometry} />
                            ) : (
                                q.topic === 'geometry' ? <StaticGeometryVisual description={desc} /> :
                                    <div className="text-4xl text-slate-200 font-bold select-none opacity-20">#</div>
                            )}
                        </div>
                    </div>
                )}

                {/* Text Zone - Expands to fill space if isTextOnly is true */}
                <div className={`shrink-0 text-center space-y-3 flex flex-col justify-center py-2 ${isTextOnly ? 'flex-1' : ''}`}>
                    {latex && (
                        <div className={`${getLatexSize(latex)} font-mono text-slate-900 font-bold tracking-wider`}>
                            <MathText text={`$${latex}$`} large={false} />
                        </div>
                    )}
                    {desc && (
                        <div className={`${getDescSize(desc)} font-medium text-slate-700 max-w-prose mx-auto transition-all`}>
                            <MathText text={desc} />
                        </div>
                    )}
                </div>

                {/* Answer Overlay - Also scaled up */}
                <div className={`absolute inset-0 bg-white/95 backdrop-blur-sm z-10 flex items-center justify-center transition-opacity duration-300 ${showAnswer ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                    <div className="text-center transform scale-110">
                        <div className="text-base text-slate-400 uppercase font-bold mb-2">Facit</div>
                        <div className="text-5xl font-bold text-emerald-600 font-mono px-4 break-all">
                            {q.displayAnswer}
                        </div>
                    </div>
                </div>
            </div>

            <button
                onClick={onToggle}
                className="w-full py-4 bg-slate-50 hover:bg-slate-100 border-t border-slate-100 text-sm font-bold text-slate-500 transition-colors shrink-0 z-20"
            >
                {showAnswer ? (lang === 'sv' ? "D√∂lj" : "Hide") : (lang === 'sv' ? "Visa svar" : "Show Answer")}
            </button>
        </div>
    );
};

const DoNowGrid = ({ questions, ui, onBack, lang }) => {
    const [revealed, setRevealed] = useState({});
    const [showAll, setShowAll] = useState(false);

    const toggleOne = (idx) => {
        setRevealed(prev => ({ ...prev, [idx]: !prev[idx] }));
    };

    const toggleAll = () => {
        if (showAll) {
            setRevealed({});
            setShowAll(false);
        } else {
            const all = {};
            questions.forEach((_, i) => all[i] = true);
            setRevealed(all);
            setShowAll(true);
        }
    };

    return (
        <div className="h-screen flex flex-col bg-slate-100">
            <header className="bg-white border-b border-slate-200 px-6 py-3 flex justify-between items-center shadow-sm z-20">
                <button onClick={onBack} className="flex items-center gap-2 text-slate-600 font-bold hover:text-slate-900">
                    <span>‚Üê</span> {ui.donow_title}
                </button>
                <div className="flex gap-4">
                    <button onClick={toggleAll} className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg font-bold text-sm transition-colors">
                        {showAll ? ui.donow_hide_all : ui.donow_show_all}
                    </button>
                </div>
            </header>
            <div className="flex-1 p-6 overflow-y-auto">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 h-full auto-rows-fr">
                    {questions.map((q, i) => (
                        <DoNowCard
                            key={i}
                            index={i}
                            q={q}
                            showAnswer={!!revealed[i]}
                            onToggle={() => toggleOne(i)}
                            lang={lang}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
};

export default DoNowGrid;

// FILE END: src\components\views\DoNowGrid.jsx

// =======================================================
// FILE START: src\components\views\PracticeView.jsx
// =======================================================

import React, { useState, useEffect, useRef } from 'react';
import MathText from '../ui/MathText';
import { GraphCanvas, VolumeVisualization, GeometryVisual, StaticGeometryVisual } from '../visuals/GeometryComponents';
import CluePanel from '../practice/CluePanel';
import HistoryList from '../practice/HistoryList';
import LevelUpModal from '../modals/LevelUpModal';
import StreakModal from '../modals/StreakModal'; // Assuming these exist in your project structure
import { LEVEL_DESCRIPTIONS } from '../../constants/localization'; // Updated import path

const PracticeView = ({ 
    lang, 
    ui, 
    question, 
    loading, 
    feedback, 
    streak, 
    input, 
    setInput, 
    handleSubmit, 
    handleHint, 
    handleSolution, 
    handleSkip, 
    handleChangeLevel, 
    revealedClues, 
    uiState, 
    actions, 
    levelUpAvailable, 
    setLevelUpAvailable, 
    isSolutionRevealed, 
    showStreakModal, 
    setShowStreakModal, 
    showTotalModal, 
    setShowTotalModal, 
    totalCorrect, 
    timerSettings, 
    formatTime, 
    setMobileHistoryOpen 
}) => {
    const [scaleInputLeft, setScaleInputLeft] = useState('');
    const [scaleInputRight, setScaleInputRight] = useState('');
    const inputRef = useRef(null);

    const descriptionText = typeof question?.renderData?.description === 'object' ? question.renderData.description[lang] : question?.renderData?.description;
    
    const handleChoiceClick = (choice) => { 
        if (feedback === 'correct') return; 
        setInput(choice); 
        handleSubmit({ preventDefault: () => { } }, choice); 
    };
    
    const handleFormSubmit = (e) => {
        if (question.renderData.answerType === 'scale') {
            const combined = `${scaleInputLeft}:${scaleInputRight}`;
            handleSubmit(e, combined);
        } else {
            handleSubmit(e, input);
        }
    };

    // Mobile-safe focus logic
    useEffect(() => {
        if (question) {
            setScaleInputLeft('');
            setScaleInputRight('');
            window.scrollTo({ top: 0, behavior: 'smooth' });
            const isMobile = window.innerWidth < 768;
            if (!isMobile && inputRef.current) {
                inputRef.current.focus();
            }
        }
    }, [question]);

    const maxLevels = Object.keys(LEVEL_DESCRIPTIONS[uiState.topic] || {}).length;

    return (
        <div className="flex-1 max-w-7xl mx-auto w-full p-4 sm:p-6 flex flex-col lg:flex-row gap-8 items-start fade-in">
            
            <LevelUpModal 
                visible={levelUpAvailable} 
                ui={ui} 
                onNext={() => { 
                    handleChangeLevel(1); 
                    setLevelUpAvailable(false); 
                }} 
                onStay={() => { 
                    setLevelUpAvailable(false); 
                    actions.retry(true); // Force fetch
                }} 
            />

            {/* If StreakModal component is available, render it here */}
            
            <div className="flex-1 w-full min-w-0">
                {/* HEADER BAR */}
                <div className="flex justify-between items-center mb-6 bg-white p-3 rounded-xl shadow-sm border border-gray-100">
                    <button onClick={actions.goBack} className="flex items-center gap-2 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold text-sm px-4 py-2 rounded-lg shadow-sm border border-gray-300 transition-all active:scale-95"><span>‚Üê</span> {ui.backBtn}</button>

                    <div className="flex items-center gap-3">
                        {timerSettings.duration > 0 && (
                            <div className={`font-mono text-sm font-bold px-3 py-1.5 rounded-lg border hidden sm:block ${timerSettings.remaining < 60 ? 'bg-red-50 text-red-600 border-red-200 animate-pulse' : 'bg-white text-gray-700 border-gray-200'}`}>
                                {formatTime(timerSettings.remaining)}
                            </div>
                        )}

                        <div className="flex items-center gap-2 bg-gray-50 rounded-lg p-1 border border-gray-200">
                            <button onClick={() => handleChangeLevel(-1)} disabled={uiState.level <= 1} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.prevLevel}>&lt;</button>
                            <span className="text-xs font-bold uppercase tracking-wider text-gray-500 min-w-[80px] text-center">{uiState.topic} ‚Ä¢ Lvl {uiState.level}</span>
                            <button onClick={() => handleChangeLevel(1)} disabled={uiState.level >= maxLevels} className="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm disabled:opacity-30 disabled:cursor-not-allowed transition-all text-gray-600 font-bold" title={ui.nextLevel}>&gt;</button>
                        </div>

                        <button onClick={() => setMobileHistoryOpen(true)} className="lg:hidden p-2 bg-gray-100 rounded-lg text-gray-500 hover:bg-gray-200 transition-colors">
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                    </div>
                </div>

                <main className="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 relative">
                    {loading ? (
                        <div className="p-20 text-center flex flex-col items-center gap-4">
                            <div className="w-10 h-10 border-4 border-primary-200 border-t-primary-600 rounded-full animate-spin"></div>
                        </div>
                    ) : question ? (
                        <div className="p-4 sm:p-6">
                            <div className="mb-4 flex justify-center bg-gray-50 rounded-xl p-4 min-h-[160px] items-center border border-gray-100 relative">
                                {question.renderData.graph ? (
                                    <GraphCanvas data={question.renderData.graph} />
                                ) : question.renderData.geometry ? (
                                    ['cuboid', 'triangular_prism', 'pyramid', 'sphere', 'hemisphere', 'ice_cream', 'cone', 'cylinder', 'silo'].includes(question.renderData.geometry.type)
                                        ? <VolumeVisualization data={question.renderData.geometry} />
                                        : <GeometryVisual data={question.renderData.geometry} />
                                ) : (
                                    <div className="flex flex-col items-center justify-center w-full">
                                        {uiState.topic === 'geometry' && <StaticGeometryVisual description={descriptionText} />}
                                        {question.renderData.latex && <div className="text-2xl sm:text-4xl font-mono text-gray-800 my-4 text-center"><MathText text={`$${question.renderData.latex}$`} large={true} /></div>}
                                    </div>
                                )}
                            </div>
                            
                            <div className="mb-4 text-center"><h2 className="text-lg sm:text-xl font-medium text-gray-700 leading-relaxed"><MathText text={descriptionText} /></h2></div>
                            
                            {question.renderData.answerType === 'multiple_choice' ? (
                                <div className="max-w-md mx-auto grid grid-cols-2 gap-4">
                                    {question.renderData.choices.map((choice, idx) => (
                                        <button key={idx} onClick={() => handleChoiceClick(choice)} className={`py-4 rounded-xl font-bold text-lg shadow-sm transition-all active:scale-95 border-2 ${feedback === 'correct' && choice === input ? 'bg-green-500 border-green-500 text-white' : feedback === 'incorrect' && choice === input ? 'bg-red-500 border-red-500 text-white' : 'bg-white border-gray-200 text-gray-700 hover:border-accent-500 hover:text-accent-600'}`} disabled={feedback === 'correct'}>{choice}</button>
                                    ))}
                                </div>
                            ) : (
                                <form onSubmit={handleFormSubmit} className="max-w-md mx-auto space-y-4">
                                {question.renderData.answerType === 'scale' ? (
                                    <div className="flex items-center justify-center gap-2">
                                        <input type="text" value={scaleInputLeft} onChange={(e) => setScaleInputLeft(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} />
                                        <span className="text-2xl font-bold text-gray-400">:</span>
                                        <input type="text" value={scaleInputRight} onChange={(e) => setScaleInputRight(e.target.value)} className={`w-24 p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder="X" disabled={feedback === 'correct'} />
                                    </div>
                                ) : (
                                    <div className="relative">
                                        <input ref={inputRef} type="text" value={input} onChange={(e) => setInput(e.target.value)} className={`w-full p-4 text-center text-xl font-medium border-2 rounded-xl outline-none transition-all shadow-sm ${feedback === 'correct' ? 'border-primary-500 bg-primary-50 text-primary-700' : feedback === 'incorrect' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 focus:border-accent-500 focus:ring-4 focus:ring-accent-50'}`} placeholder={ui.placeholder} disabled={feedback === 'correct'} />
                                    </div>
                                )}
                                <button type="submit" className={`w-full py-4 rounded-xl font-bold text-lg text-white shadow-md transition-all active:scale-95 ${feedback === 'correct' ? 'bg-primary-500 shadow-green-200 cursor-default' : 'bg-accent-500 hover:bg-accent-600 shadow-orange-200 hover:shadow-lg'}`}>{feedback === 'correct' ? ui.correct : feedback === 'incorrect' ? ui.incorrect : ui.submit}</button>
                                </form>
                            )}

                            <div className="mt-6 flex gap-3 justify-center flex-wrap">
                                <button type="button" onClick={handleHint} disabled={!question.clues || revealedClues.length >= question.clues.length} className="px-4 py-2 text-sm font-semibold rounded-lg bg-accent-50 text-accent-700 border border-accent-200 hover:bg-accent-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"><span>üí°</span> {ui.btnHint}</button>
                                <button type="button" onClick={handleSolution} disabled={!question.clues || isSolutionRevealed} className="px-4 py-2 text-sm font-semibold rounded-lg bg-gray-50 text-gray-600 border border-gray-200 hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">{ui.btnSolution}</button>
                                <button type="button" onClick={handleSkip} className="px-4 py-2 text-sm font-semibold rounded-lg bg-blue-50 text-blue-600 border border-blue-200 hover:bg-blue-100 transition-colors flex items-center gap-2"><span>‚è≠Ô∏è</span> {ui.btnSkip}</button>
                            </div>
                        </div>
                    ) : (
                        <div className="p-12 text-center text-red-400">
                            <p>{ui.error}</p>
                            <button onClick={() => actions.retry(true)} className="text-indigo-600 underline text-sm mt-2">Retry</button>
                        </div>
                    )}
                </main>
            </div>
            
            <div className="lg:w-80 w-full shrink-0 flex flex-col gap-4 hidden lg:flex">
                <CluePanel revealedClues={revealedClues} question={question} ui={ui} isSolutionRevealed={isSolutionRevealed} />
                <div className="flex-1 min-h-0"><HistoryList history={uiState.history} ui={ui} /></div>
            </div>
        </div>
    );
};

export default PracticeView;

// FILE END: src\components\views\PracticeView.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryComponents.jsx
// =======================================================

import React, { useRef, useEffect } from 'react';

// ----------------------------------------------------------------------
// 2D GEOMETRY VISUAL (Triangles, Circles, Polygons)
// ----------------------------------------------------------------------
export const GeometryVisual = ({ data }) => {
    if (!data) return null;
    
    // Updated Container: Supports custom width/height props and dynamic maxWidth
    const SvgContainer = ({ children, w = 300, h = 200, viewBox = "0 0 300 200" }) => (
        <svg width={w} height={h} viewBox={viewBox} className="my-2 w-full mx-auto" style={{ maxWidth: `${w}px` }}>
            {children}
        </svg>
    );
    
    const mkTxt = (x, y, txt, anchor="middle", baseline="middle", color="#374151") => 
        <text x={x} y={y} textAnchor={anchor} dominantBaseline={baseline} fontWeight="bold" fill={color} fontSize="20">{txt}</text>;

    // Angle Arc Helper (Restored for Similarity Level 1)
    const AngleArc = ({ x, y, startAngle, endAngle, label }) => {
        const r = 25;
        return (
            <g>
                <circle cx={x} cy={y} r={r} fill="none" stroke="#ef4444" strokeWidth="2" strokeDasharray={`${r*1.5}, 1000`} transform={`rotate(${startAngle}, ${x}, ${y})`} />
                {label && <text x={x + (startAngle === 0 ? 10 : -10)} y={y + (startAngle > 0 ? -35 : 35)} textAnchor="middle" fontSize="14" fill="#dc2626" fontWeight="bold">{label}</text>}
            </g>
        );
    };

    const RenderShape = ({ type, dims, labels, areaText, offsetX = 0, offsetY = 0, scale = 1 }) => {
        const cx = 150 + offsetX;
        const cy = 100 + offsetY;
        
        const baseScale = (120 / (Math.max(dims.width || 0, dims.height || 0, (dims.radius || 0)*2) || 1)) * scale;

        const sw = (dims.width || 0) * baseScale;
        const sh = (dims.height || 0) * baseScale;
        const sr = (dims.radius || 0) * baseScale;

        // Extract labels safely
        const l_b = labels?.b || labels?.base || labels?.width || labels?.w;
        const l_h = labels?.h || labels?.height;
        const l_s1 = labels?.s1;
        const l_s2 = labels?.s2;
        const l_hyp = labels?.hypotenuse;

        if (type === 'rectangle' || type === 'square' || type === 'parallelogram') {
            return (
                <g>
                    <rect x={cx - sw / 2} y={cy - sh / 2} width={sw} height={sh} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {l_b && mkTxt(cx, cy + sh / 2 + 20, l_b)}
                    {l_h && mkTxt(cx + sw / 2 + 15, cy, l_h, "start")}
                    {areaText && mkTxt(cx, cy, `${areaText} cm¬≤`, "middle", "middle", "#064e3b")}
                </g>
            );
        }
        
        if (type === 'triangle') {
            const L = cx - sw/2, R = cx + sw/2, T = cy - sh/2, B = cy + sh/2;
            
            // RIGHT TRIANGLE
            if (dims.subtype === 'right') {
                const orient = dims.orientation || 'up';
                let p1, p2, p3; 
                let lPos = { h:{x:0,y:0}, b:{x:0,y:0}, hyp:{x:0,y:0} };

                // Vertices based on orientation
                if (orient === 'up') {
                    p1 = {x: L, y: T}; p2 = {x: L, y: B}; p3 = {x: R, y: B};
                    lPos = { h: {x: L-15, y: cy}, b: {x: cx, y: B+25}, hyp: {x: cx+10, y: cy-10} };
                } else if (orient === 'down') {
                    p1 = {x: R, y: B}; p2 = {x: R, y: T}; p3 = {x: L, y: T};
                    lPos = { h: {x: R+15, y: cy}, b: {x: cx, y: T-25}, hyp: {x: cx-10, y: cy+10} };
                } else if (orient === 'left') {
                    p1 = {x: L, y: B}; p2 = {x: R, y: B}; p3 = {x: R, y: T};
                    lPos = { h: {x: R+15, y: cy}, b: {x: cx, y: B+25}, hyp: {x: cx-10, y: cy-10} };
                } else {
                    p1 = {x: R, y: T}; p2 = {x: L, y: T}; p3 = {x: L, y: B};
                    lPos = { h: {x: L-15, y: cy}, b: {x: cx, y: T-25}, hyp: {x: cx+10, y: cy+10} };
                }

                const path = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
                return (
                    <g>
                        <polygon points={path} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                        {l_h && mkTxt(lPos.h.x, lPos.h.y, l_h)}
                        {l_b && mkTxt(lPos.b.x, lPos.b.y, l_b)}
                        {l_hyp && mkTxt(lPos.hyp.x, lPos.hyp.y, l_hyp)}
                    </g>
                );
            } 
            // STANDARD TRIANGLE
            else {
                const points = `${L},${B} ${R},${B} ${cx},${T}`;
                // Only show height line/label if explicit height label exists AND no angles are being shown
                // This prevents 'h=' overlapping 's1/s2' labels in similarity checks
                const showHeight = l_h && !dims.angles;
                const hLine = <line x1={cx} y1={T} x2={cx} y2={B} stroke="#6b7280" strokeWidth="2" strokeDasharray="4" />;
                
                return (
                    <g>
                        {showHeight && hLine}
                        <polygon points={points} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.5" />
                        
                        {/* Angles */}
                        {dims.angles && (
                            <>
                                {dims.angles[0] && ( <g><path d={`M ${L} ${B} L ${L+25} ${B} A 25 25 0 0 0 ${L+15} ${B-20}`} fill="none" stroke="#ef4444" strokeWidth="2" /><text x={L+10} y={B-8} fontSize="14" fill="#dc2626" fontWeight="bold">{labels.a1}</text></g> )}
                                {dims.angles[1] && ( <g><path d={`M ${R} ${B} L ${R-25} ${B} A 25 25 0 0 1 ${R-15} ${B-20}`} fill="none" stroke="#ef4444" strokeWidth="2" /><text x={R-10} y={B-8} fontSize="14" fill="#dc2626" fontWeight="bold">{labels.a2}</text></g> )}
                            </>
                        )}

                        {/* Base/Height Labels - Only if keys exist and we aren't showing angles */}
                        {l_b && mkTxt(cx, B + 25, l_b)}
                        {showHeight && mkTxt(cx + 5, cy, l_h, "start")}
                        
                        {/* Side Comparison Labels (s1, s2) */}
                        {l_s1 && mkTxt(cx - sw/4 - 15, cy, l_s1, "end")}
                        {l_s2 && mkTxt(cx + sw/4 + 15, cy, l_s2, "start")}
                    </g>
                );
            }
        }
        
        if (type === 'circle') {
            const isDiameter = dims.show === 'diameter';
            return (
                <g>
                    <circle cx={cx} cy={cy} r={sr} fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                    {labels && (
                        isDiameter ? (
                            <>
                                <line x1={cx - sr} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" strokeDasharray="4" />
                                <text x={cx} y={cy - 15} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labels.val || `d=${dims.diameter}`}</text>
                            </>
                        ) : (
                            <>
                                <circle cx={cx} cy={cy} r={2} fill="#374151" />
                                <line x1={cx} y1={cy} x2={cx + sr} y2={cy} stroke="#374151" strokeWidth="2" />
                                <text x={cx + sr / 2} y={cy - 10} textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="22">{labels.val || `r=${dims.radius}`}</text>
                            </>
                        )
                    )}
                </g>
            );
        }
        return null;
    };

    if (data.type === 'scale_single' || data.type === 'scale_compare') { 
        const shapeEmojis = { 
            square: '‚¨õ', rectangle: '‚ñ≠', circle: '‚ö´', triangle: 'üî∫', cube: 'üßä', cylinder: 'üõ¢Ô∏è', 
            pyramid: '‚õ∞Ô∏è', cone: 'üç¶', sphere: 'üîÆ', arrow: '‚û°', star: '‚≠ê', lightning: '‚ö°', 
            key: 'üîë', heart: '‚ù§Ô∏è', cloud: '‚òÅÔ∏è', moon: 'üåô', sun: '‚òÄÔ∏è', magnifying_glass: 'üîç', map: 'üó∫Ô∏è',
            car: 'üöó', ladybug: 'üêû', house: 'üè†'
        }; 
        const emoji = shapeEmojis[data.shape] || 'üì¶'; 
        const ShapeIcon = ({ size }) => <div className="flex items-center justify-center text-6xl select-none" style={{ fontSize: size }}>{emoji}</div>; 
        
        if (data.type === 'scale_single') 
            return <div className="flex flex-col items-center gap-2 my-4"><ShapeIcon size="80px" /><span className="bg-white px-4 py-2 rounded shadow text-3xl font-bold font-mono border border-gray-200">{data.label}</span></div>; 
        
        return (
            <div className="flex items-center justify-center gap-4 sm:gap-8 my-6">
                <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.leftLabel}</span><ShapeIcon size="60px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.leftValue}</span></div>
                <div className="text-gray-300 text-3xl">‚Üí</div>
                <div className="flex flex-col items-center gap-2"><span className="text-base font-bold uppercase text-gray-400 mb-1">{data.rightLabel}</span><ShapeIcon size="100px" /><span className="text-2xl font-bold font-mono bg-white px-3 rounded border mt-2">{data.rightValue}</span></div>
            </div>
        ); 
    }

    // --- CASE 2: SIMILARITY COMPARISON (Wider Canvas) ---
    if (data.type === 'similarity_compare') {
        const leftDims = { ...data.left, width: 40, height: 40, radius: 20, subtype: data.shapeType === 'triangle' ? 'isosceles' : undefined };
        const rightDims = { ...data.right, width: 60, height: 60, radius: 30, subtype: data.shapeType === 'triangle' ? 'isosceles' : undefined };

        return (
            <SvgContainer w={500} h={200} viewBox="0 0 500 200">
                <RenderShape type={data.shapeType} dims={leftDims} labels={data.left.labels} offsetX={-25} scale={0.8} />
                <text x="250" y="100" textAnchor="middle" fontSize="30" fill="#cbd5e1">‚Üí</text>
                <RenderShape type={data.shapeType} dims={rightDims} labels={data.right.labels} offsetX={225} scale={1.2} />
            </SvgContainer>
        );
    }

    // --- CASE 3: TRANSVERSAL (Restored) ---
    if (data.type === 'transversal') {
        const labels = data.labels;
        return (
            <SvgContainer>
                <polygon points="150,20 50,180 250,180" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" fillOpacity="0.3" />
                <line x1="100" y1="100" x2="200" y2="100" stroke="#059669" strokeWidth="3" />
                
                <text x="85" y="60" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_top}</text>
                <text x="40" y="100" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="end">{labels.left_tot}</text>
                <text x="150" y="90" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_top}</text>
                <text x="150" y="200" fontSize="18" fontWeight="bold" fill="#374151" textAnchor="middle">{labels.base_bot}</text>
                
                <path d="M 150 100 l -5 -5 m 5 5 l -5 5" stroke="#059669" strokeWidth="2" fill="none"/>
                <path d="M 150 180 l -5 -5 m 5 5 l -5 5" stroke="#10b981" strokeWidth="2" fill="none"/>
            </SvgContainer>
        );
    }

    if (['rectangle', 'square', 'parallelogram', 'triangle', 'circle'].includes(data.type)) {
        return (<div className="flex justify-center my-4"><RenderShape type={data.type} dims={data} labels={data.labels} /></div>);
    }
    
    if (data.type === 'composite') {
        return (
            <div className="flex justify-center my-4">
                <svg width="200" height="200" viewBox="0 0 200 200" className="border border-gray-100 rounded-lg bg-white shadow-sm">
                    {data.subtype === 'house' ? (
                        <>
                            <rect x="50" y="80" width="100" height="80" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <polygon points="50,80 150,80 100,20" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <text x="160" y="120" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                            <text x="100" y="180" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                            <text x="130" y="60" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h_roof}</text>
                        </>
                    ) : (
                        <>
                            <rect x="50" y="70" width="100" height="100" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <path d="M 50 70 A 50 50 0 0 1 150 70" fill="#ecfdf5" stroke="#10b981" strokeWidth="3" />
                            <text x="100" y="190" textAnchor="middle" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.w}</text>
                            <text x="160" y="120" textAnchor="start" fontWeight="bold" fill="#374151" fontSize="18">{data.labels.h}</text>
                        </>
                    )}
                </svg>
            </div>
        );
    }

    return <div className="flex justify-center my-4"><div className="text-gray-400 text-sm">Visual</div></div>;
};

// ----------------------------------------------------------------------
// 3D VOLUME VISUALIZATION
// ----------------------------------------------------------------------
export const VolumeVisualization = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;

        ctx.clearRect(0, 0, w, h);
        ctx.strokeStyle = '#374151'; 
        ctx.fillStyle = '#f3f4f6';
        ctx.lineWidth = 2; 
        ctx.lineJoin = 'round'; 
        ctx.font = "bold 14px Inter, sans-serif"; 
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";

        const drawLabel = (text, x, y, color='#dc2626') => { 
            if (!text) return;
            ctx.save(); 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
            const m = ctx.measureText(text);
            ctx.fillRect(x - m.width/2 - 2, y - 10, m.width + 4, 20);
            ctx.fillStyle = color; 
            ctx.fillText(text, x, y); 
            ctx.restore(); 
        };
        const drawDashed = (x1, y1, x2, y2) => { 
            ctx.save(); 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath(); 
            ctx.moveTo(x1, y1); 
            ctx.lineTo(x2, y2); 
            ctx.stroke(); 
            ctx.restore(); 
        };

        const TARGET_SIZE = 140; 
        let dims = [];
        if (data.labels) {
            dims = Object.values(data.labels).map(v => parseInt(String(v))).filter(v => !isNaN(v));
        }
        const maxVal = Math.max(...dims, 10);
        const scale = TARGET_SIZE / maxVal;

        if (data.type === 'cuboid') {
            const dw = (parseInt(data.labels.w) || 10) * scale;
            const dh = (parseInt(data.labels.h) || 10) * scale;
            const dd = (parseInt(data.labels.d) || 10) * scale * 0.5;
            const x0 = cx - dw/2 - dd/2;
            const y0 = cy + dh/2 + dd/2;
            ctx.strokeRect(x0, y0 - dh, dw, dh);
            ctx.beginPath(); ctx.moveTo(x0, y0 - dh); ctx.lineTo(x0 + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw, y0 - dh); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x0 + dw + dd, y0 - dh - dd); ctx.lineTo(x0 + dw + dd, y0 - dd); ctx.lineTo(x0 + dw, y0); ctx.stroke();
            drawLabel(data.labels.w, x0 + dw/2, y0 + 15);
            drawLabel(data.labels.h, x0 - 20, y0 - dh/2);
            drawLabel(data.labels.d, x0 + dw + dd/2 + 5, y0 - dd/2);
        } 
        else if (data.type === 'triangular_prism') {
            const b = (parseInt(data.labels.b) || 10) * scale;
            const hTri = (parseInt(data.labels.h) || 10) * scale;
            const len = (parseInt(data.labels.l) || 20) * scale * 0.7;
            const startX = cx - b/2 - len/2;
            const startY = cy + hTri/2;
            ctx.beginPath();
            ctx.moveTo(startX, startY); ctx.lineTo(startX + b, startY); ctx.lineTo(startX + b/2, startY - hTri); ctx.closePath(); ctx.stroke();
            const offX = len; const offY = -len * 0.3;
            ctx.beginPath(); ctx.moveTo(startX + b/2, startY - hTri); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(startX + b, startY); ctx.lineTo(startX + b + offX, startY + offY); ctx.lineTo(startX + b/2 + offX, startY - hTri + offY); ctx.stroke();
            drawDashed(startX + b/2, startY, startX + b/2, startY - hTri);
            drawLabel(data.labels.h, startX + b/2 + 10, startY - hTri/2);
            drawLabel(data.labels.b, startX + b/2, startY + 15);
            drawLabel(data.labels.l, startX + b + offX/2 + 10, startY + offY/2);
        }
        else if (data.type === 'pyramid') {
            const w = (parseInt(data.labels.w || data.labels.s || 10) * scale);
            const d = (parseInt(data.labels.d || data.labels.s || 10) * scale * 0.6); 
            const hPyr = (parseInt(data.labels.h) || 10) * scale;
            const x0 = cx - w/2 - d/2;
            const y0 = cy + hPyr/3; 
            const FL = {x: x0, y: y0}; const FR = {x: x0+w, y: y0};
            const BR = {x: x0+w+d, y: y0-d}; const BL = {x: x0+d, y: y0-d};
            const Apex = {x: x0 + w/2 + d/2, y: y0 - d/2 - hPyr};
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(FR.x, FR.y); ctx.lineTo(BR.x, BR.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(BL.x, BL.y); ctx.lineTo(FL.x, FL.y); ctx.stroke(); ctx.restore();
            ctx.beginPath(); ctx.moveTo(FL.x, FL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(FR.x, FR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(BR.x, BR.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke();
            ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.moveTo(BL.x, BL.y); ctx.lineTo(Apex.x, Apex.y); ctx.stroke(); ctx.restore();
            const centerBase = {x: x0 + w/2 + d/2, y: y0 - d/2};
            drawDashed(centerBase.x, centerBase.y, Apex.x, Apex.y);
            drawLabel("h=" + data.labels.h, Apex.x + 20, centerBase.y - hPyr/2);
            drawLabel(data.labels.w || data.labels.s, x0 + w/2, y0 + 15);
        }
        else {
            let r = 50; 
            if(data.labels.r) r = parseInt(data.labels.r) * scale;
            if(data.labels.d) r = (parseInt(data.labels.d)/2) * scale;
            r = Math.max(30, Math.min(r, 70));
            const drawCircleData = (centerY, showLabel=true) => {
                 const val = data.labels.val || (data.labels.r ? `r=${data.labels.r}` : `d=${data.labels.d}`);
                 if (data.show === 'diameter') {
                     drawDashed(cx - r, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx, centerY - 10);
                 } else {
                     ctx.beginPath(); ctx.arc(cx, centerY, 2, 0, 2*Math.PI); ctx.fill();
                     drawDashed(cx, centerY, cx + r, centerY);
                     if(showLabel) drawLabel(val, cx + r/2, centerY - 10);
                 }
            };
            if (data.type === 'sphere') {
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, cy, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(cy);
            }
            else if (data.type === 'hemisphere') {
                const yBase = cy + 10;
                ctx.beginPath(); ctx.arc(cx, yBase, r, Math.PI, 0); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(cx, yBase, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                drawCircleData(yBase);
            }
            else if (data.type === 'cylinder' || data.type === 'silo') {
                const hCyl = (parseInt(data.labels.h) || 10) * scale;
                const topY = cy - hCyl/2;
                const botY = cy + hCyl/2;
                if (data.type === 'cylinder' || data.type === 'silo') {
                     ctx.beginPath(); ctx.ellipse(cx, topY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, topY); ctx.lineTo(cx-r, botY); ctx.stroke();
                     ctx.beginPath(); ctx.moveTo(cx+r, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 15, cy);
                }
                if (data.type === 'silo') { ctx.beginPath(); ctx.arc(cx, topY, r, Math.PI, 0); ctx.stroke(); }
                drawCircleData(topY, true);
            }
            else if (data.type === 'cone' || data.type === 'ice_cream') {
                 const hCone = (parseInt(data.labels.h) || 10) * scale;
                 if (data.type === 'cone') {
                     const topY = cy - hCone/2; const botY = cy + hCone/2;
                     ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, 0, Math.PI); ctx.stroke();
                     ctx.save(); ctx.setLineDash([5,5]); ctx.beginPath(); ctx.ellipse(cx, botY, r, r/4, 0, Math.PI, 2*Math.PI); ctx.stroke(); ctx.restore();
                     ctx.beginPath(); ctx.moveTo(cx-r, botY); ctx.lineTo(cx, topY); ctx.lineTo(cx+r, botY); ctx.stroke();
                     drawDashed(cx, botY, cx, topY);
                     drawLabel("h=" + data.labels.h, cx + 5, cy);
                     drawCircleData(botY, true);
                 } else {
                     const seamY = cy - 20; const tipY = seamY + hCone;
                     ctx.beginPath(); ctx.moveTo(cx-r, seamY); ctx.lineTo(cx, tipY); ctx.lineTo(cx+r, seamY); ctx.stroke();
                     ctx.beginPath(); ctx.arc(cx, seamY, r, Math.PI, 0); ctx.stroke();
                     ctx.beginPath(); ctx.ellipse(cx, seamY, r, r/4, 0, 0, 2*Math.PI); ctx.stroke();
                     drawLabel(data.labels.h, cx + r + 10, seamY + hCone/2);
                     drawCircleData(seamY, true);
                 }
            }
        }
    }, [data]);
    return <div className="flex justify-center my-2 w-full"><canvas ref={canvasRef} width={320} height={240} className="w-full max-w-[320px] h-auto bg-white rounded-lg" /></div>;
};

// Graph Canvas Component
export const GraphCanvas = ({ data }) => {
    const canvasRef = useRef(null);
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const range = data.range || 10;
        ctx.clearRect(0, 0, width, height);
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const toX = (val) => (val + range) * (width / (range * 2));
        const toY = (val) => height - (val + range) * (height / (range * 2));
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        for (let i = -range; i <= range; i += data.gridStep || 1) {
            ctx.beginPath(); ctx.moveTo(toX(i), 0); ctx.lineTo(toX(i), height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, toY(i)); ctx.lineTo(width, toY(i)); ctx.stroke();
        }
        ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(width, toY(0)); ctx.stroke();
        ctx.fillStyle = '#6b7280';
        const step = data.labelStep || 2;
        for (let i = -range; i <= range; i += step) {
            if (i === 0) continue;
            const xPos = toX(i); const yOrigin = toY(0);
            ctx.beginPath(); ctx.moveTo(xPos, yOrigin - 3); ctx.lineTo(xPos, yOrigin + 3); ctx.stroke();
            ctx.fillText(i.toString(), xPos, yOrigin + 12);
            const yPos = toY(i); const xOrigin = toX(0);
            ctx.beginPath(); ctx.moveTo(xOrigin - 3, yPos); ctx.lineTo(xOrigin + 3, yPos); ctx.stroke();
            ctx.fillText(i.toString(), xOrigin - 12, yPos);
        }
        data.lines.forEach(line => {
            ctx.strokeStyle = line.color || '#dc2626'; ctx.lineWidth = 3;
            ctx.beginPath();
            const x1 = -range; const y1 = line.slope * x1 + line.intercept;
            const x2 = range; const y2 = line.slope * x2 + line.intercept;
            ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke();
        });
    }, [data]);
    return <div className="flex justify-center my-4"><canvas ref={canvasRef} width={240} height={240} className="bg-white rounded border border-gray-300 shadow-sm" /></div>;
};

export const StaticGeometryVisual = ({ description }) => { 
    if (!description) return null; 
    const d = description.toLowerCase(); 
    if (d.includes("rect") || d.includes("rektangel")) return <div className="flex justify-center my-4 opacity-80"><div className="w-28 h-16 border-2 border-primary-500 bg-primary-50 rounded-sm"></div></div>; 
    return null; 
};

// FILE END: src\components\visuals\GeometryComponents.jsx

// =======================================================
// FILE START: src\components\visuals\GeometryVisual.jsx
// =======================================================

import React from 'react';

/**
 * Renders SVG geometry. Handles 'similarity' by rendering multiple shapes.
 * Updated to use named export to match PracticeView imports.
 */
export const GeometryVisual = ({ data }) => {
  if (!data) return null;

  // --- Helper: Render a Single Polygon ---
  const renderShape = (points, offsetX = 0, offsetY = 0, color = 'black', key) => {
    if (!points || points.length < 2) return null;
    
    // SVG Coordinate System: Y increases downwards.
    // Math Coordinate System: Y increases upwards.
    // We flip Y (-p.y) so math coordinates (0,10) render above (0,0).
    const pathData = points.map((p, i) => 
      `${i === 0 ? 'M' : 'L'} ${p.x + offsetX} ${-p.y + offsetY}`
    ).join(' ') + ' Z';

    return (
      <path 
        key={key}
        d={pathData} 
        fill={color} 
        fillOpacity="0.2" 
        stroke={color} 
        strokeWidth="2"
        vectorEffect="non-scaling-stroke" // Keeps stroke width constant on zoom
        strokeLinejoin="round"
      />
    );
  };

  // --- Helper: Render Labels ---
  const renderLabels = (labels, shapes) => {
    if (!labels) return null;
    
    return labels.map((lbl, i) => {
      let x = lbl.x;
      let y = -lbl.y; // Flip Y to match shape coordinate system
      
      // Determine offset based on shapeIndex
      // If shapeIndex is 1 (the second shape), we shift it right
      if (lbl.shapeIndex === 1 && shapes && shapes.length > 0) {
        // Find max width of shape 0 to calculate the gap offset
        const shape0Width = shapes[0].points.reduce((max, p) => Math.max(max, p.x), 0);
        const gap = 4; // Must match the gap used in ViewBox calculation
        x += (shape0Width + gap); 
      }

      return (
        <text 
          key={`lbl-${i}`} 
          x={x} 
          y={y} 
          className="text-[0.6px] fill-gray-800 font-medium font-sans select-none"
          textAnchor="middle" 
          dominantBaseline="middle"
        >
          {lbl.text}
        </text>
      );
    });
  };

  // --- ViewBox Calculation ---
  // We need to determine the bounding box of ALL shapes to zoom the SVG correctly.
  let allPoints = [];
  const gap = 4; // Space between similarity shapes

  if (data.type === 'similarity' && data.shapes) {
    // Shape 1 points (no offset)
    const s0Points = data.shapes[0].points;
    
    // Shape 2 points (offset by Shape 1 width + gap)
    const s0Width = s0Points.reduce((max, p) => Math.max(max, p.x), 0);
    const s1Points = data.shapes[1].points.map(p => ({
        x: p.x + s0Width + gap,
        y: p.y
    }));

    allPoints = [...s0Points, ...s1Points];
  } else if (data.points) {
    // Standard single shape
    allPoints = data.points;
  }

  // Safety check
  if (allPoints.length === 0) {
      return <div className="p-4 text-gray-400 italic text-sm text-center">Visual unavailable</div>;
  }

  const minX = Math.min(...allPoints.map(p => p.x));
  const maxX = Math.max(...allPoints.map(p => p.x));
  const minY = Math.min(...allPoints.map(p => -p.y)); // SVG Y
  const maxY = Math.max(...allPoints.map(p => -p.y));

  const padding = 2; // Breathing room around shapes
  const width = maxX - minX + (padding * 2);
  const height = maxY - minY + (padding * 2);
  
  // Construct ViewBox
  const viewBox = `${minX - padding} ${minY - padding} ${width} ${height}`;

  return (
    <div className="w-full flex justify-center items-center p-6 bg-white rounded-xl shadow-sm border border-gray-100 my-4">
      <svg 
        viewBox={viewBox} 
        className="w-full max-w-[500px] h-auto overflow-visible"
        preserveAspectRatio="xMidYMid meet"
      >
        {/* Debug Grid/Axes if requested */}
        {data.showAxes && (
           <g stroke="#e5e7eb" strokeWidth="0.1">
             <line x1="-100" y1="0" x2="100" y2="0" stroke="#9ca3af" />
             <line x1="0" y1="-100" x2="0" y2="100" stroke="#9ca3af" />
           </g>
        )}

        {/* --- Render Logic for Similarity --- */}
        {data.type === 'similarity' && data.shapes && (
          <>
            {/* Shape 1 */}
            {renderShape(data.shapes[0].points, 0, 0, data.shapes[0].color, 's1')}
            
            {/* Shape 2 (Offset) */}
            {(() => {
              const s1Offset = data.shapes[0].points.reduce((max, p) => Math.max(max, p.x), 0) + gap;
              return renderShape(data.shapes[1].points, s1Offset, 0, data.shapes[1].color, 's2');
            })()}
            
            {/* Labels */}
            {renderLabels(data.labels, data.shapes)}
          </>
        )}

        {/* --- Render Logic for Standard Single Shape --- */}
        {(!data.type || data.type !== 'similarity') && (
           <g>
             {renderShape(data.points, 0, 0, '#3B82F6', 'single')}
             {/* If standard shapes have labels, render them here. Currently assumes custom labels array is for similarity */}
           </g>
        )}
      </svg>
    </div>
  );
};

GeometryVisual.requiresCanvas = true;

// FILE END: src\components\visuals\GeometryVisual.jsx

// =======================================================
// FILE START: src\components\visuals\GraphCanvas.jsx
// =======================================================

import React, { useEffect, useRef } from 'react';

/**
 * GraphCanvas
 * Renders a coordinate system and linear functions (y = kx + m).
 * Supports drawing two lines for system of equations if needed.
 */
export const GraphCanvas = ({ visual }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !visual) return;

    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    // Config
    const scale = 20; // pixels per unit
    const centerX = w / 2;
    const centerY = h / 2;

    // Reset
    ctx.clearRect(0, 0, w, h);
    
    // Draw Grid
    ctx.strokeStyle = '#e5e7eb'; // light gray
    ctx.lineWidth = 1;
    
    // Vertical grid lines
    for (let x = 0; x <= w; x += scale) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
    }
    // Horizontal grid lines
    for (let y = 0; y <= h; y += scale) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
    }

    // Draw Axes
    ctx.strokeStyle = '#374151'; // dark gray
    ctx.lineWidth = 2;
    
    // X-Axis
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(w, centerY);
    ctx.stroke();

    // Y-Axis
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, h);
    ctx.stroke();

    // Helper: Plot a line given slope (k) and intercept (m)
    const drawLine = (k, m, color = '#2563eb') => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        // Calculate start and end points
        // x = -10 (far left in units), x = 10 (far right)
        // Canvas coords: cx = centerX + x*scale, cy = centerY - y*scale
        
        const x1 = -15;
        const y1 = k * x1 + m;
        
        const x2 = 15;
        const y2 = k * x2 + m;

        ctx.moveTo(centerX + x1 * scale, centerY - y1 * scale);
        ctx.lineTo(centerX + x2 * scale, centerY - y2 * scale);
        ctx.stroke();
    };

    // Draw Lines from visual data
    if (visual.lines) {
        visual.lines.forEach((line, index) => {
            // Alternate colors for systems
            const color = index === 0 ? '#3b82f6' : '#ef4444'; 
            drawLine(line.k, line.m, color);
        });
    }

  }, [visual]);

  return (
    <div className="flex justify-center my-4 overflow-hidden rounded-lg border border-gray-200">
      <canvas 
        ref={canvasRef} 
        width={300} 
        height={300} 
        className="bg-white"
      />
    </div>
  );
};

GraphCanvas.requiresCanvas = true;

// FILE END: src\components\visuals\GraphCanvas.jsx

// =======================================================
// FILE START: src\components\visuals\SimpleTextLevel.jsx
// =======================================================

import React from 'react';

const SimpleTextLevel = ({ data }) => {
  return (
    <div className="text-content">
      <p>{data.question}</p>
    </div>
  );
};

// We simply don't add the property, or explicitly set it to false
// SimpleTextLevel.requiresCanvas = false; 

export default SimpleTextLevel;

// FILE END: src\components\visuals\SimpleTextLevel.jsx

// =======================================================
// FILE START: src\components\visuals\VolumeVisualization.jsx
// =======================================================

import React, { useEffect, useRef } from 'react';

/**
 * VolumeVisualization
 * Renders 3D shapes (Cubes, Rectangular Prisms, Cylinders) on HTML5 Canvas.
 * * MIGRATION NOTE:
 * - Uses TARGET_SIZE = 160.
 * - Implements dynamic scaling: scale = TARGET_SIZE / Math.max(w, h, d).
 */
export const VolumeVisualization = ({ visual }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !visual) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    ctx.lineJoin = 'round';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#374151'; // gray-700
    ctx.fillStyle = '#E5E7EB';   // gray-200

    const centerX = width / 2;
    const centerY = height / 2;

    // SCALING LOGIC
    const TARGET_SIZE = 160;
    // Determine max dimension to scale appropriately
    const maxDim = Math.max(
      visual.width || 0,
      visual.height || 0,
      visual.depth || 0,
      (visual.radius || 0) * 2
    );
    
    // Avoid division by zero
    const scale = maxDim > 0 ? TARGET_SIZE / maxDim : 1;

    // Drawing functions
    const drawCubeOrPrism = () => {
        const w = (visual.width || 0) * scale;
        const h = (visual.height || 0) * scale;
        const d = (visual.depth || 0) * scale * 0.5; // Foreshortening depth
        
        const x = centerX - w / 2;
        const y = centerY - h / 2;

        // Front Face
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.stroke();
        ctx.fill();

        // Top Face
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + d, y - d);
        ctx.lineTo(x + w + d, y - d);
        ctx.lineTo(x + w, y);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#D1D5DB'; // slightly darker
        ctx.fill();

        // Side Face
        ctx.beginPath();
        ctx.moveTo(x + w, y);
        ctx.lineTo(x + w + d, y - d);
        ctx.lineTo(x + w + d, y + h - d);
        ctx.lineTo(x + w, y + h);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#9CA3AF'; // darkest
        ctx.fill();
        
        // Labels
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        if (visual.labels) {
            // Simple label placement approximation
            if (visual.labels.w) ctx.fillText(visual.labels.w, x + w/2, y + h + 15);
            if (visual.labels.h) ctx.fillText(visual.labels.h, x - 20, y + h/2);
            if (visual.labels.d) ctx.fillText(visual.labels.d, x + w + d/2, y - d/2);
        }
    };

    const drawCylinder = () => {
        const r = (visual.radius || 0) * scale;
        const h = (visual.height || 0) * scale;
        
        // Ellipse squash factor
        const squash = 0.3; 
        const ry = r * squash;

        const x = centerX;
        const yTop = centerY - h/2;
        const yBottom = centerY + h/2;

        // Top Ellipse
        ctx.beginPath();
        ctx.ellipse(x, yTop, r, ry, 0, 0, 2 * Math.PI);
        ctx.fillStyle = '#D1D5DB';
        ctx.fill();
        ctx.stroke();

        // Body
        ctx.beginPath();
        ctx.moveTo(x - r, yTop);
        ctx.lineTo(x - r, yBottom);
        // Bottom curve (half ellipse)
        ctx.ellipse(x, yBottom, r, ry, 0, 0, Math.PI, false);
        ctx.lineTo(x + r, yTop);
        ctx.fillStyle = '#E5E7EB';
        ctx.fill();
        
        // Re-stroke sides to cover fill overlap
        ctx.beginPath();
        ctx.moveTo(x - r, yTop);
        ctx.lineTo(x - r, yBottom);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + r, yTop);
        ctx.lineTo(x + r, yBottom);
        ctx.stroke();

        // Bottom full ellipse stroke (optional, but helps depth)
        ctx.beginPath();
        ctx.ellipse(x, yBottom, r, ry, 0, 0, Math.PI, false);
        ctx.stroke();
        
        // Labels
        ctx.fillStyle = '#000';
        ctx.font = '14px Arial';
        if (visual.labels) {
            if (visual.labels.r) ctx.fillText(visual.labels.r, x + r/2, yTop - 5);
            if (visual.labels.h) ctx.fillText(visual.labels.h, x + r + 10, centerY);
        }
    };

    // Render based on type
    if (visual.type === 'cube' || visual.type === 'cuboid') {
        drawCubeOrPrism();
    } else if (visual.type === 'cylinder') {
        drawCylinder();
    }

  }, [visual]);

  return (
    <div className="flex justify-center my-4">
      <canvas 
        ref={canvasRef} 
        width={300} 
        height={250} 
        className="bg-white rounded-lg"
      />
    </div>
  );
};

VolumeVisualization.requiresCanvas = true;

// FILE END: src\components\visuals\VolumeVisualization.jsx

// =======================================================
// FILE START: src\constants\curriculum.js
// =======================================================

export const CATEGORIES = {
    ARITHMETIC: {
        id: 'ARITHMETIC',
        label: { en: 'Number Theory', sv: 'Taluppfattning' },
        color: 'pink',
        generators: [
            { id: 'BasicArithmeticGen', api: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'NegativeNumbersGen', api: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'TenPowersGen', api: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } }
        ]
    },
    ALGEBRA: {
        id: 'ALGEBRA',
        label: { en: 'Algebra', sv: 'Algebra' },
        color: 'indigo',
        generators: [
            { id: 'ExpressionSimplificationGen', api: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'EquationGenerator', api: 'equation', label: { sv: "Ekvationer", en: "Equations" } }
        ]
    },
    GEOMETRY: {
        id: 'GEOMETRY',
        label: { en: 'Geometry', sv: 'Geometri' },
        color: 'emerald',
        generators: [
            { id: 'GeometryGenerator', api: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'ScaleGenerator', api: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'VolumeGenerator', api: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'SimilarityGenerator', api: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } }
        ]
    },
    FUNCTIONS: {
        id: 'FUNCTIONS',
        label: { en: 'Functions', sv: 'Samband' },
        color: 'purple',
        generators: [
            { id: 'LinearGraphGenerator', api: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    BasicArithmeticGen: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    NegativeNumbersGen: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    TenPowersGen: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    EquationGenerator: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    ExpressionSimplificationGen: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    GeometryGenerator: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        5: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    ScaleGenerator: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    VolumeGenerator: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
    },
    SimilarityGenerator: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    LinearGraphGenerator: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    }
};

export const getColorClasses = (color, type) => {
    const c = color || 'emerald';
    switch (type) {
        case 'bg-light': return `bg-${c}-50`;
        case 'bg-dark': return `bg-${c}-500`;
        case 'border': return `border-${c}-100`;
        case 'text': return `text-${c}-700`;
        case 'ring': return `ring-${c}-500`;
        case 'border-solid': return `border-${c}-500`;
        default: return '';
    }
};

// FILE END: src\constants\curriculum.js

// =======================================================
// FILE START: src\constants\localization.js
// =======================================================

export const CATEGORIES = {
    arithmetic: {
        label: { sv: "Taluppfattning", en: "Number Theory" },
        color: "pink",
        topics: [
            { id: 'arithmetic', label: { sv: "De Fyra R√§knes√§tten", en: "Basic Counting" } },
            { id: 'negative', label: { sv: "Negativa Tal", en: "Negative Numbers" } },
            { id: 'ten_powers', label: { sv: "10, 100, 1000", en: "10, 100, 1000" } }
        ]
    },
    algebra: {
        label: { sv: "Algebra", en: "Algebra" },
        color: "indigo",
        topics: [
            { id: 'simplify', label: { sv: "Uttryck", en: "Expressions" } },
            { id: 'equation', label: { sv: "Ekvationer", en: "Equations" } }
        ]
    },
    geometry: {
        label: { sv: "Geometri", en: "Geometry" },
        color: "emerald",
        topics: [
            { id: 'geometry', label: { sv: "Area & Omkrets", en: "Area & Perimeter" } },
            { id: 'scale', label: { sv: "Skala", en: "Scale" } },
            { id: 'volume', label: { sv: "Volym", en: "Volume" } },
            { id: 'similarity', label: { sv: "Likformighet", en: "Similar Shapes" } }
        ]
    },
    functions: {
        label: { sv: "Samband", en: "Functions" },
        color: "purple",
        topics: [
            { id: 'graph', label: { sv: "R√§ta Linjen", en: "Linear Graphs" } }
        ]
    }
};

export const LEVEL_DESCRIPTIONS = {
    arithmetic: {
        1: { sv: "Addition (1-3 siffror)", en: "Addition (1-3 digits)" },
        2: { sv: "Subtraktion (1-3 siffror)", en: "Subtraction (1-3 digits)" },
        3: { sv: "Decimaltal (+/-)", en: "Decimals (+/-)" },
        4: { sv: "Multiplikation (L√§tt)", en: "Multiplication (Easy)" },
        5: { sv: "Multiplikation (Medel)", en: "Multiplication (Medium)" },
        6: { sv: "Multiplikation (Sv√•r)", en: "Multiplication (Hard)" },
        7: { sv: "Division (L√§tt)", en: "Division (Easy)" },
        8: { sv: "Alla r√§knes√§tt (heltal)", en: "Mixed Integers" },
        9: { sv: "Alla r√§knes√§tt (med decimal)", en: "Mixed (incl. Decimals)" }
    },
    negative: {
        1: { sv: "Addition & Subtraktion", en: "Addition & Subtraction" },
        2: { sv: "Addition & Subtraktion (Sv√•r)", en: "Addition & Subtraction (Hard)" },
        3: { sv: "Multiplikation", en: "Multiplication" },
        4: { sv: "Division", en: "Division" },
        5: { sv: "Blandat", en: "Mixed" }
    },
    ten_powers: {
        1: { sv: "Multiplikation & Division (10, 100...)", en: "Mult & Div (10, 100...)" },
        2: { sv: "Begreppsf√∂rst√•else (MC)", en: "Conceptual (MC)" },
        3: { sv: "Decimala faktorer (0.1, 0.01...)", en: "Decimal factors (0.1, 0.01...)" }
    },
    equation: {
        1: { sv: "Enstegsekvationer", en: "One-step equations" },
        2: { sv: "Tv√•stegsekvationer", en: "Two-step equations" },
        3: { sv: "Multiplikation med parentes", en: "Multiplication with parentheses" },
        4: { sv: "X p√• b√•da sidor", en: "X on both sides" },
        5: { sv: "Probleml√∂sning (Skriv)", en: "Word Problems (Write)" },
        6: { sv: "Probleml√∂sning (L√∂s)", en: "Word Problems (Solve)" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    simplify: {
        1: { sv: "F√∂renkla uttryck", en: "Combine like terms" },
        2: { sv: "Parenteser", en: "Distribute into parentheses" },
        3: { sv: "Distribuera & f√∂renkla", en: "Distribute and combine" },
        4: { sv: "Subtrahera parenteser", en: "Subtracting parentheses" },
        5: { sv: "Textuppgifter", en: "Word Problems" },
        6: { sv: "Blandat", en: "Mixed" }
    },
    geometry: {
        1: { sv: "Omkrets (Rektangel)", en: "Perimeter (Rectangle)" },
        2: { sv: "Area (Rektangel)", en: "Area (Rectangle)" },
        3: { sv: "Area (Triangel)", en: "Area (Triangle)" },
        4: { sv: "Cirklar (Omkrets & Area)", en: "Circles (Perimeter & Area)" },
        5: { sv: "Sammansatta figurer", en: "Composite shapes" }
    },
    scale: {
        1: { sv: "Begreppsf√∂rst√•else", en: "Concepts" },
        2: { sv: "Ber√§kna l√§ngd (Enkel)", en: "Calc Length (Simple)" },
        3: { sv: "Ber√§kna l√§ngd (Sv√•r)", en: "Calc Length (Hard)" },
        4: { sv: "Ange skala", en: "Determine Scale" },
        5: { sv: "Utan bilder", en: "No Pictures" },
        6: { sv: "Areaskala", en: "Area Scale" },
        7: { sv: "Blandat", en: "Mixed" }
    },
    volume: {
        1: { sv: "R√§tblock & Kub", en: "Prisms & Cubes" },
        2: { sv: "Triangul√§rt Prisma", en: "Triangular Prism" },
        3: { sv: "Cylinder", en: "Cylinder" },
        4: { sv: "Pyramid & Kon", en: "Pyramid & Cone" },
        5: { sv: "Klot", en: "Sphere" },
        6: { sv: "Blandat", en: "Mixed" },
        7: { sv: "Blandat med olika enheter", en: "Mixed with units" }
    },
    similarity: {
        1: { sv: "Likformig eller inte?", en: "Similar or not?" },
        2: { sv: "Ber√§kna l√§ngden (x)", en: "Calculate length (x)" },
        3: { sv: "Topptriangelsatsen", en: "Top Triangle Theorem" },
        4: { sv: "Pythagoras sats", en: "Pythagorean Theorem" }
    },
    graph: {
        1: { sv: "Hitta m (sk√§rning)", en: "Find y-intercept (m)" },
        2: { sv: "Hitta k (positiv)", en: "Find slope (Positive)" },
        3: { sv: "Hitta k (negativ)", en: "Find slope (Negative)" },
        4: { sv: "Hitta funktion (y=kx+m)", en: "Find equation (y=kx+m)" },
        5: { sv: "Blandat", en: "Mixed graphs" }
    }
};

export const UI_TEXT = {
    sv: {
        streak: "",
        loading: "Laddar fr√•ga...", error: "Kunde inte ladda fr√•gan.",
        btnHint: "Ledtr√•d", btnSolution: "Visa l√∂sning", btnSkip: "Hoppa √∂ver",
        submit: "Svara", correct: "R√§tt! N√§sta...", incorrect: "Inte riktigt, f√∂rs√∂k igen", placeholder: "Skriv ditt svar...",
        level: "Niv√•", history: "Historik", noHistory: "Inga svar √§n.", clueUsed: "Hj√§lp",
        dashboardTitle: "V√§lj omr√•de att √∂va p√•",
        progressionInfo: "V√§lj ett omr√•de. Systemet anpassar sig efter dig. Klarar du 8 fr√•gor i rad p√• en niv√• f√∂resl√•r vi att du g√•r vidare till n√§sta.",
        startBtn: "B√∂rja √∂va", backBtn: "Meny", selectLevel: "V√§lj niv√•:",
        hintsTitle: "Ledtr√•dar", prevLevel: "F√∂reg√•ende", nextLevel: "N√§sta",
        levelUpTitle: "Bra jobbat! üî•", levelUpDesc: "Du har klarat 8 fr√•gor i rad! Vill du g√• vidare till n√§sta niv√•?", levelUpYes: "N√§sta niv√•", levelUpNo: "Stanna p√• samma niv√•", levelUpHint: "Kom ih√•g att du alltid kan byta niv√• manuellt h√∂gst upp p√• sidan.",
        aboutBtn: "Om skaparen", aboutTitle: "Om skaparen", aboutText: "Charles √§r en speciall√§rare som arbetar i Sverige och brinner f√∂r att uppt√§cka nya s√§tt att undervisa i klassrummet.",
        contactLink: "F√∂lj mig p√• LinkedIn",
        tagline: "R√§tt st√∂d. Direkt.",
        tagCorrect: "R√§tt", tagWrong: "Fel", tagSkipped: "Hoppad",
        streak_modal_title: "Fantastiskt! üî•", streak_modal_msg: "Du har n√•tt en streak p√• {streak}!",
        total_modal_title: "Snyggt jobbat! ‚úÖ", total_modal_msg: "Du svarade r√§tt p√• {total} fr√•gor! Bra jobbat!",
        btn_close_streak: "Bra jobbat!", btn_close_total: "Forts√§tt",
        timer_title: "√ñvningstimer", timer_off: "Av", timer_min: "min", timer_reset: "√Öterst√§ll", timer_paused: "Pausad",
        stats_title: "Statistik", stats_times_up: "Tiden √§r ute!", stats_longest_streak: "L√§ngsta streak", stats_attempted: "F√∂rs√∂kta fr√•gor", stats_correct_no_help: "R√§tt (utan hj√§lp)", stats_correct_help: "R√§tt (med hj√§lp)", stats_incorrect: "Fel", stats_skipped: "Hoppade √∂ver", stats_close: "St√§ng",
        menu_btn: "Meny", level_breakdown: "Niv√•detaljer",
        stat_skip: "Hoppad", stat_wrong: "Fel", stat_help: "Hj√§lp", stat_correct: "R√§tt", stat_total: "Totalt",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Uppstart (Do Now)", donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.", donow_gen: "Generera", donow_clear: "Rensa", donow_show_all: "Visa alla svar", donow_hide_all: "D√∂lj alla svar"
    },
    en: {
        streak: "",
        loading: "Loading question...", error: "Could not load question.",
        btnHint: "Hint", btnSolution: "Show Solution", btnSkip: "Skip",
        submit: "Submit", correct: "Correct! Next...", incorrect: "Not quite, try again", placeholder: "Enter your answer...",
        level: "Level", history: "History", noHistory: "No answers yet.", clueUsed: "Clue",
        dashboardTitle: "Choose a topic to practice",
        progressionInfo: "Choose a topic. The system adapts to you. Answer 8 questions correctly in a row to unlock the next level.",
        startBtn: "Start Practice", backBtn: "Menu", selectLevel: "Select Level:",
        hintsTitle: "Hints", prevLevel: "Previous", nextLevel: "Next",
        levelUpTitle: "Great Job! üî•", levelUpDesc: "You've answered 8 in a row! Do you want to try the next level?", levelUpYes: "Next Level", levelUpNo: "Stay Here", levelUpHint: "Remember, you can always change difficulty manually at the top.",
        aboutBtn: "About the creator", aboutTitle: "About the creator", aboutText: "Charles is a special education teacher currently working in Sweden and is passionate about discovering new ways to teach in the classroom.",
        contactLink: "Follow me on LinkedIn",
        tagline: "Right support. Instantly.",
        tagCorrect: "Correct", tagWrong: "Wrong", tagSkipped: "Skipped",
        streak_modal_title: "Awesome! üî•", streak_modal_msg: "You hit a streak of {streak}!",
        total_modal_title: "Great work! ‚úÖ", total_modal_msg: "You answered {total} questions correctly! Great job!",
        btn_close_streak: "Great job!", btn_close_total: "Continue",
        timer_title: "Practice Timer", timer_off: "Off", timer_min: "min", timer_reset: "Reset", timer_paused: "Paused",
        stats_title: "Statistics", stats_times_up: "Time's up!", stats_longest_streak: "Longest streak", stats_attempted: "Problems attempted", stats_correct_no_help: "Correct (no help)", stats_correct_help: "Correct (with help)", stats_incorrect: "Incorrect", stats_skipped: "Skipped", stats_close: "Close",
        menu_btn: "Menu", level_breakdown: "Level Breakdown",
        stat_skip: "Skip", stat_wrong: "Wrong", stat_help: "Help", stat_correct: "Correct", stat_total: "Total",
        lgr_btn: "LGR22",
        donow_btn: "Do Now", donow_title: "Do Now Activity", donow_desc: "Select up to 3 levels. System generates 6 questions total.", donow_gen: "Generate", donow_clear: "Clear", donow_show_all: "Show all answers", donow_hide_all: "Hide all answers"
    }
};

// FILE END: src\constants\localization.js

// =======================================================
// FILE START: src\core\generators\BasicArithmeticGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class BasicArithmeticGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSimple(lang);
            case 2: return this.level2_SubSimple(lang);
            case 3: return this.level3_Decimals(lang);
            case 4: return this.level4_MultEasy(lang);
            case 5: return this.level5_MultMedium(lang);
            case 6: return this.level6_MultHard(lang);
            case 7: return this.level7_DivEasy(lang);
            case 8: return this.level8_MixedIntegers(lang);
            case 9: return this.level9_MixedDecimals(lang);
            default: return this.level1_AddSimple(lang);
        }
    }

    // Helper for vertical layout
    private makeVertical(top: number | string, bottom: number | string, op: string): string {
        return `\\begin{array}{r} ${top} \\\\ ${op} \\; ${bottom} \\\\ \\hline \\end{array}`;
    }

    // Level 1: Addition (1-3 digits)
    private level1_AddSimple(lang: string): any {
        const a = MathUtils.randomInt(1, 999);
        const b = MathUtils.randomInt(1, 999);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        
        return this.createProblem(a, b, '+', lang, isVertical);
    }

    // Level 2: Subtraction
    private level2_SubSimple(lang: string): any {
        const a = MathUtils.randomInt(2, 999);
        const b = MathUtils.randomInt(1, a - 1);
        const isVertical = MathUtils.randomInt(0, 1) === 1;

        return this.createProblem(a, b, '-', lang, isVertical);
    }

    // Level 3: Decimals (+/-)
    private level3_Decimals(lang: string): any {
        const op = MathUtils.randomChoice(['+', '-']);
        
        // Legacy Logic: Ensure reasonable numbers
        const getDec = () => MathUtils.randomInt(1, 4900) / 100;
        let a = getDec();
        let b = getDec();

        if (op === '+') {
            while (Math.floor(a + b) > 50) { a = getDec(); b = getDec(); }
        } else {
            if (b > a) [a, b] = [b, a]; // Ensure positive result
            while (Math.floor(a - b) > 50) { a = getDec(); b = getDec(); if (b > a) [a, b] = [b, a]; }
        }
        
        // Always vertical for decimals to encourage alignment practice
        return this.createProblem(a, b, op, lang, true, [
            { text: lang === 'sv' ? "St√§ll upp talen ovanp√• varandra." : "Line up the numbers vertically." },
            { text: lang === 'sv' ? "Viktigt: Decimaltecknen m√•ste vara rakt under varandra." : "Important: The decimal points must line up vertically." }
        ]);
    }

    // Level 4: Mult Easy (Tables 2-9)
    private level4_MultEasy(lang: string): any {
        const a = MathUtils.randomInt(1, 10);
        const b = MathUtils.randomInt(1, 10);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        return this.createProblem(a, b, '*', lang, isVertical);
    }

    // Level 5: Mult Medium (2 digit x 1 digit)
    private level5_MultMedium(lang: string): any {
        const a = MathUtils.randomInt(2, 20);
        const b = MathUtils.randomInt(2, 20);
        const isVertical = MathUtils.randomInt(0, 1) === 1;
        return this.createProblem(a, b, '*', lang, isVertical);
    }

    // Level 6: Mult Hard (Decimals) - Restored Legacy Subtypes
    private level6_MultHard(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        let a = 0, b = 0;

        if (type === 1) { // 0.x * 0.y
            a = MathUtils.randomInt(1, 9) / 10;
            b = MathUtils.randomInt(1, 9) / 10;
        } else if (type === 2) { // Int * 0.x
            a = MathUtils.randomInt(2, 20);
            b = MathUtils.randomInt(1, 9) / 10;
        } else if (type === 3) { // 0.x * 0.yz
            a = MathUtils.randomInt(1, 9) / 10;
            b = MathUtils.randomInt(1, 99) / 100;
        } else { // Int * 0.yz
            a = MathUtils.randomInt(2, 20);
            b = MathUtils.randomInt(1, 99) / 100;
        }

        return this.createProblem(a, b, '*', lang, false, [
            { text: lang === 'sv' ? "Ignorera decimalen f√∂rst. R√§kna som heltal." : "Ignore the decimal first. Calculate as integers." },
            { text: lang === 'sv' ? "R√§kna sedan hur m√•nga decimaler talen har totalt och s√§tt in i svaret." : "Count total decimal places and apply to the answer." }
        ]);
    }

    // Level 7: Division Easy (Integer results)
    private level7_DivEasy(lang: string): any {
        const f1 = MathUtils.randomInt(1, 10);
        const f2 = MathUtils.randomInt(1, 10);
        const product = f1 * f2;
        const divisor = MathUtils.randomInt(0, 1) === 1 ? f1 : f2;
        const answer = product / divisor;
        
        const latex = `\\frac{${product}}{${divisor}}`;
        const desc = lang === 'sv' ? "Dividera." : "Divide.";

        return {
            renderData: { latex, description: desc, answerType: 'text' },
            token: Buffer.from(answer.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? `T√§nk multiplikation: Vad g√•nger ${divisor} blir ${product}?` : `Think multiplication: What times ${divisor} makes ${product}?`, latex: `${divisor} \\cdot ? = ${product}` }
            ]
        };
    }

    // Level 8: Mixed Integers
    private level8_MixedIntegers(lang: string): any {
        const mode = MathUtils.randomChoice([1, 2, 4, 7]);
        if (mode === 1) return this.level1_AddSimple(lang);
        if (mode === 2) return this.level2_SubSimple(lang);
        if (mode === 4) return this.level4_MultEasy(lang);
        return this.level7_DivEasy(lang);
    }

    // Level 9: Mixed Decimals
    private level9_MixedDecimals(lang: string): any {
        const type = MathUtils.randomInt(1, 7);
        // Map 1-7 range roughly to the decimal/harder types
        if (type <= 3) return this.level3_Decimals(lang); // Add/Sub
        if (type <= 6) return this.level6_MultHard(lang); // Mult
        return this.level7_DivEasy(lang); // Keep division integer based for now as per legacy
    }

    // Helper
    private createProblem(a: number, b: number, op: string, lang: string, vertical: boolean = false, extraClues: any[] = []) {
        let ans = 0;
        let latex = "";
        
        if (op === '+') ans = a + b;
        if (op === '-') ans = a - b;
        if (op === '*') ans = a * b;
        
        // JS Floating point fix
        ans = Math.round(ans * 1000) / 1000;

        if (vertical) {
            const opSymbol = op === '*' ? '\\times' : op;
            const top = Math.max(a, b); // Standard convention puts larger on top usually
            const bot = Math.min(a, b);
            // Exception: Subtraction must respect order a - b
            if (op === '-') {
                latex = this.makeVertical(a, b, opSymbol);
            } else {
                latex = this.makeVertical(top, bot, opSymbol);
            }
        } else {
            const opSymbol = op === '*' ? '\\cdot' : op;
            latex = `${a} ${opSymbol} ${b}`;
        }

        const description = vertical 
            ? (lang === 'sv' ? "St√§ll upp och ber√§kna." : "Set up and calculate.")
            : (lang === 'sv' ? "Ber√§kna." : "Calculate.");

        // Default clues if none provided
        const defaultClues = [];
        if (vertical) {
            defaultClues.push({ text: lang === 'sv' ? "B√∂rja r√§kna fr√•n h√∂ger (entalen)." : "Start calculating from the right (ones)." });
        }

        return {
            renderData: { latex, description, answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: extraClues.length > 0 ? extraClues : defaultClues
        };
    }
}

// FILE END: src\core\generators\BasicArithmeticGen.ts

// =======================================================
// FILE START: src\core\generators\ExpressionSimplificationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ExpressionSimplificationGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_CombineTerms(lang);
            case 2: return this.level2_Parentheses(lang);
            case 3: return this.level3_DistributeAndSimplify(lang);
            case 4: return this.level4_SubtractParentheses(lang);
            case 5: return this.level5_WordProblems(lang);
            case 6: return this.level6_Mixed(lang);
            default: return this.level1_CombineTerms(lang);
        }
    }

    // --- LEVEL 1: Combine Like Terms ---
    private level1_CombineTerms(lang: string): any {
        // Subtypes:
        // 1. ax + bx (Simple)
        // 2. ax + b + cx (Interleaved constant)
        // 3. ax + b + cx + d (Full mix)
        // 4. a - bx + cx + d (Negative start var, or const first)

        const subType = MathUtils.randomInt(1, 4);
        const v = 'x'; // Keep it simple for lower levels
        let latex = "";
        let answer = "";
        let clues: any[] = [];
        let desc = lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.";

        if (subType === 1) {
            // ax + bx
            const c1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 9);
            latex = `${c1}${v} + ${c2}${v}`;
            answer = `${c1+c2}${v}`;
            clues.push({ 
                text: lang === 'sv' ? "Addera koefficienterna (siffrorna framf√∂r x)." : "Add the coefficients.",
                latex: `${c1} + ${c2} = ${c1+c2}`
            });
            clues.push({
                text: lang === 'sv' ? "Svaret beh√•ller variabeln." : "Keep the variable.",
                latex: `\\mathbf{${answer}}`
            });
        } 
        else if (subType === 2) {
            // ax + b + cx
            const c1 = MathUtils.randomInt(2, 9);
            const k1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 9);
            
            // Random order: ax + b + cx OR b + ax + cx
            if (Math.random() > 0.5) latex = `${c1}${v} + ${k1} + ${c2}${v}`;
            else latex = `${k1} + ${c1}${v} + ${c2}${v}`;

            answer = `${c1+c2}${v} + ${k1}`;
            
            clues.push({
                text: lang === 'sv' ? "Hitta termerna med x och l√§gg ihop dem." : "Find the x-terms and add them.",
                latex: `${c1}${v} + ${c2}${v} = ${c1+c2}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Konstanten (siffran utan x) √§r kvar." : "The constant remains.",
                latex: `+ ${k1}`
            });
            clues.push({
                text: lang === 'sv' ? "S√§tt ihop uttrycket." : "Combine them.",
                latex: `\\mathbf{${answer}}`
            });
        }
        else if (subType === 3) {
            // ax + b + cx + d
            const c1 = MathUtils.randomInt(2, 6);
            const k1 = MathUtils.randomInt(2, 9);
            const c2 = MathUtils.randomInt(2, 6);
            const k2 = MathUtils.randomInt(2, 9);

            latex = `${c1}${v} + ${k1} + ${c2}${v} + ${k2}`;
            answer = `${c1+c2}${v} + ${k1+k2}`;

            clues.push({
                text: lang === 'sv' ? "Steg 1: Addera x-termerna." : "Step 1: Add the x-terms.",
                latex: `${c1}${v} + ${c2}${v} = ${c1+c2}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Steg 2: Addera siffrorna (konstanterna)." : "Step 2: Add the constants.",
                latex: `${k1} + ${k2} = ${k1+k2}`
            });
            clues.push({
                text: lang === 'sv' ? "Resultat:" : "Result:",
                latex: `\\mathbf{${answer}}`
            });
        }
        else {
            // a - bx + cx + d (Negative handling)
            // Ensure result x is positive for simplicity in L1
            const k1 = MathUtils.randomInt(5, 15);
            const c_neg = MathUtils.randomInt(2, 5); // -bx
            const c_pos = c_neg + MathUtils.randomInt(1, 5); // cx, ensuring sum > 0
            const k2 = MathUtils.randomInt(2, 9);

            latex = `${k1} - ${c_neg}${v} + ${c_pos}${v} + ${k2}`;
            // (c_pos - c_neg)x + (k1 + k2)
            answer = `${c_pos - c_neg}${v} + ${k1+k2}`;

            clues.push({
                text: lang === 'sv' ? "Steg 1: Hantera x-termerna. T√§nk p√• minustecknet." : "Step 1: Handle x-terms. Mind the minus sign.",
                latex: `-${c_neg}${v} + ${c_pos}${v} = ${c_pos - c_neg}${v}`
            });
            clues.push({
                text: lang === 'sv' ? "Steg 2: Addera siffrorna." : "Step 2: Add the numbers.",
                latex: `${k1} + ${k2} = ${k1+k2}`
            });
            clues.push({
                text: lang === 'sv' ? "S√§tt ihop delarna." : "Combine parts.",
                latex: `\\mathbf{${answer}}`
            });
        }

        return {
            renderData: { latex, description: desc, answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: clues
        };
    }

    // --- LEVEL 2: Parentheses (Distribution) ---
    private level2_Parentheses(lang: string): any {
        const v = 'x';
        const outer = MathUtils.randomInt(2, 5);
        const innerC = MathUtils.randomInt(2, 5);
        const innerK = MathUtils.randomInt(1, 5);
        
        const latex = `${outer}(${innerC}${v} + ${innerK})`;
        const resC = outer * innerC;
        const resK = outer * innerK;
        const answer = `${resC}${v} + ${resK}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Multiplicera talet utanf√∂r med B√ÖDA termerna inuti." : "Multiply the number outside with BOTH terms inside.", 
                    latex: `${outer} \\cdot ${innerC}${v} + ${outer} \\cdot ${innerK}` 
                },
                { 
                    text: lang === 'sv' ? "Ber√§kna produkterna." : "Calculate the products.", 
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 3: Distribute & Combine ---
    private level3_DistributeAndSimplify(lang: string): any {
        const outer = MathUtils.randomInt(2, 4);
        const inC = MathUtils.randomInt(2, 4);
        const inK = MathUtils.randomInt(1, 5);
        const extraX = MathUtils.randomInt(2, 6);
        
        const latex = `${outer}(${inC}x + ${inK}) + ${extraX}x`;
        
        const distX = outer * inC;
        const distK = outer * inK;
        const totalX = distX + extraX;
        
        const answer = `${totalX}x + ${distK}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "B√∂rja med att ta bort parentesen." : "Start by removing the parentheses.", 
                    latex: `${distX}x + ${distK} + ${extraX}x` 
                },
                { 
                    text: lang === 'sv' ? "L√§gg ihop x-termerna." : "Combine the x-terms.", 
                    latex: `${distX}x + ${extraX}x = ${totalX}x` 
                },
                {
                    text: lang === 'sv' ? "Resultat:" : "Result:",
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 4: Subtracting Parentheses ---
    private level4_SubtractParentheses(lang: string): any {
        const startX = MathUtils.randomInt(5, 10);
        const subX = MathUtils.randomInt(1, startX - 1);
        const subK = MathUtils.randomInt(1, 5);
        
        const latex = `${startX}x - (${subX}x + ${subK})`;
        const resX = startX - subX;
        const resK = -subK; 
        
        const answer = `${resX}x - ${Math.abs(resK)}`;

        return {
            renderData: { latex, description: lang === 'sv' ? "F√∂renkla uttrycket." : "Simplify the expression.", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "Minus framf√∂r en parentes √§ndrar tecken p√• allt inuti." : "A minus in front of parentheses changes the sign of everything inside.", 
                    latex: `${startX}x - ${subX}x - ${subK}` 
                },
                { 
                    text: lang === 'sv' ? "F√∂renkla x-termerna." : "Simplify the x-terms.",
                    latex: `${startX}x - ${subX}x = ${resX}x`
                },
                {
                    text: lang === 'sv' ? "Resultat:" : "Result:",
                    latex: `\\mathbf{${answer}}`
                }
            ]
        };
    }

    // --- LEVEL 5: Word Problems ---
    private level5_WordProblems(lang: string): any {
        const A = MathUtils.randomInt(2, 6);  
        const B = MathUtils.randomInt(5, 30); 
        const C = MathUtils.randomInt(2, 6);  
        
        const scenarios = [
            {
                type: 'add',
                sv: `Du har ${A} p√•sar med godis (x) och k√∂per ${C} p√•sar till. Du har ocks√• ${B} l√∂sa godisar.`,
                en: `You have ${A} bags of candy (x) and buy ${C} more bags. You also have ${B} loose candies.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `Du k√∂per ${A} tr√∂jor och ${C} byxor som alla kostar x kr styck. Du har en rabattkupong p√• ${B} kr.`,
                en: `You buy ${A} shirts and ${C} pants that all cost x kr each. You have a discount coupon for ${B} kr.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `Du betalar x kr/m√•nad i ${A} m√•nader, sen ${C} m√•nader till. Startavgiften var ${B} kr.`,
                en: `You pay x kr/mo for ${A} months, then ${C} months. Start fee was ${B} kr.`,
                op: '+', expl: '+'
            },
            {
                type: 'add',
                sv: `En triangel har sidorna x, ${A}x och ${C}x. Plus en extra str√§cka p√• ${B} cm.`,
                en: `A triangle has sides x, ${A}x, and ${C}x. Plus an extra length of ${B} cm.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `Du sparar x kr i ${A} veckor och ${C} veckor. Sen k√∂per du n√•got f√∂r ${B} kr.`,
                en: `You save x kr for ${A} weeks and ${C} weeks. Then you spend ${B} kr.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `Ett lag k√∂per x biljetter till ${A} spelare och ${C} ledare. Bokningsavgiften √§r ${B} kr.`,
                en: `A team buys x tickets for ${A} players and ${C} coaches. Booking fee is ${B} kr.`,
                op: '+', expl: '+'
            },
            {
                type: 'sub',
                sv: `En lastbil lastar ${A} l√•dor och ${C} paket (vikt x). Man lastar av ${B} kg skr√§p.`,
                en: `A truck loads ${A} boxes and ${C} packages (weight x). Unloads ${B} kg trash.`,
                op: '-', expl: '-'
            },
            {
                type: 'add',
                sv: `I ett spel f√•r du x po√§ng i runda 1. Runda 2 ger ${A} g√•nger mer, runda 3 ger ${C} g√•nger mer. Bonus ${B} po√§ng.`,
                en: `Game: x points round 1. Round 2 is ${A}x, Round 3 is ${C}x. Bonus ${B} points.`,
                op: '+', expl: '+'
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const totalX = A + C; // Simplified logic assuming 1x is implied or adjusted in prompt if A/C not 1
        // Note: Scenarios assume "A bags" means "Ax", "C bags" means "Cx". 
        // If A or C represents "times more", logic holds.
        
        const answer = `${totalX}x ${s.op} ${B}`;
        
        const desc = lang === 'sv' 
            ? `${s.sv} Skriv ett uttryck f√∂r totalen och f√∂renkla.` 
            : `${s.en} Write an expression for the total and simplify.`;

        return {
            renderData: { latex: "", description: desc, answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? `1. Hitta x-termerna: ${A}x + ${C}x.` : `1. Find x-terms: ${A}x + ${C}x.`,
                    latex: `${totalX}x`
                },
                { 
                    text: lang === 'sv' ? `2. L√§gg till konstanten (${B}).` : `2. Add the constant (${B}).`, 
                    latex: `${totalX}x ${s.op} ${B}` 
                }
            ]
        };
    }

    private level6_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        return this.generate(lvl, lang);
    }
}

// FILE END: src\core\generators\ExpressionSimplificationGen.ts

// =======================================================
// FILE START: src\core\generators\GeometryGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class GeometryGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        let mode = level;
        if (level >= 6) mode = MathUtils.randomInt(3, 5);

        switch (mode) {
            case 1: return this.level1_PerimeterRect(lang);
            case 2: return this.level2_AreaRect(lang);
            case 3: return this.level3_AreaTriangle(lang);
            case 4: return this.level4_Circles(lang);
            case 5: return this.level5_Composite(lang);
            default: return this.level1_PerimeterRect(lang);
        }
    }

    private level1_PerimeterRect(lang: string): any {
        const w = MathUtils.randomInt(3, 12);
        const h = MathUtils.randomInt(2, 8);
        const ans = 2 * (w + h);
        return {
            renderData: { geometry: { type: 'rectangle', width: w, height: h, labels: { width: w, height: h } }, description: lang === 'sv' ? "Ber√§kna omkretsen." : "Calculate the perimeter.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Omkretsen √§r str√§ckan runt hela figuren." : "Perimeter is the distance around the shape.", latex: "" },
                { text: lang === 'sv' ? "Addera alla fyra sidor." : "Add all four sides.", latex: `${w} + ${w} + ${h} + ${h} = \\mathbf{${ans}}` }
            ]
        };
    }

    private level2_AreaRect(lang: string): any {
        const w = MathUtils.randomInt(3, 12);
        const h = MathUtils.randomInt(2, 8);
        const ans = w * h;
        return {
            renderData: { geometry: { type: 'rectangle', width: w, height: h, labels: { width: w, height: h } }, description: lang === 'sv' ? "Ber√§kna arean." : "Calculate the area.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Area = Basen ¬∑ H√∂jden" : "Area = Base ¬∑ Height", latex: `A = ${w} \\cdot ${h}` },
                { latex: `\\mathbf{${ans}}` }
            ]
        };
    }

    private level3_AreaTriangle(lang: string): any {
        const b = MathUtils.randomInt(4, 14);
        const h = MathUtils.randomInt(2, 8) * 2;
        const ans = (b * h) / 2;
        const subtype = MathUtils.randomChoice(['right', 'isosceles']); 
        return {
            renderData: { 
                geometry: { type: 'triangle', subtype, width: b, height: h, labels: { width: b, height: h } }, 
                description: lang === 'sv' ? "Ber√§kna arean." : "Calculate the area.", answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Area = (Basen ¬∑ H√∂jden) / 2" : "Area = (Base ¬∑ Height) / 2", latex: `A = \\frac{${b} \\cdot ${h}}{2}` },
                { latex: `A = \\frac{${b*h}}{2} = \\mathbf{${ans}}` }
            ]
        };
    }

    private level4_Circles(lang: string): any {
        const r = MathUtils.randomInt(3, 9);
        const d = r * 2;
        const isArea = MathUtils.randomInt(0, 1) === 1;
        const showD = MathUtils.randomInt(0, 1) === 1;
        
        let ans = 0, desc = "", steps = [];
        const labelVal = showD ? `d=${d}` : `r=${r}`;

        if (isArea) {
            ans = Math.round(3.14 * r * r * 10) / 10;
            desc = lang === 'sv' ? "Ber√§kna arean (avrunda till 1 decimal)." : "Calculate area (round to 1 decimal).";
            if (showD) steps.push({ text: lang === 'sv' ? "F√∂rst, hitta radien (h√§lften av diametern)." : "First, find radius (half of diameter).", latex: `r = ${d}/2 = ${r}` });
            steps.push({ latex: `A \\approx 3.14 \\cdot ${r}^2 \\approx \\mathbf{${ans}}` });
        } else {
            ans = Math.round(2 * 3.14 * r * 10) / 10;
            desc = lang === 'sv' ? "Ber√§kna omkretsen (avrunda till 1 decimal)." : "Calculate circumference (round to 1 decimal).";
            steps.push({ latex: showD ? `O \\approx 3.14 \\cdot ${d} \\approx \\mathbf{${ans}}` : `O \\approx 2 \\cdot 3.14 \\cdot ${r} \\approx \\mathbf{${ans}}` });
        }

        return {
            renderData: { 
                geometry: { 
                    type: 'circle', 
                    radius: r, 
                    diameter: d, 
                    labels: { val: labelVal, radius: r, diameter: d }, 
                    show: showD ? 'diameter' : 'radius' 
                }, 
                description: desc, answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: steps
        };
    }

    private level5_Composite(lang: string): any {
        const type = MathUtils.randomChoice(['house', 'portal']);
        // Increased random range up to 20
        let w = MathUtils.randomInt(4, 20);
        const h = MathUtils.randomInt(4, 20);
        
        const isArea = MathUtils.randomInt(0, 1) === 1;
        let ans = 0, steps = [], geom: any = {}, desc = "";

        if (type === 'house') {
            const hRoof = MathUtils.randomInt(3, 10);

            if (isArea) {
                const aRect = w * h;
                const aTri = (w * hRoof) / 2;
                ans = aRect + aTri;
                
                desc = lang === 'sv' 
                    ? `Ber√§kna arean av huset (Rektangel ${w}x${h} + Tak ${hRoof}).` 
                    : `Calculate house area (Rectangle ${w}x${h} + Roof ${hRoof}).`;

                steps = [{ latex: `${w}\\cdot${h} + \\frac{${w}\\cdot${hRoof}}{2} = \\mathbf{${ans}}` }];
            } else {
                // Perimeter
                const half = w / 2;
                const slope = Math.sqrt(half*half + hRoof*hRoof);
                ans = Math.round((w + 2*h + 2*slope) * 10) / 10;
                
                desc = lang === 'sv' 
                    ? `Ber√§kna omkretsen (Bredd ${w}, V√§gg ${h}, Takh√∂jd ${hRoof}).` 
                    : `Calculate perimeter (Width ${w}, Wall ${h}, Roof height ${hRoof}).`;

                steps = [{ latex: `${w} + 2\\cdot${h} + 2\\cdot${Math.round(slope*10)/10} \\approx \\mathbf{${ans}}` }];
            }
            geom = { type: 'composite', subtype: 'house', labels: { w, h, h_roof: hRoof } };
        } else {
            // Portal (Rectangle + Semicircle)
            // Ensure width is even for cleaner radius
            if (w % 2 !== 0) w += 1;
            const r = w / 2;

            if (isArea) {
                const aRect = w * h;
                const aSemi = Math.round(3.14 * r * r / 2 * 10) / 10;
                ans = Math.round((aRect + aSemi)*10)/10;
                
                desc = lang === 'sv' 
                    ? `Ber√§kna arean av portalen (Bredd ${w}, H√∂jd ${h}).` 
                    : `Calculate portal area (Width ${w}, Height ${h}).`;

                steps = [{ latex: `${w}\\cdot${h} + \\frac{3.14\\cdot${r}^2}{2} \\approx \\mathbf{${ans}}` }];
            } else {
                const arc = 3.14 * r; // half circ
                ans = Math.round((w + 2*h + arc) * 10) / 10;
                
                desc = lang === 'sv' 
                    ? `Ber√§kna omkretsen (Bredd ${w}, H√∂jd ${h}).` 
                    : `Calculate perimeter (Width ${w}, Height ${h}).`;

                steps = [{ latex: `${w} + 2\\cdot${h} + 3.14\\cdot${r} \\approx \\mathbf{${ans}}` }];
            }
            geom = { type: 'composite', subtype: 'portal', labels: { w, h } };
        }

        return {
            renderData: { geometry: geom, description: desc, answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: steps
        };
    }
}

// FILE END: src\core\generators\GeometryGenerator.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';
import { LinearEquationProblemGen } from './LinearEquationProblemGen.js';

export class LinearEquationGen {
    private problemGen: LinearEquationProblemGen;

    constructor() {
        this.problemGen = new LinearEquationProblemGen();
    }

    public generate(level: number, lang: string = 'sv'): any {
        // Delegate Word Problems to the Specialist
        if (level === 5 || level === 6) {
            return this.problemGen.generate(level, lang);
        }
        
        // Mixed Level Drill
        if (level === 7) {
            return this.level7_Mixed(lang);
        }

        switch (level) {
            case 1: return this.level1_OneStep(lang);
            case 2: return this.level2_TwoStep(lang);
            case 3: return this.level3_Parentheses(lang);
            case 4: return this.level4_BothSides(lang);
            default: return this.level1_OneStep(lang);
        }
    }

    // --- LEVEL 1: One-Step Equations ---
    private level1_OneStep(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        let latex = '', answer = '', clues = [];
        
        if (type === 1) { // x / k = res
            const k = MathUtils.randomInt(2, 9);
            const res = MathUtils.randomInt(2, 10);
            const val = res * k;
            latex = `\\frac{x}{${k}} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' ? `F√∂r att f√• x ensamt, multiplicera b√•da sidor med ${k}.` : `To isolate x, multiply both sides by ${k}.`, 
                latex: `x = ${res} \\cdot ${k}` 
            }];
        } 
        else if (type === 2) { // k * x = res
            const k = MathUtils.randomInt(2, 9);
            const val = MathUtils.randomInt(2, 10);
            const res = k * val;
            latex = `${k}x = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' ? `F√∂r att f√• x ensamt, dela b√•da sidor med ${k}.` : `To isolate x, divide both sides by ${k}.`, 
                latex: `x = \\frac{${res}}{${k}}` 
            }];
        } 
        else if (type === 3) { // x + k = res
            const k = MathUtils.randomInt(1, 20);
            const val = MathUtils.randomInt(1, 20);
            const res = val + k;
            latex = `x + ${k} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' ? `Subtrahera ${k} fr√•n b√•da sidor f√∂r att f√• x ensamt.` : `Subtract ${k} from both sides to isolate x.`, 
                latex: `x = ${res} - ${k}` 
            }];
        } 
        else { // x - k = res
            const k = MathUtils.randomInt(1, 20);
            const val = MathUtils.randomInt(1, 20);
            const res = val - k;
            latex = `x - ${k} = ${res}`;
            answer = val.toString();
            clues = [{ 
                text: lang === 'sv' ? `Addera ${k} till b√•da sidor f√∂r att f√• x ensamt.` : `Add ${k} to both sides to isolate x.`, 
                latex: `x = ${res} + ${k}` 
            }];
        }

        return {
            renderData: { 
                latex, 
                description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", 
                answerType: 'text' 
            },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 2: Two-Step Equations ---
    // Varieties: ax+b=c, ax-b=c, x/a+b=c, x/a-b=c
    private level2_TwoStep(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const x = MathUtils.randomInt(2, 12);
        let latex = '', answer = x.toString(), clues = [];

        if (type === 1) { // ax + b = c
            const a = MathUtils.randomInt(2, 9);
            const b = MathUtils.randomInt(1, 15);
            const c = a * x + b;
            latex = `${a}x + ${b} = ${c}`;
            clues = [
                { text: lang === 'sv' ? `B√∂rja med att ta bort konstanten ${b} (subtrahera).` : `Start by removing the constant ${b} (subtract).`, latex: `${a}x = ${c} - ${b}` },
                { text: lang === 'sv' ? `Dela nu med ${a} f√∂r att hitta x.` : `Now divide by ${a} to find x.`, latex: `x = \\frac{${c-b}}{${a}}` }
            ];
        }
        else if (type === 2) { // ax - b = c
            const a = MathUtils.randomInt(2, 9);
            const b = MathUtils.randomInt(1, 15);
            const c = a * x - b;
            latex = `${a}x - ${b} = ${c}`;
            clues = [
                { text: lang === 'sv' ? `B√∂rja med att ta bort ${b} genom att addera det.` : `Start by removing ${b} by adding it.`, latex: `${a}x = ${c} + ${b}` },
                { text: lang === 'sv' ? `Dela med ${a}.` : `Divide by ${a}.`, latex: `x = \\frac{${c+b}}{${a}}` }
            ];
        }
        else if (type === 3) { // x/a + b = c
            const a = MathUtils.randomInt(2, 8);
            const b = MathUtils.randomInt(1, 10);
            const realX = x * a; 
            const c = x + b; // Here x represents (x/a) value temporarily in logic
            latex = `\\frac{x}{${a}} + ${b} = ${c}`;
            answer = realX.toString();
            clues = [
                { text: lang === 'sv' ? `Ta bort ${b} f√∂rst (subtrahera).` : `Remove ${b} first (subtract).`, latex: `\\frac{x}{${a}} = ${c} - ${b} = ${c-b}` },
                { text: lang === 'sv' ? `Multiplicera med ${a} f√∂r att f√• x ensamt.` : `Multiply by ${a} to isolate x.`, latex: `x = ${c-b} \\cdot ${a}` }
            ];
        }
        else { // x/a - b = c
            const a = MathUtils.randomInt(2, 8);
            const b = MathUtils.randomInt(1, 10);
            const realX = x * a;
            const c = x - b; 
            latex = `\\frac{x}{${a}} - ${b} = ${c}`;
            answer = realX.toString();
            clues = [
                { text: lang === 'sv' ? `Ta bort ${b} f√∂rst (addera).` : `Remove ${b} first (add).`, latex: `\\frac{x}{${a}} = ${c} + ${b} = ${c+b}` },
                { text: lang === 'sv' ? `Multiplicera med ${a} f√∂r att f√• x ensamt.` : `Multiply by ${a} to isolate x.`, latex: `x = ${c+b} \\cdot ${a}` }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 3: Parentheses ---
    // Varieties: a(x+b)=c, a(x-b)=c, a(bx-c)=d, a(bx+c)=d
    private level3_Parentheses(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const a = MathUtils.randomInt(2, 6);
        let latex = '', answer = '', clues = [];

        if (type === 1) { // a(x + b) = c
            const x = MathUtils.randomInt(1, 10);
            const b = MathUtils.randomInt(1, 9);
            const c = a * (x + b);
            answer = x.toString();
            latex = `${a}(x + ${b}) = ${c}`;
            clues = [
                { text: lang === 'sv' ? "Multiplicera in i parentesen." : "Distribute into the parentheses.", latex: `${a}x + ${a*b} = ${c}` },
                { text: lang === 'sv' ? "L√∂s sedan ekvationen som vanligt." : "Then solve the equation as usual.", latex: `${a}x = ${c - a*b}` }
            ];
        }
        else if (type === 2) { // a(x - b) = c
            const x = MathUtils.randomInt(5, 15);
            const b = MathUtils.randomInt(1, x - 1);
            const c = a * (x - b);
            answer = x.toString();
            latex = `${a}(x - ${b}) = ${c}`;
            clues = [
                { text: lang === 'sv' ? "Multiplicera in (kom ih√•g minustecknet)." : "Distribute (remember the minus sign).", latex: `${a}x - ${a*b} = ${c}` },
                { text: lang === 'sv' ? `Addera ${a*b} till b√•da sidor.` : `Add ${a*b} to both sides.`, latex: `${a}x = ${c + a*b}` }
            ];
        }
        else if (type === 3) { // a(bx - c) = d (Inner coefficient)
            const bVar = MathUtils.randomInt(2, 5);
            const x = MathUtils.randomInt(2, 8);
            const cVar = MathUtils.randomInt(1, bVar * x - 1);
            const d = a * (bVar * x - cVar);
            answer = x.toString();
            latex = `${a}(${bVar}x - ${cVar}) = ${d}`;
            clues = [
                { text: lang === 'sv' ? `Multiplicera in ${a} i parentesen.` : `Distribute ${a} into the parentheses.`, latex: `${a*bVar}x - ${a*cVar} = ${d}` },
                { text: lang === 'sv' ? "Addera konstanten och dela med koefficienten." : "Add the constant and divide by the coefficient." }
            ];
        }
        else { // a(bx + c) = d
            const bVar = MathUtils.randomInt(2, 5);
            const x = MathUtils.randomInt(1, 8);
            const cVar = MathUtils.randomInt(1, 9);
            const d = a * (bVar * x + cVar);
            answer = x.toString();
            latex = `${a}(${bVar}x + ${cVar}) = ${d}`;
            clues = [
                { text: lang === 'sv' ? "Multiplicera in i parentesen." : "Distribute into the parentheses.", latex: `${a*bVar}x + ${a*cVar} = ${d}` },
                { text: lang === 'sv' ? "Subtrahera konstanten och dela med koefficienten." : "Subtract the constant and divide by the coefficient." }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    // --- LEVEL 4: Variables on Both Sides ---
    private level4_BothSides(lang: string): any {
        const type = MathUtils.randomInt(1, 4);
        const x = MathUtils.randomInt(1, 10);
        let a = MathUtils.randomInt(3, 9);
        let c = MathUtils.randomInt(2, a - 1); // a > c to keep x positive usually
        if (a === c) a++;

        let latex = '', answer = x.toString(), clues = [];

        if (type === 1) { // ax + b = cx + d
            const b = MathUtils.randomInt(1, 15);
            const d = a*x + b - c*x;
            if (d <= 0) return this.level4_BothSides(lang); // Retry for clean numbers

            latex = `${a}x + ${b} = ${c}x + ${d}`;
            clues = [
                { text: lang === 'sv' ? `Samla x p√• ena sidan. Subtrahera ${c}x.` : `Gather x on one side. Subtract ${c}x.`, latex: `${a-c}x + ${b} = ${d}` },
                { text: lang === 'sv' ? "Flytta √∂ver konstanten och l√∂s ut x." : "Move the constant and solve for x." }
            ];
        }
        else if (type === 2) { // ax - b = cx + d
            const b = MathUtils.randomInt(1, 15);
            const d = a*x - b - c*x;
            if (d <= 0) return this.level4_BothSides(lang);

            latex = `${a}x - ${b} = ${c}x + ${d}`;
            clues = [
                { text: lang === 'sv' ? `Subtrahera ${c}x fr√•n b√•da sidor.` : `Subtract ${c}x from both sides.`, latex: `${a-c}x - ${b} = ${d}` },
                { text: lang === 'sv' ? `Addera ${b} till b√•da sidor.` : `Add ${b} to both sides.` }
            ];
        }
        else if (type === 3) { // ax + b = cx - d (Requires swapping to keep x positive visual simple)
            // Ensure c > a for this form typically, or handle negative
            const temp = a; a = c; c = temp; 
            const b = MathUtils.randomInt(1, 15);
            const d = c*x - a*x - b; // derived d
            if (d <= 0) return this.level4_BothSides(lang); // Retry

            // equation: ax + b = cx - d
            latex = `${a}x + ${b} = ${c}x - ${d}`;
            clues = [
                { text: lang === 'sv' ? `Subtrahera ${a}x fr√•n b√•da sidor (f√∂r att h√•lla x positivt).` : `Subtract ${a}x from both sides (to keep x positive).`, latex: `${b} = ${c-a}x - ${d}` },
                { text: lang === 'sv' ? `Addera ${d} till b√•da sidor.` : `Add ${d} to both sides.`, latex: `${b+d} = ${c-a}x` }
            ];
        }
        else { // ax - b = cx - d
            if (a < c) { const t = a; a = c; c = t; }
            const b = MathUtils.randomInt(5, 20);
            const d = b - (a*x - c*x);
            if (d <= 0) return this.level4_BothSides(lang);

            latex = `${a}x - ${b} = ${c}x - ${d}`;
            clues = [
                { text: lang === 'sv' ? `Subtrahera ${c}x fr√•n b√•da sidor.` : `Subtract ${c}x from both sides.`, latex: `${a-c}x - ${b} = -${d}` },
                { text: lang === 'sv' ? `Addera ${b} till b√•da sidor.` : `Add ${b} to both sides.` }
            ];
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "L√∂s ekvationen" : "Solve the equation", answerType: 'text' },
            token: Buffer.from(answer).toString('base64'),
            clues
        };
    }

    private level7_Mixed(lang: string): any {
        // Random procedural level 1-4
        return this.generate(MathUtils.randomInt(1, 4), lang);
    }
}

// FILE END: src\core\generators\LinearEquationGen.ts

// =======================================================
// FILE START: src\core\generators\LinearEquationProblemGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearEquationProblemGen {
    public generate(level: number, lang: string = 'sv'): any {
        const isWriteMode = level === 5;
        const type = MathUtils.randomChoice(['A', 'B', 'C', 'D']);
        
        let data: any;

        switch (type) {
            case 'A': data = this.scenarioA_RatePlusFixed(lang); break; // ax + b = c
            case 'B': data = this.scenarioB_RateMinusFixed(lang); break; // ax - b = c
            case 'C': data = this.scenarioC_CompareSum(lang); break; // x + (x+a) = c
            case 'D': data = this.scenarioD_CompareDiff(lang); break; // x + (x-b) = c
            default: data = this.scenarioA_RatePlusFixed(lang);
        }

        const taskText = isWriteMode 
            ? (lang === 'sv' ? "Skriv en ekvation som beskriver problemet (du beh√∂ver inte l√∂sa den)." : "Write an equation that describes the problem (you don't need to solve it).")
            : (lang === 'sv' ? "L√∂s problemet. Vilket tal √§r x?" : "Solve the problem. What number is x?");

        const answer = isWriteMode ? data.equation : data.solution;
        const steps = isWriteMode ? data.stepsWrite : data.stepsSolve;

        return {
            renderData: {
                latex: "",
                description: `${data.text} ${taskText}`,
                answerType: isWriteMode ? 'text' : 'text'
            },
            token: Buffer.from(answer.toString()).toString('base64'),
            serverData: { answer: answer, solutionSteps: steps }
        };
    }

    // --- Type A: ax + b = c (Rate + Fixed Cost) ---
    private scenarioA_RatePlusFixed(lang: string) {
        // Expanded Scenarios
        const scenarios = [
            {   // Shopping
                item: lang === 'sv' ? "√§pplen" : "apples",
                unit: lang === 'sv' ? "st" : "each",
                fixed: lang === 'sv' ? "kasse" : "bag",
                textSv: (a:number, b:number, c:number) => `Du k√∂per x √§pplen f√∂r ${a} kr/st och en kasse f√∂r ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x apples for ${a} kr each and a bag for ${b} kr. In total you pay ${c} kr.`
            },
            {   // Taxi
                item: "km",
                unit: "km",
                fixed: lang === 'sv' ? "startavgift" : "start fee",
                textSv: (a:number, b:number, c:number) => `En taxi kostar ${a} kr/km plus ${b} kr i startavgift. Resan kostade totalt ${c} kr. Du √•kte x km.`,
                textEn: (a:number, b:number, c:number) => `A taxi costs ${a} kr/km plus a ${b} kr start fee. The trip cost ${c} kr in total. You traveled x km.`
            },
            {   // Rental
                item: "min",
                unit: "min",
                fixed: lang === 'sv' ? "uppl√•sningsavgift" : "unlock fee",
                textSv: (a:number, b:number, c:number) => `Att hyra en elscooter kostar ${b} kr i startavgift och ${a} kr per minut. Du betalade ${c} kr f√∂r x minuter.`,
                textEn: (a:number, b:number, c:number) => `Renting an e-scooter costs ${b} kr to unlock and ${a} kr per minute. You paid ${c} kr for x minutes.`
            },
            {   // Subscription
                item: lang === 'sv' ? "m√•nader" : "months",
                unit: lang === 'sv' ? "m√•n" : "mo",
                fixed: lang === 'sv' ? "startavgift" : "signup fee",
                textSv: (a:number, b:number, c:number) => `Ett gymkort kostar ${a} kr i m√•naden och ${b} kr i startavgift. Du har betalat totalt ${c} kr. Hur m√•nga m√•nader (x) har du tr√§nat?`,
                textEn: (a:number, b:number, c:number) => `A gym membership costs ${a} kr/month plus a ${b} kr signup fee. You have paid ${c} kr in total. For how many months (x)?`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(3, 15);
        const a = MathUtils.randomInt(5, 30);
        const b = MathUtils.randomChoice([10, 20, 49, 50, 99]);
        const c = a * x + b;

        const equation = `${a}x+${b}=${c}`;
        const text = lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c);

        const stepsWrite = [
            { text: lang === 'sv' ? `1. Den r√∂rliga kostnaden √§r priset per ${s.unit} g√•nger antalet (x).` : `1. The variable cost is the price per ${s.unit} times the quantity (x).`, latex: `${a} \\cdot x = ${a}x` },
            { text: lang === 'sv' ? `2. L√§gg till den fasta avgiften (${s.fixed}).` : `2. Add the fixed fee (${s.fixed}).`, latex: `+ ${b}` },
            { text: lang === 'sv' ? `3. Summan ska bli totalbeloppet ${c}.` : `3. The sum must equal the total ${c}.`, latex: `${a}x + ${b} = ${c}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? `Ta bort den fasta avgiften (${b}) fr√•n totalen.` : `Subtract the fixed fee (${b}) from the total.`, latex: `${a}x = ${c} - ${b} = ${c-b}` },
            { text: lang === 'sv' ? `Dela det som √§r kvar med priset per ${s.unit} (${a}).` : `Divide the remainder by the price per ${s.unit} (${a}).`, latex: `x = \\frac{${c-b}}{${a}} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type B: ax - b = c (Discount) ---
    private scenarioB_RateMinusFixed(lang: string) {
        const scenarios = [
            {
                textSv: (a:number, b:number, c:number) => `Du k√∂per x datorspel f√∂r ${a} kr/st. Du har en rabattkupong p√• ${b} kr. Totalt betalar du ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x video games for ${a} kr each. You have a discount coupon for ${b} kr. You pay ${c} kr total.`
            },
            {
                textSv: (a:number, b:number, c:number) => `En grupp p√• x personer g√•r p√• bio. Biljetten kostar ${a} kr. Gruppen f√•r en grupprabatt p√• ${b} kr. De betalar totalt ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `A group of x people go to the cinema. Tickets are ${a} kr. The group gets a ${b} kr discount. They pay ${c} kr total.`
            },
            {
                textSv: (a:number, b:number, c:number) => `Du k√∂per x tr√∂jor som kostar ${a} kr styck. Eftersom du √§r medlem f√•r du ${b} kr rabatt p√• hela k√∂pet. Du betalar ${c} kr.`,
                textEn: (a:number, b:number, c:number) => `You buy x shirts costing ${a} kr each. As a member, you get ${b} kr off the total purchase. You pay ${c} kr.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(2, 8);
        const a = MathUtils.randomInt(50, 150);
        const b = MathUtils.randomChoice([20, 50, 100]);
        const c = a * x - b;

        const equation = `${a}x-${b}=${c}`;
        const text = lang === 'sv' ? s.textSv(a,b,c) : s.textEn(a,b,c);

        const stepsWrite = [
            { text: lang === 'sv' ? "1. B√∂rja med vad det hade kostat utan rabatt (pris g√•nger antal)." : "1. Start with the cost without discount (price times quantity).", latex: `${a}x` },
            { text: lang === 'sv' ? `2. Rabatten minskar priset, s√• vi subtraherar ${b}.` : `2. The discount reduces the price, so subtract ${b}.`, latex: `- ${b}` },
            { text: lang === 'sv' ? "3. S√§tt uttrycket lika med det du faktiskt betalade." : "3. Set the expression equal to what you actually paid.", latex: `${a}x - ${b} = ${c}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "L√§gg tillbaka rabatten p√• totalen f√∂r att se vad ordinarie pris var." : "Add the discount back to the total to find the original price.", latex: `${a}x = ${c} + ${b} = ${c+b}` },
            { text: lang === 'sv' ? `Dela med styckpriset (${a}) f√∂r att se hur m√•nga du k√∂pte.` : `Divide by the unit price (${a}) to see how many you bought.`, latex: `x = \\frac{${c+b}}{${a}} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type C: Compare Sum (x + (x+a) = c) ---
    private scenarioC_CompareSum(lang: string) {
        const scenarios = [
            {   // Money
                textSv: (a:number, c:number) => `Kim har x kr. Alex har ${a} kr mer √§n Kim. Tillsammans har de ${c} kr.`,
                textEn: (a:number, c:number) => `Kim has x kr. Alex has ${a} kr more than Kim. Together they have ${c} kr.`
            },
            {   // Age
                textSv: (a:number, c:number) => `Leo √§r x √•r. Hans syster √§r ${a} √•r √§ldre. Tillsammans √§r de ${c} √•r.`,
                textEn: (a:number, c:number) => `Leo is x years old. His sister is ${a} years older. Together they are ${c} years old.`
            },
            {   // Election/Votes
                textSv: (a:number, c:number) => `I ett val fick Parti A x r√∂ster. Parti B fick ${a} fler r√∂ster. Totalt fick de ${c} r√∂ster.`,
                textEn: (a:number, c:number) => `In an election, Party A got x votes. Party B got ${a} more votes. In total they got ${c} votes.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(5, 25);
        const a = MathUtils.randomInt(2, 10);
        const total = x + (x + a);
        
        const equation = `2x+${a}=${total}`;
        const text = lang === 'sv' ? s.textSv(a, total) : s.textEn(a, total);

        const stepsWrite = [
            { text: lang === 'sv' ? "Person/Sak 1:" : "Person/Item 1:", latex: "x" },
            { text: lang === 'sv' ? `Person/Sak 2 (som har ${a} mer):` : `Person/Item 2 (has ${a} more):`, latex: `x + ${a}` },
            { text: lang === 'sv' ? "Addera dem f√∂r att f√• summan:" : "Add them to get the sum:", latex: `x + (x + ${a}) = ${total} \\implies 2x + ${a} = ${total}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "Ta bort det extra (skillnaden) fr√•n totalen." : "Remove the extra difference from the total.", latex: `2x = ${total} - ${a} = ${total-a}` },
            { text: lang === 'sv' ? "Dela resten lika p√• tv√•." : "Divide the remainder equally by two.", latex: `x = \\frac{${total-a}}{2} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }

    // --- Type D: Compare Diff (x + (x-b) = c) ---
    private scenarioD_CompareDiff(lang: string) {
        const scenarios = [
            {   // Class size
                textSv: (b:number, c:number) => `I klass 7A g√•r det x elever. I 7B g√•r det ${b} f√§rre elever. Totalt g√•r det ${c} elever i √•rskursen.`,
                textEn: (b:number, c:number) => `Class 7A has x students. 7B has ${b} fewer students. There are ${c} students in total.`
            },
            {   // Lengths
                textSv: (b:number, c:number) => `En planka delas i tv√• bitar. Den f√∂rsta √§r x cm. Den andra √§r ${b} cm kortare. Hela plankan var ${c} cm.`,
                textEn: (b:number, c:number) => `A plank is cut in two. The first piece is x cm. The second is ${b} cm shorter. The whole plank was ${c} cm.`
            },
            {   // Weight
                textSv: (b:number, c:number) => `Hundvalpen v√§ger x kg. Katten v√§ger ${b} kg mindre. Tillsammans v√§ger de ${c} kg.`,
                textEn: (b:number, c:number) => `The puppy weighs x kg. The cat weighs ${b} kg less. Together they weigh ${c} kg.`
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        const x = MathUtils.randomInt(10, 50);
        const b = MathUtils.randomInt(2, 9);
        const total = x + (x - b);

        const equation = `2x-${b}=${total}`;
        const text = lang === 'sv' ? s.textSv(b, total) : s.textEn(b, total);

        const stepsWrite = [
            { text: lang === 'sv' ? "Del 1:" : "Part 1:", latex: "x" },
            { text: lang === 'sv' ? `Del 2 (som √§r ${b} mindre):` : `Part 2 (which is ${b} less):`, latex: `x - ${b}` },
            { text: lang === 'sv' ? "Summan av delarna:" : "Sum of the parts:", latex: `x + (x - ${b}) = ${total} \\implies 2x - ${b} = ${total}` }
        ];

        const stepsSolve = [
            { text: lang === 'sv' ? "L√§gg till skillnaden till totalen f√∂r att 'j√§mna ut' det." : "Add the difference to the total to 'even it out'.", latex: `2x = ${total} + ${b} = ${total+b}` },
            { text: lang === 'sv' ? "Dela resultatet p√• tv√•." : "Divide the result by two.", latex: `x = \\frac{${total+b}}{2} = ${x}` }
        ];

        return { text, equation, solution: x, stepsWrite, stepsSolve };
    }
}

// FILE END: src\core\generators\LinearEquationProblemGen.ts

// =======================================================
// FILE START: src\core\generators\LinearGraphGenerator.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class LinearGraphGenerator {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_FindM(lang);
            case 2: return this.level2_FindK_Pos(lang);
            case 3: return this.level3_FindK_Neg(lang);
            case 4: return this.level4_FindFunction(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_FindM(lang);
        }
    }

    private level1_FindM(lang: string): any {
        const m = MathUtils.randomInt(-4, 4);
        return {
            renderData: { graph: { range: 10, lines: [{ slope: 1, intercept: m, color: '#2563eb' }] }, description: "Best√§m m-v√§rdet.", answerType: 'text' },
            token: Buffer.from(m.toString()).toString('base64'),
            serverData: { answer: m, solutionSteps: [
                { text: lang === 'sv' ? "m √§r v√§rdet d√§r linjen sk√§r y-axeln." : "m is where the line crosses the y-axis." },
                { latex: `(0, ${m})` }
            ]}
        };
    }

    private level2_FindK_Pos(lang: string): any {
        const k = MathUtils.randomInt(1, 3);
        return {
            renderData: { graph: { range: 10, lines: [{ slope: k, intercept: 0, color: '#16a34a' }] }, description: "Best√§m k-v√§rdet (lutningen).", answerType: 'text' },
            token: Buffer.from(k.toString()).toString('base64'),
            serverData: { answer: k, solutionSteps: [
                { text: lang === 'sv' ? "G√• 1 steg √•t h√∂ger. Hur m√•nga steg g√•r du upp?" : "Go 1 step right. How many steps up?", latex: `\\Delta x = 1, \\Delta y = ${k}` }
            ]}
        };
    }

    private level3_FindK_Neg(lang: string): any {
        const k = MathUtils.randomInt(-3, -1);
        return {
            renderData: { graph: { range: 10, lines: [{ slope: k, intercept: 5, color: '#dc2626' }] }, description: "Best√§m k-v√§rdet.", answerType: 'text' },
            token: Buffer.from(k.toString()).toString('base64'),
            serverData: { answer: k, solutionSteps: [
                { text: lang === 'sv' ? "Linjen lutar ned√•t, s√• k √§r negativt." : "Line slopes down, so k is negative.", latex: `k = ${k}` }
            ]}
        };
    }

    private level4_FindFunction(lang: string): any {
        const k = MathUtils.randomChoice([1, 2, -1, -2]);
        const m = MathUtils.randomInt(-3, 3);
        const sign = m >= 0 ? '+' : '';
        const eq = `y=${k}x${sign}${m}`;
        
        return {
            renderData: { graph: { range: 10, lines: [{ slope: k, intercept: m, color: '#7c3aed' }] }, description: "Skriv formeln (y=kx+m).", answerType: 'text' },
            token: Buffer.from(eq).toString('base64'),
            serverData: { answer: eq, solutionSteps: [
                { text: lang === 'sv' ? "1. Hitta m (y-sk√§rning)." : "1. Find m (intercept).", latex: `m=${m}` },
                { text: lang === 'sv' ? "2. Hitta k (lutning)." : "2. Find k (slope).", latex: `k=${k}` }
            ]}
        };
    }

    private level5_Mixed(lang: string): any {
        return this.generate(MathUtils.randomInt(1, 4), lang);
    }
}

// FILE END: src\core\generators\LinearGraphGenerator.ts

// =======================================================
// FILE START: src\core\generators\NegativeNumbersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class NegativeNumbersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_AddSubSimple(lang);
            case 2: return this.level2_AddSubHard(lang);
            case 3: return this.level3_Multiplication(lang);
            case 4: return this.level4_Division(lang);
            case 5: return this.level5_Mixed(lang);
            default: return this.level1_AddSubSimple(lang);
        }
    }

    private p(n: number): string {
        return n < 0 ? `(${n})` : `${n}`;
    }

    // Level 1: Simple (-5 + 3, 2 - 8)
    private level1_AddSubSimple(lang: string): any {
        // Range logic from legacy: 10 range, min -10
        const start = MathUtils.randomInt(-10, 10);
        const change = MathUtils.randomInt(1, 10);
        const op = Math.random() > 0.5 ? '+' : '-';
        const ans = op === '+' ? start + change : start - change;

        return {
            renderData: { 
                latex: `${start} ${op} ${change}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "T√§nk p√• en termometer." : "Think of a thermometer." },
                { 
                    text: op === '+' 
                        ? (lang === 'sv' ? `Starta p√• ${start} och g√• ${change} steg UPP√ÖT.` : `Start at ${start} and go ${change} steps UP.`) 
                        : (lang === 'sv' ? `Starta p√• ${start} och g√• ${change} steg NED√ÖT.` : `Start at ${start} and go ${change} steps DOWN.`) 
                }
            ]
        };
    }

    // Level 2: Double signs (5 - (-3))
    private level2_AddSubHard(lang: string): any {
        const a = MathUtils.randomInt(-10, 10);
        const b = MathUtils.randomInt(-10, -1); // Negative second number ensures double sign
        const op = Math.random() > 0.5 ? '+' : '-';
        const ans = op === '+' ? a + b : a - b;

        let ruleText = "";
        let ruleLatex = "";

        // Pedagogical Logic
        if (op === '+') {
            // Adding a negative: 5 + (-3) -> 5 - 3
            ruleText = lang === 'sv' ? "Plus och minus bredvid varandra blir MINUS." : "Plus and minus next to each other become MINUS.";
            ruleLatex = `${a} - ${Math.abs(b)}`;
        } else {
            // Subtracting a negative: 5 - (-3) -> 5 + 3
            ruleText = lang === 'sv' ? "Tv√• minus bredvid varandra blir PLUS." : "Two minuses next to each other become PLUS.";
            ruleLatex = `${a} + ${Math.abs(b)}`;
        }

        return {
            renderData: { 
                latex: `${a} ${op} (${b})`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: ruleText, latex: ruleLatex },
                { text: lang === 'sv' ? "R√§kna nu ut det nya uttrycket." : "Now calculate the new expression." }
            ]
        };
    }

    // Level 3: Multiplication (-5 * -5)
    private level3_Multiplication(lang: string): any {
        // Ensure non-zero to emphasize sign rules
        let a = 0, b = 0;
        while(a===0) a = MathUtils.randomInt(-10, 10);
        while(b===0) b = MathUtils.randomInt(-10, 10);
        
        const ans = a * b;
        const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);

        return {
            renderData: { 
                latex: `${this.p(a)} \\cdot ${this.p(b)}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { 
                    text: sameSign 
                    ? (lang === 'sv' ? "Lika tecken ger PLUS (+)." : "Same signs give PLUS (+).") 
                    : (lang === 'sv' ? "Olika tecken ger MINUS (-)." : "Different signs give MINUS (-).") 
                },
                {
                    text: lang === 'sv' ? `Multiplicera siffrorna: ${Math.abs(a)} * ${Math.abs(b)}` : `Multiply the numbers: ${Math.abs(a)} * ${Math.abs(b)}`,
                    latex: `\\mathbf{${ans}}`
                }
            ]
        };
    }

    // Level 4: Division
    private level4_Division(lang: string): any {
        let b = 0;
        while(b === 0) b = MathUtils.randomInt(-10, 10);
        
        const maxRes = Math.floor(100 / Math.abs(b));
        let res = 0;
        while(res === 0) res = MathUtils.randomInt(-maxRes, maxRes);
        
        const a = res * b;
        const ans = res;
        
        const sameSign = (a > 0 && b > 0) || (a < 0 && b < 0);

        return {
            renderData: { 
                latex: `\\frac{${a}}{${b}}`, 
                description: lang === 'sv' ? "Ber√§kna." : "Calculate.", 
                answerType: 'text' 
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { 
                    text: sameSign 
                    ? (lang === 'sv' ? "Lika tecken ger PLUS (+)." : "Same signs give PLUS (+).") 
                    : (lang === 'sv' ? "Olika tecken ger MINUS (-)." : "Different signs give MINUS (-).") 
                },
                {
                    text: lang === 'sv' ? `Dividera siffrorna: ${Math.abs(a)} / ${Math.abs(b)}` : `Divide the numbers: ${Math.abs(a)} / ${Math.abs(b)}`
                }
            ]
        };
    }

    private level5_Mixed(lang: string): any {
        const lvl = MathUtils.randomInt(1, 4);
        return this.generate(lvl, lang);
    }
}

// FILE END: src\core\generators\NegativeNumbersGen.ts

// =======================================================
// FILE START: src\core\generators\ScaleGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class ScaleGen {
    // Ensure these match the keys in GeometryComponents.jsx
    private static readonly SHAPES = ['arrow', 'star', 'lightning', 'key', 'heart', 'cloud', 'moon', 'sun'];
    private static readonly AREA_SHAPES = ['rectangle', 'triangle', 'circle', 'square'];

    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concepts(lang);
            case 2: return this.level2_CalcLengthSimple(lang);
            case 3: return this.level3_MixedScenarios(lang);
            case 4: return this.level4_DetermineScale(lang);
            case 5: return this.level5_NoPictures(lang);
            case 6: return this.level6_AreaScale(lang);
            case 7: return this.level7_Mixed(lang);
            default: return this.level1_Concepts(lang);
        }
    }

    // Level 1: Concepts
    private level1_Concepts(lang: string): any {
        const isReduction = MathUtils.randomInt(0, 1) === 1;
        const ratio = MathUtils.randomChoice([2, 5, 10, 50, 100]);
        const scaleStr = isReduction ? `1:${ratio}` : `${ratio}:1`;
        
        const qType = MathUtils.randomInt(1, 2);
        let desc = "", correct = "", wrong = "", expl = "";

        if (qType === 1) {
            desc = lang === 'sv' ? `Visar skalan ${scaleStr} en f√∂rstoring eller en f√∂rminskning?` : `Does ${scaleStr} show an enlargement or reduction?`;
            if (isReduction) {
                correct = lang === 'sv' ? "F√∂rminskning" : "Reduction";
                wrong = lang === 'sv' ? "F√∂rstoring" : "Enlargement";
                expl = lang === 'sv' 
                    ? "Det f√∂rsta talet (1) √§r mindre √§n det andra. Bilden √§r mindre √§n verkligheten." 
                    : "The first number (1) is smaller. The image is smaller than reality.";
            } else {
                correct = lang === 'sv' ? "F√∂rstoring" : "Enlargement";
                wrong = lang === 'sv' ? "F√∂rminskning" : "Reduction";
                expl = lang === 'sv' 
                    ? "Det f√∂rsta talet √§r st√∂rre √§n 1. Bilden √§r st√∂rre √§n verkligheten." 
                    : "The first number is larger than 1. The image is larger than reality.";
            }
        } else {
            desc = lang === 'sv' ? `Skalan √§r ${scaleStr}. Vad √§r st√∂rst?` : `Scale is ${scaleStr}. Which is larger?`;
            const real = lang === 'sv' ? "Verkligheten" : "Reality";
            const img = lang === 'sv' ? "Bilden" : "The image";
            if (isReduction) {
                correct = real; wrong = img;
                expl = lang === 'sv' 
                    ? `1 cm p√• bilden motsvarar ${ratio} cm i verkligheten. Verkligheten √§r allts√• mycket st√∂rre.` 
                    : `1 cm on the image equals ${ratio} cm in reality. So reality is much larger.`;
            } else {
                correct = img; wrong = real;
                expl = lang === 'sv' 
                    ? `${ratio} cm p√• bilden √§r bara 1 cm i verkligheten. Bilden √§r uppf√∂rstorad.` 
                    : `${ratio} cm on the image is only 1 cm in reality. The image is magnified.`;
            }
        }

        return {
            renderData: {
                description: desc,
                latex: scaleStr,
                answerType: 'multiple_choice',
                choices: Math.random() > 0.5 ? [correct, wrong] : [wrong, correct],
                geometry: { type: 'scale_single', shape: 'magnifying_glass', label: scaleStr }
            },
            token: Buffer.from(correct).toString('base64'),
            clues: [{ text: expl, latex: "" }]
        };
    }

    // Level 2: Simple Length
    private level2_CalcLengthSimple(lang: string): any {
        const scale = MathUtils.randomChoice([2, 3, 4, 5, 10]);
        const imgVal = MathUtils.randomInt(2, 12);
        const isReduction = MathUtils.randomInt(0, 1) === 1;
        const scaleStr = isReduction ? `1:${scale}` : `${scale}:1`;
        const subType = MathUtils.randomInt(0, 1);
        const shape = MathUtils.randomChoice(ScaleGen.SHAPES);
        
        let ans = 0, label = "", desc = "", steps = [];

        if (isReduction) {
            if (subType === 0) { // Find Real
                ans = imgVal * scale;
                desc = lang === 'sv' ? `Bilden √§r ${imgVal} cm. Skalan √§r ${scaleStr}. Hur l√•ng √§r den i verkligheten? (cm)` : `Image is ${imgVal} cm. Scale ${scaleStr}. Reality? (cm)`;
                label = `${imgVal} cm`;
                steps.push({ 
                    text: lang === 'sv' ? "Verkligheten √§r st√∂rre √§n bilden. Multiplicera bilden med skalan." : "Reality is larger. Multiply image by scale.", 
                    latex: `${imgVal} \\cdot ${scale} = \\mathbf{${ans}}` 
                });
            } else { // Find Image
                const real = imgVal * scale;
                ans = imgVal;
                desc = lang === 'sv' ? `I verkligheten √§r den ${real} cm. Skalan √§r ${scaleStr}. Hur l√•ng √§r den p√• ritningen?` : `Reality is ${real} cm. Scale ${scaleStr}. Drawing?`;
                label = `${real} cm`; 
                steps.push({ 
                    text: lang === 'sv' ? "Bilden √§r mindre √§n verkligheten. Dividera verkligheten med skalan." : "Image is smaller. Divide reality by scale.", 
                    latex: `\\frac{${real}}{${scale}} = \\mathbf{${ans}}` 
                });
            }
        } else {
            // Enlargement
            if (subType === 0) { // Find Image
                ans = imgVal * scale;
                desc = lang === 'sv' ? `Verkligheten √§r ${imgVal} cm. Skala ${scaleStr}. Hur stor blir den p√• bild?` : `Reality is ${imgVal} cm. Scale ${scaleStr}. Image size?`;
                label = `${imgVal} cm`;
                steps.push({ 
                    text: lang === 'sv' ? "Bilden √§r en f√∂rstoring. Multiplicera verkligheten med skalan." : "Image is enlarged. Multiply reality by scale.", 
                    latex: `${imgVal} \\cdot ${scale} = \\mathbf{${ans}}` 
                });
            } else { // Find Real
                ans = imgVal;
                const drawVal = ans * scale;
                desc = lang === 'sv' ? `P√• bilden √§r den ${drawVal} cm. Skala ${scaleStr}. Hur stor √§r den i verkligheten?` : `Image is ${drawVal} cm. Scale ${scaleStr}. Reality?`;
                label = `${drawVal} cm`;
                steps.push({ 
                    text: lang === 'sv' ? "Verkligheten √§r mindre √§n den f√∂rstorade bilden. Dividera bildens m√•tt med skalan." : "Reality is smaller than the enlarged image. Divide the image measurement by the scale.", 
                    latex: `\\frac{${drawVal}}{${scale}} = \\mathbf{${ans}}` 
                });
            }
        }

        return {
            renderData: { description: desc, latex: scaleStr, answerType: 'numeric', geometry: { type: 'scale_single', shape, label } },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: steps
        };
    }

    // Level 3: Mixed Scenarios (Map, House, Model, Microscope, Astronomy, Weather)
    private level3_MixedScenarios(lang: string): any {
        const type = MathUtils.randomChoice(['map', 'house', 'model', 'microscope', 'astro', 'cloud']);
        
        let scale = 0, drawVal = 0, answer = 0;
        let scaleStr = "", desc = "", label = "", icon = "";
        let steps: any[] = [];

        if (type === 'map') {
            // Map: Find Reality in km/m
            scale = MathUtils.randomChoice([10000, 20000, 50000]);
            scaleStr = `1:${scale}`;
            drawVal = MathUtils.randomInt(2, 10);
            const realCm = drawVal * scale;
            const realKm = realCm / 100000;
            const useKm = realKm >= 1;
            const unit = useKm ? 'km' : 'm';
            answer = useKm ? realKm : realCm / 100;
            
            icon = 'map'; 
            label = `${drawVal} cm`;
            
            desc = lang === 'sv' 
                ? `P√• en karta √§r avst√•ndet ${drawVal} cm. Skalan √§r ${scaleStr}. Hur l√•ngt √§r det i verkligheten? (Svara i ${unit})`
                : `On a map distance is ${drawVal} cm. Scale is ${scaleStr}. How far is it in reality? (Answer in ${unit})`;
                
            steps = [
                { text: lang === 'sv' ? "Kartor √§r f√∂rminskningar. Verkligheten √§r st√∂rre, s√• vi multiplicerar med skalan." : "Maps are reductions. Reality is larger, so we multiply by the scale.", latex: `${drawVal} \\cdot ${scale} = ${realCm} \\text{ cm}` },
                { text: lang === 'sv' ? `Omvandla cm till ${unit} (1 km = 100 000 cm, 1 m = 100 cm).` : `Convert cm to ${unit} (1 km = 100,000 cm, 1 m = 100 cm).`, latex: `\\mathbf{${answer}}` }
            ];
        } 
        else if (type === 'house') {
            // House Plan: Find Reality in m
            scale = MathUtils.randomChoice([50, 100]);
            scaleStr = `1:${scale}`;
            drawVal = MathUtils.randomInt(4, 15);
            const realCm = drawVal * scale;
            answer = realCm / 100; // meters
            
            icon = 'house'; 
            label = `${drawVal} cm`;
            
            desc = lang === 'sv'
                ? `P√• en ritning √§r en v√§gg ${drawVal} cm l√•ng. Skalan √§r ${scaleStr}. Hur l√•ng √§r den i verkligheten? (Svara i m)`
                : `On a blueprint a wall is ${drawVal} cm. Scale ${scaleStr}. How long in reality? (Answer in m)`;
                
            steps = [
                { text: lang === 'sv' ? "Verkligheten √§r st√∂rre √§n ritningen. Multiplicera m√•ttet med skalan." : "Reality is larger than the drawing. Multiply the measurement by the scale.", latex: `${drawVal} \\cdot ${scale} = ${realCm} \\text{ cm}` },
                { text: lang === 'sv' ? "Omvandla cm till meter (dela med 100)." : "Convert cm to meters (divide by 100).", latex: `\\frac{${realCm}}{100} = \\mathbf{${answer}}` }
            ];
        }
        else if (type === 'model') {
            // Model Car: Find Model size in cm given Reality in m
            scale = MathUtils.randomChoice([20, 24, 40]);
            scaleStr = `1:${scale}`;
            const realM = MathUtils.randomInt(3, 6);
            const realCm = realM * 100;
            // Ensure integer division
            let adjRealCm = realCm;
            while (adjRealCm % scale !== 0) adjRealCm += 100; 
            const adjRealM = adjRealCm / 100;
            
            answer = adjRealCm / scale;
            
            icon = 'car'; 
            label = `${adjRealM} m`;
            
            desc = lang === 'sv'
                ? `En bil √§r ${adjRealM} m l√•ng i verkligheten. Skalan p√• modellen √§r ${scaleStr}. Hur l√•ng √§r modellen? (Svara i cm)`
                : `A car is ${adjRealM} m long. Model scale is ${scaleStr}. How long is the model? (Answer in cm)`;
                
            steps = [
                { text: lang === 'sv' ? "G√∂r f√∂rst om bilens l√§ngd till cm." : "First convert the car's length to cm.", latex: `${adjRealM} \\text{ m} = ${adjRealCm} \\text{ cm}` },
                { text: lang === 'sv' ? "Modellen √§r mindre √§n bilen. Dividera med skalan." : "The model is smaller. Divide by the scale.", latex: `\\frac{${adjRealCm}}{${scale}} = \\mathbf{${answer}}` }
            ];
        }
        else if (type === 'astro') {
             // Moon/Sun distance or size
             scale = MathUtils.randomChoice([1000000, 10000000]);
             scaleStr = `1:${scale}`;
             const drawCm = MathUtils.randomInt(2, 8);
             const realCm = drawCm * scale;
             const realKm = realCm / 100000;
             answer = realKm;

             icon = MathUtils.randomChoice(['moon', 'sun']);
             label = `${drawCm} cm`;

             desc = lang === 'sv' 
                ? `I en rymdmodell √§r avst√•ndet ${drawCm} cm. Skalan √§r ${scaleStr}. Hur m√•nga km √§r det i verkligheten?`
                : `In a space model the distance is ${drawCm} cm. Scale is ${scaleStr}. How many km in reality?`;

             steps = [
                 { text: lang === 'sv' ? "Verkligheten √§r enormt mycket st√∂rre. Multiplicera med skalan." : "Reality is huge. Multiply by scale.", latex: `${drawCm} \\cdot ${scale} = ${realCm} \\text{ cm}` },
                 { text: lang === 'sv' ? "Omvandla cm till km (dela med 100 000)." : "Convert cm to km (divide by 100,000).", latex: `\\mathbf{${answer}}` }
             ];
        }
        else if (type === 'cloud') {
             // Cloud height
             scale = 20000;
             scaleStr = `1:${scale}`;
             const drawCm = MathUtils.randomInt(2, 10);
             const realCm = drawCm * scale;
             const realM = realCm / 100;
             answer = realM;

             icon = 'cloud';
             label = `${drawCm} cm`;

             desc = lang === 'sv'
                ? `P√• en v√§derkarta √§r molnh√∂jden ${drawCm} cm. Skalan √§r ${scaleStr}. Hur h√∂gt √§r molnet i meter?`
                : `On a weather map cloud height is ${drawCm} cm. Scale ${scaleStr}. Height in meters?`;
             
             steps = [
                 { text: lang === 'sv' ? "Multiplicera med skalan f√∂r att f√• verklig h√∂jd i cm." : "Multiply by scale to get real height in cm.", latex: `${drawCm} \\cdot ${scale} = ${realCm} \\text{ cm}` },
                 { text: lang === 'sv' ? "Omvandla till meter." : "Convert to meters.", latex: `\\mathbf{${answer}}` }
             ];
        }
        else {
            // Microscope (Ladybug/Cell): Enlargement.
            scale = MathUtils.randomChoice([10, 20, 50]);
            scaleStr = `${scale}:1`;
            const realMm = MathUtils.randomInt(2, 8);
            answer = realMm;
            const drawCm = (realMm * scale) / 10;
            
            icon = 'ladybug';
            label = `${drawCm} cm`;
            
            desc = lang === 'sv'
                ? `P√• en bild √§r en insekt ${drawCm} cm l√•ng. Skalan √§r ${scaleStr} (f√∂rstoring). Hur l√•ng √§r den i verkligheten? (Svara i mm)`
                : `In a picture an insect is ${drawCm} cm. Scale ${scaleStr}. Reality? (Answer in mm)`;
                
            steps = [
                { text: lang === 'sv' ? "G√∂r om bildens m√•tt till mm (x10)." : "Convert picture to mm (x10).", latex: `${drawCm} \\text{ cm} = ${drawCm*10} \\text{ mm}` },
                { text: lang === 'sv' ? "Verkligheten √§r mindre √§n den f√∂rstorade bilden. Dividera med skalan." : "Reality is smaller than the zoomed image. Divide by scale.", latex: `\\frac{${drawCm*10}}{${scale}} = \\mathbf{${answer}}` }
            ];
        }

        return {
            renderData: {
                description: desc,
                latex: scaleStr,
                answerType: 'numeric',
                geometry: { type: 'scale_single', shape: icon, label: label }
            },
            token: Buffer.from(answer.toString()).toString('base64'),
            clues: steps
        };
    }

    // Level 4: Determine Scale
    private level4_DetermineScale(lang: string): any {
        const factor = MathUtils.randomChoice([2, 3, 4, 5]);
        const base = MathUtils.randomInt(2, 6);
        const lg = base * factor;
        const isReduction = MathUtils.randomInt(0, 1) === 1;
        const shape = MathUtils.randomChoice(ScaleGen.SHAPES);
        
        let leftL, rightL, leftV, rightV, ansLeft, ansRight;
        if (isReduction) {
            leftL = lang === 'sv' ? "Bild" : "Image"; leftV = `${base} cm`;
            rightL = lang === 'sv' ? "Verklighet" : "Reality"; rightV = `${lg} cm`;
            ansLeft = 1; ansRight = factor;
        } else {
            leftL = lang === 'sv' ? "Verklighet" : "Reality"; leftV = `${base} cm`;
            rightL = lang === 'sv' ? "Bild" : "Image"; rightV = `${lg} cm`;
            ansLeft = factor; ansRight = 1;
        }

        return {
            renderData: {
                description: lang === 'sv' ? "Best√§m skalan." : "Determine the scale.",
                answerType: 'scale',
                geometry: { type: 'scale_compare', shape, leftLabel: leftL, leftValue: leftV, rightLabel: rightL, rightValue: rightV }
            },
            token: Buffer.from(`${ansLeft}:${ansRight}`).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Skala = Bild : Verklighet" : "Scale = Image : Reality", latex: "" },
                { text: lang === 'sv' ? "F√∂renkla." : "Simplify.", latex: `1:${factor}` }
            ]
        };
    }

    // Level 5: Word Problems
    private level5_NoPictures(lang: string): any {
        const scenarios = [
            { sv: "Ett torn √§r 50 m h√∂gt. En modell √§r 50 cm h√∂g.", en: "Tower is 50 m. Model is 50 cm.", scale: "1:100", conv: "50 m = 5000 cm" },
            { sv: "En insekt √§r 5 mm l√•ng. P√• bild 10 cm.", en: "Insect is 5 mm. Image is 10 cm.", scale: "20:1", conv: "10 cm = 100 mm" }
        ];
        const s = MathUtils.randomChoice(scenarios);
        
        return {
            renderData: { description: `${s.sv} (Skala?)`, answerType: 'scale' },
            token: Buffer.from(s.scale).toString('base64'),
            clues: [{ text: lang === 'sv' ? "G√∂r om till samma enhet." : "Convert to same unit.", latex: s.conv }]
        };
    }

    // Level 6: Area Scale
    private level6_AreaScale(lang: string): any {
        const shape = MathUtils.randomChoice(ScaleGen.AREA_SHAPES);
        const L = MathUtils.randomInt(2, 5); 
        const A = L * L;
        const baseArea = MathUtils.randomInt(2, 10);
        const bigArea = baseArea * A;

        return {
            renderData: {
                description: lang === 'sv' ? `L√§ngdskala 1:${L}. Lilla arean ${baseArea}. Stora arean?` : `Length scale 1:${L}. Small area ${baseArea}. Big area?`,
                answerType: 'numeric',
                geometry: { type: 'compare_shapes_area', shapeType: shape, left: { label: 'Bild', area: baseArea }, right: { label: 'Verklighet', area: '?' } }
            },
            token: Buffer.from(bigArea.toString()).toString('base64'),
            clues: [{ latex: `A_{skala} = L_{skala}^2 = ${L}^2 = ${A}` }]
        };
    }

    private level7_Mixed(lang: string): any {
        return this.generate(MathUtils.randomInt(2, 6), lang);
    }
}

// FILE END: src\core\generators\ScaleGen.ts

// =======================================================
// FILE START: src\core\generators\SimilarityGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class SimilarityGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Concept(lang);
            case 2: return this.level2_CalcSide(lang);
            case 3: return this.level3_TopTriangle(lang);
            case 4: return this.level4_Pythagoras(lang);
            default: return this.level1_Concept(lang);
        }
    }

    // Level 1: Concept (Similar or Not?)
    private level1_Concept(lang: string): any {
        const isSimilar = MathUtils.randomInt(0, 1) === 1;
        const type = MathUtils.randomChoice(['rect_sides', 'tri_sides', 'tri_angles']);
        
        let geom: any = { type: 'similarity_compare' };
        let desc = "";
        let steps = [];

        if (type === 'rect_sides') {
            geom.shapeType = 'rectangle';
            const w1 = MathUtils.randomInt(2, 5) * 10;
            const h1 = MathUtils.randomInt(2, 5) * 10;
            
            const k = isSimilar ? MathUtils.randomChoice([1.5, 2, 0.5]) : MathUtils.randomChoice([1.2, 1.8, 0.8]);
            const w2 = Math.round(w1 * k);
            const h2 = isSimilar ? Math.round(h1 * k) : Math.round(h1 * (k + 0.5)); 

            geom.left = { labels: { b: w1, h: h1 } };
            geom.right = { labels: { b: w2, h: h2 } };
            
            desc = lang === 'sv' ? "√Ñr rektanglarna likformiga?" : "Are the rectangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "F√∂r att de ska vara likformiga m√•ste f√∂rh√•llandet mellan sidorna vara samma. J√§mf√∂r baserna och h√∂jderna." : "For similarity, side ratios must be equal. Compare bases and heights.", 
                latex: `\\frac{${w2}}{${w1}} \\text{ vs } \\frac{${h2}}{${h1}}` 
            });
        } 
        else if (type === 'tri_angles') {
            geom.shapeType = 'triangle';
            const a1 = MathUtils.randomInt(40, 75);
            const a2 = MathUtils.randomInt(40, 75);
            
            const b1 = isSimilar ? a1 : a1 + MathUtils.randomChoice([-15, 15]);
            const b2 = isSimilar ? a2 : a2;

            // Pass angles for visual arcs
            geom.left = { angles: [a1, a2, null], labels: { a1: `${a1}¬∞`, a2: `${a2}¬∞` } };
            geom.right = { angles: [b1, b2, null], labels: { a1: `${b1}¬∞`, a2: `${b2}¬∞` } };

            desc = lang === 'sv' ? "√Ñr trianglarna likformiga?" : "Are the triangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "Likformiga trianglar m√•ste ha exakt samma vinklar. J√§mf√∂r vinklarna." : "Similar triangles must have exactly the same angles. Compare them.", 
                latex: "" 
            });
        }
        else { // tri_sides
            geom.shapeType = 'triangle';
            const s1 = MathUtils.randomInt(4, 9);
            const s2 = MathUtils.randomInt(4, 9);
            
            const k = isSimilar ? 2 : 1.5;
            const r1 = s1 * k;
            const r2 = isSimilar ? s2 * k : Math.floor(s2 * (k + 0.4));

            geom.left = { labels: { s1: s1, s2: s2 } };
            geom.right = { labels: { s1: r1, s2: r2 } };
            
            desc = lang === 'sv' ? "√Ñr trianglarna likformiga?" : "Are the triangles similar?";
            steps.push({ 
                text: lang === 'sv' ? "Kolla om b√•da sidorna har v√§xt lika mycket (samma skalning)." : "Check if both sides scaled by the same factor.", 
                latex: `\\frac{${r1}}{${s1}} \\text{ vs } \\frac{${r2}}{${s2}}` 
            });
        }

        const correct = isSimilar ? (lang === 'sv' ? "Ja" : "Yes") : (lang === 'sv' ? "Nej" : "No");
        const wrong = isSimilar ? (lang === 'sv' ? "Nej" : "No") : (lang === 'sv' ? "Ja" : "Yes");

        return {
            renderData: {
                description: desc,
                answerType: 'multiple_choice',
                choices: [correct, wrong],
                geometry: geom,
                latex: ""
            },
            token: Buffer.from(correct).toString('base64'),
            clues: steps
        };
    }

    // Level 2: Calc Side (Updated with more variety and division)
    private level2_CalcSide(lang: string): any {
        // Expanded scale factors: decimals and larger integers
        const k = MathUtils.randomChoice([1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]);
        
        const s1 = MathUtils.randomInt(3, 12);
        const s2 = MathUtils.randomInt(3, 12);
        
        const bigS1 = Math.round(s1 * k * 10) / 10;
        const bigS2 = Math.round(s2 * k * 10) / 10;
        
        // Randomly find small side (division) or big side (multiplication)
        const findBig = MathUtils.randomInt(0, 1) === 1;
        let ans = 0, clues = [];

        let lLabels: any = { s1, s2 };
        let rLabels: any = {};

        if (findBig) {
            // Finding a side on the larger triangle
            ans = bigS1;
            // Left (Small) has s1, s2. Right (Big) has x, bigS2.
            lLabels = { s1: s1, s2: s2 };
            rLabels = { s1: 'x', s2: bigS2 };
            
            clues.push({ 
                text: lang === 'sv' ? "1. Hitta skalan genom att j√§mf√∂ra de k√§nda sidorna." : "1. Find scale by comparing the known sides.", 
                latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` 
            });
            clues.push({ 
                text: lang === 'sv' ? "2. Den ok√§nda sidan √§r i den stora figuren. Multiplicera." : "2. The unknown side is in the large shape. Multiply.", 
                latex: `x = ${s1} \\cdot ${k} = \\mathbf{${ans}}` 
            });
        } else {
            // Finding a side on the smaller triangle
            ans = s1;
            // Left (Small) has x, s2. Right (Big) has bigS1, bigS2.
            lLabels = { s1: 'x', s2: s2 };
            rLabels = { s1: bigS1, s2: bigS2 };
            
            clues.push({ 
                text: lang === 'sv' ? "1. Hitta skalan genom att j√§mf√∂ra de k√§nda sidorna." : "1. Find scale by comparing the known sides.", 
                latex: `k = \\frac{${bigS2}}{${s2}} = ${k}` 
            });
            clues.push({ 
                text: lang === 'sv' ? "2. Den ok√§nda sidan √§r i den lilla figuren. Dividera." : "2. The unknown side is in the small shape. Divide.", 
                latex: `x = \\frac{${bigS1}}{${k}} = \\mathbf{${ans}}` 
            });
        }
        
        return {
            renderData: { 
                geometry: { type: 'similarity_compare', shapeType: 'triangle', left: { labels: lLabels }, right: { labels: rLabels } }, 
                description: lang === 'sv' ? "Figurerna √§r likformiga. Ber√§kna x." : "Shapes are similar. Calculate x.", 
                answerType: 'text',
                latex: ""
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: clues
        };
    }

    // Level 3: Top Triangle
    private level3_TopTriangle(lang: string): any {
        const top = MathUtils.randomInt(4, 10);
        const add = MathUtils.randomInt(2, 6);
        const tot = top + add;
        
        const smallBase = MathUtils.randomInt(5, 12);
        const largeBase = (tot / top) * smallBase;
        
        // Ensure integer answer or simple decimal
        // Reroll if ugly
        if (!Number.isInteger(largeBase) && (largeBase * 10) % 5 !== 0) return this.level3_TopTriangle(lang);

        return {
            renderData: { 
                geometry: { type: 'transversal', labels: { left_top: top, left_tot: tot, base_top: smallBase, base_bot: 'x' } }, 
                description: lang === 'sv' ? "Ber√§kna basen x." : "Calculate base x.", 
                answerType: 'text',
                latex: ""
            },
            token: Buffer.from(largeBase.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Topptriangelsatsen: Liten/Stor = Liten/Stor" : "Top Triangle Theorem: Small side / Big side = Small base / Big base", latex: `\\frac{${top}}{${tot}} = \\frac{${smallBase}}{x}` },
                { text: lang === 'sv' ? "L√∂s ut x." : "Solve for x.", latex: `x = \\frac{${tot} \\cdot ${smallBase}}{${top}} = \\mathbf{${largeBase}}` }
            ]
        };
    }

    // Level 4: Pythagoras
    private level4_Pythagoras(lang: string): any {
        const [a, b, c] = MathUtils.randomChoice([[3,4,5], [5,12,13], [6,8,10], [8,15,17]]);
        const findHyp = MathUtils.randomInt(0, 1) === 1;
        const orient = MathUtils.randomChoice(['up', 'down', 'left', 'right']);
        
        let ans = 0;
        let labels: any = {};
        let clue = "";
        let desc = "";

        if (findHyp) {
            ans = c;
            labels = { base: a, height: b, hypotenuse: 'x' };
            clue = `x = \\sqrt{${a}^2 + ${b}^2} = \\mathbf{${c}}`;
            desc = lang === 'sv' ? "Ber√§kna hypotenusan (x)." : "Calculate hypotenuse (x).";
        } else {
            ans = a;
            labels = { base: 'x', height: b, hypotenuse: c };
            clue = `x = \\sqrt{${c}^2 - ${b}^2} = \\mathbf{${a}}`;
            desc = lang === 'sv' ? "Ber√§kna kateten (x)." : "Calculate leg (x).";
        }

        return {
            renderData: { 
                geometry: { type: 'triangle', subtype: 'right', width: a, height: b, labels, orientation: orient }, 
                description: desc,
                answerType: 'text',
                latex: ""
            },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Pythagoras sats:" : "Pythagoras theorem:", latex: "a^2 + b^2 = c^2" },
                { text: lang === 'sv' ? (findHyp ? "F√∂r hypotenusan, addera kvadraterna." : "F√∂r en katet, subtrahera.") : (findHyp ? "Add squares." : "Subtract squares."), latex: clue }
            ]
        };
    }
}

// FILE END: src\core\generators\SimilarityGen.ts

// =======================================================
// FILE START: src\core\generators\TenPowersGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class TenPowersGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_MultDivBig(lang);
            case 2: return this.level2_Concepts(lang);
            case 3: return this.level3_MixedFactors(lang);
            default: return this.level1_MultDivBig(lang);
        }
    }

    private fixFloat(n: number) { return parseFloat(n.toFixed(6)); }

    // Level 1: Mult/Div by 10, 100, 1000
    private level1_MultDivBig(lang: string): any {
        const power = MathUtils.randomChoice([10, 100, 1000]);
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const num = MathUtils.randomInt(2, 900);
        let ans = 0, latex = "";
        
        const zeros = power.toString().length - 1;
        const stepsText = lang === 'sv' ? "steg" : "steps";
        const dir = isMult 
            ? (lang === 'sv' ? "H√ñGER" : "RIGHT") 
            : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");

        if (isMult) {
            ans = num * power;
            latex = `${num} \\cdot ${power}`;
        } else {
            ans = this.fixFloat(num / power);
            latex = `${num} / ${power}`;
        }

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna." : "Calculate.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [{ 
                text: lang === 'sv' 
                ? `Flytta kommatecknet ${zeros} ${stepsText} √•t ${dir} (l√§gg till nollor).` 
                : `Move decimal ${zeros} ${stepsText} ${dir} (add zeros).`,
                latex: "" 
            }]
        };
    }

    // Level 2: Conceptual Equivalence
    private level2_Concepts(lang: string): any {
        const scenarios = [
            // --- DECIMALS (0.1, 0.01, 0.001) ---
            { 
                op: 'mul', val: 0.1, equivOp: 'div', equivVal: 10,
                clueSv: "Att multiplicera med 0.1 √§r som att ta en tiondel av kakan. Det blir mindre, precis som n√§r man delar med 10.",
                clueEn: "Multiplying by 0.1 is like taking one tenth of a cake. It gets smaller, just like dividing by 10."
            },
            { 
                op: 'div', val: 0.1, equivOp: 'mul', equivVal: 10,
                clueSv: "Att dela med 0.1 betyder: 'Hur m√•nga sm√• 0.1-bitar f√•r plats i 1?' Det f√•r plats 10 stycken. Svaret blir stort.",
                clueEn: "Dividing by 0.1 means: 'How many small 0.1 pieces fit into 1?' It fits 10 times. The answer becomes large."
            },
            { 
                op: 'mul', val: 0.01, equivOp: 'div', equivVal: 100,
                clueSv: "Att multiplicera med 0.01 √§r som att ta en hundradel. Det √§r samma som att dela p√• 100.",
                clueEn: "Multiplying by 0.01 is like taking one hundredth. That's the same as dividing by 100."
            },
            { 
                op: 'div', val: 0.01, equivOp: 'mul', equivVal: 100,
                clueSv: "Att dela med en hundradel (0.01) g√∂r talet mycket st√∂rre. Hur m√•nga hundradelar g√•r det p√• en hel? Jo, 100.",
                clueEn: "Dividing by one hundredth (0.01) makes the number much bigger. How many hundredths fit in a whole? 100."
            },
            { 
                op: 'mul', val: 0.001, equivOp: 'div', equivVal: 1000,
                clueSv: "En tusendel √§r v√§ldigt litet. Att multiplicera med 0.001 √§r som att dela med 1000.",
                clueEn: "A thousandth is very small. Multiplying by 0.001 is like dividing by 1000."
            },
            { 
                op: 'div', val: 0.001, equivOp: 'mul', equivVal: 1000,
                clueSv: "Att dela med en tusendel betyder att vi ser hur m√•nga pyttesm√• bitar som f√•r plats. Det blir 1000 g√•nger fler.",
                clueEn: "Dividing by a thousandth means seeing how many tiny pieces fit. It becomes 1000 times more."
            },
            // --- INTEGERS (10, 100, 1000) ---
            { 
                op: 'mul', val: 10, equivOp: 'div', equivVal: 0.1,
                clueSv: "Att g√∂ra n√•got 10 g√•nger st√∂rre √§r samma som att se hur m√•nga tiondelar som ryms i det (division med 0.1).",
                clueEn: "Making something 10 times bigger is like seeing how many tenths fit inside it (dividing by 0.1)."
            },
            { 
                op: 'div', val: 10, equivOp: 'mul', equivVal: 0.1,
                clueSv: "Att dela upp i 10 h√∂gar √§r samma sak som att ta en tiondel (0.1) av h√∂gen.",
                clueEn: "Splitting into 10 piles is the same as taking one tenth (0.1) of the pile."
            },
            { 
                op: 'mul', val: 100, equivOp: 'div', equivVal: 0.01,
                clueSv: "G√•nger 100 √§r en stor √∂kning. Det √§r matematiskt samma som att dela med det lilla talet 0.01.",
                clueEn: "Times 100 is a big increase. Mathematically, it's the same as dividing by the tiny number 0.01."
            },
            { 
                op: 'div', val: 100, equivOp: 'mul', equivVal: 0.01,
                clueSv: "Att dela med 100 √§r samma som att ta en hundradel (0.01).",
                clueEn: "Dividing by 100 is the same as taking one hundredth (0.01)."
            },
             { 
                op: 'mul', val: 1000, equivOp: 'div', equivVal: 0.001,
                clueSv: "G√•nger 1000 √§r samma som att dela med en tusendel.",
                clueEn: "Times 1000 is the same as dividing by a thousandth."
            },
            { 
                op: 'div', val: 1000, equivOp: 'mul', equivVal: 0.001,
                clueSv: "Att dela med 1000 √§r samma som att ta en tusendel (0.001).",
                clueEn: "Dividing by 1000 is the same as taking one thousandth (0.001)."
            }
        ];

        const s = MathUtils.randomChoice(scenarios);
        
        let description = "";
        
        if (lang === 'sv') {
            const opStr = s.op === 'mul' ? "multiplicera med" : "dela med";
            const targetOpStr = s.equivOp === 'mul' ? "multiplicera med..." : "dela med...";
            description = `Att ${opStr} ${s.val} √§r samma sak som att ${targetOpStr}`;
        } else {
            const opStr = s.op === 'mul' ? "multiplying by" : "dividing by";
            const targetOpStr = s.equivOp === 'mul' ? "multiplying by..." : "dividing by...";
            description = `To ${opStr} ${s.val} is the same as ${targetOpStr}`;
        }

        // Fixed set of answer choices
        const choices = ["10", "100", "1000", "0.1", "0.01", "0.001"];
        const clueText = lang === 'sv' ? (s.clueSv || "") : (s.clueEn || "");

        return {
            renderData: { 
                latex: "", 
                description, 
                answerType: 'multiple_choice', 
                choices 
            },
            token: Buffer.from(s.equivVal.toString()).toString('base64'),
            clues: [
                { text: clueText, latex: "" }
            ]
        };
    }

    // Level 3: Mixed Factors (0.1...1000)
    private level3_MixedFactors(lang: string): any {
        const factor = MathUtils.randomChoice([0.1, 0.01, 0.001, 10, 100, 1000]);
        const isMult = MathUtils.randomInt(0, 1) === 1;
        const num = MathUtils.randomFloat(2, 50, 1);
        
        let ans = 0, latex = "";
        let direction = "";
        let steps = 0;
        
        // Count decimal shift
        if (factor >= 10) steps = factor.toString().length - 1;
        else steps = factor.toString().length - 2;

        if (isMult) {
            ans = this.fixFloat(num * factor);
            latex = `${num} \\cdot ${factor}`;
            const isRight = factor >= 10;
            direction = isRight ? (lang === 'sv' ? "H√ñGER" : "RIGHT") : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");
        } else {
            ans = this.fixFloat(num / factor);
            latex = `${num} / ${factor}`;
            const isRight = factor < 1;
            direction = isRight ? (lang === 'sv' ? "H√ñGER" : "RIGHT") : (lang === 'sv' ? "V√ÑNSTER" : "LEFT");
        }

        const clueText = lang === 'sv' 
            ? `Flytta kommatecknet ${steps} steg √•t ${direction}.` 
            : `Move decimal ${steps} steps ${direction}.`;

        return {
            renderData: { latex, description: lang === 'sv' ? "Ber√§kna." : "Calculate.", answerType: 'text' },
            token: Buffer.from(ans.toString()).toString('base64'),
            clues: [{ text: clueText, latex: `\\mathbf{${ans}}` }]
        };
    }
}

// FILE END: src\core\generators\TenPowersGen.ts

// =======================================================
// FILE START: src\core\generators\VolumeGen.ts
// =======================================================

import { MathUtils } from '../utils/MathUtils.js';

export class VolumeGen {
    public generate(level: number, lang: string = 'sv'): any {
        switch (level) {
            case 1: return this.level1_Cuboid(lang);
            case 2: return this.level2_TriPrism(lang);
            case 3: return this.level3_Cylinder(lang);
            case 4: return this.level4_PyramidCone(lang);
            case 5: return this.level5_SphereComposite(lang);
            case 6: return this.level6_Mixed(lang);
            case 7: return this.level7_Units(lang);
            default: return this.level1_Cuboid(lang);
        }
    }

    // Level 1: Rectangular Prism (Cuboid) & Cube
    private level1_Cuboid(lang: string): any {
        const w = MathUtils.randomInt(2, 10);
        const d = MathUtils.randomInt(2, 10);
        const h = MathUtils.randomInt(2, 10);
        const volume = w * d * h;

        return {
            renderData: {
                geometry: { type: 'cuboid', labels: { w, h, d } },
                description: lang === 'sv' ? "Ber√§kna volymen." : "Calculate the volume.",
                answerType: 'text'
            },
            token: Buffer.from(volume.toString()).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "F√∂r r√§tblock √§r volymen = Bredd ¬∑ Djup ¬∑ H√∂jd." : "For a rectangular prism, Volume = Width ¬∑ Depth ¬∑ Height.", 
                    latex: "V = b \\cdot d \\cdot h" 
                },
                { 
                    text: lang === 'sv' ? "Multiplicera sidorna." : "Multiply the sides.", 
                    latex: `V = ${w} \\cdot ${d} \\cdot ${h} = \\mathbf{${volume}}` 
                }
            ]
        };
    }

    // Level 2: Triangular Prism
    private level2_TriPrism(lang: string): any {
        const b = MathUtils.randomInt(3, 10);
        const hTri = MathUtils.randomInt(2, 8); 
        const len = MathUtils.randomInt(5, 15); 
        const areaBase = (b * hTri) / 2;
        const volume = areaBase * len;

        return {
            renderData: {
                geometry: { type: 'triangular_prism', labels: { b, h: hTri, l: len } },
                description: lang === 'sv' ? "Ber√§kna volymen." : "Calculate the volume.",
                answerType: 'text'
            },
            token: Buffer.from(volume.toString()).toString('base64'),
            clues: [
                { 
                    text: lang === 'sv' ? "1. R√§kna f√∂rst ut arean p√• triangeln (Basytan)." : "1. First calculate the area of the triangle (Base Area).", 
                    latex: `B = \\frac{${b} \\cdot ${hTri}}{2} = ${areaBase}` 
                },
                { 
                    text: lang === 'sv' ? "2. Multiplicera basytan med l√§ngden." : "2. Multiply the base area by the length.", 
                    latex: `V = B \\cdot l = ${areaBase} \\cdot ${len} = \\mathbf{${volume}}` 
                }
            ]
        };
    }

    // Level 3: Cylinder
    private level3_Cylinder(lang: string): any {
        const r = MathUtils.randomInt(2, 6);
        const h = MathUtils.randomInt(5, 15);
        const piApprox = 3.14;
        
        // Randomly show radius or diameter
        const showDiameter = MathUtils.randomInt(0, 1) === 1;
        const d = r * 2;
        
        // Ensure explicit label value is passed to prevent "undefined"
        const labelVal = showDiameter ? `d=${d}` : `r=${r}`;

        const vol = Math.round(Math.PI * r * r * h); 
        
        let steps = [];
        
        if (showDiameter) {
            steps.push({
                text: lang === 'sv' ? "Vi har diametern (d). Radien (r) √§r h√§lften." : "We have the diameter (d). The radius (r) is half.",
                latex: `r = \\frac{${d}}{2} = ${r}`
            });
        }
        
        steps.push({
            text: lang === 'sv' ? "R√§kna ut basytan (cirkeln)." : "Calculate the base area (circle).",
            latex: `B = \\pi \\cdot r^2 \\approx 3.14 \\cdot ${r}^2`
        });
        
        steps.push({
            text: lang === 'sv' ? "Multiplicera med h√∂jden." : "Multiply by the height.",
            latex: `V \\approx 3.14 \\cdot ${r*r} \\cdot ${h} \\approx \\mathbf{${vol}}`
        });

        return {
            renderData: {
                geometry: { 
                    type: 'cylinder', 
                    labels: { r, h, val: labelVal }, 
                    show: showDiameter ? 'diameter' : 'radius' 
                },
                description: lang === 'sv' ? "Ber√§kna volymen (heltal)." : "Calculate volume (integer).",
                answerType: 'text'
            },
            token: Buffer.from(vol.toString()).toString('base64'),
            clues: steps
        };
    }

    // Level 4: Pyramid & Cone
    private level4_PyramidCone(lang: string): any {
        const isCone = MathUtils.randomInt(0, 1) === 1;
        const h = MathUtils.randomInt(5, 15);
        
        let vol = 0, geom: any = {}, steps = [], desc = "";

        if (isCone) {
            // CONE
            const r = MathUtils.randomInt(3, 8);
            const d = r * 2;
            const showDiameter = MathUtils.randomInt(0, 1) === 1;
            
            // Pass explicit string to avoid undefined
            const labelVal = showDiameter ? `d=${d}` : `r=${r}`;
            
            vol = Math.round((Math.PI * r * r * h) / 3);
            
            desc = lang === 'sv' ? "Ber√§kna volymen av konen (heltal)." : "Calculate the volume of the cone (integer).";
            
            if (showDiameter) {
                steps.push({
                    text: lang === 'sv' ? "F√∂rst, hitta radien (h√§lften av diametern)." : "First, find the radius (half the diameter).",
                    latex: `r = ${d} / 2 = ${r}`
                });
            }

            steps.push({
                text: lang === 'sv' ? "Volymen f√∂r en kon √§r (Basytan ¬∑ H√∂jden) / 3." : "Volume of a cone is (Base ¬∑ Height) / 3.",
                latex: `V = \\frac{\\pi \\cdot r^2 \\cdot h}{3}`
            });

            steps.push({
                text: lang === 'sv' ? "S√§tt in v√§rdena." : "Insert the values.",
                latex: `V \\approx \\frac{3.14 \\cdot ${r}^2 \\cdot ${h}}{3} \\approx \\mathbf{${vol}}`
            });

            geom = { 
                type: 'cone', 
                labels: { r, h, val: labelVal },
                show: showDiameter ? 'diameter' : 'radius'
            };

        } else {
            // PYRAMID (Rectangular Base)
            const w = MathUtils.randomInt(3, 8); // Width
            const l = MathUtils.randomInt(3, 8); // Length
            
            vol = Math.round((w * l * h) / 3);
            
            desc = lang === 'sv' ? "Ber√§kna volymen av pyramiden (heltal)." : "Calculate the volume of the pyramid (integer).";

            steps.push({
                text: lang === 'sv' ? "R√§kna ut basytan (rektangeln)." : "Calculate the base area (rectangle).",
                latex: `B = ${w} \\cdot ${l} = ${w*l}`
            });

            steps.push({
                text: lang === 'sv' ? "Volymen f√∂r en pyramid √§r (Basytan ¬∑ H√∂jden) / 3." : "Volume of a pyramid is (Base ¬∑ Height) / 3.",
                latex: `V = \\frac{B \\cdot h}{3} = \\frac{${w*l} \\cdot ${h}}{3} \\approx \\mathbf{${vol}}`
            });

            // Geometry component expects 'w'/'d' for rectangular base
            geom = { 
                type: 'pyramid', 
                labels: { w, d: l, h } 
            };
        }

        return {
            renderData: { geometry: geom, description: desc, answerType: 'text' },
            token: Buffer.from(vol.toString()).toString('base64'),
            clues: steps
        };
    }

    // Level 5: Sphere, Hemisphere, Ice Cream, Silo
    private level5_SphereComposite(lang: string): any {
        // Randomly pick a shape type
        const type = MathUtils.randomChoice(['sphere', 'hemisphere', 'ice_cream', 'silo']);
        
        const r = MathUtils.randomInt(3, 10);
        const d = r * 2;
        const showDiameter = MathUtils.randomInt(0, 1) === 1; // 50% chance for Sphere/Hemi
        
        // Pass explicit string to avoid undefined
        const labelVal = showDiameter ? `d=${d}` : `r=${r}`;

        let vol = 0, geom: any = {}, steps = [], desc = "";

        if (type === 'sphere') {
            vol = Math.round((4 * Math.PI * Math.pow(r, 3)) / 3);
            desc = lang === 'sv' ? "Ber√§kna volymen (Klot)." : "Calculate volume (Sphere).";
            
            if (showDiameter) {
                steps.push({
                    text: lang === 'sv' ? "Vi har diametern. Radien √§r h√§lften." : "We have diameter. Radius is half.",
                    latex: `r = ${d}/2 = ${r}`
                });
            }

            steps.push({
                text: lang === 'sv' ? "Anv√§nd formeln f√∂r klotets volym." : "Use the sphere volume formula.",
                latex: `V = \\frac{4 \\cdot \\pi \\cdot r^3}{3}`
            });
            steps.push({
                text: lang === 'sv' ? "S√§tt in radien och ber√§kna." : "Insert radius and calculate.",
                latex: `V \\approx \\frac{4 \\cdot 3.14 \\cdot ${r}^3}{3} \\approx \\mathbf{${vol}}`
            });

            geom = { 
                type: 'sphere', 
                labels: { val: labelVal, r }, 
                show: showDiameter ? 'diameter' : 'radius' 
            };

        } else if (type === 'hemisphere') {
            const vFull = (4 * Math.PI * Math.pow(r, 3)) / 3;
            vol = Math.round(vFull / 2);
            desc = lang === 'sv' ? "Ber√§kna volymen (Halvklot)." : "Calculate volume (Hemisphere).";

            if (showDiameter) {
                steps.push({
                    text: lang === 'sv' ? "Vi har diametern. Radien √§r h√§lften." : "We have diameter. Radius is half.",
                    latex: `r = ${d}/2 = ${r}`
                });
            }

            steps.push({
                text: lang === 'sv' ? "R√§kna ut volymen f√∂r ett HELT klot f√∂rst." : "Calculate the volume of a FULL sphere first.",
                latex: `V_{hel} = \\frac{4 \\cdot \\pi \\cdot ${r}^3}{3} \\approx ${Math.round(vFull)}`
            });
            steps.push({
                text: lang === 'sv' ? "Dela sedan med 2." : "Then divide by 2.",
                latex: `V_{halv} = \\frac{${Math.round(vFull)}}{2} \\approx \\mathbf{${vol}}`
            });

            geom = { 
                type: 'hemisphere', 
                labels: { val: labelVal, r }, 
                show: showDiameter ? 'diameter' : 'radius' 
            };

        } else if (type === 'ice_cream') {
            // Cone + Hemisphere
            const hCone = MathUtils.randomInt(r + 2, 15);
            const vCone = (Math.PI * r * r * hCone) / 3;
            const vHemi = (2 * Math.PI * Math.pow(r, 3)) / 3; // (4/3 pi r^3) / 2 = 2/3 pi r^3
            vol = Math.round(vCone + vHemi);
            
            desc = lang === 'sv' ? "Ber√§kna totala volymen (Glass)." : "Calculate total volume (Ice Cream).";
            
            steps = [
                { text: lang === 'sv' ? "Dela upp i Kon och Halvklot." : "Split into Cone and Hemisphere.", latex: "" },
                { text: lang === 'sv' ? "Konens volym:" : "Cone volume:", latex: `V_{kon} = \\frac{\\pi \\cdot ${r}^2 \\cdot ${hCone}}{3} \\approx ${Math.round(vCone)}` },
                { text: lang === 'sv' ? "Halvklotets volym:" : "Hemisphere volume:", latex: `V_{halv} = \\frac{2 \\cdot \\pi \\cdot ${r}^3}{3} \\approx ${Math.round(vHemi)}` },
                { text: lang === 'sv' ? "Addera delarna." : "Add the parts.", latex: `${Math.round(vCone)} + ${Math.round(vHemi)} = \\mathbf{${vol}}` }
            ];

            geom = { 
                type: 'ice_cream', 
                labels: { r, h: hCone, val: `r=${r}` } // Composite usually shows radius for simplicity
            };

        } else {
            // Silo (Cylinder + Hemisphere)
            const hCyl = MathUtils.randomInt(r + 2, 15);
            const vCyl = Math.PI * r * r * hCyl;
            const vHemi = (2 * Math.PI * Math.pow(r, 3)) / 3;
            vol = Math.round(vCyl + vHemi);

            desc = lang === 'sv' ? "Ber√§kna totala volymen (Silo)." : "Calculate total volume (Silo).";

            steps = [
                { text: lang === 'sv' ? "Dela upp i Cylinder och Halvklot." : "Split into Cylinder and Hemisphere.", latex: "" },
                { text: lang === 'sv' ? "Cylinderns volym:" : "Cylinder volume:", latex: `V_{cyl} = \\pi \\cdot ${r}^2 \\cdot ${hCyl} \\approx ${Math.round(vCyl)}` },
                { text: lang === 'sv' ? "Halvklotets volym:" : "Hemisphere volume:", latex: `V_{halv} = \\frac{2 \\cdot \\pi \\cdot ${r}^3}{3} \\approx ${Math.round(vHemi)}` },
                { text: lang === 'sv' ? "Addera delarna." : "Add the parts.", latex: `${Math.round(vCyl)} + ${Math.round(vHemi)} = \\mathbf{${vol}}` }
            ];

            geom = { 
                type: 'silo', 
                labels: { r, h: hCyl, val: `r=${r}` } 
            };
        }

        return {
            renderData: { geometry: geom, description: desc, answerType: 'text' },
            token: Buffer.from(vol.toString()).toString('base64'),
            clues: steps
        };
    }

    // Level 6: Mixed
    private level6_Mixed(lang: string): any {
        const mode = MathUtils.randomInt(3, 5);
        if (mode === 3) return this.level3_Cylinder(lang);
        if (mode === 4) return this.level4_PyramidCone(lang);
        return this.level5_SphereComposite(lang);
    }

    // Level 7: Units Conversion Logic
    private level7_Units(lang: string): any {
        const side = MathUtils.randomInt(1, 10);
        const volLiters = Math.pow(side, 3);
        const sideCm = side * 10;
        
        return {
            renderData: { 
                geometry: { type: 'cuboid', labels: { w: `${sideCm} cm`, h: `${sideCm} cm`, d: `${sideCm} cm` } }, 
                description: lang === 'sv' ? "Hur m√•nga liter rymmer kuben?" : "How many liters does the cube hold?", 
                answerType: 'text' 
            },
            token: Buffer.from(volLiters.toString()).toString('base64'),
            clues: [
                { text: lang === 'sv' ? "Kom ih√•g: 1 liter = 1 dm¬≥." : "Remember: 1 liter = 1 dm¬≥." },
                { text: lang === 'sv' ? "Omvandla sidan till decimeter (dm) f√∂rst." : "Convert the side to decimeters (dm) first.", latex: `${sideCm} \\text{ cm} = ${side} \\text{ dm}` },
                { text: lang === 'sv' ? "R√§kna ut volymen." : "Calculate the volume.", latex: `V = ${side}^3 = \\mathbf{${volLiters}}` }
            ]
        };
    }
}

// FILE END: src\core\generators\VolumeGen.ts

// =======================================================
// FILE START: src\core\interfaces\Generator.ts
// =======================================================

export interface QuestionData {
    text?: string;
    renderData?: any; // Preferred
    visual?: any;     // Legacy
    answer: string | number;
    clues: string[];
}

export interface Generator {
    /**
     * Generates a new question.
     * @param level Difficulty level (1-9)
     * @param lang Language code ('sv' | 'en')
     */
    generate(level: number, lang: string): QuestionData;

    /**
     * Optional: Custom validation logic for answers.
     * @param userAnswer The user's input
     * @param systemAnswer The generated correct answer
     */
    validate?(userAnswer: string, systemAnswer: string): boolean;
}

// FILE END: src\core\interfaces\Generator.ts

// =======================================================
// FILE START: src\core\rules\ProgressionRules.ts
// =======================================================

export class ProgressionRules {
    private static readonly STREAK_THRESHOLD = 8;

    private static readonly MAX_LEVELS: Record<string, number> = {
        arithmetic: 9,
        negative: 5,
        ten_powers: 3,
        scale: 7,
        equation: 7,
        simplify: 6,
        geometry: 5,
        volume: 7,
        graph: 5,
        similarity: 4 // UPDATED to 4
    };

    public static checkLevelUp(newStreak: number, currentLevel: number, topic: string): boolean {
        const maxLevel = this.MAX_LEVELS[topic] || 5;
        if (newStreak > 0 && newStreak % this.STREAK_THRESHOLD === 0 && currentLevel < maxLevel) {
            return true;
        }
        return false;
    }
}

// FILE END: src\core\rules\ProgressionRules.ts

// =======================================================
// FILE START: src\core\types\generator.ts
// =======================================================

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { generateToken } from '../src/core/utils/security';

// IMPORTS
import { ScaleGenerator } from '../src/core/generators/ScaleGenerator';
import { GeometryGenerator } from '../src/core/generators/GeometryGenerator';
import { LinearGraphGenerator } from '../src/core/generators/LinearGraphGenerator';
import { LinearEquationGenerator } from '../src/core/generators/LinearEquationGen';
import { ExpressionSimplificationGen } from '../src/core/generators/ExpressionSimplificationGen';
import { LinearEquationProblemGen } from '../src/core/generators/LinearEquationProblemGen';
import { VolumeGenerator } from '../src/core/generators/VolumeGenerator';
import { SimilarityGenerator } from '../src/core/generators/SimilarityGenerator';
import { BasicArithmeticGen } from '../src/core/generators/BasicArithmeticGen';
import { NegativeNumbersGen } from '../src/core/generators/NegativeNumbersGen';
import { TenPowersGenerator } from '../src/core/generators/TenPowersGen'; // Added

function formatAnswerForToken(answer: any): string | number {
    if (typeof answer === 'object' && answer !== null) {
        if ('k' in answer && 'm' in answer) {
            const { k, m } = answer;
            const mStr = m >= 0 ? `+ ${m}` : `- ${Math.abs(m)}`;
            return `${k}x ${mStr}`; 
        }
        if ('left' in answer && 'right' in answer) {
            return `${answer.left}:${answer.right}`; 
        }
        return JSON.stringify(answer);
    }
    return String(answer);
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const { topic, level, lang = 'sv', seed = Date.now().toString() } = req.query;

    if (!topic || !level) {
      return res.status(400).json({ error: 'Missing topic or level' });
    }

    const lvl = parseInt(level as string, 10);
    const lg = lang as 'sv' | 'en';
    
    // Multiplier for difficulty scaling (optional usage in generators)
    const multiplier = Math.max(1, Math.ceil(lvl / 3)); 

    let qData;
    let tolerance = 0; 

    switch (topic) {
      case 'arithmetic':
        qData = BasicArithmeticGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'negative':
        qData = NegativeNumbersGen.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'ten_powers': // Added Case
        qData = TenPowersGenerator.generate(lvl, seed as string, lg, multiplier);
        break;

      case 'equation':
        if (lvl === 5 || lvl === 6) {
             qData = LinearEquationProblemGen.generate(lvl, seed as string, lg, multiplier);
        } else if (lvl === 7) {
             // Mixed equations including word problems
             if (Math.random() > 0.5) qData = LinearEquationProblemGen.generate(6, seed as string, lg, multiplier);
             else qData = LinearEquationGenerator.generate(7, seed as string, lg, multiplier);
        } else {
             qData = LinearEquationGenerator.generate(lvl, seed as string, lg, multiplier);
        }
        break;
        
      case 'geometry':
        qData = GeometryGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5; 
        break;
        
      case 'graph':
        qData = LinearGraphGenerator.generate(lvl, seed as string, lg);
        break;
        
      case 'simplify':
        qData = ExpressionSimplificationGen.generate(lvl, seed as string, lg, multiplier);
        break;
        
      case 'volume':
        qData = VolumeGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.5;
        break;

      case 'similarity':
        qData = SimilarityGenerator.generate(lvl, seed as string, lg, multiplier);
        tolerance = 0.1;
        break;

      case 'scale':
      default:
        qData = ScaleGenerator.generate(lvl, seed as string, lg, multiplier);
        break;
    }

    if (!qData || !qData.serverData) {
      throw new Error(`Generator for topic '${topic}' failed to return data.`);
    }

    const tokenAnswer = formatAnswerForToken(qData.serverData.answer);
    const token = generateToken(qData.questionId, tokenAnswer, tolerance);
    
    return res.status(200).json({
      questionId: qData.questionId,
      renderData: qData.renderData,
      clues: qData.serverData.solutionSteps,
      token: token,
      attempts: 0
    });

  } catch (error) {
    console.error('Generator Error:', error);
    return res.status(500).json({ error: 'Failed to generate question' });
  }
}

// FILE END: src\core\types\generator.ts

// =======================================================
// FILE START: src\core\utils\i18n.ts
// =======================================================

export type Language = 'sv' | 'en';

export const UI_STRINGS = {
    sv: {
        // --- General UI ---
        submit: "Svara",
        next: "N√§sta fr√•ga",
        correct: "R√§tt!",
        incorrect: "Inte riktigt, f√∂rs√∂k igen",
        try_again: "F√∂rs√∂k igen",
        score: "Po√§ng",
        streak: "Svit",
        level: "Niv√•",
        loading: "Laddar...",
        error: "Fel vid laddning",
        dashboard_title: "V√§lj omr√•de att √∂va p√•",
        backBtn: "Meny",
        history: "Historik",
        noHistory: "Inga svar √§n.",
        btnHint: "Ledtr√•d",
        btnSolution: "Visa l√∂sning",
        btnSkip: "Hoppa √∂ver",
        placeholder: "Skriv ditt svar...",
        hintsTitle: "Ledtr√•dar",
        clueUsed: "Hj√§lp",
        donow: "Startuppgift",
        donow_title: "Uppstart (Do Now)",
        donow_desc: "V√§lj upp till 3 niv√•er. Systemet genererar 6 fr√•gor totalt.",
        donow_gen: "Generera",
        donow_show_all: "Visa alla",
        donow_hide_all: "D√∂lj alla",
        aboutBtn: "Om skaparen",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Aritmetik",
            negative: "Negativa Tal",
            simplification: "F√∂renkling",
            linear_eq: "Ekvationer",
            linear_eq_prob: "Probleml√∂sning",
            geometry: "Geometri",
            volume: "Volym & Area",
            similarity: "Likformighet",
            scale: "Skala",
            linear_graph: "R√§ta Linjen",
            ten_powers: "Tiopotenser"
        },

        // --- Math Vocabulary (Common) ---
        common: {
            calculate: "Ber√§kna",
            equation: "Ekvation",
            simplify: "F√∂renkla",
            solve: "L√∂s ut x",
            evaluate: "Ber√§kna",
            find_k: "Best√§m k-v√§rdet",
            find_m: "Best√§m m-v√§rdet",
            find_equation: "Best√§m linjens ekvation",
            match_graph: "Vilken ekvation h√∂r till grafen?",
            determine_equation: "Best√§m ekvationen f√∂r linjen som g√•r genom:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Ber√§kna summan",
            sub: "Ber√§kna differensen",
            mul: "Ber√§kna produkten",
            div: "Ber√§kna kvoten",
            mixed: "Ber√§kna",
            missing_term: "Hitta det saknade talet"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Vi har ekvationen: $${eq}$`,
            multiply: (k: any) => `Multiplicera b√•da sidor med $${k}$ f√∂r att bli av med divisionen.`,
            divide: (k: any) => `Dividera b√•da sidor med $${k}$ f√∂r att f√• $x$ ensamt.`,
            add: (k: any) => `Addera $${k}$ p√• b√•da sidor.`,
            subtract: (k: any) => `Subtrahera $${k}$ p√• b√•da sidor.`,
            distribute: (k: any) => `Multiplicera in $${k}$ i parentesen.`,
            sub_var: (term: string) => `Subtrahera $${term}$ fr√•n b√•da sidor f√∂r att samla $x$ p√• en sida.`,
            collect: "Samla lika termer",
            expand: "Utveckla parentesen",
            factorise: "Faktorisera uttrycket",
            substitute: "Ers√§tt och ber√§kna"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Att addera ett negativt tal √§r samma som subtraktion.",
            sub_neg: "Tv√• minus blir plus (‚Äì ‚Äì blir +).",
            mul_neg_neg: "Minus g√•nger minus blir plus.",
            mul_pos_neg: "Plus g√•nger minus blir minus.",
            div_sign_same: "Lika tecken ger positivt svar.",
            div_sign_diff: "Olika tecken ger negativt svar.",
            simple_calc: "Ber√§kna:", 
            step_calc: "Ber√§kna:",
            plus_plus: "Positivt + Positivt",
            plus_minus: "Positivt + Negativt",
            minus_plus: "Negativt + Positivt",
            minus_minus: "Negativt - Negativt",
            mixed: "Blandat",
            multiplication: "Multiplikation",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "Best√§m m-v√§rdet (d√§r linjen sk√§r y-axeln).", en: "Find the intercept (m)." },
            q_slope: { sv: "Best√§m k-v√§rdet (lutningen).", en: "Find the slope (k)." },
            q_func: { sv: "Best√§m linjens ekvation ($y = kx + m$).", en: "Find the line equation ($y = kx + m$)." },
            look_x0: "Titta p√• grafen: Var sk√§r linjen y-axeln (d√§r $x=0$)?",
            step_intercept: (m:any) => `Linjen sk√§r y-axeln vid $y = ${m}$.`,
            step_delta: "Lutningen $k$ √§r skillnaden i $y$ delat med skillnaden i $x$.",
            step_slope_calc: "R√§kna rutor: Hur mycket √§ndras $y$ n√§r vi g√•r 1 steg √•t h√∂ger?",
            find_m: "Hitta m-v√§rdet (sk√§rning med y-axeln).",
            find_k: "Hitta k-v√§rdet (lutningen).",
            parallel: "Best√§m lutningen f√∂r en linje som √§r parallell med:",
            perpendicular: "Best√§m lutningen f√∂r en linje som √§r vinkelr√§t mot:",
            find_gradient: "Ber√§kna lutningen (k)",
            find_intercept: "Hitta y-axelsk√§rningen (m)"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Skala",
            real: "Verklig str√§cka",
            map_dist: "Avst√•nd p√• kartan",
            ratio: "Skala",
            problem_map_to_real: "Ber√§kna det verkliga avst√•ndet.",
            problem_real_to_map: "Ber√§kna avst√•ndet p√• kartan.",
            problem_find_scale: "Best√§m kartans skala.",
            reduction: "F√∂rminskning",
            enlargement: "F√∂rstoring",
            reality: "Verkligheten",
            drawing: "Bilden",
            rule_reduction: "N√§r skalan √§r 1:X √§r bilden mindre √§n verkligheten.",
            rule_enlargement: "N√§r skalan √§r X:1 √§r bilden st√∂rre √§n verkligheten.",
            step_plug_in: "S√§tt in v√§rdena i formeln: $\\frac{\\text{Bild}}{\\text{Verklighet}}$",
            calc_cm: "R√§kna f√∂rst ut det i cm.",
            conv_m: "Omvandla till meter (1 m = 100 cm).",
            conv_same: "Se till att b√•da m√•tten har samma enhet.",
            setup_ratio: "St√§ll upp f√∂rh√•llandet Bild : Verklighet.",
            step_simplify: "F√∂renkla br√•ket.",
            calc_area_img: "Ber√§kna bildens area.",
            calc_area_real: "Ber√§kna verklighetens area.",
            calc_area_scale: "Areaskalan √§r l√§ngdskalan i kvadrat."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "L√∂s ekvationen och ber√§kna $x$.",
            task_write: "Skriv en ekvation som beskriver situationen (du beh√∂ver inte l√∂sa den).",
            clue_var: "L√•t $x$ vara det vi s√∂ker.",
            clue_total: "S√§tt uttrycket lika med totalen.",
            expl_rate_val: "Pris per styck g√•nger antal.",
            expl_fixed_val: "L√§gg till den fasta avgiften.",
            expl_item_cost: "Kostnaden f√∂r varorna innan rabatt.",
            expl_discount_sub: "Subtrahera rabatten.",
            expl_person1: "Person 1 har $x$.",
            expl_person2_more: "Person 2 har mer.",
            expl_person2_less: "Person 2 har mindre.",
            expl_compare_sum: "Summan av b√•da √§r totalen.",
            a_buy: { sv: "Du k√∂per $a$ st {item} f√∂r $x$ kr/st och en p√•se f√∂r $b$ kr. Totalt betalar du $c$ kr.", en: "You buy $a$ {item} for $x$ kr each and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "En taxiresa kostar $b$ kr i startavgift och $a$ kr per km. Resan kostar totalt $c$ kr. Hur m√•nga km ($x$) √•kte du?", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "Du k√∂per $a$ st {item} som kostar $x$ kr/st. Du har en rabattkupong p√• $b$ kr. Du betalar totalt $c$ kr.", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "{name1} och {name2} samlar p√• {item}. {name2} har $a$ fler √§n {name1}. Tillsammans har de $c$ st. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "{name1} och {name2} har $c$ {item} tillsammans. {name2} har $b$ f√§rre √§n {name1}. Hur m√•nga har {name1} ($x$)?", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Ber√§kna arean",
            perimeter: "Ber√§kna omkretsen",
            circumference: "Ber√§kna omkretsen",
            volume: "Ber√§kna volymen",
            surface_area: "Ber√§kna begr√§nsningsarean",
            similarity: "Likformighet",
            scale_factor: "Hitta skalfaktorn (k)",
            missing_side: "Ber√§kna den saknade sidan",
            shape: "Figur",
            cube: "Kub",
            cuboid: "R√§tblock",
            cylinder: "Cylinder",
            sphere: "Klot",
            cone: "Kon",
            triangle: "Triangel",
            rectangle: "Rektangel",
            circle: "Cirkel",
            parallelogram: "Parallellogram",
            trapezium: "Trapets"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplikation med tiopotenser",
            div: "Division med tiopotenser",
            standard_form: "Grundpotensform",
            prefix: "Prefix"
        },

        // --- Shapes ---
        shapes: {
            square: "kvadrat",
            rectangle: "rektangel",
            circle: "cirkel",
            triangle: "triangel",
            rhombus: "romb",
            parallelogram: "parallellogram",
            pentagon: "femh√∂rning",
            hexagon: "sexh√∂rning",
            octagon: "√•ttah√∂rning",
            star: "stj√§rna",
            arrow: "pil",
            heart: "hj√§rta",
            cross: "kors",
            lightning: "blixt",
            kite: "drake",
            cube: "kub",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "kon",
            sphere: "klot"
        },
        shapes_plural: {
            rectangle: "rektanglar",
            triangle: "trianglar",
            circle: "cirklar",
            semicircle: "halvcirklar",
            parallelogram: "parallellogram"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    },

    en: {
        // --- General UI ---
        submit: "Submit Answer",
        next: "Next Question",
        correct: "Correct!",
        incorrect: "Incorrect.",
        try_again: "Try Again",
        score: "Score",
        streak: "Streak",
        level: "Level",
        loading: "Loading...",
        error: "Error loading question",
        dashboard_title: "Choose a topic to practice",
        backBtn: "Menu",
        history: "History",
        noHistory: "No answers yet.",
        btnHint: "Hint",
        btnSolution: "Show Solution",
        btnSkip: "Skip",
        placeholder: "Enter your answer...",
        hintsTitle: "Hints",
        clueUsed: "Clue",
        donow: "Do Now",
        donow_title: "Do Now Activity",
        donow_desc: "Select up to 3 levels. System generates 6 questions total.",
        donow_gen: "Generate",
        donow_show_all: "Show All",
        donow_hide_all: "Hide All",
        aboutBtn: "About",

        // --- Dashboard Topics ---
        topics: {
            arithmetic: "Arithmetic",
            negative: "Negative Numbers",
            simplification: "Simplification",
            linear_eq: "Linear Equations",
            linear_eq_prob: "Equation Problems",
            geometry: "Geometry",
            volume: "Volume & Surface Area",
            similarity: "Similarity",
            scale: "Scale & Maps",
            linear_graph: "Linear Graphs",
            ten_powers: "Powers of 10"
        },

        // --- Math Vocabulary ---
        common: {
            calculate: "Calculate",
            equation: "Equation",
            simplify: "Simplify",
            solve: "Solve for x",
            evaluate: "Evaluate",
            find_k: "Find the gradient (k)",
            find_m: "Find the y-intercept (m)",
            find_equation: "Find the equation of the line",
            match_graph: "Which equation matches the graph?",
            determine_equation: "Determine the equation of the line passing through:"
        },

        // --- Arithmetic ---
        arithmetic: {
            add: "Calculate the sum",
            sub: "Calculate the difference",
            mul: "Calculate the product",
            div: "Calculate the quotient",
            mixed: "Evaluate the expression",
            missing_term: "Find the missing number"
        },

        // --- Algebra ---
        algebra: {
            intro: (eq: string) => `Equation: $${eq}$`,
            multiply: (k: any) => `Multiply both sides by $${k}$ to remove the division.`,
            divide: (k: any) => `Divide both sides by $${k}$ to isolate $x$.`,
            add: (k: any) => `Add $${k}$ to both sides.`,
            subtract: (k: any) => `Subtract $${k}$ from both sides.`,
            distribute: (k: any) => `Distribute $${k}$ into the parentheses.`,
            sub_var: (term: string) => `Subtract $${term}$ from both sides to collect $x$ on one side.`,
            collect: "Collect like terms",
            expand: "Expand the brackets",
            factorise: "Factorise the expression",
            substitute: "Substitute and evaluate"
        },

        // --- Negative Numbers ---
        neg_signs: {
            add_neg: "Adding a negative number is the same as subtraction.",
            sub_neg: "Subtracting a negative number is the same as addition (‚Äì ‚Äì becomes +).",
            mul_neg_neg: "Negative times negative becomes positive.",
            mul_pos_neg: "Positive times negative becomes negative.",
            div_sign_same: "Same signs give a positive result.",
            div_sign_diff: "Different signs give a negative result.",
            simple_calc: "Calculate:",
            step_calc: "Calculate:",
            plus_plus: "Positive + Positive",
            plus_minus: "Positive + Negative",
            minus_plus: "Negative + Positive",
            minus_minus: "Negative - Negative",
            mixed: "Mixed",
            multiplication: "Multiplication",
            division: "Division"
        },

        // --- Linear Graphs ---
        graph: {
            q_intercept: { sv: "", en: "Find the intercept (m)." },
            q_slope: { sv: "", en: "Find the slope (k)." },
            q_func: { sv: "", en: "Find the line equation ($y = kx + m$)."},
            look_x0: "Look at the graph: Where does the line cross the y-axis (where $x=0$)?",
            step_intercept: (m:any) => `The line crosses the y-axis at $y = ${m}$.`,
            step_delta: "The slope $k$ is the change in $y$ divided by the change in $x$.",
            step_slope_calc: "Count squares: How much does $y$ change when we go 1 step to the right?",
            find_m: "Find the m-value (y-intercept).",
            find_k: "Find the k-value (slope).",
            parallel: "Find the slope of a line parallel to:",
            perpendicular: "Find the slope of a line perpendicular to:",
            find_gradient: "Calculate the gradient",
            find_intercept: "Find the intercept"
        },

        // --- Scale & Maps ---
        scale: {
            map: "Map Scale",
            real: "Real Distance",
            map_dist: "Map Distance",
            ratio: "Ratio",
            problem_map_to_real: "Calculate the real world distance.",
            problem_real_to_map: "Calculate the distance on the map.",
            problem_find_scale: "Determine the scale of the map.",
            reduction: "Reduction",
            enlargement: "Enlargement",
            reality: "Reality",
            drawing: "Drawing",
            rule_reduction: "When the scale is 1:X, the image is smaller than reality.",
            rule_enlargement: "When the scale is X:1, the image is larger than reality.",
            step_plug_in: "Insert the values into the formula: $\\frac{\\text{Image}}{\\text{Reality}}$",
            calc_cm: "Calculate it in cm first.",
            conv_m: "Convert to meters (1 m = 100 cm).",
            conv_same: "Ensure both measurements have the same unit.",
            setup_ratio: "Set up the ratio Image : Reality.",
            step_simplify: "Simplify the fraction.",
            calc_area_img: "Calculate the area of the image.",
            calc_area_real: "Calculate the area of reality.",
            calc_area_scale: "The area scale is the length scale squared."
        },

        // --- Problem Solving ---
        problem_solving: {
            task_solve: "Solve the equation and calculate $x$.",
            task_write: "Write an equation that describes the situation (you don't need to solve it).",
            clue_var: "Let $x$ be what we are looking for.",
            clue_total: "Set the expression equal to the total.",
            expl_rate_val: "Price per item times quantity.",
            expl_fixed_val: "Add the fixed fee.",
            expl_item_cost: "The cost of items before discount.",
            expl_discount_sub: "Subtract the discount.",
            expl_person1: "Person 1 has $x$.",
            expl_person2_more: "Person 2 has more.",
            expl_person2_less: "Person 2 has less.",
            expl_compare_sum: "The sum of both is the total.",
            a_buy: { sv: "", en: "You buy $a$ {item} for $x$ kr/st and a bag for $b$ kr. Total cost is $c$ kr." },
            a_taxi: { sv: "", en: "A taxi ride has a start fee of $b$ kr and costs $a$ kr per km. Total cost is $c$ kr. How many km ($x$) did you travel?" },
            b_discount: { sv: "", en: "You buy $a$ {item} costing $x$ kr each. You have a discount coupon of $b$ kr. You pay $c$ kr in total." },
            c_compare: { sv: "", en: "{name1} and {name2} collect {item}. {name2} has $a$ more than {name1}. Together they have $c$. How many does {name1} have ($x$)?" },
            d_compare: { sv: "", en: "{name1} and {name2} have $c$ {item} together. {name2} has $b$ fewer than {name1}. How many does {name1} have ($x$)?" }
        },

        // --- Geometry & Volume ---
        geometry: {
            area: "Calculate the Area",
            perimeter: "Calculate the Perimeter",
            circumference: "Calculate the Circumference",
            volume: "Calculate the Volume",
            surface_area: "Calculate the Surface Area",
            similarity: "Similarity",
            scale_factor: "Find the Scale Factor",
            missing_side: "Find the missing side length",
            shape: "Shape",
            cube: "Cube",
            cuboid: "Rectangular Prism",
            cylinder: "Cylinder",
            sphere: "Sphere",
            cone: "Cone",
            triangle: "Triangle",
            rectangle: "Rectangle",
            circle: "Circle",
            parallelogram: "Parallelogram",
            trapezium: "Trapezium"
        },

        // --- Ten Powers ---
        ten_powers: {
            mult: "Multiplication by powers of 10",
            div: "Division by powers of 10",
            standard_form: "Standard Form (Scientific Notation)",
            prefix: "Unit Prefixes"
        },

        // --- Shapes ---
        shapes: {
            square: "square",
            rectangle: "rectangle",
            circle: "circle",
            triangle: "triangle",
            rhombus: "rhombus",
            parallelogram: "parallellogram",
            pentagon: "pentagon",
            hexagon: "hexagon",
            octagon: "octagon",
            star: "star",
            arrow: "arrow",
            heart: "heart",
            cross: "cross",
            lightning: "lightning",
            kite: "kite",
            cube: "cube",
            cylinder: "cylinder",
            pyramid: "pyramid",
            cone: "cone",
            sphere: "sphere"
        },
        shapes_plural: {
            rectangle: "rectangles",
            triangle: "triangles",
            circle: "circles",
            semicircle: "semicircles",
            parallelogram: "parallelograms"
        },

        // --- Units ---
        units: {
            cm: "cm",
            m: "m",
            km: "km",
            mm: "mm",
            cm2: "cm¬≤",
            m2: "m¬≤",
            km2: "km¬≤",
            cm3: "cm¬≥",
            m3: "m¬≥",
            liter: "L",
            degrees: "¬∞"
        }
    }
};

export const TERMS = UI_STRINGS;

// Helper to handle both string and object keys safely
export function t(lang: Language, keyOrObj: string | { sv: string, en: string }): string {
    const l = (lang === 'en') ? 'en' : 'sv';
    
    // Check if input is a localized object {sv:..., en:...}
    if (typeof keyOrObj === 'object' && keyOrObj !== null) {
        // @ts-ignore
        return keyOrObj[l] || keyOrObj['sv'] || "";
    }
    
    // Check if input is a dot-notation string "geometry.area"
    if (typeof keyOrObj === 'string') {
        if (keyOrObj.includes('.')) {
            const keys = keyOrObj.split('.');
            let value: any = UI_STRINGS[l];
            for (const k of keys) {
                if (value && value[k]) {
                    value = value[k];
                } else {
                    return keyOrObj; // Return key if missing
                }
            }
            return typeof value === 'string' ? value : keyOrObj;
        }
        
        // Direct key lookup in UI root
        // @ts-ignore
        return UI_STRINGS[l][keyOrObj] || keyOrObj;
    }
    
    return String(keyOrObj);
}

// FILE END: src\core\utils\i18n.ts

// =======================================================
// FILE START: src\core\utils\MathUtils.ts
// =======================================================

export class MathUtils {
    static randomInt(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static randomFloat(min: number, max: number, decimals: number = 1): number {
        const val = Math.random() * (max - min) + min;
        return Number(val.toFixed(decimals));
    }

    static randomChoice<T>(arr: T[]): T {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    static gcd(a: number, b: number): number {
        return b === 0 ? a : MathUtils.gcd(b, a % b);
    }
}

// FILE END: src\core\utils\MathUtils.ts

// =======================================================
// FILE START: src\core\utils\random.ts
// =======================================================

export class Random {
    private seed: string;

    constructor(seed: string) {
        this.seed = seed;
    }

    public intBetween(min: number, max: number): number {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    
    public pick<T>(array: T[]): T {
        return array[this.intBetween(0, array.length - 1)];
    }

    // Added missing method caused the crash in Similarity Level 4
    public bool(): boolean {
        return Math.random() < 0.5;
    }
}

// FILE END: src\core\utils\random.ts

// =======================================================
// FILE START: src\core\utils\security.ts
// =======================================================

import * as crypto from 'crypto';

// Use a fixed secret for development, but in prod use process.env.HMAC_SECRET
const SECRET_KEY = process.env.HMAC_SECRET || 'dev-secret-key-change-me-in-prod';

// Derive a consistent 32-byte key from the secret
const KEY = crypto.scryptSync(SECRET_KEY, 'salt', 32);
const ALGORITHM = 'aes-256-cbc';

export interface TokenPayload {
  qId: string;      
  enc: string;      
  tol?: number;     
  ts: number;       
}

export function normalizeAnswer(input: string | number): string {
  if (input === undefined || input === null) return "";
  return input
    .toString()
    .toLowerCase()
    .trim()
    .replace(',', '.') 
    .replace(/\s+/g, ''); 
}

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return iv.toString('hex') + ':' + encrypted;
}

function decrypt(text: string): string {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const encryptedText = textParts.join(':');
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

export function generateToken(qId: string, answer: string | number | object, tol: number = 0): string {
  let encVal = "";
  if (typeof answer === 'object') {
      encVal = JSON.stringify(answer);
  } else {
      encVal = String(answer);
  }

  const payload: TokenPayload = {
    qId,
    enc: encrypt(encVal),
    tol,
    ts: Date.now()
  };

  const payloadStr = JSON.stringify(payload);
  const payloadB64 = Buffer.from(payloadStr).toString('base64');

  const signature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payloadB64)
    .digest('hex');

  return `${payloadB64}.${signature}`;
}

export function verifyAnswer(userAnswer: string | number, token: string): boolean {
  try {
    const [payloadB64, signature] = token.split('.');
    if (!payloadB64 || !signature) return false;

    const expectedSignature = crypto
      .createHmac('sha256', SECRET_KEY)
      .update(payloadB64)
      .digest('hex');

    if (signature !== expectedSignature) return false;

    const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
    const correctVal = decrypt(payload.enc);
    const userVal = normalizeAnswer(userAnswer);

    if (payload.tol && payload.tol > 0) {
        const cNum = parseFloat(correctVal);
        const uNum = parseFloat(userVal);
        if (!isNaN(cNum) && !isNaN(uNum)) {
            return Math.abs(cNum - uNum) <= payload.tol;
        }
    }
    
    // Check for "x=" prefix flexibility for Equation levels
    if (userVal.startsWith('x=') && !correctVal.startsWith('x=')) {
         return userVal.split('=')[1] === normalizeAnswer(correctVal);
    }
    
    // Handle scale/coordinate objects
    if (correctVal.startsWith('{')) {
        return normalizeAnswer(correctVal) === userVal;
    }

    return normalizeAnswer(correctVal) === userVal;
  } catch (err) {
    console.error("Token verification failed:", err);
    return false;
  }
}

// NEW EXPORT to retrieve answer for history logs
export function getCorrectAnswer(token: string): string {
    try {
        const [payloadB64, signature] = token.split('.');
        const payload: TokenPayload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('utf-8'));
        return decrypt(payload.enc);
    } catch (e) {
        return "";
    }
}

// FILE END: src\core\utils\security.ts

// =======================================================
// FILE START: src\core\utils\textEngine.ts
// =======================================================

import { Random } from "./random";

export interface LocalizedText {
    sv: string;
    en: string;
}

export type ContextKey = 'shopping' | 'school' | 'hobbies' | 'age';

interface ContextData {
    items: LocalizedText[];
    people: string[];
}

export const CONTEXTS: Record<ContextKey, ContextData> = {
    shopping: {
        items: [
            { sv: "√§pplen", en: "apples" },
            { sv: "pennor", en: "pens" },
            { sv: "b√∂cker", en: "books" },
            { sv: "godisbitar", en: "candies" },
            { sv: "tidningar", en: "magazines" },
            { sv: "bananer", en: "bananas" },
            { sv: "apelsiner", en: "oranges" },
            { sv: "chokladkakor", en: "chocolate bars" },
            { sv: "l√§skburkar", en: "soda cans" },
            { sv: "mj√∂lkpaket", en: "milk cartons" },
            { sv: "br√∂dlimpor", en: "loaves of bread" },
            { sv: "ostbitar", en: "pieces of cheese" },
            { sv: "kex", en: "biscuits" },
            { sv: "tuggummin", en: "gums" },
            { sv: "glassar", en: "ice creams" },
            { sv: "flaskor vatten", en: "bottles of water" },
            { sv: "chips", en: "chips" },
            { sv: "√§gg", en: "eggs" },
            { sv: "tomater", en: "tomatoes" },
            { sv: "gurkor", en: "cucumbers" }
        ],
        people: ["Kim", "Alex", "Charlie", "Mika", "Robin", "Sasha", "Lo", "Eli", "Sam", "Noa"]
    },
    school: {
        items: [
            { sv: "suddgummin", en: "erasers" },
            { sv: "linjaler", en: "rulers" },
            { sv: "skrivb√∂cker", en: "notebooks" },
            { sv: "markeingspennor", en: "markers" },
            { sv: "blyertspennor", en: "pencils" },
            { sv: "pennv√§ssare", en: "pencil sharpeners" },
            { sv: "ryggs√§ckar", en: "backpacks" },
            { sv: "minir√§knare", en: "calculators" },
            { sv: "gem", en: "paper clips" },
            { sv: "h√§ftapparater", en: "staplers" },
            { sv: "saxar", en: "scissors" },
            { sv: "limstift", en: "glue sticks" },
            { sv: "mappar", en: "folders" },
            { sv: "kritor", en: "crayons" },
            { sv: "whiteboardpennor", en: "whiteboard markers" },
            { sv: "geometrikit", en: "geometry kits" },
            { sv: "passare", en: "compasses" },
            { sv: "gradskivor", en: "protractors" },
            { sv: "papper", en: "papers" },
            { sv: "b√∂cker", en: "textbooks" }
        ],
        people: ["l√§raren", "eleven", "rektorn", "vaktm√§staren", "bibliotekarien", "skolsyster", "syokonsulenten", "bildl√§raren", "idrottsl√§raren", "musikl√§raren"]
    },
    hobbies: {
        items: [
            { sv: "fotbollskort", en: "soccer cards" },
            { sv: "frim√§rken", en: "stamps" },
            { sv: "mynt", en: "coins" },
            { sv: "sn√§ckor", en: "seashells" },
            { sv: "klisterm√§rken", en: "stickers" },
            { sv: "pok√©monkort", en: "Pok√©mon cards" },
            { sv: "glaskulor", en: "marbles" },
            { sv: "stenar", en: "stones" },
            { sv: "fj√§drar", en: "feathers" },
            { sv: "knappar", en: "buttons" },
            { sv: "serietidningar", en: "comic books" },
            { sv: "actionfigurer", en: "action figures" },
            { sv: "bilar", en: "toy cars" },
            { sv: "dockor", en: "dolls" },
            { sv: "nyckelringar", en: "keychains" },
            { sv: "vykort", en: "postcards" },
            { sv: "poster", en: "posters" },
            { sv: "medaljer", en: "medals" },
            { sv: "trof√©er", en: "trophies" },
            { sv: "pusselbitar", en: "puzzle pieces" }
        ],
        people: ["Sam", "Noa", "Leo", "Mia", "Ella", "Liam", "William", "Elias", "Hugo", "Alice", "Maja", "Elsa", "Astrid", "Wilma", "Freja", "Olivia", "Selma", "Alma", "Signe", "Ebba"]
    },
    age: {
        items: [
            { sv: "√•r", en: "years" }
        ],
        people: ["Anna", "Bj√∂rn", "Cecilia", "David", "Erik", "Fia", "Gustav", "Hanna", "Isak", "Julia", "Kalle", "Lisa", "Magnus", "Nina", "Oskar", "Petra", "Qasim", "Rebecka", "Simon", "Tove"]
    }
};

export class TextEngine {
    /**
     * Replaces placeholders like {name} or {value} in a string with actual values.
     */
    public static fillTemplate(template: string, replacements: Record<string, string | number>): string {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
            return replacements[key] !== undefined ? String(replacements[key]) : match;
        });
    }

    public static getRandomContextItem(rng: Random, context: ContextKey, lang: 'sv' | 'en'): string {
        const ctx = CONTEXTS[context];
        const item = rng.pick(ctx.items);
        return item[lang];
    }

    public static getRandomName(rng: Random, context: ContextKey): string {
        return rng.pick(CONTEXTS[context].people);
    }
}

// FILE END: src\core\utils\textEngine.ts

// =======================================================
// FILE START: src\index.css
// =======================================================

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
  -webkit-font-smoothing: antialiased;
  @apply bg-gray-50 text-gray-800;
}

/* Legacy Animations */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Custom Scrollbar from Legacy Code */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Print Styles for Do Now Grid */
.print-break-inside-avoid {
  break-inside: avoid;
}

/* Katex Adjustments */
.katex {
  font-size: 1.1em;
}

// FILE END: src\index.css

// =======================================================
// FILE START: src\main.jsx
// =======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// FILE END: src\main.jsx

// =======================================================
// FILE START: tailwind.config.js
// =======================================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Legacy Color Palette
        primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' },
        accent: { 50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74', 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c', 800: '#9a3412', 900: '#7c2d12' }
      },
      fontFamily: { 
        sans: ['Inter', 'sans-serif'] 
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      }
    },
  },
  plugins: [],
}

// FILE END: tailwind.config.js

// =======================================================
// FILE START: tsconfig.json
// =======================================================

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022", "DOM"],
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"]
    }
  },
  "include": ["src", "api"]
}

// FILE END: tsconfig.json

// =======================================================
// FILE START: vercel.json
// =======================================================

{
  "version": 2,
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/$1" },
    { "source": "/(.*)", "destination": "/index.html" }
  ],
  "functions": {
    "api/*.ts": {
      "maxDuration": 10
    }
  }
}

// FILE END: vercel.json

// =======================================================
// FILE START: vite.config.js
// =======================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@core': path.resolve(__dirname, './src/core'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  }
})

// FILE END: vite.config.js
